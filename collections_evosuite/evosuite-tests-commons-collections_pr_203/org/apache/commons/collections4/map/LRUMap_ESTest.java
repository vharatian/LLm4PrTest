/*
 * This file was automatically generated by EvoSuite
 * Sat Aug 23 15:15:22 GMT 2025
 */

package org.apache.commons.collections4.map;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.function.BiFunction;
import org.apache.commons.collections4.map.AbstractHashedMap;
import org.apache.commons.collections4.map.AbstractLinkedMap;
import org.apache.commons.collections4.map.LRUMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFileOutputStream;
import org.evosuite.runtime.mock.java.util.MockDate;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true) 
public class LRUMap_ESTest extends LRUMap_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>();
      MockDate mockDate0 = new MockDate();
      BiFunction<MockDate, Object, MockDate> biFunction0 = (BiFunction<MockDate, Object, MockDate>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      doReturn(mockDate0).when(biFunction0).apply(any(org.evosuite.runtime.mock.java.util.MockDate.class) , any());
      lRUMap0.compute(mockDate0, biFunction0);
      LRUMap<Object, Object> lRUMap1 = new LRUMap<Object, Object>(lRUMap0);
      lRUMap1.size = 2512;
      boolean boolean0 = lRUMap1.isFull();
      assertFalse(lRUMap1.isScanUntilRemovable());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      HashMap<MockDate, MockDate> hashMap0 = new HashMap<MockDate, MockDate>();
      MockDate mockDate0 = new MockDate();
      hashMap0.put(mockDate0, mockDate0);
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>(hashMap0);
      // Undeclared exception!
      try { 
        lRUMap0.addMapping(11, 11, mockDate0, mockDate0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 11
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>(2);
      LRUMap<Object, Object> lRUMap1 = new LRUMap<Object, Object>();
      AbstractLinkedMap.LinkEntry<Object, Object> abstractLinkedMap_LinkEntry0 = lRUMap1.header;
      lRUMap0.moveToMRU(abstractLinkedMap_LinkEntry0);
      // Undeclared exception!
      try { 
        lRUMap0.reuseMapping(abstractLinkedMap_LinkEntry0, (-165), 12, abstractLinkedMap_LinkEntry0, (Object) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.next=null, data[removeIndex]=null previous=null key=null=null value=null size=0 maxSize=2 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>(2);
      AbstractLinkedMap.LinkEntry<Object, Object> abstractLinkedMap_LinkEntry0 = lRUMap0.header;
      // Undeclared exception!
      try { 
        lRUMap0.reuseMapping(abstractLinkedMap_LinkEntry0, (-165), 12, abstractLinkedMap_LinkEntry0, (Object) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.next=null, data[removeIndex]=null previous=null key=null=null value=null size=0 maxSize=2 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>(2, 2);
      LRUMap<Object, Object> lRUMap1 = new LRUMap<Object, Object>();
      AbstractLinkedMap.LinkEntry<Object, Object> abstractLinkedMap_LinkEntry0 = lRUMap1.header;
      lRUMap0.moveToMRU(abstractLinkedMap_LinkEntry0);
      assertEquals(2, lRUMap0.maxSize());
      assertFalse(lRUMap1.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      LRUMap<Object, AbstractLinkedMap.LinkEntry<Object, Object>> lRUMap0 = new LRUMap<Object, AbstractLinkedMap.LinkEntry<Object, Object>>(4580, 32, 4319.9463F, true);
      assertEquals(4580, lRUMap0.maxSize());
      assertTrue(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>(4, 4, 4);
      assertEquals(4, lRUMap0.maxSize());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      LRUMap<MockDate, Object> lRUMap0 = new LRUMap<MockDate, Object>(452, 1.0F, false);
      assertEquals(452, lRUMap0.maxSize());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      LRUMap<MockDate, Object> lRUMap0 = new LRUMap<MockDate, Object>(1372);
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream(pipedInputStream0);
      ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(pipedOutputStream0);
      lRUMap0.doWriteObject(objectOutputStream0);
      assertEquals(1372, lRUMap0.maxSize());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>();
      AbstractLinkedMap.LinkEntry<Object, Object> abstractLinkedMap_LinkEntry0 = lRUMap0.header;
      boolean boolean0 = lRUMap0.removeLRU(abstractLinkedMap_LinkEntry0);
      assertEquals(100, lRUMap0.maxSize());
      assertFalse(lRUMap0.isScanUntilRemovable());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>(2514, true);
      boolean boolean0 = lRUMap0.isScanUntilRemovable();
      assertEquals(2514, lRUMap0.maxSize());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>();
      LRUMap<MockDate, Object> lRUMap1 = new LRUMap<MockDate, Object>(2000, 2000, 2000, false);
      lRUMap1.get((Object) lRUMap0);
      assertFalse(lRUMap1.isScanUntilRemovable());
      assertEquals(2000, lRUMap1.maxSize());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>(32, 32);
      MockDate mockDate0 = new MockDate();
      BiFunction<MockDate, Object, MockDate> biFunction0 = (BiFunction<MockDate, Object, MockDate>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      doReturn(mockDate0).when(biFunction0).apply(any(org.evosuite.runtime.mock.java.util.MockDate.class) , any());
      lRUMap0.compute(mockDate0, biFunction0);
      LRUMap<Object, Object> lRUMap1 = new LRUMap<Object, Object>(lRUMap0);
      Object object0 = lRUMap1.get((Object) mockDate0);
      assertNotNull(object0);
      assertTrue(lRUMap1.isFull());
      assertFalse(lRUMap1.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      MockDate mockDate0 = new MockDate(727L);
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>(1, true);
      BiFunction<Object, MockDate, MockDate> biFunction0 = (BiFunction<Object, MockDate, MockDate>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      lRUMap0.merge(mockDate0, mockDate0, biFunction0);
      LRUMap<MockDate, MockDate> lRUMap1 = lRUMap0.clone();
      assertTrue(lRUMap1.isFull());
      assertTrue(lRUMap0.isFull());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>(32, 32);
      MockDate mockDate0 = new MockDate(32);
      BiFunction<Object, Object, MockDate> biFunction0 = (BiFunction<Object, Object, MockDate>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      lRUMap0.merge(mockDate0, mockDate0, biFunction0);
      LRUMap<MockDate, MockDate> lRUMap1 = lRUMap0.clone();
      assertFalse(lRUMap1.isScanUntilRemovable());
      assertTrue(lRUMap1.equals((Object)lRUMap0));
      assertEquals(32, lRUMap1.maxSize());
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      LRUMap<AbstractLinkedMap.LinkEntry<Object, Object>, MockDate> lRUMap0 = new LRUMap<AbstractLinkedMap.LinkEntry<Object, Object>, MockDate>();
      MockDate mockDate0 = new MockDate((-1L));
      // Undeclared exception!
      try { 
        lRUMap0.updateEntry((AbstractHashedMap.HashEntry<AbstractLinkedMap.LinkEntry<Object, Object>, MockDate>) null, mockDate0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      LRUMap<MockDate, Object> lRUMap0 = new LRUMap<MockDate, Object>();
      AbstractLinkedMap.LinkEntry<MockDate, Object> abstractLinkedMap_LinkEntry0 = lRUMap0.getEntry((Object) null);
      AbstractHashedMap.HashEntry<MockDate, Object> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<MockDate, Object>(abstractLinkedMap_LinkEntry0, 1563, (Object) null, abstractLinkedMap_LinkEntry0);
      // Undeclared exception!
      try { 
        lRUMap0.updateEntry(abstractHashedMap_HashEntry0, (Object) null);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // org.apache.commons.collections4.map.AbstractHashedMap$HashEntry cannot be cast to org.apache.commons.collections4.map.AbstractLinkedMap$LinkEntry
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>();
      // Undeclared exception!
      try { 
        lRUMap0.moveToMRU((AbstractLinkedMap.LinkEntry<MockDate, MockDate>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>();
      // Undeclared exception!
      try { 
        lRUMap0.doWriteObject((ObjectOutputStream) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, Object>((Map<?, ?>) null, true);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>();
      LRUMap<MockDate, Object> lRUMap1 = null;
      try {
        lRUMap1 = new LRUMap<MockDate, Object>(lRUMap0, false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<MockDate, MockDate>((Map<? extends MockDate, ? extends MockDate>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>();
      LRUMap<MockDate, MockDate> lRUMap1 = null;
      try {
        lRUMap1 = new LRUMap<MockDate, MockDate>(lRUMap0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      LRUMap<Object, FilterInputStream> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, FilterInputStream>(0, 0, 1.0F, false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, Object>(0, 0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      LRUMap<Object, AbstractLinkedMap.LinkEntry<Object, Object>> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, AbstractLinkedMap.LinkEntry<Object, Object>>(1036, 0.0F, false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Load factor must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      LRUMap<AbstractLinkedMap.LinkEntry<MockDate, MockDate>, Object> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<AbstractLinkedMap.LinkEntry<MockDate, MockDate>, Object>((-1), (-4204.4956F));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>();
      lRUMap0.isFull();
      assertEquals(100, lRUMap0.maxSize());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>(2);
      AbstractLinkedMap.LinkEntry<Object, Object> abstractLinkedMap_LinkEntry0 = lRUMap0.header;
      LRUMap<MockDate, MockDate> lRUMap1 = new LRUMap<MockDate, MockDate>();
      lRUMap1.get((Object) abstractLinkedMap_LinkEntry0, false);
      assertEquals(2, lRUMap0.maxSize());
      assertFalse(lRUMap1.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>();
      AbstractLinkedMap.LinkEntry<Object, Object> abstractLinkedMap_LinkEntry0 = lRUMap0.header;
      // Undeclared exception!
      try { 
        lRUMap0.reuseMapping(abstractLinkedMap_LinkEntry0, 4, 4, abstractLinkedMap_LinkEntry0, abstractLinkedMap_LinkEntry0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.next=null, data[removeIndex]=null previous=null key=null=null value=null=null size=0 maxSize=100 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>();
      AbstractLinkedMap.LinkEntry<Object, Object> abstractLinkedMap_LinkEntry0 = lRUMap0.header;
      // Undeclared exception!
      try { 
        lRUMap0.moveToMRU(abstractLinkedMap_LinkEntry0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Can't move header to MRU This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>(32, 32);
      MockDate mockDate0 = new MockDate();
      BiFunction<MockDate, Object, MockDate> biFunction0 = (BiFunction<MockDate, Object, MockDate>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      doReturn(mockDate0).when(biFunction0).apply(any(org.evosuite.runtime.mock.java.util.MockDate.class) , any());
      lRUMap0.compute(mockDate0, biFunction0);
      LRUMap<Object, Object> lRUMap1 = new LRUMap<Object, Object>(lRUMap0, false);
      AbstractLinkedMap.LinkEntry<Object, Object> abstractLinkedMap_LinkEntry0 = lRUMap1.header;
      lRUMap1.moveToMRU(abstractLinkedMap_LinkEntry0);
      assertTrue(lRUMap1.isFull());
      assertFalse(lRUMap1.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>();
      AbstractHashedMap.HashEntry<Object, Object> abstractHashedMap_HashEntry0 = lRUMap0.createEntry((AbstractHashedMap.HashEntry<Object, Object>) null, (-1995), (Object) null, (Object) null);
      // Undeclared exception!
      try { 
        lRUMap0.updateEntry(abstractHashedMap_HashEntry0, (Object) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.before is null. This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>(32, 32);
      MockDate mockDate0 = new MockDate(32, 32, 32, 32, 32);
      BiFunction<MockDate, Object, MockDate> biFunction0 = (BiFunction<MockDate, Object, MockDate>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      doReturn(mockDate0).when(biFunction0).apply(any(org.evosuite.runtime.mock.java.util.MockDate.class) , any());
      lRUMap0.compute(mockDate0, biFunction0);
      LRUMap<Object, MockDate> lRUMap1 = new LRUMap<Object, MockDate>(lRUMap0);
      MockDate mockDate1 = lRUMap1.get((Object) mockDate0, false);
      assertNotNull(mockDate1);
      assertFalse(lRUMap1.isScanUntilRemovable());
      assertTrue(lRUMap1.isFull());
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>(32, 32);
      MockDate mockDate0 = new MockDate(32, 32, 32, 32, 32);
      BiFunction<MockDate, Object, MockDate> biFunction0 = (BiFunction<MockDate, Object, MockDate>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      doReturn(mockDate0).when(biFunction0).apply(any(org.evosuite.runtime.mock.java.util.MockDate.class) , any());
      lRUMap0.compute(mockDate0, biFunction0);
      LRUMap<Object, MockDate> lRUMap1 = new LRUMap<Object, MockDate>(lRUMap0);
      MockDate mockDate1 = lRUMap1.get((Object) mockDate0, true);
      assertNotNull(mockDate1);
      assertFalse(lRUMap1.isScanUntilRemovable());
      assertTrue(lRUMap1.isFull());
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, Object>(4, 40, 40);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap initial size must not be greater than max size
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<MockDate, MockDate>(0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      LRUMap<Object, AbstractLinkedMap.LinkEntry<Object, Object>> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, AbstractLinkedMap.LinkEntry<Object, Object>>((-1943), true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      HashMap<MockDate, MockDate> hashMap0 = new HashMap<MockDate, MockDate>();
      MockDate mockDate0 = new MockDate();
      hashMap0.put(mockDate0, mockDate0);
      LRUMap<MockDate, Object> lRUMap0 = new LRUMap<MockDate, Object>(hashMap0, true);
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("org.apache.commons.collections4.map.AbstractHashedMap$KeySetIterator");
      ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(mockFileOutputStream0);
      try { 
        lRUMap0.doWriteObject(objectOutputStream0);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Error in writing to file
         //
         verifyException("org.evosuite.runtime.mock.java.io.NativeMockedIO", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      MockDate mockDate0 = new MockDate();
      HashMap<MockDate, MockDate> hashMap0 = new HashMap<MockDate, MockDate>();
      hashMap0.put(mockDate0, mockDate0);
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>(hashMap0);
      lRUMap0.put(mockDate0, (MockDate) null);
      assertTrue(lRUMap0.isFull());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>(4, 4);
      boolean boolean0 = lRUMap0.isScanUntilRemovable();
      assertFalse(boolean0);
      assertEquals(4, lRUMap0.maxSize());
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      MockDate mockDate0 = new MockDate();
      HashMap<MockDate, MockDate> hashMap0 = new HashMap<MockDate, MockDate>();
      hashMap0.put(mockDate0, mockDate0);
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>(hashMap0);
      lRUMap0.addMapping(0, 0, mockDate0, mockDate0);
      assertFalse(lRUMap0.isScanUntilRemovable());
      assertEquals(1, lRUMap0.size());
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>(1063);
      // Undeclared exception!
      try { 
        lRUMap0.reuseMapping((AbstractLinkedMap.LinkEntry<Object, Object>) null, 1063, 1063, (Object) null, (Object) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // NPE, entry=null entryIsHeader=false key=null value=null size=0 maxSize=1063 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      LRUMap<MockDate, MockDate> lRUMap0 = new LRUMap<MockDate, MockDate>(32, 32);
      LRUMap<MockDate, MockDate> lRUMap1 = lRUMap0.clone();
      assertEquals(32, lRUMap1.maxSize());
      assertFalse(lRUMap1.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      LRUMap<MockDate, Object> lRUMap0 = new LRUMap<MockDate, Object>();
      // Undeclared exception!
      try { 
        lRUMap0.doReadObject((ObjectInputStream) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }
}
