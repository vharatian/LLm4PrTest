[
  {
    "pr_number": 352,
    "title": "[CSV-310] Misleading error message when QuoteMode set to None",
    "state": "closed",
    "created_at": "2023-09-06T13:16:24Z",
    "merge_commit_sha": "c2cf3057d37a8645234d083be4d5c4c5ab97ccc2",
    "base_sha": "5af4338d6e42d2efd8d91ba26d14025c93200a38",
    "head_sha": "eb95e6dff7a2eab9f0b52f9f5cac8850f596f8c3",
    "user_login": "gbidsilva",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    /**\n     * Test to ensure that setting QuoteMode to NONE without setting an escape character\n     * throws the correct IllegalArgumentException with the updated message.\n     */\n    @Test\n    public void testQuotePolicyNoneWithoutEscapeThrowsExceptionWithUpdatedMessage() {\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> \n            CSVFormat.newFormat('!').builder().setQuoteMode(QuoteMode.NONE).build()\n        );\n        assertEquals(\"Quote mode set to NONE but no escape character is set\", exception.getMessage());\n    }\n}",
        "file_content": "/*\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n * this work for additional information regarding copyright ownership.\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n * (the \"License\"); you may not use this file except in compliance with\r\n * the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage org.apache.commons.csv;\r\n\r\nimport static org.apache.commons.csv.Constants.BACKSLASH;\r\nimport static org.apache.commons.csv.Constants.COMMA;\r\nimport static org.apache.commons.csv.Constants.COMMENT;\r\nimport static org.apache.commons.csv.Constants.CR;\r\nimport static org.apache.commons.csv.Constants.CRLF;\r\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\r\nimport static org.apache.commons.csv.Constants.EMPTY;\r\nimport static org.apache.commons.csv.Constants.LF;\r\nimport static org.apache.commons.csv.Constants.PIPE;\r\nimport static org.apache.commons.csv.Constants.SP;\r\nimport static org.apache.commons.csv.Constants.TAB;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Serializable;\r\nimport java.io.StringWriter;\r\nimport java.io.Writer;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.Arrays;\r\nimport java.util.HashSet;\r\nimport java.util.Objects;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Specifies the format of a CSV file for parsing and writing.\r\n *\r\n * <h2>Using predefined formats</h2>\r\n *\r\n * <p>\r\n * You can use one of the predefined formats:\r\n * </p>\r\n *\r\n * <ul>\r\n * <li>{@link #DEFAULT}</li>\r\n * <li>{@link #EXCEL}</li>\r\n * <li>{@link #INFORMIX_UNLOAD}</li>\r\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\r\n * <li>{@link #MYSQL}</li>\r\n * <li>{@link #RFC4180}</li>\r\n * <li>{@link #ORACLE}</li>\r\n * <li>{@link #POSTGRESQL_CSV}</li>\r\n * <li>{@link #POSTGRESQL_TEXT}</li>\r\n * <li>{@link #TDF}</li>\r\n * </ul>\r\n *\r\n * <p>\r\n * For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\r\n * </pre>\r\n *\r\n * <p>\r\n * The {@link CSVParser} provides static methods to parse other input types, for example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\r\n * </pre>\r\n *\r\n * <h2>Defining formats</h2>\r\n *\r\n * <p>\r\n * You can extend a format by calling the {@code set} methods. For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\r\n * </pre>\r\n *\r\n * <h2>Defining column names</h2>\r\n *\r\n * <p>\r\n * To define the column names you want to use to access records, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * Calling {@link Builder#setHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and assumes that your CSV source does not\r\n * contain a first record that also defines column names.\r\n *\r\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\r\n * {@link Builder#setSkipHeaderRecord(boolean)} with {@code true}.\r\n * </p>\r\n *\r\n * <h2>Parsing</h2>\r\n *\r\n * <p>\r\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * Reader in = ...;\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\r\n * </pre>\r\n *\r\n * <p>\r\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\r\n * </p>\r\n *\r\n * <h2>Referencing columns safely</h2>\r\n *\r\n * <p>\r\n * If your source contains a header record, you can simplify your code and safely reference columns, by using {@link Builder#setHeader(String...)} with no\r\n * arguments:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader();\r\n * </pre>\r\n *\r\n * <p>\r\n * This causes the parser to read the first record and use its values as column names.\r\n *\r\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\r\n * </p>\r\n *\r\n * <pre>\r\n * String value = record.get(&quot;Col1&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * This makes your code impervious to changes in column order in the CSV file.\r\n * </p>\r\n *\r\n * <h2>Serialization</h2>\r\n * <p>\r\n *   This class implements the {@link Serializable} interface with the following caveats:\r\n * </p>\r\n * <ul>\r\n *   <li>This class will no longer implement Serializable in 2.0.</li>\r\n *   <li>Serialization is not supported from one version to the next.</li>\r\n * </ul>\r\n * <p>\r\n *   The {@code serialVersionUID} values are:\r\n * </p>\r\n * <ul>\r\n *   <li>Version 1.10.0: {@code 2L}</li>\r\n *   <li>Version 1.9.0 through 1.0: {@code 1L}</li>\r\n * </ul>\r\n *\r\n * <h2>Notes</h2>\r\n * <p>\r\n * This class is immutable.\r\n * </p>\r\n * <p>\r\n * Not all settings are used for both parsing and writing.\r\n * </p>\r\n */\r\npublic final class CSVFormat implements Serializable {\r\n\r\n    /**\r\n     * Builds CSVFormat instances.\r\n     *\r\n     * @since 1.9.0\r\n     */\r\n    public static class Builder {\r\n\r\n        /**\r\n         * Creates a new default builder.\r\n         *\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create() {\r\n            return new Builder(CSVFormat.DEFAULT);\r\n        }\r\n\r\n        /**\r\n         * Creates a new builder for the given format.\r\n         *\r\n         * @param csvFormat the source format.\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create(final CSVFormat csvFormat) {\r\n            return new Builder(csvFormat);\r\n        }\r\n\r\n        private boolean allowMissingColumnNames;\r\n\r\n        private boolean autoFlush;\r\n\r\n        private Character commentMarker;\r\n\r\n        private String delimiter;\r\n\r\n        private DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n        private Character escapeCharacter;\r\n\r\n        private String[] headerComments;\r\n\r\n        private String[] headers;\r\n\r\n        private boolean ignoreEmptyLines;\r\n\r\n        private boolean ignoreHeaderCase;\r\n\r\n        private boolean ignoreSurroundingSpaces;\r\n\r\n        private String nullString;\r\n\r\n        private Character quoteCharacter;\r\n\r\n        private String quotedNullString;\r\n\r\n        private QuoteMode quoteMode;\r\n\r\n        private String recordSeparator;\r\n\r\n        private boolean skipHeaderRecord;\r\n\r\n        private boolean trailingDelimiter;\r\n\r\n        private boolean trim;\r\n\r\n        private Builder(final CSVFormat csvFormat) {\r\n            this.delimiter = csvFormat.delimiter;\r\n            this.quoteCharacter = csvFormat.quoteCharacter;\r\n            this.quoteMode = csvFormat.quoteMode;\r\n            this.commentMarker = csvFormat.commentMarker;\r\n            this.escapeCharacter = csvFormat.escapeCharacter;\r\n            this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;\r\n            this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;\r\n            this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;\r\n            this.recordSeparator = csvFormat.recordSeparator;\r\n            this.nullString = csvFormat.nullString;\r\n            this.headerComments = csvFormat.headerComments;\r\n            this.headers = csvFormat.headers;\r\n            this.skipHeaderRecord = csvFormat.skipHeaderRecord;\r\n            this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;\r\n            this.trailingDelimiter = csvFormat.trailingDelimiter;\r\n            this.trim = csvFormat.trim;\r\n            this.autoFlush = csvFormat.autoFlush;\r\n            this.quotedNullString = csvFormat.quotedNullString;\r\n            this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;\r\n        }\r\n\r\n        /**\r\n         * Builds a new CSVFormat instance.\r\n         *\r\n         * @return a new CSVFormat instance.\r\n         */\r\n        public CSVFormat build() {\r\n            return new CSVFormat(this);\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior, true to allow, false to disallow.\r\n         *\r\n         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n         * @return This instance.\r\n         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.\r\n         */\r\n        @Deprecated\r\n        public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n            setDuplicateHeaderMode(allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\r\n         * {@link IllegalArgumentException} to be thrown.\r\n         *\r\n         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\r\n         *                                cause an {@link IllegalArgumentException} to be thrown.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n            this.allowMissingColumnNames = allowMissingColumnNames;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to flush on close.\r\n         *\r\n         * @param autoFlush whether to flush on close.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAutoFlush(final boolean autoFlush) {\r\n            this.autoFlush = autoFlush;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment marker character, use {@code null} to disable comments.\r\n         * <p>\r\n         * The comment start character is only recognized at the start of a line.\r\n         * </p>\r\n         * <p>\r\n         * Comments are printed first, before headers.\r\n         * </p>\r\n         * <p>\r\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of\r\n         * each comment line.\r\n         * </p>\r\n         * <p>\r\n         * If the comment marker is not set, then the header comments are ignored.\r\n         * </p>\r\n         * <p>\r\n         * For example:\r\n         * </p>\r\n         * <pre>\r\n         * builder.setCommentMarker('#')\r\n         *        .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0));\r\n         * </pre>\r\n         * <p>\r\n         * writes:\r\n         * </p>\r\n         * <pre>\r\n         * # Generated by Apache Commons CSV.\r\n         * # 1970-01-01T00:00:00Z\r\n         * </pre>\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final char commentMarker) {\r\n            setCommentMarker(Character.valueOf(commentMarker));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment marker character, use {@code null} to disable comments.\r\n         * <p>\r\n         * The comment start character is only recognized at the start of a line.\r\n         * </p>\r\n         * <p>\r\n         * Comments are printed first, before headers.\r\n         * </p>\r\n         * <p>\r\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of\r\n         * each comment line.\r\n         * </p>\r\n         * <p>\r\n         * If the comment marker is not set, then the header comments are ignored.\r\n         * </p>\r\n         * <p>\r\n         * For example:\r\n         * </p>\r\n         * <pre>\r\n         * builder.setCommentMarker('#')\r\n         *        .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0));\r\n         * </pre>\r\n         * <p>\r\n         * writes:\r\n         * </p>\r\n         * <pre>\r\n         * # Generated by Apache Commons CSV.\r\n         * # 1970-01-01T00:00:00Z\r\n         * </pre>\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final Character commentMarker) {\r\n            if (isLineBreak(commentMarker)) {\r\n                throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\r\n            }\r\n            this.commentMarker = commentMarker;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final char delimiter) {\r\n            return setDelimiter(String.valueOf(delimiter));\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final String delimiter) {\r\n            if (containsLineBreak(delimiter)) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n            }\r\n            if (delimiter.isEmpty()) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be empty\");\r\n            }\r\n            this.delimiter = delimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior.\r\n         *\r\n         * @param duplicateHeaderMode the duplicate header names behavior\r\n         * @return This instance.\r\n         * @since 1.10.0\r\n         */\r\n        public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {\r\n          this.duplicateHeaderMode = Objects.requireNonNull(duplicateHeaderMode, \"duplicateHeaderMode\");\r\n          return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final char escapeCharacter) {\r\n            setEscape(Character.valueOf(escapeCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final Character escapeCharacter) {\r\n            if (isLineBreak(escapeCharacter)) {\r\n                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\r\n            }\r\n            this.escapeCharacter = escapeCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header defined by the given {@link Enum} class.\r\n         *\r\n         * <p>\r\n         * Example:\r\n         * </p>\r\n         *\r\n         * <pre>\r\n         * public enum HeaderEnum {\r\n         *     Name, Email, Phone\r\n         * }\r\n         *\r\n         * Builder builder = builder.setHeader(HeaderEnum.class);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {\r\n            String[] header = null;\r\n            if (headerEnum != null) {\r\n                final Enum<?>[] enumValues = headerEnum.getEnumConstants();\r\n                header = new String[enumValues.length];\r\n                Arrays.setAll(header, i -> enumValues[i].name());\r\n            }\r\n            return setHeader(header);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSet);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSet resultSet) throws SQLException {\r\n            return setHeader(resultSet != null ? resultSet.getMetaData() : null);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSetMetaData);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n            String[] labels = null;\r\n            if (resultSetMetaData != null) {\r\n                final int columnCount = resultSetMetaData.getColumnCount();\r\n                labels = new String[columnCount];\r\n                for (int i = 0; i < columnCount; i++) {\r\n                    labels[i] = resultSetMetaData.getColumnLabel(i + 1);\r\n                }\r\n            }\r\n            return setHeader(labels);\r\n        }\r\n\r\n        /**\r\n         * Sets the header to the given values. The header can be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param header the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final String... header) {\r\n            this.headers = CSVFormat.clone(header);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments to write before the CSV data.\r\n         * <p>\r\n         * This setting is ignored by the parser.\r\n         * </p>\r\n         * <p>\r\n         * Comments are printed first, before headers.\r\n         * </p>\r\n         * <p>\r\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of\r\n         * each comment line.\r\n         * </p>\r\n         * <p>\r\n         * If the comment marker is not set, then the header comments are ignored.\r\n         * </p>\r\n         * <p>\r\n         * For example:\r\n         * </p>\r\n         * <pre>\r\n         * builder.setCommentMarker('#')\r\n         *        .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0));\r\n         * </pre>\r\n         * <p>\r\n         * writes:\r\n         * </p>\r\n         * <pre>\r\n         * # Generated by Apache Commons CSV.\r\n         * # 1970-01-01T00:00:00Z\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final Object... headerComments) {\r\n            this.headerComments = CSVFormat.clone(toStringArray(headerComments));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments to write before the CSV data.\r\n         * <p>\r\n         * This setting is ignored by the parser.\r\n         * </p>\r\n         * <p>\r\n         * Comments are printed first, before headers.\r\n         * </p>\r\n         * <p>\r\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of\r\n         * each comment line.\r\n         * </p>\r\n         * <p>\r\n         * If the comment marker is not set, then the header comments are ignored.\r\n         * </p>\r\n         * <p>\r\n         * For example:\r\n         * </p>\r\n         * <pre>\r\n         * builder.setCommentMarker('#')\r\n         *        .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0).toString());\r\n         * </pre>\r\n         * <p>\r\n         * writes:\r\n         * </p>\r\n         * <pre>\r\n         * # Generated by Apache Commons CSV.\r\n         * # 1970-01-01T00:00:00Z\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final String... headerComments) {\r\n            this.headerComments = CSVFormat.clone(headerComments);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty\r\n         * records.\r\n         *\r\n         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate\r\n         *                         empty lines to empty records.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n            this.ignoreEmptyLines = ignoreEmptyLines;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         *\r\n         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n            this.ignoreHeaderCase = ignoreHeaderCase;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         *\r\n         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         *\r\n         * <ul>\r\n         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n         * </ul>\r\n         *\r\n         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         * @return This instance.\r\n         */\r\n        public Builder setNullString(final String nullString) {\r\n            this.nullString = nullString;\r\n            this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character.\r\n         *\r\n         * @param quoteCharacter the quote character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final char quoteCharacter) {\r\n            setQuote(Character.valueOf(quoteCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character, use {@code null} to disable.\r\n         *\r\n         * @param quoteCharacter the quote character, use {@code null} to disable.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final Character quoteCharacter) {\r\n            if (isLineBreak(quoteCharacter)) {\r\n                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\r\n            }\r\n            this.quoteCharacter = quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote policy to use for output.\r\n         *\r\n         * @param quoteMode the quote policy to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuoteMode(final QuoteMode quoteMode) {\r\n            this.quoteMode = quoteMode;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final char recordSeparator) {\r\n            this.recordSeparator = String.valueOf(recordSeparator);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final String recordSeparator) {\r\n            this.recordSeparator = recordSeparator;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to skip the header record.\r\n         *\r\n         * @param skipHeaderRecord whether to skip the header record.\r\n         * @return This instance.\r\n         */\r\n        public Builder setSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n            this.skipHeaderRecord = skipHeaderRecord;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to add a trailing delimiter.\r\n         *\r\n         * @param trailingDelimiter whether to add a trailing delimiter.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrailingDelimiter(final boolean trailingDelimiter) {\r\n            this.trailingDelimiter = trailingDelimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to trim leading and trailing blanks.\r\n         *\r\n         * @param trim whether to trim leading and trailing blanks.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrim(final boolean trim) {\r\n            this.trim = trim;\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Predefines formats.\r\n     *\r\n     * @since 1.2\r\n     */\r\n    public enum Predefined {\r\n\r\n        /**\r\n         * @see CSVFormat#DEFAULT\r\n         */\r\n        Default(CSVFormat.DEFAULT),\r\n\r\n        /**\r\n         * @see CSVFormat#EXCEL\r\n         */\r\n        Excel(CSVFormat.EXCEL),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD\r\n         * @since 1.3\r\n         */\r\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\r\n         * @since 1.3\r\n         */\r\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_CSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_TSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MYSQL\r\n         */\r\n        MySQL(CSVFormat.MYSQL),\r\n\r\n        /**\r\n         * @see CSVFormat#ORACLE\r\n         */\r\n        Oracle(CSVFormat.ORACLE),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         * @since 1.5\r\n         */\r\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         */\r\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\r\n\r\n        /**\r\n         * @see CSVFormat#RFC4180\r\n         */\r\n        RFC4180(CSVFormat.RFC4180),\r\n\r\n        /**\r\n         * @see CSVFormat#TDF\r\n         */\r\n        TDF(CSVFormat.TDF);\r\n\r\n        private final CSVFormat format;\r\n\r\n        Predefined(final CSVFormat format) {\r\n            this.format = format;\r\n        }\r\n\r\n        /**\r\n         * Gets the format.\r\n         *\r\n         * @return the format.\r\n         */\r\n        public CSVFormat getFormat() {\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing\r\n     * empty lines.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Default\r\n     */\r\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false,\r\n            false, false, false, DuplicateHeaderMode.ALLOW_ALL);\r\n\r\n    /**\r\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is locale-dependent, it might be necessary\r\n     * to customize this format to accommodate your regional settings.\r\n     *\r\n     * <p>\r\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setAllowMissingColumnNames(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     * <p>\r\n     * Note: This is currently like {@link #RFC4180} plus {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)} and\r\n     * {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(false)}.\r\n     * </p>\r\n     *\r\n     * @see Predefined#Excel\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat EXCEL = DEFAULT.builder()\r\n            .setIgnoreEmptyLines(false)\r\n            .setAllowMissingColumnNames(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with an LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.builder()\r\n            .setDelimiter(PIPE)\r\n            .setEscape(BACKSLASH)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with an LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with {@code '\"'}. A header line with field\r\n     * names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format. Values are double quoted only if needed and special\r\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\r\n     *          documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_TSV = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with an LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\r\n     *      -data.html</a>\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MYSQL = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default Oracle format used by the SQL*Loader utility.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with the system line separator character as the record separator. Values are\r\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\r\n     * {@code \"\"}. Values are trimmed.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setTrim()}</li>\r\n     * <li>{@code setSystemRecordSeparator()}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.MINIMAL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Oracle\r\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\r\n     * @since 1.6\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat ORACLE = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setTrim(true)\r\n            .setRecordSeparator(System.lineSeparator())\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with an LF character as the line separator. Values are double quoted and special\r\n     * characters are not escaped. The default NULL string is {@code \"\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape(null)}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(null)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(EMPTY)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL text format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with an LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#RFC4180\r\n     */\r\n    public static final CSVFormat RFC4180 = DEFAULT.builder().setIgnoreEmptyLines(false).build();\r\n\r\n    private static final long serialVersionUID = 2L;\r\n\r\n    /**\r\n     * Tab-delimited format.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreSurroundingSpaces(true)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#TDF\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat TDF = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setIgnoreSurroundingSpaces(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Null-safe clone of an array.\r\n     *\r\n     * @param <T>    The array element type.\r\n     * @param values the source array\r\n     * @return the cloned array.\r\n     */\r\n    @SafeVarargs\r\n    static <T> T[] clone(final T... values) {\r\n        return values == null ? null : values.clone();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains the search char.\r\n     *\r\n     * @param source the string to check.\r\n     * @param searchCh the character to search.\r\n     *\r\n     * @return true if {@code c} contains a line break character\r\n     */\r\n    private static boolean contains(final String source, final char searchCh) {\r\n        return Objects.requireNonNull(source, \"source\").indexOf(searchCh) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains a line break character.\r\n     *\r\n     * @param source the string to check.\r\n     *\r\n     * @return true if {@code c} contains a line break character.\r\n     */\r\n    private static boolean containsLineBreak(final String source) {\r\n        return contains(source, CR) || contains(source, LF);\r\n    }\r\n\r\n    static boolean isBlank(final String value) {\r\n        return value == null || value.trim().isEmpty();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check.\r\n     *\r\n     * @return true if {@code c} is a line break character.\r\n     */\r\n    private static boolean isLineBreak(final char c) {\r\n        return c == LF || c == CR;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check, may be null.\r\n     *\r\n     * @return true if {@code c} is a line break character (and not null).\r\n     */\r\n    private static boolean isLineBreak(final Character c) {\r\n        return c != null && isLineBreak(c.charValue());\r\n    }\r\n\r\n    /** Same test as in as {@link String#trim()}. */\r\n    private static boolean isTrimChar(final char ch) {\r\n        return ch <= SP;\r\n    }\r\n\r\n    /** Same test as in as {@link String#trim()}. */\r\n    private static boolean isTrimChar(final CharSequence charSequence, final int pos) {\r\n        return isTrimChar(charSequence.charAt(pos));\r\n    }\r\n\r\n    /**\r\n     * Creates a new CSV format with the specified delimiter.\r\n     *\r\n     * <p>\r\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.\r\n     * </p>\r\n     *\r\n     * @param delimiter the char used for value separation, must not be a line break character\r\n     * @return a new CSV format.\r\n     * @throws IllegalArgumentException if the delimiter is a line break character\r\n     *\r\n     * @see #DEFAULT\r\n     * @see #RFC4180\r\n     * @see #MYSQL\r\n     * @see #EXCEL\r\n     * @see #TDF\r\n     */\r\n    public static CSVFormat newFormat(final char delimiter) {\r\n        return new CSVFormat(String.valueOf(delimiter), null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false,\r\n                DuplicateHeaderMode.ALLOW_ALL);\r\n    }\r\n\r\n    static String[] toStringArray(final Object[] values) {\r\n        if (values == null) {\r\n            return null;\r\n        }\r\n        final String[] strings = new String[values.length];\r\n        Arrays.setAll(strings, i -> Objects.toString(values[i], null));\r\n        return strings;\r\n    }\r\n\r\n    static CharSequence trim(final CharSequence charSequence) {\r\n        if (charSequence instanceof String) {\r\n            return ((String) charSequence).trim();\r\n        }\r\n        final int count = charSequence.length();\r\n        int len = count;\r\n        int pos = 0;\r\n\r\n        while (pos < len && isTrimChar(charSequence, pos)) {\r\n            pos++;\r\n        }\r\n        while (pos < len && isTrimChar(charSequence, len - 1)) {\r\n            len--;\r\n        }\r\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\r\n    }\r\n\r\n    /**\r\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\r\n     *\r\n     * @param format name\r\n     * @return one of the predefined formats\r\n     * @since 1.2\r\n     */\r\n    public static CSVFormat valueOf(final String format) {\r\n        return CSVFormat.Predefined.valueOf(format).getFormat();\r\n    }\r\n\r\n    private final DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n    private final boolean allowMissingColumnNames;\r\n\r\n    private final boolean autoFlush;\r\n\r\n    private final Character commentMarker; // null if commenting is disabled\r\n\r\n    private final String delimiter;\r\n\r\n    private final Character escapeCharacter; // null if escaping is disabled\r\n\r\n    private final String[] headers; // array of header column names\r\n\r\n    private final String[] headerComments; // array of header comment lines\r\n\r\n    private final boolean ignoreEmptyLines;\r\n\r\n    private final boolean ignoreHeaderCase; // should ignore header names case\r\n\r\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\r\n\r\n    private final String nullString; // the string to be used for null values\r\n\r\n    private final Character quoteCharacter; // null if quoting is disabled\r\n\r\n    private final String quotedNullString;\r\n\r\n    private final QuoteMode quoteMode;\r\n\r\n    private final String recordSeparator; // for outputs\r\n\r\n    private final boolean skipHeaderRecord;\r\n\r\n    private final boolean trailingDelimiter;\r\n\r\n    private final boolean trim;\r\n\r\n    private CSVFormat(final Builder builder) {\r\n        this.delimiter = builder.delimiter;\r\n        this.quoteCharacter = builder.quoteCharacter;\r\n        this.quoteMode = builder.quoteMode;\r\n        this.commentMarker = builder.commentMarker;\r\n        this.escapeCharacter = builder.escapeCharacter;\r\n        this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = builder.allowMissingColumnNames;\r\n        this.ignoreEmptyLines = builder.ignoreEmptyLines;\r\n        this.recordSeparator = builder.recordSeparator;\r\n        this.nullString = builder.nullString;\r\n        this.headerComments = builder.headerComments;\r\n        this.headers = builder.headers;\r\n        this.skipHeaderRecord = builder.skipHeaderRecord;\r\n        this.ignoreHeaderCase = builder.ignoreHeaderCase;\r\n        this.trailingDelimiter = builder.trailingDelimiter;\r\n        this.trim = builder.trim;\r\n        this.autoFlush = builder.autoFlush;\r\n        this.quotedNullString = builder.quotedNullString;\r\n        this.duplicateHeaderMode = builder.duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    /**\r\n     * Creates a customized CSV format.\r\n     *\r\n     * @param delimiter               the char used for value separation, must not be a line break character.\r\n     * @param quoteChar               the Character used as value encapsulation marker, may be {@code null} to disable.\r\n     * @param quoteMode               the quote mode.\r\n     * @param commentStart            the Character used for comment identification, may be {@code null} to disable.\r\n     * @param escape                  the Character used to escape special characters in values, may be {@code null} to disable.\r\n     * @param ignoreSurroundingSpaces {@code true} when whitespaces enclosing values should be ignored.\r\n     * @param ignoreEmptyLines        {@code true} when the parser should skip empty lines.\r\n     * @param recordSeparator         the line separator to use for output.\r\n     * @param nullString              the line separator to use for output.\r\n     * @param headerComments          the comments to be printed by the Printer before the actual CSV data.\r\n     * @param header                  the header\r\n     * @param skipHeaderRecord        if {@code true} the header row will be skipped\r\n     * @param allowMissingColumnNames if {@code true} the missing column names are allowed when parsing the header line\r\n     * @param ignoreHeaderCase        if {@code true} header names will be accessed ignoring case when parsing input\r\n     * @param trim                    if {@code true} next record value will be trimmed\r\n     * @param trailingDelimiter       if {@code true} the trailing delimiter wil be added before record separator (if set)\r\n     * @param autoFlush               if {@code true} the underlying stream will be flushed before closing\r\n     * @param duplicateHeaderMode     the behavior when handling duplicate headers\r\n     * @throws IllegalArgumentException if the delimiter is a line break character.\r\n     */\r\n    private CSVFormat(final String delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape,\r\n            final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\r\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames,\r\n            final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush,\r\n            final DuplicateHeaderMode duplicateHeaderMode) {\r\n        this.delimiter = delimiter;\r\n        this.quoteCharacter = quoteChar;\r\n        this.quoteMode = quoteMode;\r\n        this.commentMarker = commentStart;\r\n        this.escapeCharacter = escape;\r\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = allowMissingColumnNames;\r\n        this.ignoreEmptyLines = ignoreEmptyLines;\r\n        this.recordSeparator = recordSeparator;\r\n        this.nullString = nullString;\r\n        this.headerComments = toStringArray(headerComments);\r\n        this.headers = clone(header);\r\n        this.skipHeaderRecord = skipHeaderRecord;\r\n        this.ignoreHeaderCase = ignoreHeaderCase;\r\n        this.trailingDelimiter = trailingDelimiter;\r\n        this.trim = trim;\r\n        this.autoFlush = autoFlush;\r\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n        this.duplicateHeaderMode = duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    private void append(final char c, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(c);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    private void append(final CharSequence csq, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(csq);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    /**\r\n     * Creates a new Builder for this instance.\r\n     *\r\n     * @return a new Builder.\r\n     */\r\n    public Builder builder() {\r\n        return Builder.create(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a copy of this instance.\r\n     *\r\n     * @return a copy of this instance.\r\n     */\r\n    CSVFormat copy() {\r\n        return builder().build();\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(final Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null || getClass() != obj.getClass()) {\r\n            return false;\r\n        }\r\n        final CSVFormat other = (CSVFormat) obj;\r\n        return duplicateHeaderMode == other.duplicateHeaderMode && allowMissingColumnNames == other.allowMissingColumnNames &&\r\n                autoFlush == other.autoFlush && Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) &&\r\n                Objects.equals(escapeCharacter, other.escapeCharacter) && Arrays.equals(headers, other.headers) &&\r\n                Arrays.equals(headerComments, other.headerComments) && ignoreEmptyLines == other.ignoreEmptyLines &&\r\n                ignoreHeaderCase == other.ignoreHeaderCase && ignoreSurroundingSpaces == other.ignoreSurroundingSpaces &&\r\n                Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) && quoteMode == other.quoteMode &&\r\n                Objects.equals(quotedNullString, other.quotedNullString) && Objects.equals(recordSeparator, other.recordSeparator) &&\r\n                skipHeaderRecord == other.skipHeaderRecord && trailingDelimiter == other.trailingDelimiter && trim == other.trim;\r\n    }\r\n\r\n    /**\r\n     * Formats the specified values.\r\n     *\r\n     * @param values the values to format\r\n     * @return the formatted values\r\n     */\r\n    public String format(final Object... values) {\r\n        final StringWriter out = new StringWriter();\r\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\r\n            csvPrinter.printRecord(values);\r\n            final String res = out.toString();\r\n            final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\r\n            return res.substring(0, len);\r\n        } catch (final IOException e) {\r\n            // should not happen because a StringWriter does not do IO.\r\n            throw new IllegalStateException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether duplicate names are allowed in the headers.\r\n     *\r\n     * @return whether duplicate header names are allowed\r\n     * @since 1.7\r\n     * @deprecated Use {@link #getDuplicateHeaderMode()}.\r\n     */\r\n    @Deprecated\r\n    public boolean getAllowDuplicateHeaderNames() {\r\n        return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;\r\n    }\r\n\r\n    /**\r\n     * Gets whether missing column names are allowed when parsing the header line.\r\n     *\r\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an {@link IllegalArgumentException}.\r\n     */\r\n    public boolean getAllowMissingColumnNames() {\r\n        return allowMissingColumnNames;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to flush on close.\r\n     *\r\n     * @return whether to flush on close.\r\n     * @since 1.6\r\n     */\r\n    public boolean getAutoFlush() {\r\n        return autoFlush;\r\n    }\r\n\r\n    /**\r\n     * Gets the comment marker character, {@code null} disables comments.\r\n     * <p>\r\n     * The comment start character is only recognized at the start of a line.\r\n     * </p>\r\n     * <p>\r\n     * Comments are printed first, before headers.\r\n     * </p>\r\n     * <p>\r\n     * Use {@link Builder#setCommentMarker(char)} or {@link Builder#setCommentMarker(Character)} to set the comment\r\n     * marker written at the start of each comment line.\r\n     * </p>\r\n     * <p>\r\n     * If the comment marker is not set, then the header comments are ignored.\r\n     * </p>\r\n     * <p>\r\n     * For example:\r\n     * </p>\r\n     * <pre>\r\n     * builder.setCommentMarker('#')\r\n     *        .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0));\r\n     * </pre>\r\n     * <p>\r\n     * writes:\r\n     * </p>\r\n     * <pre>\r\n     * # Generated by Apache Commons CSV.\r\n     * # 1970-01-01T00:00:00Z\r\n     * </pre>\r\n     *\r\n     * @return the comment start marker, may be {@code null}\r\n     */\r\n    public Character getCommentMarker() {\r\n        return commentMarker;\r\n    }\r\n\r\n    /**\r\n     * Gets the first character delimiting the values (typically ';', ',' or '\\t').\r\n     *\r\n     * @return the first delimiter character.\r\n     * @deprecated Use {@link #getDelimiterString()}.\r\n     */\r\n    @Deprecated\r\n    public char getDelimiter() {\r\n        return delimiter.charAt(0);\r\n    }\r\n\r\n    /**\r\n     * Gets the character delimiting the values (typically \";\", \",\" or \"\\t\").\r\n     *\r\n     * @return the delimiter.\r\n     * @since 1.9.0\r\n     */\r\n    public String getDelimiterString() {\r\n        return delimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets how duplicate headers are handled.\r\n     *\r\n     * @return if duplicate header values are allowed, allowed conditionally, or disallowed.\r\n     * @since 1.10.0\r\n     */\r\n    public DuplicateHeaderMode getDuplicateHeaderMode() {\r\n        return duplicateHeaderMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the escape character.\r\n     *\r\n     * @return the escape character, may be {@code null}\r\n     */\r\n    public Character getEscapeCharacter() {\r\n        return escapeCharacter;\r\n    }\r\n\r\n    /**\r\n     * Gets a copy of the header array.\r\n     *\r\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\r\n     */\r\n    public String[] getHeader() {\r\n        return headers != null ? headers.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Gets a copy of the header comment array to write before the CSV data.\r\n     * <p>\r\n     * This setting is ignored by the parser.\r\n     * </p>\r\n     * <p>\r\n     * Comments are printed first, before headers.\r\n     * </p>\r\n     * <p>\r\n     * Use {@link Builder#setCommentMarker(char)} or {@link Builder#setCommentMarker(Character)} to set the comment\r\n     * marker written at the start of each comment line.\r\n     * </p>\r\n     * <p>\r\n     * If the comment marker is not set, then the header comments are ignored.\r\n     * </p>\r\n     * <p>\r\n     * For example:\r\n     * </p>\r\n     * <pre>\r\n     * builder.setCommentMarker('#')\r\n     *        .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0));\r\n     * </pre>\r\n     * <p>\r\n     * writes:\r\n     * </p>\r\n     * <pre>\r\n     * # Generated by Apache Commons CSV.\r\n     * # 1970-01-01T00:00:00Z\r\n     * </pre>\r\n     *\r\n     * @return a copy of the header comment array; {@code null} if disabled.\r\n     */\r\n    public String[] getHeaderComments() {\r\n        return headerComments != null ? headerComments.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Gets whether empty lines between records are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty records.\r\n     */\r\n    public boolean getIgnoreEmptyLines() {\r\n        return ignoreEmptyLines;\r\n    }\r\n\r\n    /**\r\n     * Gets whether header names will be accessed ignoring case when parsing input.\r\n     *\r\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case-sensitive.\r\n     * @since 1.3\r\n     */\r\n    public boolean getIgnoreHeaderCase() {\r\n        return ignoreHeaderCase;\r\n    }\r\n\r\n    /**\r\n     * Gets whether spaces around values are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\r\n     */\r\n    public boolean getIgnoreSurroundingSpaces() {\r\n        return ignoreSurroundingSpaces;\r\n    }\r\n\r\n    /**\r\n     * Gets the String to convert to and from {@code null}.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     */\r\n    public String getNullString() {\r\n        return nullString;\r\n    }\r\n\r\n    /**\r\n     * Gets the character used to encapsulate values containing special characters.\r\n     *\r\n     * @return the quoteChar character, may be {@code null}\r\n     */\r\n    public Character getQuoteCharacter() {\r\n        return quoteCharacter;\r\n    }\r\n\r\n    /**\r\n     * Gets the quote policy output fields.\r\n     *\r\n     * @return the quote policy\r\n     */\r\n    public QuoteMode getQuoteMode() {\r\n        return quoteMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the record separator delimiting output records.\r\n     *\r\n     * @return the record separator\r\n     */\r\n    public String getRecordSeparator() {\r\n        return recordSeparator;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to skip the header record.\r\n     *\r\n     * @return whether to skip the header record.\r\n     */\r\n    public boolean getSkipHeaderRecord() {\r\n        return skipHeaderRecord;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to add a trailing delimiter.\r\n     *\r\n     * @return whether to add a trailing delimiter.\r\n     * @since 1.3\r\n     */\r\n    public boolean getTrailingDelimiter() {\r\n        return trailingDelimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to trim leading and trailing blanks. This is used by {@link #print(Object, Appendable, boolean)} Also by\r\n     * {CSVParser#addRecordValue(boolean)}\r\n     *\r\n     * @return whether to trim leading and trailing blanks.\r\n     */\r\n    public boolean getTrim() {\r\n        return trim;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + Arrays.hashCode(headers);\r\n        result = prime * result + Arrays.hashCode(headerComments);\r\n        return prime * result + Objects.hash(duplicateHeaderMode, allowMissingColumnNames, autoFlush, commentMarker, delimiter, escapeCharacter,\r\n                ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator,\r\n                skipHeaderRecord, trailingDelimiter, trim);\r\n    }\r\n\r\n    /**\r\n     * Tests whether comments are supported by this format.\r\n     *\r\n     * Note that the comment introducer character is only recognized at the start of a line.\r\n     *\r\n     * @return {@code true} is comments are supported, {@code false} otherwise\r\n     */\r\n    public boolean isCommentMarkerSet() {\r\n        return commentMarker != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether the next characters constitute a delimiter\r\n     *\r\n     * @param ch\r\n     *            the current char\r\n     * @param charSeq\r\n     *            the match char sequence\r\n     * @param startIndex\r\n     *            where start to match\r\n     * @param delimiter\r\n     *            the delimiter\r\n     * @param delimiterLength\r\n     *            the delimiter length\r\n     * @return true if the match is successful\r\n     */\r\n    private boolean isDelimiter(final char ch, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength) {\r\n        if (ch != delimiter[0]) {\r\n            return false;\r\n        }\r\n        final int len = charSeq.length();\r\n        if (startIndex + delimiterLength > len) {\r\n            return false;\r\n        }\r\n        for (int i = 1; i < delimiterLength; i++) {\r\n            if (charSeq.charAt(startIndex + i) != delimiter[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests whether escapes are being processed.\r\n     *\r\n     * @return {@code true} if escapes are processed\r\n     */\r\n    public boolean isEscapeCharacterSet() {\r\n        return escapeCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether a null string has been defined.\r\n     *\r\n     * @return {@code true} if a nullString is defined\r\n     */\r\n    public boolean isNullStringSet() {\r\n        return nullString != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether a quoteChar has been defined.\r\n     *\r\n     * @return {@code true} if a quoteChar is defined\r\n     */\r\n    public boolean isQuoteCharacterSet() {\r\n        return quoteCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Parses the specified content.\r\n     *\r\n     * <p>\r\n     * See also the various static parse methods on {@link CSVParser}.\r\n     * </p>\r\n     *\r\n     * @param reader the input stream\r\n     * @return a parser over a stream of {@link CSVRecord}s.\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    public CSVParser parse(final Reader reader) throws IOException {\r\n        return new CSVParser(reader, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out the output.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     */\r\n    public CSVPrinter print(final Appendable out) throws IOException {\r\n        return new CSVPrinter(out, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified {@code File} with given {@code Charset}.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\r\n        // The writer will be closed when close() is called.\r\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\r\n    }\r\n\r\n    /**\r\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated as needed. Useful when one wants to\r\n     * avoid creating CSVPrinters. Trims the value if {@link #getTrim()} is true.\r\n     *\r\n     * @param value     value to output.\r\n     * @param out       where to print the value.\r\n     * @param newRecord if this a new record.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\r\n        // null values are considered empty\r\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\r\n        CharSequence charSequence;\r\n        if (value == null) {\r\n            // https://issues.apache.org/jira/browse/CSV-203\r\n            if (null == nullString) {\r\n                charSequence = EMPTY;\r\n            } else if (QuoteMode.ALL == quoteMode) {\r\n                charSequence = quotedNullString;\r\n            } else {\r\n                charSequence = nullString;\r\n            }\r\n        } else if (value instanceof CharSequence) {\r\n            charSequence = (CharSequence) value;\r\n        } else if (value instanceof Reader) {\r\n            print((Reader) value, out, newRecord);\r\n            return;\r\n        } else {\r\n            charSequence = value.toString();\r\n        }\r\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\r\n        print(value, charSequence, out, newRecord);\r\n    }\r\n\r\n    private synchronized void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\r\n        final int offset = 0;\r\n        final int len = value.length();\r\n        if (!newRecord) {\r\n            out.append(getDelimiterString());\r\n        }\r\n        if (object == null) {\r\n            out.append(value);\r\n        } else if (isQuoteCharacterSet()) {\r\n            // The original object is needed so can check for Number\r\n            printWithQuotes(object, value, out, newRecord);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(value, out);\r\n        } else {\r\n            out.append(value, offset, len);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified {@code Path} with given {@code Charset},\r\n     * returns a {@code CSVPrinter} which the caller MUST close.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\r\n        return print(Files.newBufferedWriter(out, charset));\r\n    }\r\n\r\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\r\n        // Reader is never null\r\n        if (!newRecord) {\r\n            append(getDelimiterString(), out);\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            printWithQuotes(reader, out);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(reader, out);\r\n        } else if (out instanceof Writer) {\r\n            IOUtils.copyLarge(reader, (Writer) out);\r\n        } else {\r\n            IOUtils.copy(reader, out);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Prints to the {@link System#out}.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @return a printer to {@link System#out}.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    public CSVPrinter printer() throws IOException {\r\n        return new CSVPrinter(System.out, this);\r\n    }\r\n\r\n    /**\r\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\r\n     *\r\n     * @param appendable where to write\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void println(final Appendable appendable) throws IOException {\r\n        if (getTrailingDelimiter()) {\r\n            append(getDelimiterString(), appendable);\r\n        }\r\n        if (recordSeparator != null) {\r\n            append(recordSeparator, appendable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints the given {@code values} to {@code out} as a single record of delimiter-separated values followed by the record separator.\r\n     *\r\n     * <p>\r\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing\r\n     * the record, so there is no need to call {@link #println(Appendable)}.\r\n     * </p>\r\n     *\r\n     * @param appendable    where to write.\r\n     * @param values values to output.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException {\r\n        for (int i = 0; i < values.length; i++) {\r\n            print(values[i], appendable, i == 0);\r\n        }\r\n        println(appendable);\r\n    }\r\n\r\n    /*\r\n     * Note: Must only be called if escaping is enabled, otherwise will generate NPE.\r\n     */\r\n    private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int end = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n\r\n        while (pos < end) {\r\n            char c = charSeq.charAt(pos);\r\n            final boolean isDelimiterStart = isDelimiter(c, charSeq, pos, delim, delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    appendable.append(charSeq, start, pos);\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                appendable.append(escape);\r\n                appendable.append(c);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        pos++;\r\n                        c = charSeq.charAt(pos);\r\n                        appendable.append(escape);\r\n                        appendable.append(c);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            appendable.append(charSeq, start, pos);\r\n        }\r\n    }\r\n\r\n    private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n\r\n        @SuppressWarnings(\"resource\") // Temp reader on input reader.\r\n        final ExtendedBufferedReader bufferedReader = new ExtendedBufferedReader(reader);\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        int c;\r\n        while (-1 != (c = bufferedReader.read())) {\r\n            builder.append((char) c);\r\n            final boolean isDelimiterStart = isDelimiter((char) c, builder.toString() + new String(bufferedReader.lookAhead(delimLength - 1)), pos, delim,\r\n                    delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    append(builder.substring(start, pos), appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                append(escape, appendable);\r\n                append((char) c, appendable);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        c = bufferedReader.read();\r\n                        append(escape, appendable);\r\n                        append((char) c, appendable);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            append(builder.substring(start, pos), appendable);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\r\n     */\r\n    // the original object is needed so can check for Number\r\n    private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\r\n        boolean quote = false;\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int len = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char quoteChar = getQuoteCharacter().charValue();\r\n        // If escape char not specified, default to the quote char\r\n        // This avoids having to keep checking whether there is an escape character\r\n        // at the cost of checking against quote twice\r\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\r\n\r\n        QuoteMode quoteModePolicy = getQuoteMode();\r\n        if (quoteModePolicy == null) {\r\n            quoteModePolicy = QuoteMode.MINIMAL;\r\n        }\r\n        switch (quoteModePolicy) {\r\n        case ALL:\r\n        case ALL_NON_NULL:\r\n            quote = true;\r\n            break;\r\n        case NON_NUMERIC:\r\n            quote = !(object instanceof Number);\r\n            break;\r\n        case NONE:\r\n            // Use the existing escaping code\r\n            printWithEscapes(charSeq, out);\r\n            return;\r\n        case MINIMAL:\r\n            if (len <= 0) {\r\n                // Always quote an empty token that is the first\r\n                // on the line, as it may be the only thing on the\r\n                // line. If it were not quoted in that case,\r\n                // an empty line has no tokens.\r\n                if (newRecord) {\r\n                    quote = true;\r\n                }\r\n            } else {\r\n                char c = charSeq.charAt(pos);\r\n\r\n                if (c <= COMMENT) {\r\n                    // Some other chars at the start of a value caused the parser to fail, so for now\r\n                    // encapsulate if we start in anything less than '#'. We are being conservative\r\n                    // by including the default comment char too.\r\n                    quote = true;\r\n                } else {\r\n                    while (pos < len) {\r\n                        c = charSeq.charAt(pos);\r\n                        if (c == LF || c == CR || c == quoteChar || c == escapeChar || isDelimiter(c, charSeq, pos, delim, delimLength)) {\r\n                            quote = true;\r\n                            break;\r\n                        }\r\n                        pos++;\r\n                    }\r\n\r\n                    if (!quote) {\r\n                        pos = len - 1;\r\n                        c = charSeq.charAt(pos);\r\n                        // Some other chars at the end caused the parser to fail, so for now\r\n                        // encapsulate if we end in anything less than ' '\r\n                        if (isTrimChar(c)) {\r\n                            quote = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!quote) {\r\n                // No encapsulation needed - write out the original value\r\n                out.append(charSeq, start, len);\r\n                return;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\r\n        }\r\n\r\n        if (!quote) {\r\n            // No encapsulation needed - write out the original value\r\n            out.append(charSeq, start, len);\r\n            return;\r\n        }\r\n\r\n        // We hit something that needed encapsulation\r\n        out.append(quoteChar);\r\n\r\n        // Pick up where we left off: pos should be positioned on the first character that caused\r\n        // the need for encapsulation.\r\n        while (pos < len) {\r\n            final char c = charSeq.charAt(pos);\r\n            if (c == quoteChar || c == escapeChar) {\r\n                // write out the chunk up until this point\r\n                out.append(charSeq, start, pos);\r\n                out.append(escapeChar); // now output the escape\r\n                start = pos; // and restart with the matched char\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // Write the last segment\r\n        out.append(charSeq, start, pos);\r\n        out.append(quoteChar);\r\n    }\r\n\r\n    /**\r\n     * Always use quotes unless QuoteMode is NONE, so we do not have to look ahead.\r\n     *\r\n     * @param reader What to print\r\n     * @param appendable Where to print it\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {\r\n\r\n        if (getQuoteMode() == QuoteMode.NONE) {\r\n            printWithEscapes(reader, appendable);\r\n            return;\r\n        }\r\n\r\n        int pos = 0;\r\n\r\n        final char quote = getQuoteCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        append(quote, appendable);\r\n\r\n        int c;\r\n        while (-1 != (c = reader.read())) {\r\n            builder.append((char) c);\r\n            if (c == quote) {\r\n                // write out segment up until this char\r\n                if (pos > 0) {\r\n                    append(builder.substring(0, pos), appendable);\r\n                    append(quote, appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n\r\n                append((char) c, appendable);\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > 0) {\r\n            append(builder.substring(0, pos), appendable);\r\n        }\r\n\r\n        append(quote, appendable);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        final StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\r\n        if (isEscapeCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\r\n        }\r\n        if (quoteMode != null) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\r\n        }\r\n        if (isCommentMarkerSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\r\n        }\r\n        if (isNullStringSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"NullString=<\").append(nullString).append('>');\r\n        }\r\n        if (recordSeparator != null) {\r\n            sb.append(' ');\r\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\r\n        }\r\n        if (getIgnoreEmptyLines()) {\r\n            sb.append(\" EmptyLines:ignored\");\r\n        }\r\n        if (getIgnoreSurroundingSpaces()) {\r\n            sb.append(\" SurroundingSpaces:ignored\");\r\n        }\r\n        if (getIgnoreHeaderCase()) {\r\n            sb.append(\" IgnoreHeaderCase:ignored\");\r\n        }\r\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\r\n        if (headerComments != null) {\r\n            sb.append(' ');\r\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\r\n        }\r\n        if (headers != null) {\r\n            sb.append(' ');\r\n            sb.append(\"Header:\").append(Arrays.toString(headers));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    String trim(final String value) {\r\n        return getTrim() ? value.trim() : value;\r\n    }\r\n\r\n    /**\r\n     * Verifies the validity and consistency of the attributes, and throws an {@link IllegalArgumentException} if necessary.\r\n     * <p>\r\n     * Because an instance can be used for both writing and parsing, not all conditions can be tested here. For example, allowMissingColumnNames is only used\r\n     * for parsing, so it cannot be used here.\r\n     * </p>\r\n     *\r\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.\r\n     */\r\n    private void validate() throws IllegalArgumentException {\r\n        if (containsLineBreak(delimiter)) {\r\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n        }\r\n\r\n        if (quoteCharacter != null && contains(delimiter, quoteCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && contains(delimiter, escapeCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\r\n        }\r\n\r\n        if (commentMarker != null && contains(delimiter, commentMarker.charValue())) {\r\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\r\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\r\n        }\r\n\r\n        // Validate headers\r\n        if (headers != null && duplicateHeaderMode != DuplicateHeaderMode.ALLOW_ALL) {\r\n            final Set<String> dupCheckSet = new HashSet<>(headers.length);\r\n            final boolean emptyDuplicatesAllowed = duplicateHeaderMode == DuplicateHeaderMode.ALLOW_EMPTY;\r\n            for (final String header : headers) {\r\n                final boolean blank = isBlank(header);\r\n                // Sanitise all empty headers to the empty string \"\" when checking duplicates\r\n                final boolean containsHeader = !dupCheckSet.add(blank ? \"\" : header);\r\n                if (containsHeader && !(blank && emptyDuplicatesAllowed)) {\r\n                    throw new IllegalArgumentException(\r\n                        String.format(\r\n                            \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\r\n                            header, Arrays.toString(headers)));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} that allows duplicate header names.\r\n     *\r\n     * @return a new {@code CSVFormat} that allows duplicate header names\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean) Builder#setAllowDuplicateHeaderNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames() {\r\n        return builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     *\r\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n        final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\r\n        return builder().setDuplicateHeaderMode(mode).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @see Builder#setAllowMissingColumnNames(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames() {\r\n        return builder().setAllowMissingColumnNames(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\r\n     *\r\n     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause\r\n     *                                an {@link IllegalArgumentException} to be thrown.\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n        return builder().setAllowMissingColumnNames(allowMissingColumnNames).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to flush on close.\r\n     *\r\n     * @param autoFlush whether to flush on close.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setAutoFlush(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\r\n        return builder().setAutoFlush(autoFlush).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final char commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final Character commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the delimiter of the format set to the specified character.\r\n     *\r\n     * @param delimiter the delimiter character\r\n     * @return A new CSVFormat that is equal to this with the specified character as a delimiter\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setDelimiter(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withDelimiter(final char delimiter) {\r\n        return builder().setDelimiter(delimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final char escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final Character escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} using the first record as header.\r\n     *\r\n     * <p>\r\n     * Calling this method is equivalent to calling:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\r\n     * </pre>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but using the first record as header.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(String...) Builder#setHeader()}.{@link Builder#setSkipHeaderRecord(boolean) setSkipHeaderRecord(true)}.\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withFirstRecordAsHeader() {\r\n        // @formatter:off\r\n        return builder()\r\n                .setHeader()\r\n                .setSkipHeaderRecord(true)\r\n                .build();\r\n        // @formatter:on\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format defined by the enum class.\r\n     *\r\n     * <p>\r\n     * Example:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * public enum Header {\r\n     *     Name, Email, Phone\r\n     * }\r\n     *\r\n     * CSVFormat format = aformat.withHeader(Header.class);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setHeader(String...)\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(Class)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\r\n        return builder().setHeader(headerEnum).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(resultSet);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSet)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\r\n        return builder().setHeader(resultSet).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(metaData);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSetMetaData)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n        return builder().setHeader(resultSetMetaData).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file\r\n     * with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param header the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @deprecated Use {@link Builder#setHeader(String...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final String... header) {\r\n        return builder().setHeader(header).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.\r\n     * This setting is ignored by the parser.\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n     * </pre>\r\n     *\r\n     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeaderComments(Object...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeaderComments(final Object... headerComments) {\r\n        return builder().setHeaderComments(headerComments).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @see Builder#setIgnoreEmptyLines(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines() {\r\n        return builder().setIgnoreEmptyLines(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty\r\n     *                         lines to empty records.\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n        return builder().setIgnoreEmptyLines(ignoreEmptyLines).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that will ignore the new case header name behavior.\r\n     * @see Builder#setIgnoreHeaderCase(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean) Builder#setIgnoreHeaderCase(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase() {\r\n        return builder().setIgnoreHeaderCase(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether header names should be accessed ignoring case.\r\n     *\r\n     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n        return builder().setIgnoreHeaderCase(ignoreHeaderCase).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\r\n     * @see Builder#setIgnoreSurroundingSpaces(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean) Builder#setIgnoreSurroundingSpaces(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces() {\r\n        return builder().setIgnoreSurroundingSpaces(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n        return builder().setIgnoreSurroundingSpaces(ignoreSurroundingSpaces).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with conversions to and from null for strings on input and output.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\r\n     * @deprecated Use {@link Builder#setNullString(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withNullString(final String nullString) {\r\n        return builder().setNullString(nullString).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final char quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character, use {@code null} to disable.\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final Character quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\r\n     *\r\n     * @param quoteMode the quote policy to use for output.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\r\n     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuoteMode(final QuoteMode quoteMode) {\r\n        return builder().setQuoteMode(quoteMode).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified character.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @deprecated Use {@link Builder#setRecordSeparator(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified String.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with skipping the header record set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean) Builder#setSkipHeaderRecord(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord() {\r\n        return builder().setSkipHeaderRecord(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to skip the header record.\r\n     *\r\n     * @param skipHeaderRecord whether to skip the header record.\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setHeader(String...)\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n        return builder().setSkipHeaderRecord(skipHeaderRecord).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows\r\n     * and LF on Linux.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSystemRecordSeparator() {\r\n        return builder().setRecordSeparator(System.lineSeparator()).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} to add a trailing delimiter.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean) Builder#setTrailingDelimiter(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter() {\r\n        return builder().setTrailingDelimiter(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to add a trailing delimiter.\r\n     *\r\n     * @param trailingDelimiter whether to add a trailing delimiter.\r\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\r\n        return builder().setTrailingDelimiter(trailingDelimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean) Builder#setTrim(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim() {\r\n        return builder().setTrim(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @param trim whether to trim leading and trailing blanks.\r\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim(final boolean trim) {\r\n        return builder().setTrim(trim).build();\r\n    }\r\n}\r",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 2f7e6b9ff..d6218213a 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -2449,7 +2449,7 @@ private void validate() throws IllegalArgumentException {\n         }\r\n \r\n         if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\r\n-            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\r\n+            throw new IllegalArgumentException(\"Quote mode set to NONE but no escape character is set\");\r\n         }\r\n \r\n         // Validate headers\r\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 348,
    "title": "Update exception message in CSVRecord#getNextRecord()",
    "state": "closed",
    "created_at": "2023-08-30T11:47:16Z",
    "merge_commit_sha": "008269a7ea44dda0d743d5a10f175ad3628270a6",
    "base_sha": "87529dea16bd7f20f6b7e8d3597689ad6043156e",
    "head_sha": "dbc418b9e79369d4a4b440340322b45192d10aed",
    "user_login": "gbidsilva",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.UncheckedIOException;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVParserTest2 {\n\n    @Test\n    public void testUncheckedIOExceptionMessage() {\n        final String csvData = \"a,b,c\\n1,2,3\\nx,y,z\";\n        try (CSVParser parser = CSVParser.parse(new StringReader(csvData), CSVFormat.DEFAULT)) {\n            // Simulate an IOException during parsing\n            assertThrows(UncheckedIOException.class, () -> {\n                throw new IOException(\"Simulated IOException\");\n            }, \"Exception reading next record: Simulated IOException\");\n        } catch (IOException e) {\n            // Handle the IOException thrown by CSVParser.parse\n            e.printStackTrace();\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.UncheckedIOException;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n\n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n\n            return this.current != null;\n        }\n\n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n\n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n\n            return next;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Header information based on name and position.\n     */\n    private static final class Headers {\n\n        /**\n         * Header column positions (0-based)\n         */\n        final Map<String, Integer> headerMap;\n\n        /**\n         * Header names in column order\n         */\n        final List<String> headerNames;\n\n        Headers(final Map<String, Integer> headerMap, final List<String> headerNames) {\n            this.headerMap = headerMap;\n            this.headerNames = headerNames;\n        }\n    }\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        return parse(file.toPath(), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        Objects.requireNonNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates and returns a parser for the given {@link Path}, which the caller MUST close.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(path, \"path\");\n        Objects.requireNonNull(format, \"format\");\n        return parse(Files.newInputStream(path), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(string, \"string\");\n        Objects.requireNonNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates and returns a parser for the given URL, which the caller MUST close.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(url, \"url\");\n        Objects.requireNonNull(charset, \"charset\");\n        Objects.requireNonNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private String headerComment;\n\n    private String trailerComment;\n\n    private final CSVFormat format;\n\n    private final Headers headers;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Constructs a new instance using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Constructs a new instance using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n        throws IOException {\n        Objects.requireNonNull(reader, \"reader\");\n        Objects.requireNonNull(format, \"format\");\n\n        this.format = format.copy();\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headers = createHeaders();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.format.trim(this.reusableToken.content.toString());\n        if (lastRecord && input.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        this.recordList.add(handleNull(input));\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    private Map<String, Integer> createEmptyHeaderMap() {\n        return this.format.getIgnoreHeaderCase() ?\n                new TreeMap<>(String.CASE_INSENSITIVE_ORDER) :\n                new LinkedHashMap<>();\n    }\n\n    /**\n     * Creates the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Headers createHeaders() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        List<String> headerNames = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = createEmptyHeaderMap();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                    headerComment = nextRecord.getComment();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    final CSVRecord nextRecord = this.nextRecord();\n                    if (nextRecord != null) {\n                        headerComment = nextRecord.getComment();\n                    }\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                // Track an occurrence of a null, empty or blank header.\n                boolean observedMissing = false;\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean blankHeader = CSVFormat.isBlank(header);\n                    if (blankHeader && !this.format.getAllowMissingColumnNames()) {\n                        throw new IllegalArgumentException(\n                            \"A header name is missing in \" + Arrays.toString(headerRecord));\n                    }\n\n                    final boolean containsHeader = blankHeader ? observedMissing : hdrMap.containsKey(header);\n                    final DuplicateHeaderMode headerMode = this.format.getDuplicateHeaderMode();\n                    final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\n                    final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\n\n                    if (containsHeader && !duplicatesAllowed && !(blankHeader && emptyDuplicatesAllowed)) {\n                        throw new IllegalArgumentException(\n                            String.format(\n                                \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\n                                header, Arrays.toString(headerRecord)));\n                    }\n                    observedMissing |= blankHeader;\n                    if (header != null) {\n                        hdrMap.put(header, Integer.valueOf(i));\n                        if (headerNames == null) {\n                            headerNames = new ArrayList<>(headerRecord.length);\n                        }\n                        headerNames.add(header);\n                    }\n                }\n            }\n        }\n        if (headerNames == null) {\n            headerNames = Collections.emptyList(); // immutable\n        } else {\n            headerNames = Collections.unmodifiableList(headerNames);\n        }\n        return new Headers(hdrMap, headerNames);\n    }\n\n    /**\n     * Gets the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Gets the header comment, if any.\n     * The header comment appears before the header record.\n     *\n     * @return the header comment for this stream, or null if no comment is available.\n     * @since 1.10.0\n     */\n    public String getHeaderComment() {\n        return headerComment;\n    }\n\n    /**\n     * Gets a copy of the header map as defined in the CSVFormat's header.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * <p>\n     * Note: The map can only provide a one-to-one mapping when the format did not\n     * contain null or duplicate column names.\n     * </p>\n     *\n     * @return a copy of the header map.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        if (this.headers.headerMap == null) {\n            return null;\n        }\n        final Map<String, Integer> map = createEmptyHeaderMap();\n        map.putAll(this.headers.headerMap);\n        return map;\n    }\n\n    /**\n     * Gets the underlying header map.\n     *\n     * @return the underlying header map.\n     */\n    Map<String, Integer> getHeaderMapRaw() {\n        return this.headers.headerMap;\n    }\n\n    /**\n     * Gets a read-only list of header names that iterates in column order as defined in the CSVFormat's header.\n     * <p>\n     * Note: The list provides strings that can be used as keys in the header map.\n     * The list will not contain null column names if they were present in the input\n     * format.\n     * </p>\n     *\n     * @return read-only list of header names that iterates in column order.\n     * @see #getHeaderMap()\n     * @since 1.7\n     */\n    public List<String> getHeaderNames() {\n        return Collections.unmodifiableList(headers.headerNames);\n    }\n\n    /**\n     * Gets the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws UncheckedIOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() {\n        return stream().collect(Collectors.toList());\n    }\n\n    /**\n     * Gets the trailer comment, if any.\n     * Trailer comments are located between the last record and EOF\n     *\n     * @return the trailer comment for this stream, or null if no comment is available.\n     * @since 1.10.0\n     */\n    public String getTrailerComment() {\n        return trailerComment;\n    }\n\n    /**\n     * Handle whether input is parsed as null\n     *\n     * @param input\n     *           the cell data to further processed\n     * @return null if input is parsed as null, or input itself if input isn't parsed as null\n     */\n    private String handleNull(final String input) {\n        final boolean isQuoted = this.reusableToken.isQuoted;\n        final String nullString = format.getNullString();\n        final boolean strictQuoteMode = isStrictQuoteMode();\n        if (input.equals(nullString)) {\n            // nullString = NULL(String), distinguish between \"NULL\" and NULL in ALL_NON_NULL or NON_NUMERIC quote mode\n            return strictQuoteMode && isQuoted ? input : null;\n        }\n        // don't set nullString, distinguish between \"\" and ,, (absent values) in All_NON_NULL or NON_NUMERIC quote mode\n        return strictQuoteMode && nullString == null && input.isEmpty() && !isQuoted ? null : input;\n    }\n\n    /**\n     * Checks whether there is a header comment.\n     * The header comment appears before the header record.\n     * Note that if the parser's format has been given an explicit header\n     * (with {@link CSVFormat.Builder#setHeader(String... )} or another overload)\n     * and the header record is not being skipped\n     * ({@link CSVFormat.Builder#setSkipHeaderRecord} is false) then any initial comments\n     * will be associated with the first record, not the header.\n     *\n     * @return true if this parser has seen a header comment, false otherwise\n     * @since 1.10.0\n     */\n    public boolean hasHeaderComment() {\n        return headerComment != null;\n    }\n\n    /**\n     * Checks whether there is a trailer comment.\n     * Trailer comments are located between the last record and EOF.\n     * The trailer comments will only be available after the parser has\n     * finished processing this stream.\n     *\n     * @return true if this parser has seen a trailer comment, false otherwise\n     * @since 1.10.0\n     */\n    public boolean hasTrailerComment() {\n        return trailerComment != null;\n    }\n\n    /**\n     * Tests whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Tests whether the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or {@link QuoteMode#NON_NUMERIC}.\n     *\n     * @return true if the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or\n     *         {@link QuoteMode#NON_NUMERIC}.\n     */\n    private boolean isStrictQuoteMode() {\n        return this.format.getQuoteMode() == QuoteMode.ALL_NON_NULL ||\n               this.format.getQuoteMode() == QuoteMode.NON_NUMERIC;\n    }\n\n    /**\n     * Returns the record iterator.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed, the iterator will not yield any more records.\n     * A call to {@link Iterator#hasNext()} will return {@code false} and\n     * a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     * <p>\n     * If it is necessary to construct an iterator which is usable after the\n     * parser is closed, one option is to extract all records as a list with\n     * {@link #getRecords()}, and return an iterator to that list.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                } else if (sb != null) {\n                    trailerComment = sb.toString();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this, this.recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment,\n                this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a sequential {@code Stream} with this collection as its source.\n     * <p>\n     * If the parser is closed, the stream will not produce any more values.\n     * See the comments in {@link #iterator()}.\n     * </p>\n     * @return a sequential {@code Stream} with this collection as its source.\n     * @since 1.9.0\n     */\n    public Stream<CSVRecord> stream() {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator(), Spliterator.ORDERED), false);\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 96e77a77d..8679367c2 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -147,7 +147,7 @@ private CSVRecord getNextRecord() {\n             try {\n                 return CSVParser.this.nextRecord();\n             } catch (final IOException e) {\n-                throw new UncheckedIOException(e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n+                throw new UncheckedIOException(\"Exception reading next record: \" + e.toString(), e);\n             }\n         }\n \n"
      }
    ]
  },
  {
    "pr_number": 347,
    "title": "[CSV-147] Better error message during faulty CSV record read",
    "state": "closed",
    "created_at": "2023-08-30T08:12:27Z",
    "merge_commit_sha": "a33b24c26c2303af61cc7bcdf0fb94d62d3b19e1",
    "base_sha": "710459843cbe3cf4f1ca3aaac5a6eb22d049e643",
    "head_sha": "c0759cd95c997bfbbbab5d0d3f5270960f40e033",
    "user_login": "gbidsilva",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/Lexer.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport org.junit.jupiter.api.Test;\n\npublic class LexerTest2 {\n\n    private Lexer createLexer(final String input, final CSVFormat format) {\n        return new Lexer(format, new ExtendedBufferedReader(new StringReader(input)));\n    }\n\n    @Test\n    public void testInvalidCharBetweenEncapsulatedTokenAndDelimiter() {\n        final String code = \"\\\"foo\\\"x,bar\";\n        final CSVFormat format = CSVFormat.DEFAULT.withQuote('\"');\n        try (final Lexer lexer = createLexer(code, format)) {\n            assertThrows(IOException.class, () -> lexer.nextToken(new Token()), \n                \"Invalid char between encapsulated token and delimiter at line: 1, position: 5\");\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport static org.apache.commons.csv.Token.Type.COMMENT;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Token.Type.INVALID;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.IOException;\n\n/**\n * Lexical analyzer.\n */\nfinal class Lexer implements Closeable {\n\n    private static final String CR_STRING = Character.toString(CR);\n    private static final String LF_STRING = Character.toString(LF);\n\n    /**\n     * Constant char to use for disabling comments, escapes, and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char[] delimiter;\n    private final char[] delimiterBuf;\n    private final char[] escapeDelimiterBuf;\n    private final char escape;\n    private final char quoteChar;\n    private final char commentStart;\n\n    private final boolean ignoreSurroundingSpaces;\n    private final boolean ignoreEmptyLines;\n\n    /** The input stream */\n    private final ExtendedBufferedReader reader;\n    private String firstEol;\n\n    private boolean isLastTokenDelimiter;\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n        this.reader = reader;\n        this.delimiter = format.getDelimiterString().toCharArray();\n        this.escape = mapNullToDisabled(format.getEscapeCharacter());\n        this.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\n        this.commentStart = mapNullToDisabled(format.getCommentMarker());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n        this.delimiterBuf = new char[delimiter.length - 1];\n        this.escapeDelimiterBuf = new char[2 * delimiter.length - 1];\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        reader.close();\n    }\n\n    /**\n     * Returns the current character position\n     *\n     * @return the current character position\n     */\n    long getCharacterPosition() {\n        return reader.getPosition();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        return reader.getCurrentLineNumber();\n    }\n\n    String getFirstEol(){\n        return firstEol;\n    }\n\n    boolean isClosed() {\n        return reader.isClosed();\n    }\n\n    boolean isCommentStart(final int ch) {\n        return ch == commentStart;\n    }\n\n    /**\n     * Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n     *\n     * @param ch\n     *             the current character.\n     * @return true if the next characters constitute a delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isDelimiter(final int ch) throws IOException {\n        isLastTokenDelimiter = false;\n        if (ch != delimiter[0]) {\n            return false;\n        }\n        if (delimiter.length == 1) {\n            isLastTokenDelimiter = true;\n            return true;\n        }\n        reader.lookAhead(delimiterBuf);\n        for (int i = 0; i < delimiterBuf.length; i++) {\n            if (delimiterBuf[i] != delimiter[i+1]) {\n                return false;\n            }\n        }\n        final int count = reader.read(delimiterBuf, 0, delimiterBuf.length);\n        isLastTokenDelimiter = count != END_OF_STREAM;\n        return isLastTokenDelimiter;\n    }\n\n    /**\n     * Tests if the given character indicates the end of the file.\n     *\n     * @return true if the given character indicates the end of the file.\n     */\n    boolean isEndOfFile(final int ch) {\n        return ch == END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character is the escape character.\n     *\n     * @return true if the given character is the escape character.\n     */\n    boolean isEscape(final int ch) {\n        return ch == escape;\n    }\n\n    /**\n     * Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n     *\n     * For example, for delimiter \"[|]\" and escape '!', return true if the next characters constitute \"![!|!]\".\n     *\n     * @return true if the next characters constitute an escape delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isEscapeDelimiter() throws IOException {\n        reader.lookAhead(escapeDelimiterBuf);\n        if (escapeDelimiterBuf[0] != delimiter[0]) {\n            return false;\n        }\n        for (int i = 1; i < delimiter.length; i++) {\n            if (escapeDelimiterBuf[2 * i] != delimiter[i] || escapeDelimiterBuf[2 * i - 1] != escape) {\n                return false;\n            }\n        }\n        final int count = reader.read(escapeDelimiterBuf, 0, escapeDelimiterBuf.length);\n        return count != END_OF_STREAM;\n    }\n\n    private boolean isMetaChar(final int ch) {\n        return ch == escape || ch == quoteChar || ch == commentStart;\n    }\n\n    boolean isQuoteChar(final int ch) {\n        return ch == quoteChar;\n    }\n\n    /**\n     * Tests if the current character represents the start of a line: a CR, LF, or is at the start of the file.\n     *\n     * @param ch the character to check\n     * @return true if the character is at the start of a line.\n     */\n    boolean isStartOfLine(final int ch) {\n        return ch == LF || ch == CR || ch == UNDEFINED;\n    }\n\n    private char mapNullToDisabled(final Character c) {\n        return c == null ? DISABLED : c.charValue();\n    }\n\n    /**\n     * Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token\n     *            an existing Token object to reuse. The caller is responsible for initializing the Token.\n     * @return the next token found.\n     * @throws IOException on stream access error.\n     */\n    Token nextToken(final Token token) throws IOException {\n\n        // Get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n\n        // read the next char and set eol\n        int c = reader.read();\n        /*\n         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n         * - they are equivalent here.\n         */\n        boolean eol = readEndOfLine(c);\n\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol && isStartOfLine(lastChar)) {\n                // Go on char ahead ...\n                lastChar = c;\n                c = reader.read();\n                eol = readEndOfLine(c);\n                // reached the end of the file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type = EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // Did we reach EOF during the last iteration already? EOF\n        if (isEndOfFile(lastChar) || !isLastTokenDelimiter && isEndOfFile(c)) {\n            token.type = EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n            final String line = reader.readLine();\n            if (line == null) {\n                token.type = EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n            final String comment = line.trim();\n            token.content.append(comment);\n            token.type = COMMENT;\n            return token;\n        }\n\n        // Important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (Character.isWhitespace((char)c) && !isDelimiter(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n\n    /**\n     * Parses an encapsulated token.\n     * <p>\n     * Encapsulated tokens are surrounded by the given encapsulating string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token is ignored. The token is finished when one of the following conditions becomes true:\n     * </p>\n     * <ul>\n     * <li>An unescaped encapsulator has been reached and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             Thrown when in an invalid state: EOF before closing encapsulator or invalid character before\n     *             delimiter or EOL.\n     */\n    private Token parseEncapsulatedToken(final Token token) throws IOException {\n        token.isQuoted = true;\n        // Save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        int c;\n        while (true) {\n            c = reader.read();\n\n            if (isEscape(c)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) c).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n            } else if (isQuoteChar(c)) {\n                if (isQuoteChar(reader.lookAhead())) {\n                    // double or escaped encapsulator -> add single encapsulator to token\n                    c = reader.read();\n                    token.content.append((char) c);\n                } else {\n                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                    while (true) {\n                        c = reader.read();\n                        if (isDelimiter(c)) {\n                            token.type = TOKEN;\n                            return token;\n                        }\n                        if (isEndOfFile(c)) {\n                            token.type = EOF;\n                            token.isReady = true; // There is data at EOF\n                            return token;\n                        }\n                        if (readEndOfLine(c)) {\n                            token.type = EORECORD;\n                            return token;\n                        }\n                        if (!Character.isWhitespace((char)c)) {\n                            // error invalid char between token and next delimiter\n                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                    \") invalid char between encapsulated token and delimiter\");\n                        }\n                    }\n                }\n            } else if (isEndOfFile(c)) {\n                // error condition (end of file before end of token)\n                throw new IOException(\"(startline \" + startLineNumber +\n                        \") EOF reached before encapsulated token finished\");\n            } else {\n                // consume character\n                token.content.append((char) c);\n            }\n        }\n    }\n\n    /**\n     * Parses a simple token.\n     * <p>\n     * Simple tokens are tokens that are not surrounded by encapsulators. A simple token might contain escaped\n     * delimiters (as \\, or \\;). The token is finished when one of the following conditions becomes true:\n     * </p>\n     * <ul>\n     * <li>The end of line has been reached (EORECORD)</li>\n     * <li>The end of stream has been reached (EOF)</li>\n     * <li>An unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token\n     *            the current token\n     * @param ch\n     *            the current character\n     * @return the filled token\n     * @throws IOException\n     *             on stream access error\n     */\n    private Token parseSimpleToken(final Token token, int ch) throws IOException {\n        // Faster to use while(true)+break than while(token.type == INVALID)\n        while (true) {\n            if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                break;\n            }\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                break;\n            }\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                break;\n            }\n            // continue\n            if (isEscape(ch)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) ch).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read(); // continue\n        }\n\n        if (ignoreSurroundingSpaces) {\n            trimTrailingSpaces(token.content);\n        }\n\n        return token;\n    }\n\n    /**\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     */\n    boolean readEndOfLine(int ch) throws IOException {\n        // check if we have \\r\\n...\n        if (ch == CR && reader.lookAhead() == LF) {\n            // note: does not change ch outside of this method!\n            ch = reader.read();\n            // Save the EOL state\n            if (firstEol == null) {\n                this.firstEol = Constants.CRLF;\n            }\n        }\n        // save EOL state here.\n        if (firstEol == null) {\n            if (ch == LF) {\n                this.firstEol = LF_STRING;\n            } else if (ch == CR) {\n                this.firstEol = CR_STRING;\n            }\n        }\n\n        return ch == LF || ch == CR;\n    }\n\n    // TODO escape handling needs more work\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link Constants#END_OF_STREAM} if char following the escape is\n     *      invalid.\n     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n     *      the escape character is not allowed at end of stream\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int ch = reader.read();\n        switch (ch) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return ch;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isMetaChar(ch)) {\n                return ch;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return END_OF_STREAM;\n        }\n    }\n\n    void trimTrailingSpaces(final StringBuilder buffer) {\n        int length = buffer.length();\n        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n            length = length - 1;\n        }\n        if (length != buffer.length()) {\n            buffer.setLength(length);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex 017167203..50aa176d3 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -367,8 +367,8 @@ private Token parseEncapsulatedToken(final Token token) throws IOException {\n                         }\n                         if (!Character.isWhitespace((char)c)) {\n                             // error invalid char between token and next delimiter\n-                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n-                                    \") invalid char between encapsulated token and delimiter\");\n+                            throw new IOException(\"Invalid char between encapsulated token and delimiter at line: \" +\n+                                    getCurrentLineNumber() + \", position: \" + getCharacterPosition());\n                         }\n                     }\n                 }\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 344,
    "title": "[Javadoc] CSVFormat#setHeaderComments() ",
    "state": "closed",
    "created_at": "2023-08-24T11:59:00Z",
    "merge_commit_sha": "082827ceef359ab4554721477bed8fe77fb655ff",
    "base_sha": "9668d4628eecb44f57d1107adece8f954054cbc4",
    "head_sha": "f1294a7a65b2a6472dfcac86de0e61483ef8735d",
    "user_login": "gbidsilva",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.CSVFormat.RFC4180;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.time.Instant;\nimport java.util.Arrays;\nimport java.util.Objects;\n\nimport org.apache.commons.csv.CSVFormat.Builder;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    /**\n     * Test setting header comments with a comment marker.\n     */\n    @Test\n    public void testSetHeaderCommentsWithCommentMarker() {\n        final CSVFormat format = CSVFormat.DEFAULT.builder()\n                .setCommentMarker('#')\n                .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0))\n                .build();\n        assertNotNull(format.getHeaderComments());\n        assertArrayEquals(new String[]{\"Generated by Apache Commons CSV\", \"1970-01-01T00:00:00Z\"}, format.getHeaderComments());\n    }\n\n    /**\n     * Test setting header comments without a comment marker.\n     */\n    @Test\n    public void testSetHeaderCommentsWithoutCommentMarker() {\n        final CSVFormat format = CSVFormat.DEFAULT.builder()\n                .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0))\n                .build();\n        assertNull(format.getHeaderComments());\n    }\n\n    /**\n     * Test setting header comments with a comment marker using String array.\n     */\n    @Test\n    public void testSetHeaderCommentsWithCommentMarkerStringArray() {\n        final CSVFormat format = CSVFormat.DEFAULT.builder()\n                .setCommentMarker('#')\n                .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0).toString())\n                .build();\n        assertNotNull(format.getHeaderComments());\n        assertArrayEquals(new String[]{\"Generated by Apache Commons CSV\", \"1970-01-01T00:00:00Z\"}, format.getHeaderComments());\n    }\n\n    /**\n     * Test setting header comments without a comment marker using String array.\n     */\n    @Test\n    public void testSetHeaderCommentsWithoutCommentMarkerStringArray() {\n        final CSVFormat format = CSVFormat.DEFAULT.builder()\n                .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0).toString())\n                .build();\n        assertNull(format.getHeaderComments());\n    }\n}",
        "file_content": "/*\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n * this work for additional information regarding copyright ownership.\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n * (the \"License\"); you may not use this file except in compliance with\r\n * the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage org.apache.commons.csv;\r\n\r\nimport static org.apache.commons.csv.Constants.BACKSLASH;\r\nimport static org.apache.commons.csv.Constants.COMMA;\r\nimport static org.apache.commons.csv.Constants.COMMENT;\r\nimport static org.apache.commons.csv.Constants.CR;\r\nimport static org.apache.commons.csv.Constants.CRLF;\r\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\r\nimport static org.apache.commons.csv.Constants.EMPTY;\r\nimport static org.apache.commons.csv.Constants.LF;\r\nimport static org.apache.commons.csv.Constants.PIPE;\r\nimport static org.apache.commons.csv.Constants.SP;\r\nimport static org.apache.commons.csv.Constants.TAB;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Serializable;\r\nimport java.io.StringWriter;\r\nimport java.io.Writer;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.Arrays;\r\nimport java.util.HashSet;\r\nimport java.util.Objects;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Specifies the format of a CSV file for parsing and writing.\r\n *\r\n * <h2>Using predefined formats</h2>\r\n *\r\n * <p>\r\n * You can use one of the predefined formats:\r\n * </p>\r\n *\r\n * <ul>\r\n * <li>{@link #DEFAULT}</li>\r\n * <li>{@link #EXCEL}</li>\r\n * <li>{@link #INFORMIX_UNLOAD}</li>\r\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\r\n * <li>{@link #MYSQL}</li>\r\n * <li>{@link #RFC4180}</li>\r\n * <li>{@link #ORACLE}</li>\r\n * <li>{@link #POSTGRESQL_CSV}</li>\r\n * <li>{@link #POSTGRESQL_TEXT}</li>\r\n * <li>{@link #TDF}</li>\r\n * </ul>\r\n *\r\n * <p>\r\n * For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\r\n * </pre>\r\n *\r\n * <p>\r\n * The {@link CSVParser} provides static methods to parse other input types, for example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\r\n * </pre>\r\n *\r\n * <h2>Defining formats</h2>\r\n *\r\n * <p>\r\n * You can extend a format by calling the {@code set} methods. For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\r\n * </pre>\r\n *\r\n * <h2>Defining column names</h2>\r\n *\r\n * <p>\r\n * To define the column names you want to use to access records, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * Calling {@link Builder#setHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and assumes that your CSV source does not\r\n * contain a first record that also defines column names.\r\n *\r\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\r\n * {@link Builder#setSkipHeaderRecord(boolean)} with {@code true}.\r\n * </p>\r\n *\r\n * <h2>Parsing</h2>\r\n *\r\n * <p>\r\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * Reader in = ...;\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\r\n * </pre>\r\n *\r\n * <p>\r\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\r\n * </p>\r\n *\r\n * <h2>Referencing columns safely</h2>\r\n *\r\n * <p>\r\n * If your source contains a header record, you can simplify your code and safely reference columns, by using {@link Builder#setHeader(String...)} with no\r\n * arguments:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader();\r\n * </pre>\r\n *\r\n * <p>\r\n * This causes the parser to read the first record and use its values as column names.\r\n *\r\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\r\n * </p>\r\n *\r\n * <pre>\r\n * String value = record.get(&quot;Col1&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * This makes your code impervious to changes in column order in the CSV file.\r\n * </p>\r\n *\r\n * <h2>Serialization</h2>\r\n * <p>\r\n *   This class implements the {@link Serializable} interface with the following caveats:\r\n * </p>\r\n * <ul>\r\n *   <li>This class will no longer implement Serializable in 2.0.</li>\r\n *   <li>Serialization is not supported from one version to the next.</li>\r\n * </ul>\r\n * <p>\r\n *   The {@code serialVersionUID} values are:\r\n * </p>\r\n * <ul>\r\n *   <li>Version 1.10.0: {@code 2L}</li>\r\n *   <li>Version 1.9.0 through 1.0: {@code 1L}</li>\r\n * </ul>\r\n *\r\n * <h2>Notes</h2>\r\n * <p>\r\n * This class is immutable.\r\n * </p>\r\n * <p>\r\n * Not all settings are used for both parsing and writing.\r\n * </p>\r\n */\r\npublic final class CSVFormat implements Serializable {\r\n\r\n    /**\r\n     * Builds CSVFormat instances.\r\n     *\r\n     * @since 1.9.0\r\n     */\r\n    public static class Builder {\r\n\r\n        /**\r\n         * Creates a new default builder.\r\n         *\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create() {\r\n            return new Builder(CSVFormat.DEFAULT);\r\n        }\r\n\r\n        /**\r\n         * Creates a new builder for the given format.\r\n         *\r\n         * @param csvFormat the source format.\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create(final CSVFormat csvFormat) {\r\n            return new Builder(csvFormat);\r\n        }\r\n\r\n        private boolean allowMissingColumnNames;\r\n\r\n        private boolean autoFlush;\r\n\r\n        private Character commentMarker;\r\n\r\n        private String delimiter;\r\n\r\n        private DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n        private Character escapeCharacter;\r\n\r\n        private String[] headerComments;\r\n\r\n        private String[] headers;\r\n\r\n        private boolean ignoreEmptyLines;\r\n\r\n        private boolean ignoreHeaderCase;\r\n\r\n        private boolean ignoreSurroundingSpaces;\r\n\r\n        private String nullString;\r\n\r\n        private Character quoteCharacter;\r\n\r\n        private String quotedNullString;\r\n\r\n        private QuoteMode quoteMode;\r\n\r\n        private String recordSeparator;\r\n\r\n        private boolean skipHeaderRecord;\r\n\r\n        private boolean trailingDelimiter;\r\n\r\n        private boolean trim;\r\n\r\n        private Builder(final CSVFormat csvFormat) {\r\n            this.delimiter = csvFormat.delimiter;\r\n            this.quoteCharacter = csvFormat.quoteCharacter;\r\n            this.quoteMode = csvFormat.quoteMode;\r\n            this.commentMarker = csvFormat.commentMarker;\r\n            this.escapeCharacter = csvFormat.escapeCharacter;\r\n            this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;\r\n            this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;\r\n            this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;\r\n            this.recordSeparator = csvFormat.recordSeparator;\r\n            this.nullString = csvFormat.nullString;\r\n            this.headerComments = csvFormat.headerComments;\r\n            this.headers = csvFormat.headers;\r\n            this.skipHeaderRecord = csvFormat.skipHeaderRecord;\r\n            this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;\r\n            this.trailingDelimiter = csvFormat.trailingDelimiter;\r\n            this.trim = csvFormat.trim;\r\n            this.autoFlush = csvFormat.autoFlush;\r\n            this.quotedNullString = csvFormat.quotedNullString;\r\n            this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;\r\n        }\r\n\r\n        /**\r\n         * Builds a new CSVFormat instance.\r\n         *\r\n         * @return a new CSVFormat instance.\r\n         */\r\n        public CSVFormat build() {\r\n            return new CSVFormat(this);\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior, true to allow, false to disallow.\r\n         *\r\n         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n         * @return This instance.\r\n         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.\r\n         */\r\n        @Deprecated\r\n        public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n            setDuplicateHeaderMode(allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\r\n         * {@link IllegalArgumentException} to be thrown.\r\n         *\r\n         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\r\n         *                                cause an {@link IllegalArgumentException} to be thrown.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n            this.allowMissingColumnNames = allowMissingColumnNames;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to flush on close.\r\n         *\r\n         * @param autoFlush whether to flush on close.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAutoFlush(final boolean autoFlush) {\r\n            this.autoFlush = autoFlush;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final char commentMarker) {\r\n            setCommentMarker(Character.valueOf(commentMarker));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final Character commentMarker) {\r\n            if (isLineBreak(commentMarker)) {\r\n                throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\r\n            }\r\n            this.commentMarker = commentMarker;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final char delimiter) {\r\n            return setDelimiter(String.valueOf(delimiter));\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final String delimiter) {\r\n            if (containsLineBreak(delimiter)) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n            }\r\n            if (delimiter.isEmpty()) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be empty\");\r\n            }\r\n            this.delimiter = delimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior.\r\n         *\r\n         * @param duplicateHeaderMode the duplicate header names behavior\r\n         * @return This instance.\r\n         * @since 1.10.0\r\n         */\r\n        public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {\r\n          this.duplicateHeaderMode = Objects.requireNonNull(duplicateHeaderMode, \"duplicateHeaderMode\");\r\n          return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final char escapeCharacter) {\r\n            setEscape(Character.valueOf(escapeCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final Character escapeCharacter) {\r\n            if (isLineBreak(escapeCharacter)) {\r\n                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\r\n            }\r\n            this.escapeCharacter = escapeCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header defined by the given {@link Enum} class.\r\n         *\r\n         * <p>\r\n         * Example:\r\n         * </p>\r\n         *\r\n         * <pre>\r\n         * public enum HeaderEnum {\r\n         *     Name, Email, Phone\r\n         * }\r\n         *\r\n         * Builder builder = builder.setHeader(HeaderEnum.class);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {\r\n            String[] header = null;\r\n            if (headerEnum != null) {\r\n                final Enum<?>[] enumValues = headerEnum.getEnumConstants();\r\n                header = new String[enumValues.length];\r\n                Arrays.setAll(header, i -> enumValues[i].name());\r\n            }\r\n            return setHeader(header);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSet);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSet resultSet) throws SQLException {\r\n            return setHeader(resultSet != null ? resultSet.getMetaData() : null);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSetMetaData);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n            String[] labels = null;\r\n            if (resultSetMetaData != null) {\r\n                final int columnCount = resultSetMetaData.getColumnCount();\r\n                labels = new String[columnCount];\r\n                for (int i = 0; i < columnCount; i++) {\r\n                    labels[i] = resultSetMetaData.getColumnLabel(i + 1);\r\n                }\r\n            }\r\n            return setHeader(labels);\r\n        }\r\n\r\n        /**\r\n         * Sets the header to the given values. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final String... header) {\r\n            this.headers = CSVFormat.clone(header);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final Object... headerComments) {\r\n            this.headerComments = CSVFormat.clone(toStringArray(headerComments));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * Builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final String... headerComments) {\r\n            this.headerComments = CSVFormat.clone(headerComments);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty\r\n         * records.\r\n         *\r\n         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate\r\n         *                         empty lines to empty records.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n            this.ignoreEmptyLines = ignoreEmptyLines;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         *\r\n         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n            this.ignoreHeaderCase = ignoreHeaderCase;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         *\r\n         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         *\r\n         * <ul>\r\n         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n         * </ul>\r\n         *\r\n         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         * @return This instance.\r\n         */\r\n        public Builder setNullString(final String nullString) {\r\n            this.nullString = nullString;\r\n            this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character.\r\n         *\r\n         * @param quoteCharacter the quote character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final char quoteCharacter) {\r\n            setQuote(Character.valueOf(quoteCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character, use {@code null} to disable.\r\n         *\r\n         * @param quoteCharacter the quote character, use {@code null} to disable.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final Character quoteCharacter) {\r\n            if (isLineBreak(quoteCharacter)) {\r\n                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\r\n            }\r\n            this.quoteCharacter = quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote policy to use for output.\r\n         *\r\n         * @param quoteMode the quote policy to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuoteMode(final QuoteMode quoteMode) {\r\n            this.quoteMode = quoteMode;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final char recordSeparator) {\r\n            this.recordSeparator = String.valueOf(recordSeparator);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final String recordSeparator) {\r\n            this.recordSeparator = recordSeparator;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to skip the header record.\r\n         *\r\n         * @param skipHeaderRecord whether to skip the header record.\r\n         * @return This instance.\r\n         */\r\n        public Builder setSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n            this.skipHeaderRecord = skipHeaderRecord;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to add a trailing delimiter.\r\n         *\r\n         * @param trailingDelimiter whether to add a trailing delimiter.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrailingDelimiter(final boolean trailingDelimiter) {\r\n            this.trailingDelimiter = trailingDelimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to trim leading and trailing blanks.\r\n         *\r\n         * @param trim whether to trim leading and trailing blanks.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrim(final boolean trim) {\r\n            this.trim = trim;\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Predefines formats.\r\n     *\r\n     * @since 1.2\r\n     */\r\n    public enum Predefined {\r\n\r\n        /**\r\n         * @see CSVFormat#DEFAULT\r\n         */\r\n        Default(CSVFormat.DEFAULT),\r\n\r\n        /**\r\n         * @see CSVFormat#EXCEL\r\n         */\r\n        Excel(CSVFormat.EXCEL),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD\r\n         * @since 1.3\r\n         */\r\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\r\n         * @since 1.3\r\n         */\r\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_CSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_TSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MYSQL\r\n         */\r\n        MySQL(CSVFormat.MYSQL),\r\n\r\n        /**\r\n         * @see CSVFormat#ORACLE\r\n         */\r\n        Oracle(CSVFormat.ORACLE),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         * @since 1.5\r\n         */\r\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         */\r\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\r\n\r\n        /**\r\n         * @see CSVFormat#RFC4180\r\n         */\r\n        RFC4180(CSVFormat.RFC4180),\r\n\r\n        /**\r\n         * @see CSVFormat#TDF\r\n         */\r\n        TDF(CSVFormat.TDF);\r\n\r\n        private final CSVFormat format;\r\n\r\n        Predefined(final CSVFormat format) {\r\n            this.format = format;\r\n        }\r\n\r\n        /**\r\n         * Gets the format.\r\n         *\r\n         * @return the format.\r\n         */\r\n        public CSVFormat getFormat() {\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing\r\n     * empty lines.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Default\r\n     */\r\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false,\r\n            false, false, false, DuplicateHeaderMode.ALLOW_ALL);\r\n\r\n    /**\r\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is locale dependent, it might be necessary\r\n     * to customize this format to accommodate to your regional settings.\r\n     *\r\n     * <p>\r\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setAllowMissingColumnNames(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     * <p>\r\n     * Note: This is currently like {@link #RFC4180} plus {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)} and\r\n     * {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(false)}.\r\n     * </p>\r\n     *\r\n     * @see Predefined#Excel\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat EXCEL = DEFAULT.builder()\r\n            .setIgnoreEmptyLines(false)\r\n            .setAllowMissingColumnNames(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.builder()\r\n            .setDelimiter(PIPE)\r\n            .setEscape(BACKSLASH)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with {@code '\"'}. A header line with field\r\n     * names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format. Values are double quoted only if needed and special\r\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\r\n     *          documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_TSV = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\r\n     *      -data.html</a>\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MYSQL = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default Oracle format used by the SQL*Loader utility.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\r\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\r\n     * {@code \"\"}. Values are trimmed.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setTrim()}</li>\r\n     * <li>{@code setSystemRecordSeparator()}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.MINIMAL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Oracle\r\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\r\n     * @since 1.6\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat ORACLE = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setTrim(true)\r\n            .setRecordSeparator(System.lineSeparator())\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\r\n     * characters are not escaped. The default NULL string is {@code \"\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape(null)}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(null)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(EMPTY)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL text format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#RFC4180\r\n     */\r\n    public static final CSVFormat RFC4180 = DEFAULT.builder().setIgnoreEmptyLines(false).build();\r\n\r\n    private static final long serialVersionUID = 2L;\r\n\r\n    /**\r\n     * Tab-delimited format.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreSurroundingSpaces(true)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#TDF\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat TDF = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setIgnoreSurroundingSpaces(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Null-safe clone of an array.\r\n     *\r\n     * @param <T>    The array element type.\r\n     * @param values the source array\r\n     * @return the cloned array.\r\n     */\r\n    @SafeVarargs\r\n    static <T> T[] clone(final T... values) {\r\n        return values == null ? null : values.clone();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains the search char.\r\n     *\r\n     * @param source the string to check.\r\n     * @param searchCh the character to search.\r\n     *\r\n     * @return true if {@code c} contains a line break character\r\n     */\r\n    private static boolean contains(final String source, final char searchCh) {\r\n        return Objects.requireNonNull(source, \"source\").indexOf(searchCh) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains a line break character.\r\n     *\r\n     * @param source the string to check.\r\n     *\r\n     * @return true if {@code c} contains a line break character.\r\n     */\r\n    private static boolean containsLineBreak(final String source) {\r\n        return contains(source, CR) || contains(source, LF);\r\n    }\r\n\r\n    static boolean isBlank(final String value) {\r\n        return value == null || value.trim().isEmpty();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check.\r\n     *\r\n     * @return true if {@code c} is a line break character.\r\n     */\r\n    private static boolean isLineBreak(final char c) {\r\n        return c == LF || c == CR;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check, may be null.\r\n     *\r\n     * @return true if {@code c} is a line break character (and not null).\r\n     */\r\n    private static boolean isLineBreak(final Character c) {\r\n        return c != null && isLineBreak(c.charValue());\r\n    }\r\n\r\n    /** Same test as in as {@link String#trim()}. */\r\n    private static boolean isTrimChar(final char ch) {\r\n        return ch <= SP;\r\n    }\r\n\r\n    /** Same test as in as {@link String#trim()}. */\r\n    private static boolean isTrimChar(final CharSequence charSequence, final int pos) {\r\n        return isTrimChar(charSequence.charAt(pos));\r\n    }\r\n\r\n    /**\r\n     * Creates a new CSV format with the specified delimiter.\r\n     *\r\n     * <p>\r\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.\r\n     * </p>\r\n     *\r\n     * @param delimiter the char used for value separation, must not be a line break character\r\n     * @return a new CSV format.\r\n     * @throws IllegalArgumentException if the delimiter is a line break character\r\n     *\r\n     * @see #DEFAULT\r\n     * @see #RFC4180\r\n     * @see #MYSQL\r\n     * @see #EXCEL\r\n     * @see #TDF\r\n     */\r\n    public static CSVFormat newFormat(final char delimiter) {\r\n        return new CSVFormat(String.valueOf(delimiter), null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false,\r\n                DuplicateHeaderMode.ALLOW_ALL);\r\n    }\r\n\r\n    static String[] toStringArray(final Object[] values) {\r\n        if (values == null) {\r\n            return null;\r\n        }\r\n        final String[] strings = new String[values.length];\r\n        Arrays.setAll(strings, i -> Objects.toString(values[i], null));\r\n        return strings;\r\n    }\r\n\r\n    static CharSequence trim(final CharSequence charSequence) {\r\n        if (charSequence instanceof String) {\r\n            return ((String) charSequence).trim();\r\n        }\r\n        final int count = charSequence.length();\r\n        int len = count;\r\n        int pos = 0;\r\n\r\n        while (pos < len && isTrimChar(charSequence, pos)) {\r\n            pos++;\r\n        }\r\n        while (pos < len && isTrimChar(charSequence, len - 1)) {\r\n            len--;\r\n        }\r\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\r\n    }\r\n\r\n    /**\r\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\r\n     *\r\n     * @param format name\r\n     * @return one of the predefined formats\r\n     * @since 1.2\r\n     */\r\n    public static CSVFormat valueOf(final String format) {\r\n        return CSVFormat.Predefined.valueOf(format).getFormat();\r\n    }\r\n\r\n    private final DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n    private final boolean allowMissingColumnNames;\r\n\r\n    private final boolean autoFlush;\r\n\r\n    private final Character commentMarker; // null if commenting is disabled\r\n\r\n    private final String delimiter;\r\n\r\n    private final Character escapeCharacter; // null if escaping is disabled\r\n\r\n    private final String[] headers; // array of header column names\r\n\r\n    private final String[] headerComments; // array of header comment lines\r\n\r\n    private final boolean ignoreEmptyLines;\r\n\r\n    private final boolean ignoreHeaderCase; // should ignore header names case\r\n\r\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\r\n\r\n    private final String nullString; // the string to be used for null values\r\n\r\n    private final Character quoteCharacter; // null if quoting is disabled\r\n\r\n    private final String quotedNullString;\r\n\r\n    private final QuoteMode quoteMode;\r\n\r\n    private final String recordSeparator; // for outputs\r\n\r\n    private final boolean skipHeaderRecord;\r\n\r\n    private final boolean trailingDelimiter;\r\n\r\n    private final boolean trim;\r\n\r\n    private CSVFormat(final Builder builder) {\r\n        this.delimiter = builder.delimiter;\r\n        this.quoteCharacter = builder.quoteCharacter;\r\n        this.quoteMode = builder.quoteMode;\r\n        this.commentMarker = builder.commentMarker;\r\n        this.escapeCharacter = builder.escapeCharacter;\r\n        this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = builder.allowMissingColumnNames;\r\n        this.ignoreEmptyLines = builder.ignoreEmptyLines;\r\n        this.recordSeparator = builder.recordSeparator;\r\n        this.nullString = builder.nullString;\r\n        this.headerComments = builder.headerComments;\r\n        this.headers = builder.headers;\r\n        this.skipHeaderRecord = builder.skipHeaderRecord;\r\n        this.ignoreHeaderCase = builder.ignoreHeaderCase;\r\n        this.trailingDelimiter = builder.trailingDelimiter;\r\n        this.trim = builder.trim;\r\n        this.autoFlush = builder.autoFlush;\r\n        this.quotedNullString = builder.quotedNullString;\r\n        this.duplicateHeaderMode = builder.duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    /**\r\n     * Creates a customized CSV format.\r\n     *\r\n     * @param delimiter               the char used for value separation, must not be a line break character.\r\n     * @param quoteChar               the Character used as value encapsulation marker, may be {@code null} to disable.\r\n     * @param quoteMode               the quote mode.\r\n     * @param commentStart            the Character used for comment identification, may be {@code null} to disable.\r\n     * @param escape                  the Character used to escape special characters in values, may be {@code null} to disable.\r\n     * @param ignoreSurroundingSpaces {@code true} when whitespaces enclosing values should be ignored.\r\n     * @param ignoreEmptyLines        {@code true} when the parser should skip empty lines.\r\n     * @param recordSeparator         the line separator to use for output.\r\n     * @param nullString              the line separator to use for output.\r\n     * @param headerComments          the comments to be printed by the Printer before the actual CSV data.\r\n     * @param header                  the header\r\n     * @param skipHeaderRecord        if {@code true} the header row will be skipped\r\n     * @param allowMissingColumnNames if {@code true} the missing column names are allowed when parsing the header line\r\n     * @param ignoreHeaderCase        if {@code true} header names will be accessed ignoring case when parsing input\r\n     * @param trim                    if {@code true} next record value will be trimmed\r\n     * @param trailingDelimiter       if {@code true} the trailing delimiter wil be added before record separator (if set)\r\n     * @param autoFlush               if {@code true} the underlying stream will be flushed before closing\r\n     * @param duplicateHeaderMode     the behavior when handling duplicate headers\r\n     * @throws IllegalArgumentException if the delimiter is a line break character.\r\n     */\r\n    private CSVFormat(final String delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape,\r\n            final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\r\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames,\r\n            final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush,\r\n            final DuplicateHeaderMode duplicateHeaderMode) {\r\n        this.delimiter = delimiter;\r\n        this.quoteCharacter = quoteChar;\r\n        this.quoteMode = quoteMode;\r\n        this.commentMarker = commentStart;\r\n        this.escapeCharacter = escape;\r\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = allowMissingColumnNames;\r\n        this.ignoreEmptyLines = ignoreEmptyLines;\r\n        this.recordSeparator = recordSeparator;\r\n        this.nullString = nullString;\r\n        this.headerComments = toStringArray(headerComments);\r\n        this.headers = clone(header);\r\n        this.skipHeaderRecord = skipHeaderRecord;\r\n        this.ignoreHeaderCase = ignoreHeaderCase;\r\n        this.trailingDelimiter = trailingDelimiter;\r\n        this.trim = trim;\r\n        this.autoFlush = autoFlush;\r\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n        this.duplicateHeaderMode = duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    private void append(final char c, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(c);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    private void append(final CharSequence csq, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(csq);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    /**\r\n     * Creates a new Builder for this instance.\r\n     *\r\n     * @return a new Builder.\r\n     */\r\n    public Builder builder() {\r\n        return Builder.create(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a copy of this instance.\r\n     *\r\n     * @return a copy of this instance.\r\n     */\r\n    CSVFormat copy() {\r\n        return builder().build();\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(final Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null || getClass() != obj.getClass()) {\r\n            return false;\r\n        }\r\n        final CSVFormat other = (CSVFormat) obj;\r\n        return duplicateHeaderMode == other.duplicateHeaderMode && allowMissingColumnNames == other.allowMissingColumnNames &&\r\n                autoFlush == other.autoFlush && Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) &&\r\n                Objects.equals(escapeCharacter, other.escapeCharacter) && Arrays.equals(headers, other.headers) &&\r\n                Arrays.equals(headerComments, other.headerComments) && ignoreEmptyLines == other.ignoreEmptyLines &&\r\n                ignoreHeaderCase == other.ignoreHeaderCase && ignoreSurroundingSpaces == other.ignoreSurroundingSpaces &&\r\n                Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) && quoteMode == other.quoteMode &&\r\n                Objects.equals(quotedNullString, other.quotedNullString) && Objects.equals(recordSeparator, other.recordSeparator) &&\r\n                skipHeaderRecord == other.skipHeaderRecord && trailingDelimiter == other.trailingDelimiter && trim == other.trim;\r\n    }\r\n\r\n    /**\r\n     * Formats the specified values.\r\n     *\r\n     * @param values the values to format\r\n     * @return the formatted values\r\n     */\r\n    public String format(final Object... values) {\r\n        final StringWriter out = new StringWriter();\r\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\r\n            csvPrinter.printRecord(values);\r\n            final String res = out.toString();\r\n            final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\r\n            return res.substring(0, len);\r\n        } catch (final IOException e) {\r\n            // should not happen because a StringWriter does not do IO.\r\n            throw new IllegalStateException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether duplicate names are allowed in the headers.\r\n     *\r\n     * @return whether duplicate header names are allowed\r\n     * @since 1.7\r\n     * @deprecated Use {@link #getDuplicateHeaderMode()}.\r\n     */\r\n    @Deprecated\r\n    public boolean getAllowDuplicateHeaderNames() {\r\n        return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;\r\n    }\r\n\r\n    /**\r\n     * Gets whether missing column names are allowed when parsing the header line.\r\n     *\r\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an {@link IllegalArgumentException}.\r\n     */\r\n    public boolean getAllowMissingColumnNames() {\r\n        return allowMissingColumnNames;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to flush on close.\r\n     *\r\n     * @return whether to flush on close.\r\n     * @since 1.6\r\n     */\r\n    public boolean getAutoFlush() {\r\n        return autoFlush;\r\n    }\r\n\r\n    /**\r\n     * Gets the character marking the start of a line comment.\r\n     * <p>\r\n     * The comment format for each line is:\r\n     * </p>\r\n     * <pre>\r\n     * CommentMarker SPACE CommentArrayElement\r\n     * </pre>\r\n     * <p>\r\n     * For example, using a comment marker {@code '#'} and a comment array {@code comments [\"line 1\", \"line 2\"]}:\r\n     * </p>\r\n     * <pre>\r\n     * # line 1\r\n     * # line 2\r\n     * </pre>\r\n     *\r\n     * @return the comment start marker, may be {@code null}\r\n     */\r\n    public Character getCommentMarker() {\r\n        return commentMarker;\r\n    }\r\n\r\n    /**\r\n     * Gets the first character delimiting the values (typically ';', ',' or '\\t').\r\n     *\r\n     * @return the first delimiter character.\r\n     * @deprecated Use {@link #getDelimiterString()}.\r\n     */\r\n    @Deprecated\r\n    public char getDelimiter() {\r\n        return delimiter.charAt(0);\r\n    }\r\n\r\n    /**\r\n     * Gets the character delimiting the values (typically \";\", \",\" or \"\\t\").\r\n     *\r\n     * @return the delimiter.\r\n     * @since 1.9.0\r\n     */\r\n    public String getDelimiterString() {\r\n        return delimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets how duplicate headers are handled.\r\n     *\r\n     * @return if duplicate header values are allowed, allowed conditionally, or disallowed.\r\n     * @since 1.10.0\r\n     */\r\n    public DuplicateHeaderMode getDuplicateHeaderMode() {\r\n        return duplicateHeaderMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the escape character.\r\n     *\r\n     * @return the escape character, may be {@code null}\r\n     */\r\n    public Character getEscapeCharacter() {\r\n        return escapeCharacter;\r\n    }\r\n\r\n    /**\r\n     * Gets a copy of the header array.\r\n     *\r\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\r\n     */\r\n    public String[] getHeader() {\r\n        return headers != null ? headers.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Gets a copy of the header comment array.\r\n     *\r\n     * @return a copy of the header comment array; {@code null} if disabled.\r\n     */\r\n    public String[] getHeaderComments() {\r\n        return headerComments != null ? headerComments.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Gets whether empty lines between records are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty records.\r\n     */\r\n    public boolean getIgnoreEmptyLines() {\r\n        return ignoreEmptyLines;\r\n    }\r\n\r\n    /**\r\n     * Gets whether header names will be accessed ignoring case when parsing input.\r\n     *\r\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case-sensitive.\r\n     * @since 1.3\r\n     */\r\n    public boolean getIgnoreHeaderCase() {\r\n        return ignoreHeaderCase;\r\n    }\r\n\r\n    /**\r\n     * Gets whether spaces around values are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\r\n     */\r\n    public boolean getIgnoreSurroundingSpaces() {\r\n        return ignoreSurroundingSpaces;\r\n    }\r\n\r\n    /**\r\n     * Gets the String to convert to and from {@code null}.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     */\r\n    public String getNullString() {\r\n        return nullString;\r\n    }\r\n\r\n    /**\r\n     * Gets the character used to encapsulate values containing special characters.\r\n     *\r\n     * @return the quoteChar character, may be {@code null}\r\n     */\r\n    public Character getQuoteCharacter() {\r\n        return quoteCharacter;\r\n    }\r\n\r\n    /**\r\n     * Gets the quote policy output fields.\r\n     *\r\n     * @return the quote policy\r\n     */\r\n    public QuoteMode getQuoteMode() {\r\n        return quoteMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the record separator delimiting output records.\r\n     *\r\n     * @return the record separator\r\n     */\r\n    public String getRecordSeparator() {\r\n        return recordSeparator;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to skip the header record.\r\n     *\r\n     * @return whether to skip the header record.\r\n     */\r\n    public boolean getSkipHeaderRecord() {\r\n        return skipHeaderRecord;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to add a trailing delimiter.\r\n     *\r\n     * @return whether to add a trailing delimiter.\r\n     * @since 1.3\r\n     */\r\n    public boolean getTrailingDelimiter() {\r\n        return trailingDelimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to trim leading and trailing blanks. This is used by {@link #print(Object, Appendable, boolean)} Also by\r\n     * {CSVParser#addRecordValue(boolean)}\r\n     *\r\n     * @return whether to trim leading and trailing blanks.\r\n     */\r\n    public boolean getTrim() {\r\n        return trim;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + Arrays.hashCode(headers);\r\n        result = prime * result + Arrays.hashCode(headerComments);\r\n        return prime * result + Objects.hash(duplicateHeaderMode, allowMissingColumnNames, autoFlush, commentMarker, delimiter, escapeCharacter,\r\n                ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator,\r\n                skipHeaderRecord, trailingDelimiter, trim);\r\n    }\r\n\r\n    /**\r\n     * Tests whether comments are supported by this format.\r\n     *\r\n     * Note that the comment introducer character is only recognized at the start of a line.\r\n     *\r\n     * @return {@code true} is comments are supported, {@code false} otherwise\r\n     */\r\n    public boolean isCommentMarkerSet() {\r\n        return commentMarker != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether the next characters constitute a delimiter\r\n     *\r\n     * @param ch\r\n     *            the current char\r\n     * @param charSeq\r\n     *            the match char sequence\r\n     * @param startIndex\r\n     *            where start to match\r\n     * @param delimiter\r\n     *            the delimiter\r\n     * @param delimiterLength\r\n     *            the delimiter length\r\n     * @return true if the match is successful\r\n     */\r\n    private boolean isDelimiter(final char ch, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength) {\r\n        if (ch != delimiter[0]) {\r\n            return false;\r\n        }\r\n        final int len = charSeq.length();\r\n        if (startIndex + delimiterLength > len) {\r\n            return false;\r\n        }\r\n        for (int i = 1; i < delimiterLength; i++) {\r\n            if (charSeq.charAt(startIndex + i) != delimiter[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests whether escape are being processed.\r\n     *\r\n     * @return {@code true} if escapes are processed\r\n     */\r\n    public boolean isEscapeCharacterSet() {\r\n        return escapeCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether a nullString has been defined.\r\n     *\r\n     * @return {@code true} if a nullString is defined\r\n     */\r\n    public boolean isNullStringSet() {\r\n        return nullString != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether a quoteChar has been defined.\r\n     *\r\n     * @return {@code true} if a quoteChar is defined\r\n     */\r\n    public boolean isQuoteCharacterSet() {\r\n        return quoteCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Parses the specified content.\r\n     *\r\n     * <p>\r\n     * See also the various static parse methods on {@link CSVParser}.\r\n     * </p>\r\n     *\r\n     * @param reader the input stream\r\n     * @return a parser over a stream of {@link CSVRecord}s.\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    public CSVParser parse(final Reader reader) throws IOException {\r\n        return new CSVParser(reader, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out the output.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     */\r\n    public CSVPrinter print(final Appendable out) throws IOException {\r\n        return new CSVPrinter(out, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified {@code File} with given {@code Charset}.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\r\n        // The writer will be closed when close() is called.\r\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\r\n    }\r\n\r\n    /**\r\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated as needed. Useful when one wants to\r\n     * avoid creating CSVPrinters. Trims the value if {@link #getTrim()} is true.\r\n     *\r\n     * @param value     value to output.\r\n     * @param out       where to print the value.\r\n     * @param newRecord if this a new record.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\r\n        // null values are considered empty\r\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\r\n        CharSequence charSequence;\r\n        if (value == null) {\r\n            // https://issues.apache.org/jira/browse/CSV-203\r\n            if (null == nullString) {\r\n                charSequence = EMPTY;\r\n            } else if (QuoteMode.ALL == quoteMode) {\r\n                charSequence = quotedNullString;\r\n            } else {\r\n                charSequence = nullString;\r\n            }\r\n        } else if (value instanceof CharSequence) {\r\n            charSequence = (CharSequence) value;\r\n        } else if (value instanceof Reader) {\r\n            print((Reader) value, out, newRecord);\r\n            return;\r\n        } else {\r\n            charSequence = value.toString();\r\n        }\r\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\r\n        print(value, charSequence, out, newRecord);\r\n    }\r\n\r\n    private synchronized void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\r\n        final int offset = 0;\r\n        final int len = value.length();\r\n        if (!newRecord) {\r\n            out.append(getDelimiterString());\r\n        }\r\n        if (object == null) {\r\n            out.append(value);\r\n        } else if (isQuoteCharacterSet()) {\r\n            // the original object is needed so can check for Number\r\n            printWithQuotes(object, value, out, newRecord);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(value, out);\r\n        } else {\r\n            out.append(value, offset, len);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified {@code Path} with given {@code Charset},\r\n     * returns a {@code CSVPrinter} which the caller MUST close.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\r\n        return print(Files.newBufferedWriter(out, charset));\r\n    }\r\n\r\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\r\n        // Reader is never null\r\n        if (!newRecord) {\r\n            append(getDelimiterString(), out);\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            printWithQuotes(reader, out);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(reader, out);\r\n        } else if (out instanceof Writer) {\r\n            IOUtils.copyLarge(reader, (Writer) out);\r\n        } else {\r\n            IOUtils.copy(reader, out);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Prints to the {@link System#out}.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @return a printer to {@link System#out}.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    public CSVPrinter printer() throws IOException {\r\n        return new CSVPrinter(System.out, this);\r\n    }\r\n\r\n    /**\r\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\r\n     *\r\n     * @param appendable where to write\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void println(final Appendable appendable) throws IOException {\r\n        if (getTrailingDelimiter()) {\r\n            append(getDelimiterString(), appendable);\r\n        }\r\n        if (recordSeparator != null) {\r\n            append(recordSeparator, appendable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the record separator.\r\n     *\r\n     * <p>\r\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing\r\n     * the record, so there is no need to call {@link #println(Appendable)}.\r\n     * </p>\r\n     *\r\n     * @param appendable    where to write.\r\n     * @param values values to output.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException {\r\n        for (int i = 0; i < values.length; i++) {\r\n            print(values[i], appendable, i == 0);\r\n        }\r\n        println(appendable);\r\n    }\r\n\r\n    /*\r\n     * Note: Must only be called if escaping is enabled, otherwise will generate NPE.\r\n     */\r\n    private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int end = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n\r\n        while (pos < end) {\r\n            char c = charSeq.charAt(pos);\r\n            final boolean isDelimiterStart = isDelimiter(c, charSeq, pos, delim, delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    appendable.append(charSeq, start, pos);\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                appendable.append(escape);\r\n                appendable.append(c);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        pos++;\r\n                        c = charSeq.charAt(pos);\r\n                        appendable.append(escape);\r\n                        appendable.append(c);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            appendable.append(charSeq, start, pos);\r\n        }\r\n    }\r\n\r\n    private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n\r\n        @SuppressWarnings(\"resource\") // Temp reader on input reader.\r\n        final ExtendedBufferedReader bufferedReader = new ExtendedBufferedReader(reader);\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        int c;\r\n        while (-1 != (c = bufferedReader.read())) {\r\n            builder.append((char) c);\r\n            final boolean isDelimiterStart = isDelimiter((char) c, builder.toString() + new String(bufferedReader.lookAhead(delimLength - 1)), pos, delim,\r\n                    delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    append(builder.substring(start, pos), appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                append(escape, appendable);\r\n                append((char) c, appendable);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        c = bufferedReader.read();\r\n                        append(escape, appendable);\r\n                        append((char) c, appendable);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            append(builder.substring(start, pos), appendable);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\r\n     */\r\n    // the original object is needed so can check for Number\r\n    private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\r\n        boolean quote = false;\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int len = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char quoteChar = getQuoteCharacter().charValue();\r\n        // If escape char not specified, default to the quote char\r\n        // This avoids having to keep checking whether there is an escape character\r\n        // at the cost of checking against quote twice\r\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\r\n\r\n        QuoteMode quoteModePolicy = getQuoteMode();\r\n        if (quoteModePolicy == null) {\r\n            quoteModePolicy = QuoteMode.MINIMAL;\r\n        }\r\n        switch (quoteModePolicy) {\r\n        case ALL:\r\n        case ALL_NON_NULL:\r\n            quote = true;\r\n            break;\r\n        case NON_NUMERIC:\r\n            quote = !(object instanceof Number);\r\n            break;\r\n        case NONE:\r\n            // Use the existing escaping code\r\n            printWithEscapes(charSeq, out);\r\n            return;\r\n        case MINIMAL:\r\n            if (len <= 0) {\r\n                // always quote an empty token that is the first\r\n                // on the line, as it may be the only thing on the\r\n                // line. If it were not quoted in that case,\r\n                // an empty line has no tokens.\r\n                if (newRecord) {\r\n                    quote = true;\r\n                }\r\n            } else {\r\n                char c = charSeq.charAt(pos);\r\n\r\n                if (c <= COMMENT) {\r\n                    // Some other chars at the start of a value caused the parser to fail, so for now\r\n                    // encapsulate if we start in anything less than '#'. We are being conservative\r\n                    // by including the default comment char too.\r\n                    quote = true;\r\n                } else {\r\n                    while (pos < len) {\r\n                        c = charSeq.charAt(pos);\r\n                        if (c == LF || c == CR || c == quoteChar || c == escapeChar || isDelimiter(c, charSeq, pos, delim, delimLength)) {\r\n                            quote = true;\r\n                            break;\r\n                        }\r\n                        pos++;\r\n                    }\r\n\r\n                    if (!quote) {\r\n                        pos = len - 1;\r\n                        c = charSeq.charAt(pos);\r\n                        // Some other chars at the end caused the parser to fail, so for now\r\n                        // encapsulate if we end in anything less than ' '\r\n                        if (isTrimChar(c)) {\r\n                            quote = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!quote) {\r\n                // no encapsulation needed - write out the original value\r\n                out.append(charSeq, start, len);\r\n                return;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\r\n        }\r\n\r\n        if (!quote) {\r\n            // no encapsulation needed - write out the original value\r\n            out.append(charSeq, start, len);\r\n            return;\r\n        }\r\n\r\n        // we hit something that needed encapsulation\r\n        out.append(quoteChar);\r\n\r\n        // Pick up where we left off: pos should be positioned on the first character that caused\r\n        // the need for encapsulation.\r\n        while (pos < len) {\r\n            final char c = charSeq.charAt(pos);\r\n            if (c == quoteChar || c == escapeChar) {\r\n                // write out the chunk up until this point\r\n                out.append(charSeq, start, pos);\r\n                out.append(escapeChar); // now output the escape\r\n                start = pos; // and restart with the matched char\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write the last segment\r\n        out.append(charSeq, start, pos);\r\n        out.append(quoteChar);\r\n    }\r\n\r\n    /**\r\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\r\n     *\r\n     * @param reader What to print\r\n     * @param appendable Where to print it\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {\r\n\r\n        if (getQuoteMode() == QuoteMode.NONE) {\r\n            printWithEscapes(reader, appendable);\r\n            return;\r\n        }\r\n\r\n        int pos = 0;\r\n\r\n        final char quote = getQuoteCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        append(quote, appendable);\r\n\r\n        int c;\r\n        while (-1 != (c = reader.read())) {\r\n            builder.append((char) c);\r\n            if (c == quote) {\r\n                // write out segment up until this char\r\n                if (pos > 0) {\r\n                    append(builder.substring(0, pos), appendable);\r\n                    append(quote, appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n\r\n                append((char) c, appendable);\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > 0) {\r\n            append(builder.substring(0, pos), appendable);\r\n        }\r\n\r\n        append(quote, appendable);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        final StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\r\n        if (isEscapeCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\r\n        }\r\n        if (quoteMode != null) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\r\n        }\r\n        if (isCommentMarkerSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\r\n        }\r\n        if (isNullStringSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"NullString=<\").append(nullString).append('>');\r\n        }\r\n        if (recordSeparator != null) {\r\n            sb.append(' ');\r\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\r\n        }\r\n        if (getIgnoreEmptyLines()) {\r\n            sb.append(\" EmptyLines:ignored\");\r\n        }\r\n        if (getIgnoreSurroundingSpaces()) {\r\n            sb.append(\" SurroundingSpaces:ignored\");\r\n        }\r\n        if (getIgnoreHeaderCase()) {\r\n            sb.append(\" IgnoreHeaderCase:ignored\");\r\n        }\r\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\r\n        if (headerComments != null) {\r\n            sb.append(' ');\r\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\r\n        }\r\n        if (headers != null) {\r\n            sb.append(' ');\r\n            sb.append(\"Header:\").append(Arrays.toString(headers));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    String trim(final String value) {\r\n        return getTrim() ? value.trim() : value;\r\n    }\r\n\r\n    /**\r\n     * Verifies the validity and consistency of the attributes, and throws an {@link IllegalArgumentException} if necessary.\r\n     * <p>\r\n     * Because an instance can be used for both writing an parsing, not all conditions can be tested here. For example allowMissingColumnNames is only used for\r\n     * parsing, so it cannot be used here.\r\n     * </p>\r\n     *\r\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.\r\n     */\r\n    private void validate() throws IllegalArgumentException {\r\n        if (containsLineBreak(delimiter)) {\r\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n        }\r\n\r\n        if (quoteCharacter != null && contains(delimiter, quoteCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && contains(delimiter, escapeCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\r\n        }\r\n\r\n        if (commentMarker != null && contains(delimiter, commentMarker.charValue())) {\r\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\r\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\r\n        }\r\n\r\n        // Validate headers\r\n        if (headers != null && duplicateHeaderMode != DuplicateHeaderMode.ALLOW_ALL) {\r\n            final Set<String> dupCheckSet = new HashSet<>(headers.length);\r\n            final boolean emptyDuplicatesAllowed = duplicateHeaderMode == DuplicateHeaderMode.ALLOW_EMPTY;\r\n            for (final String header : headers) {\r\n                final boolean blank = isBlank(header);\r\n                // Sanitise all empty headers to the empty string \"\" when checking duplicates\r\n                final boolean containsHeader = !dupCheckSet.add(blank ? \"\" : header);\r\n                if (containsHeader && !(blank && emptyDuplicatesAllowed)) {\r\n                    throw new IllegalArgumentException(\r\n                        String.format(\r\n                            \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\r\n                            header, Arrays.toString(headers)));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} that allows duplicate header names.\r\n     *\r\n     * @return a new {@code CSVFormat} that allows duplicate header names\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean) Builder#setAllowDuplicateHeaderNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames() {\r\n        return builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     *\r\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n        final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\r\n        return builder().setDuplicateHeaderMode(mode).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @see Builder#setAllowMissingColumnNames(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames() {\r\n        return builder().setAllowMissingColumnNames(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\r\n     *\r\n     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause\r\n     *                                an {@link IllegalArgumentException} to be thrown.\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n        return builder().setAllowMissingColumnNames(allowMissingColumnNames).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to flush on close.\r\n     *\r\n     * @param autoFlush whether to flush on close.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setAutoFlush(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\r\n        return builder().setAutoFlush(autoFlush).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final char commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final Character commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the delimiter of the format set to the specified character.\r\n     *\r\n     * @param delimiter the delimiter character\r\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setDelimiter(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withDelimiter(final char delimiter) {\r\n        return builder().setDelimiter(delimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final char escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final Character escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} using the first record as header.\r\n     *\r\n     * <p>\r\n     * Calling this method is equivalent to calling:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\r\n     * </pre>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but using the first record as header.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(String...) Builder#setHeader()}.{@link Builder#setSkipHeaderRecord(boolean) setSkipHeaderRecord(true)}.\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withFirstRecordAsHeader() {\r\n        // @formatter:off\r\n        return builder()\r\n                .setHeader()\r\n                .setSkipHeaderRecord(true)\r\n                .build();\r\n        // @formatter:on\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format defined by the enum class.\r\n     *\r\n     * <p>\r\n     * Example:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * public enum Header {\r\n     *     Name, Email, Phone\r\n     * }\r\n     *\r\n     * CSVFormat format = aformat.withHeader(Header.class);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setHeader(String...)\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(Class)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\r\n        return builder().setHeader(headerEnum).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(resultSet);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSet)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\r\n        return builder().setHeader(resultSet).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(metaData);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSetMetaData)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n        return builder().setHeader(resultSetMetaData).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file\r\n     * with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @deprecated Use {@link Builder#setHeader(String...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final String... header) {\r\n        return builder().setHeader(header).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.\r\n     * This setting is ignored by the parser.\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n     * </pre>\r\n     *\r\n     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeaderComments(Object...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeaderComments(final Object... headerComments) {\r\n        return builder().setHeaderComments(headerComments).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @see Builder#setIgnoreEmptyLines(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines() {\r\n        return builder().setIgnoreEmptyLines(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty\r\n     *                         lines to empty records.\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n        return builder().setIgnoreEmptyLines(ignoreEmptyLines).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that will ignore case header name.\r\n     * @see Builder#setIgnoreHeaderCase(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean) Builder#setIgnoreHeaderCase(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase() {\r\n        return builder().setIgnoreHeaderCase(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether header names should be accessed ignoring case.\r\n     *\r\n     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n        return builder().setIgnoreHeaderCase(ignoreHeaderCase).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\r\n     * @see Builder#setIgnoreSurroundingSpaces(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean) Builder#setIgnoreSurroundingSpaces(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces() {\r\n        return builder().setIgnoreSurroundingSpaces(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n        return builder().setIgnoreSurroundingSpaces(ignoreSurroundingSpaces).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with conversions to and from null for strings on input and output.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\r\n     * @deprecated Use {@link Builder#setNullString(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withNullString(final String nullString) {\r\n        return builder().setNullString(nullString).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final char quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character, use {@code null} to disable.\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final Character quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\r\n     *\r\n     * @param quoteMode the quote policy to use for output.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\r\n     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuoteMode(final QuoteMode quoteMode) {\r\n        return builder().setQuoteMode(quoteMode).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified character.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @deprecated Use {@link Builder#setRecordSeparator(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified String.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with skipping the header record set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean) Builder#setSkipHeaderRecord(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord() {\r\n        return builder().setSkipHeaderRecord(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to skip the header record.\r\n     *\r\n     * @param skipHeaderRecord whether to skip the header record.\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setHeader(String...)\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n        return builder().setSkipHeaderRecord(skipHeaderRecord).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows\r\n     * and LF on Linux.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSystemRecordSeparator() {\r\n        return builder().setRecordSeparator(System.lineSeparator()).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} to add a trailing delimiter.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean) Builder#setTrailingDelimiter(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter() {\r\n        return builder().setTrailingDelimiter(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to add a trailing delimiter.\r\n     *\r\n     * @param trailingDelimiter whether to add a trailing delimiter.\r\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\r\n        return builder().setTrailingDelimiter(trailingDelimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean) Builder#setTrim(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim() {\r\n        return builder().setTrim(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @param trim whether to trim leading and trailing blanks.\r\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim(final boolean trim) {\r\n        return builder().setTrim(trim).build();\r\n    }\r\n}\r",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 275c0dae0..bead0aafe 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -521,28 +521,75 @@ public Builder setHeader(final String... header) {\n         }\r\n \r\n         /**\r\n-         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n-         *\r\n+         * Sets the header comments to the given values before the CSV data.\r\n+         * <p>\r\n+         * This setting is ignored by the parser.\r\n+         * </p>\r\n+         * <p>\r\n+         * Comments are printed first, before headers.\r\n+         * </p>\r\n+         * <p>\r\n+         * Use {@link Builder#setCommentMarker(char)} or {@link Builder#setCommentMarker(Character)} to set the comment marker written at the start of\r\n+         * each comment line.\r\n+         * </p>\r\n+         * <p>\r\n+         * If the comment marker is not set, then the header comments are ignored.\r\n+         * </p>\r\n+         * <p>\r\n+         * For example:\r\n+         * </p>\r\n+         * <pre>\r\n+         * builder.setCommentMarker('#')\r\n+         *        .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0));\r\n+         * </pre>\r\n+         * <p>\r\n+         * writes:\r\n+         * </p>\r\n          * <pre>\r\n-         * builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n+         * # Generated by Apache Commons CSV.\r\n+         * # 1970-01-01T00:00:00Z\r\n          * </pre>\r\n          *\r\n-         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n+         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.\r\n          * @return This instance.\r\n          */\r\n+\r\n         public Builder setHeaderComments(final Object... headerComments) {\r\n             this.headerComments = CSVFormat.clone(toStringArray(headerComments));\r\n             return this;\r\n         }\r\n \r\n         /**\r\n-         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n-         *\r\n+         * Sets the header comments to the given values before the CSV data.\r\n+         * <p>\r\n+         * This setting is ignored by the parser.\r\n+         * </p>\r\n+         * <p>\r\n+         * Comments are printed first, before headers.\r\n+         * </p>\r\n+         * <p>\r\n+         * Use {@link Builder#setCommentMarker(char)} or {@link Builder#setCommentMarker(Character)} to set the comment marker written at the start of\r\n+         * each comment line.\r\n+         * </p>\r\n+         * <p>\r\n+         * If the comment marker is not set, then the header comments are ignored.\r\n+         * </p>\r\n+         * <p>\r\n+         * For example:\r\n+         * </p>\r\n+         * <pre>\r\n+         * builder.setCommentMarker('#')\r\n+         *        .setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0).toString());\r\n+         * </pre>\r\n+         * <p>\r\n+         * writes:\r\n+         * </p>\r\n          * <pre>\r\n-         * Builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n+         * # Generated by Apache Commons CSV.\r\n+         * # 1970-01-01T00:00:00Z\r\n          * </pre>\r\n          *\r\n-         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n+         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.\r\n          * @return This instance.\r\n          */\r\n         public Builder setHeaderComments(final String... headerComments) {\r\n"
      }
    ]
  },
  {
    "pr_number": 328,
    "title": "Add missing docs",
    "state": "closed",
    "created_at": "2023-06-24T13:06:25Z",
    "merge_commit_sha": "57232617ce2f094ac6a9b8add905d7d8287c2d61",
    "base_sha": "8f07f102a37356922e7493723769dd49f93f3511",
    "head_sha": "d3ef84e248755e944cb7ef245cc2bf88be7a05e3",
    "user_login": "jkbkupczyk",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.CSVFormat.RFC4180;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testPrintToFileWithCharset() throws IOException {\n        Path tempFile = Files.createTempFile(\"csvTest\", \".csv\");\n        CSVFormat format = CSVFormat.RFC4180;\n        try (CSVPrinter printer = format.print(tempFile.toFile(), Charset.forName(\"UTF-8\"))) {\n            printer.printRecord(\"a\", \"b\", \"c\");\n        }\n        String content = Files.readString(tempFile, Charset.forName(\"UTF-8\"));\n        assertEquals(\"a,b,c\" + format.getRecordSeparator(), content);\n    }\n\n    @Test\n    public void testPrintToPathWithCharset() throws IOException {\n        Path tempFile = Files.createTempFile(\"csvTest\", \".csv\");\n        CSVFormat format = CSVFormat.RFC4180;\n        try (CSVPrinter printer = format.print(tempFile, Charset.forName(\"UTF-8\"))) {\n            printer.printRecord(\"a\", \"b\", \"c\");\n        }\n        String content = Files.readString(tempFile, Charset.forName(\"UTF-8\"));\n        assertEquals(\"a,b,c\" + format.getRecordSeparator(), content);\n    }\n\n    @Test\n    public void testGetIgnoreHeaderCaseDocumentation() {\n        CSVFormat format = CSVFormat.DEFAULT.builder().setIgnoreHeaderCase(true).build();\n        assertEquals(true, format.getIgnoreHeaderCase());\n    }\n\n    @Test\n    public void testConstructorDocumentation() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            new CSVFormat(\",\", '\"', QuoteMode.MINIMAL, '#', '\\\\', true, true, \"\\n\", null, null, null, false, false, true, true, true, true, DuplicateHeaderMode.ALLOW_ALL);\n        });\n    }\n}",
        "file_content": "/*\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n * this work for additional information regarding copyright ownership.\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n * (the \"License\"); you may not use this file except in compliance with\r\n * the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage org.apache.commons.csv;\r\n\r\nimport static org.apache.commons.csv.Constants.BACKSLASH;\r\nimport static org.apache.commons.csv.Constants.COMMA;\r\nimport static org.apache.commons.csv.Constants.COMMENT;\r\nimport static org.apache.commons.csv.Constants.CR;\r\nimport static org.apache.commons.csv.Constants.CRLF;\r\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\r\nimport static org.apache.commons.csv.Constants.EMPTY;\r\nimport static org.apache.commons.csv.Constants.LF;\r\nimport static org.apache.commons.csv.Constants.PIPE;\r\nimport static org.apache.commons.csv.Constants.SP;\r\nimport static org.apache.commons.csv.Constants.TAB;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Serializable;\r\nimport java.io.StringWriter;\r\nimport java.io.Writer;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.Arrays;\r\nimport java.util.HashSet;\r\nimport java.util.Objects;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Specifies the format of a CSV file for parsing and writing.\r\n *\r\n * <h2>Using predefined formats</h2>\r\n *\r\n * <p>\r\n * You can use one of the predefined formats:\r\n * </p>\r\n *\r\n * <ul>\r\n * <li>{@link #DEFAULT}</li>\r\n * <li>{@link #EXCEL}</li>\r\n * <li>{@link #INFORMIX_UNLOAD}</li>\r\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\r\n * <li>{@link #MYSQL}</li>\r\n * <li>{@link #RFC4180}</li>\r\n * <li>{@link #ORACLE}</li>\r\n * <li>{@link #POSTGRESQL_CSV}</li>\r\n * <li>{@link #POSTGRESQL_TEXT}</li>\r\n * <li>{@link #TDF}</li>\r\n * </ul>\r\n *\r\n * <p>\r\n * For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\r\n * </pre>\r\n *\r\n * <p>\r\n * The {@link CSVParser} provides static methods to parse other input types, for example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\r\n * </pre>\r\n *\r\n * <h2>Defining formats</h2>\r\n *\r\n * <p>\r\n * You can extend a format by calling the {@code set} methods. For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\r\n * </pre>\r\n *\r\n * <h2>Defining column names</h2>\r\n *\r\n * <p>\r\n * To define the column names you want to use to access records, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * Calling {@link Builder#setHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and assumes that your CSV source does not\r\n * contain a first record that also defines column names.\r\n *\r\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\r\n * {@link Builder#setSkipHeaderRecord(boolean)} with {@code true}.\r\n * </p>\r\n *\r\n * <h2>Parsing</h2>\r\n *\r\n * <p>\r\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * Reader in = ...;\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\r\n * </pre>\r\n *\r\n * <p>\r\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\r\n * </p>\r\n *\r\n * <h2>Referencing columns safely</h2>\r\n *\r\n * <p>\r\n * If your source contains a header record, you can simplify your code and safely reference columns, by using {@link Builder#setHeader(String...)} with no\r\n * arguments:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader();\r\n * </pre>\r\n *\r\n * <p>\r\n * This causes the parser to read the first record and use its values as column names.\r\n *\r\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\r\n * </p>\r\n *\r\n * <pre>\r\n * String value = record.get(&quot;Col1&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * This makes your code impervious to changes in column order in the CSV file.\r\n * </p>\r\n *\r\n * <h2>Serialization</h2>\r\n * <p>\r\n *   This class implements the {@link Serializable} interface with the following caveats:\r\n * </p>\r\n * <ul>\r\n *   <li>This class will no longer implement Serializable in 2.0.</li>\r\n *   <li>Serialization is not supported from one version to the next.</li>\r\n * </ul>\r\n * <p>\r\n *   The {@code serialVersionUID} values are:\r\n * </p>\r\n * <ul>\r\n *   <li>Version 1.10.0: {@code 2L}</li>\r\n *   <li>Version 1.9.0 through 1.0: {@code 1L}</li>\r\n * </ul>\r\n *\r\n * <h2>Notes</h2>\r\n * <p>\r\n * This class is immutable.\r\n * </p>\r\n * <p>\r\n * Not all settings are used for both parsing and writing.\r\n * </p>\r\n */\r\npublic final class CSVFormat implements Serializable {\r\n\r\n    /**\r\n     * Builds CSVFormat instances.\r\n     *\r\n     * @since 1.9.0\r\n     */\r\n    public static class Builder {\r\n\r\n        /**\r\n         * Creates a new default builder.\r\n         *\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create() {\r\n            return new Builder(CSVFormat.DEFAULT);\r\n        }\r\n\r\n        /**\r\n         * Creates a new builder for the given format.\r\n         *\r\n         * @param csvFormat the source format.\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create(final CSVFormat csvFormat) {\r\n            return new Builder(csvFormat);\r\n        }\r\n\r\n        private boolean allowMissingColumnNames;\r\n\r\n        private boolean autoFlush;\r\n\r\n        private Character commentMarker;\r\n\r\n        private String delimiter;\r\n\r\n        private DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n        private Character escapeCharacter;\r\n\r\n        private String[] headerComments;\r\n\r\n        private String[] headers;\r\n\r\n        private boolean ignoreEmptyLines;\r\n\r\n        private boolean ignoreHeaderCase;\r\n\r\n        private boolean ignoreSurroundingSpaces;\r\n\r\n        private String nullString;\r\n\r\n        private Character quoteCharacter;\r\n\r\n        private String quotedNullString;\r\n\r\n        private QuoteMode quoteMode;\r\n\r\n        private String recordSeparator;\r\n\r\n        private boolean skipHeaderRecord;\r\n\r\n        private boolean trailingDelimiter;\r\n\r\n        private boolean trim;\r\n\r\n        private Builder(final CSVFormat csvFormat) {\r\n            this.delimiter = csvFormat.delimiter;\r\n            this.quoteCharacter = csvFormat.quoteCharacter;\r\n            this.quoteMode = csvFormat.quoteMode;\r\n            this.commentMarker = csvFormat.commentMarker;\r\n            this.escapeCharacter = csvFormat.escapeCharacter;\r\n            this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;\r\n            this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;\r\n            this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;\r\n            this.recordSeparator = csvFormat.recordSeparator;\r\n            this.nullString = csvFormat.nullString;\r\n            this.headerComments = csvFormat.headerComments;\r\n            this.headers = csvFormat.headers;\r\n            this.skipHeaderRecord = csvFormat.skipHeaderRecord;\r\n            this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;\r\n            this.trailingDelimiter = csvFormat.trailingDelimiter;\r\n            this.trim = csvFormat.trim;\r\n            this.autoFlush = csvFormat.autoFlush;\r\n            this.quotedNullString = csvFormat.quotedNullString;\r\n            this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;\r\n        }\r\n\r\n        /**\r\n         * Builds a new CSVFormat instance.\r\n         *\r\n         * @return a new CSVFormat instance.\r\n         */\r\n        public CSVFormat build() {\r\n            return new CSVFormat(this);\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior, true to allow, false to disallow.\r\n         *\r\n         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n         * @return This instance.\r\n         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.\r\n         */\r\n        @Deprecated\r\n        public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n            setDuplicateHeaderMode(allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\r\n         * {@link IllegalArgumentException} to be thrown.\r\n         *\r\n         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\r\n         *                                cause an {@link IllegalArgumentException} to be thrown.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n            this.allowMissingColumnNames = allowMissingColumnNames;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to flush on close.\r\n         *\r\n         * @param autoFlush whether to flush on close.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAutoFlush(final boolean autoFlush) {\r\n            this.autoFlush = autoFlush;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final char commentMarker) {\r\n            setCommentMarker(Character.valueOf(commentMarker));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final Character commentMarker) {\r\n            if (isLineBreak(commentMarker)) {\r\n                throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\r\n            }\r\n            this.commentMarker = commentMarker;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final char delimiter) {\r\n            return setDelimiter(String.valueOf(delimiter));\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final String delimiter) {\r\n            if (containsLineBreak(delimiter)) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n            }\r\n            if (delimiter.isEmpty()) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be empty\");\r\n            }\r\n            this.delimiter = delimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior.\r\n         *\r\n         * @param duplicateHeaderMode the duplicate header names behavior\r\n         * @return This instance.\r\n         * @since 1.10.0\r\n         */\r\n        public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {\r\n          this.duplicateHeaderMode = Objects.requireNonNull(duplicateHeaderMode, \"duplicateHeaderMode\");\r\n          return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final char escapeCharacter) {\r\n            setEscape(Character.valueOf(escapeCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final Character escapeCharacter) {\r\n            if (isLineBreak(escapeCharacter)) {\r\n                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\r\n            }\r\n            this.escapeCharacter = escapeCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header defined by the given {@link Enum} class.\r\n         *\r\n         * <p>\r\n         * Example:\r\n         * </p>\r\n         *\r\n         * <pre>\r\n         * public enum HeaderEnum {\r\n         *     Name, Email, Phone\r\n         * }\r\n         *\r\n         * Builder builder = builder.setHeader(HeaderEnum.class);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {\r\n            String[] header = null;\r\n            if (headerEnum != null) {\r\n                final Enum<?>[] enumValues = headerEnum.getEnumConstants();\r\n                header = new String[enumValues.length];\r\n                Arrays.setAll(header, i -> enumValues[i].name());\r\n            }\r\n            return setHeader(header);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSet);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSet resultSet) throws SQLException {\r\n            return setHeader(resultSet != null ? resultSet.getMetaData() : null);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSetMetaData);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n            String[] labels = null;\r\n            if (resultSetMetaData != null) {\r\n                final int columnCount = resultSetMetaData.getColumnCount();\r\n                labels = new String[columnCount];\r\n                for (int i = 0; i < columnCount; i++) {\r\n                    labels[i] = resultSetMetaData.getColumnLabel(i + 1);\r\n                }\r\n            }\r\n            return setHeader(labels);\r\n        }\r\n\r\n        /**\r\n         * Sets the header to the given values. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final String... header) {\r\n            this.headers = CSVFormat.clone(header);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final Object... headerComments) {\r\n            this.headerComments = CSVFormat.clone(toStringArray(headerComments));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * Builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final String... headerComments) {\r\n            this.headerComments = CSVFormat.clone(headerComments);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty\r\n         * records.\r\n         *\r\n         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate\r\n         *                         empty lines to empty records.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n            this.ignoreEmptyLines = ignoreEmptyLines;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         *\r\n         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n            this.ignoreHeaderCase = ignoreHeaderCase;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         *\r\n         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         *\r\n         * <ul>\r\n         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n         * </ul>\r\n         *\r\n         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         * @return This instance.\r\n         */\r\n        public Builder setNullString(final String nullString) {\r\n            this.nullString = nullString;\r\n            this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character.\r\n         *\r\n         * @param quoteCharacter the quote character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final char quoteCharacter) {\r\n            setQuote(Character.valueOf(quoteCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character, use {@code null} to disable.\r\n         *\r\n         * @param quoteCharacter the quote character, use {@code null} to disable.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final Character quoteCharacter) {\r\n            if (isLineBreak(quoteCharacter)) {\r\n                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\r\n            }\r\n            this.quoteCharacter = quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote policy to use for output.\r\n         *\r\n         * @param quoteMode the quote policy to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuoteMode(final QuoteMode quoteMode) {\r\n            this.quoteMode = quoteMode;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final char recordSeparator) {\r\n            this.recordSeparator = String.valueOf(recordSeparator);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final String recordSeparator) {\r\n            this.recordSeparator = recordSeparator;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to skip the header record.\r\n         *\r\n         * @param skipHeaderRecord whether to skip the header record.\r\n         * @return This instance.\r\n         */\r\n        public Builder setSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n            this.skipHeaderRecord = skipHeaderRecord;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to add a trailing delimiter.\r\n         *\r\n         * @param trailingDelimiter whether to add a trailing delimiter.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrailingDelimiter(final boolean trailingDelimiter) {\r\n            this.trailingDelimiter = trailingDelimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to trim leading and trailing blanks.\r\n         *\r\n         * @param trim whether to trim leading and trailing blanks.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrim(final boolean trim) {\r\n            this.trim = trim;\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Predefines formats.\r\n     *\r\n     * @since 1.2\r\n     */\r\n    public enum Predefined {\r\n\r\n        /**\r\n         * @see CSVFormat#DEFAULT\r\n         */\r\n        Default(CSVFormat.DEFAULT),\r\n\r\n        /**\r\n         * @see CSVFormat#EXCEL\r\n         */\r\n        Excel(CSVFormat.EXCEL),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD\r\n         * @since 1.3\r\n         */\r\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\r\n         * @since 1.3\r\n         */\r\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_CSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_TSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MYSQL\r\n         */\r\n        MySQL(CSVFormat.MYSQL),\r\n\r\n        /**\r\n         * @see CSVFormat#ORACLE\r\n         */\r\n        Oracle(CSVFormat.ORACLE),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         * @since 1.5\r\n         */\r\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         */\r\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\r\n\r\n        /**\r\n         * @see CSVFormat#RFC4180\r\n         */\r\n        RFC4180(CSVFormat.RFC4180),\r\n\r\n        /**\r\n         * @see CSVFormat#TDF\r\n         */\r\n        TDF(CSVFormat.TDF);\r\n\r\n        private final CSVFormat format;\r\n\r\n        Predefined(final CSVFormat format) {\r\n            this.format = format;\r\n        }\r\n\r\n        /**\r\n         * Gets the format.\r\n         *\r\n         * @return the format.\r\n         */\r\n        public CSVFormat getFormat() {\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing\r\n     * empty lines.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Default\r\n     */\r\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false,\r\n            false, false, false, DuplicateHeaderMode.ALLOW_ALL);\r\n\r\n    /**\r\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is locale dependent, it might be necessary\r\n     * to customize this format to accommodate to your regional settings.\r\n     *\r\n     * <p>\r\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setAllowMissingColumnNames(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     * <p>\r\n     * Note: This is currently like {@link #RFC4180} plus {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)} and\r\n     * {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(false)}.\r\n     * </p>\r\n     *\r\n     * @see Predefined#Excel\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat EXCEL = DEFAULT.builder()\r\n            .setIgnoreEmptyLines(false)\r\n            .setAllowMissingColumnNames(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.builder()\r\n            .setDelimiter(PIPE)\r\n            .setEscape(BACKSLASH)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with {@code '\"'}. A header line with field\r\n     * names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format. Values are double quoted only if needed and special\r\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\r\n     *          documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_TSV = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\r\n     *      -data.html</a>\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MYSQL = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default Oracle format used by the SQL*Loader utility.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\r\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\r\n     * {@code \"\"}. Values are trimmed.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setTrim()}</li>\r\n     * <li>{@code setSystemRecordSeparator()}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.MINIMAL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Oracle\r\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\r\n     * @since 1.6\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat ORACLE = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setTrim(true)\r\n            .setRecordSeparator(System.lineSeparator())\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\r\n     * characters are not escaped. The default NULL string is {@code \"\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape(null)}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(null)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(EMPTY)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL text format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#RFC4180\r\n     */\r\n    public static final CSVFormat RFC4180 = DEFAULT.builder().setIgnoreEmptyLines(false).build();\r\n\r\n    private static final long serialVersionUID = 2L;\r\n\r\n    /**\r\n     * Tab-delimited format.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreSurroundingSpaces(true)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#TDF\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat TDF = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setIgnoreSurroundingSpaces(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Null-safe clone of an array.\r\n     *\r\n     * @param <T>    The array element type.\r\n     * @param values the source array\r\n     * @return the cloned array.\r\n     */\r\n    @SafeVarargs\r\n    static <T> T[] clone(final T... values) {\r\n        return values == null ? null : values.clone();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains the search char.\r\n     *\r\n     * @param source the string to check.\r\n     * @param searchCh the character to search.\r\n     *\r\n     * @return true if {@code c} contains a line break character\r\n     */\r\n    private static boolean contains(final String source, final char searchCh) {\r\n        return Objects.requireNonNull(source, \"source\").indexOf(searchCh) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains a line break character.\r\n     *\r\n     * @param source the string to check.\r\n     *\r\n     * @return true if {@code c} contains a line break character.\r\n     */\r\n    private static boolean containsLineBreak(final String source) {\r\n        return contains(source, CR) || contains(source, LF);\r\n    }\r\n\r\n    static boolean isBlank(final String value) {\r\n        return value == null || value.trim().isEmpty();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check.\r\n     *\r\n     * @return true if {@code c} is a line break character.\r\n     */\r\n    private static boolean isLineBreak(final char c) {\r\n        return c == LF || c == CR;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check, may be null.\r\n     *\r\n     * @return true if {@code c} is a line break character (and not null).\r\n     */\r\n    private static boolean isLineBreak(final Character c) {\r\n        return c != null && isLineBreak(c.charValue());\r\n    }\r\n\r\n    /** Same test as in as {@link String#trim()}. */\r\n    private static boolean isTrimChar(final char ch) {\r\n        return ch <= SP;\r\n    }\r\n\r\n    /** Same test as in as {@link String#trim()}. */\r\n    private static boolean isTrimChar(final CharSequence charSequence, final int pos) {\r\n        return isTrimChar(charSequence.charAt(pos));\r\n    }\r\n\r\n    /**\r\n     * Creates a new CSV format with the specified delimiter.\r\n     *\r\n     * <p>\r\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.\r\n     * </p>\r\n     *\r\n     * @param delimiter the char used for value separation, must not be a line break character\r\n     * @return a new CSV format.\r\n     * @throws IllegalArgumentException if the delimiter is a line break character\r\n     *\r\n     * @see #DEFAULT\r\n     * @see #RFC4180\r\n     * @see #MYSQL\r\n     * @see #EXCEL\r\n     * @see #TDF\r\n     */\r\n    public static CSVFormat newFormat(final char delimiter) {\r\n        return new CSVFormat(String.valueOf(delimiter), null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false,\r\n                DuplicateHeaderMode.ALLOW_ALL);\r\n    }\r\n\r\n    static String[] toStringArray(final Object[] values) {\r\n        if (values == null) {\r\n            return null;\r\n        }\r\n        final String[] strings = new String[values.length];\r\n        Arrays.setAll(strings, i -> Objects.toString(values[i], null));\r\n        return strings;\r\n    }\r\n\r\n    static CharSequence trim(final CharSequence charSequence) {\r\n        if (charSequence instanceof String) {\r\n            return ((String) charSequence).trim();\r\n        }\r\n        final int count = charSequence.length();\r\n        int len = count;\r\n        int pos = 0;\r\n\r\n        while (pos < len && isTrimChar(charSequence, pos)) {\r\n            pos++;\r\n        }\r\n        while (pos < len && isTrimChar(charSequence, len - 1)) {\r\n            len--;\r\n        }\r\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\r\n    }\r\n\r\n    /**\r\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\r\n     *\r\n     * @param format name\r\n     * @return one of the predefined formats\r\n     * @since 1.2\r\n     */\r\n    public static CSVFormat valueOf(final String format) {\r\n        return CSVFormat.Predefined.valueOf(format).getFormat();\r\n    }\r\n\r\n    private final DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n    private final boolean allowMissingColumnNames;\r\n\r\n    private final boolean autoFlush;\r\n\r\n    private final Character commentMarker; // null if commenting is disabled\r\n\r\n    private final String delimiter;\r\n\r\n    private final Character escapeCharacter; // null if escaping is disabled\r\n\r\n    private final String[] headers; // array of header column names\r\n\r\n    private final String[] headerComments; // array of header comment lines\r\n\r\n    private final boolean ignoreEmptyLines;\r\n\r\n    private final boolean ignoreHeaderCase; // should ignore header names case\r\n\r\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\r\n\r\n    private final String nullString; // the string to be used for null values\r\n\r\n    private final Character quoteCharacter; // null if quoting is disabled\r\n\r\n    private final String quotedNullString;\r\n\r\n    private final QuoteMode quoteMode;\r\n\r\n    private final String recordSeparator; // for outputs\r\n\r\n    private final boolean skipHeaderRecord;\r\n\r\n    private final boolean trailingDelimiter;\r\n\r\n    private final boolean trim;\r\n\r\n    private CSVFormat(final Builder builder) {\r\n        this.delimiter = builder.delimiter;\r\n        this.quoteCharacter = builder.quoteCharacter;\r\n        this.quoteMode = builder.quoteMode;\r\n        this.commentMarker = builder.commentMarker;\r\n        this.escapeCharacter = builder.escapeCharacter;\r\n        this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = builder.allowMissingColumnNames;\r\n        this.ignoreEmptyLines = builder.ignoreEmptyLines;\r\n        this.recordSeparator = builder.recordSeparator;\r\n        this.nullString = builder.nullString;\r\n        this.headerComments = builder.headerComments;\r\n        this.headers = builder.headers;\r\n        this.skipHeaderRecord = builder.skipHeaderRecord;\r\n        this.ignoreHeaderCase = builder.ignoreHeaderCase;\r\n        this.trailingDelimiter = builder.trailingDelimiter;\r\n        this.trim = builder.trim;\r\n        this.autoFlush = builder.autoFlush;\r\n        this.quotedNullString = builder.quotedNullString;\r\n        this.duplicateHeaderMode = builder.duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    /**\r\n     * Creates a customized CSV format.\r\n     *\r\n     * @param delimiter               the char used for value separation, must not be a line break character.\r\n     * @param quoteChar               the Character used as value encapsulation marker, may be {@code null} to disable.\r\n     * @param quoteMode               the quote mode.\r\n     * @param commentStart            the Character used for comment identification, may be {@code null} to disable.\r\n     * @param escape                  the Character used to escape special characters in values, may be {@code null} to disable.\r\n     * @param ignoreSurroundingSpaces {@code true} when whitespaces enclosing values should be ignored.\r\n     * @param ignoreEmptyLines        {@code true} when the parser should skip empty lines.\r\n     * @param recordSeparator         the line separator to use for output.\r\n     * @param nullString              the line separator to use for output.\r\n     * @param headerComments          the comments to be printed by the Printer before the actual CSV data.\r\n     * @param header                  the header\r\n     * @param skipHeaderRecord        TODO Doc me.\r\n     * @param allowMissingColumnNames TODO Doc me.\r\n     * @param ignoreHeaderCase        TODO Doc me.\r\n     * @param trim                    TODO Doc me.\r\n     * @param trailingDelimiter       TODO Doc me.\r\n     * @param autoFlush               TODO Doc me.\r\n     * @param duplicateHeaderMode     the behavior when handling duplicate headers\r\n     * @throws IllegalArgumentException if the delimiter is a line break character.\r\n     */\r\n    private CSVFormat(final String delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape,\r\n            final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\r\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames,\r\n            final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush,\r\n            final DuplicateHeaderMode duplicateHeaderMode) {\r\n        this.delimiter = delimiter;\r\n        this.quoteCharacter = quoteChar;\r\n        this.quoteMode = quoteMode;\r\n        this.commentMarker = commentStart;\r\n        this.escapeCharacter = escape;\r\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = allowMissingColumnNames;\r\n        this.ignoreEmptyLines = ignoreEmptyLines;\r\n        this.recordSeparator = recordSeparator;\r\n        this.nullString = nullString;\r\n        this.headerComments = toStringArray(headerComments);\r\n        this.headers = clone(header);\r\n        this.skipHeaderRecord = skipHeaderRecord;\r\n        this.ignoreHeaderCase = ignoreHeaderCase;\r\n        this.trailingDelimiter = trailingDelimiter;\r\n        this.trim = trim;\r\n        this.autoFlush = autoFlush;\r\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n        this.duplicateHeaderMode = duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    private void append(final char c, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(c);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    private void append(final CharSequence csq, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(csq);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    /**\r\n     * Creates a new Builder for this instance.\r\n     *\r\n     * @return a new Builder.\r\n     */\r\n    public Builder builder() {\r\n        return Builder.create(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a copy of this instance.\r\n     *\r\n     * @return a copy of this instance.\r\n     */\r\n    CSVFormat copy() {\r\n        return builder().build();\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(final Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null || getClass() != obj.getClass()) {\r\n            return false;\r\n        }\r\n        final CSVFormat other = (CSVFormat) obj;\r\n        return duplicateHeaderMode == other.duplicateHeaderMode && allowMissingColumnNames == other.allowMissingColumnNames &&\r\n                autoFlush == other.autoFlush && Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) &&\r\n                Objects.equals(escapeCharacter, other.escapeCharacter) && Arrays.equals(headers, other.headers) &&\r\n                Arrays.equals(headerComments, other.headerComments) && ignoreEmptyLines == other.ignoreEmptyLines &&\r\n                ignoreHeaderCase == other.ignoreHeaderCase && ignoreSurroundingSpaces == other.ignoreSurroundingSpaces &&\r\n                Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) && quoteMode == other.quoteMode &&\r\n                Objects.equals(quotedNullString, other.quotedNullString) && Objects.equals(recordSeparator, other.recordSeparator) &&\r\n                skipHeaderRecord == other.skipHeaderRecord && trailingDelimiter == other.trailingDelimiter && trim == other.trim;\r\n    }\r\n\r\n    /**\r\n     * Formats the specified values.\r\n     *\r\n     * @param values the values to format\r\n     * @return the formatted values\r\n     */\r\n    public String format(final Object... values) {\r\n        final StringWriter out = new StringWriter();\r\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\r\n            csvPrinter.printRecord(values);\r\n            final String res = out.toString();\r\n            final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\r\n            return res.substring(0, len);\r\n        } catch (final IOException e) {\r\n            // should not happen because a StringWriter does not do IO.\r\n            throw new IllegalStateException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether duplicate names are allowed in the headers.\r\n     *\r\n     * @return whether duplicate header names are allowed\r\n     * @since 1.7\r\n     * @deprecated Use {@link #getDuplicateHeaderMode()}.\r\n     */\r\n    @Deprecated\r\n    public boolean getAllowDuplicateHeaderNames() {\r\n        return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;\r\n    }\r\n\r\n    /**\r\n     * Gets whether missing column names are allowed when parsing the header line.\r\n     *\r\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an {@link IllegalArgumentException}.\r\n     */\r\n    public boolean getAllowMissingColumnNames() {\r\n        return allowMissingColumnNames;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to flush on close.\r\n     *\r\n     * @return whether to flush on close.\r\n     * @since 1.6\r\n     */\r\n    public boolean getAutoFlush() {\r\n        return autoFlush;\r\n    }\r\n\r\n    /**\r\n     * Gets the character marking the start of a line comment.\r\n     *\r\n     * @return the comment start marker, may be {@code null}\r\n     */\r\n    public Character getCommentMarker() {\r\n        return commentMarker;\r\n    }\r\n\r\n    /**\r\n     * Gets the first character delimiting the values (typically ';', ',' or '\\t').\r\n     *\r\n     * @return the first delimiter character.\r\n     * @deprecated Use {@link #getDelimiterString()}.\r\n     */\r\n    @Deprecated\r\n    public char getDelimiter() {\r\n        return delimiter.charAt(0);\r\n    }\r\n\r\n    /**\r\n     * Gets the character delimiting the values (typically \";\", \",\" or \"\\t\").\r\n     *\r\n     * @return the delimiter.\r\n     * @since 1.9.0\r\n     */\r\n    public String getDelimiterString() {\r\n        return delimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets how duplicate headers are handled.\r\n     *\r\n     * @return if duplicate header values are allowed, allowed conditionally, or disallowed.\r\n     * @since 1.10.0\r\n     */\r\n    public DuplicateHeaderMode getDuplicateHeaderMode() {\r\n        return duplicateHeaderMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the escape character.\r\n     *\r\n     * @return the escape character, may be {@code null}\r\n     */\r\n    public Character getEscapeCharacter() {\r\n        return escapeCharacter;\r\n    }\r\n\r\n    /**\r\n     * Gets a copy of the header array.\r\n     *\r\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\r\n     */\r\n    public String[] getHeader() {\r\n        return headers != null ? headers.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Gets a copy of the header comment array.\r\n     *\r\n     * @return a copy of the header comment array; {@code null} if disabled.\r\n     */\r\n    public String[] getHeaderComments() {\r\n        return headerComments != null ? headerComments.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Gets whether empty lines between records are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty records.\r\n     */\r\n    public boolean getIgnoreEmptyLines() {\r\n        return ignoreEmptyLines;\r\n    }\r\n\r\n    /**\r\n     * Gets whether header names will be accessed ignoring case when parsing input.\r\n     *\r\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\r\n     * @since 1.3\r\n     */\r\n    public boolean getIgnoreHeaderCase() {\r\n        return ignoreHeaderCase;\r\n    }\r\n\r\n    /**\r\n     * Gets whether spaces around values are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\r\n     */\r\n    public boolean getIgnoreSurroundingSpaces() {\r\n        return ignoreSurroundingSpaces;\r\n    }\r\n\r\n    /**\r\n     * Gets the String to convert to and from {@code null}.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     */\r\n    public String getNullString() {\r\n        return nullString;\r\n    }\r\n\r\n    /**\r\n     * Gets the character used to encapsulate values containing special characters.\r\n     *\r\n     * @return the quoteChar character, may be {@code null}\r\n     */\r\n    public Character getQuoteCharacter() {\r\n        return quoteCharacter;\r\n    }\r\n\r\n    /**\r\n     * Gets the quote policy output fields.\r\n     *\r\n     * @return the quote policy\r\n     */\r\n    public QuoteMode getQuoteMode() {\r\n        return quoteMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the record separator delimiting output records.\r\n     *\r\n     * @return the record separator\r\n     */\r\n    public String getRecordSeparator() {\r\n        return recordSeparator;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to skip the header record.\r\n     *\r\n     * @return whether to skip the header record.\r\n     */\r\n    public boolean getSkipHeaderRecord() {\r\n        return skipHeaderRecord;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to add a trailing delimiter.\r\n     *\r\n     * @return whether to add a trailing delimiter.\r\n     * @since 1.3\r\n     */\r\n    public boolean getTrailingDelimiter() {\r\n        return trailingDelimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to trim leading and trailing blanks. This is used by {@link #print(Object, Appendable, boolean)} Also by\r\n     * {CSVParser#addRecordValue(boolean)}\r\n     *\r\n     * @return whether to trim leading and trailing blanks.\r\n     */\r\n    public boolean getTrim() {\r\n        return trim;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + Arrays.hashCode(headers);\r\n        result = prime * result + Arrays.hashCode(headerComments);\r\n        return prime * result + Objects.hash(duplicateHeaderMode, allowMissingColumnNames, autoFlush, commentMarker, delimiter, escapeCharacter,\r\n                ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator,\r\n                skipHeaderRecord, trailingDelimiter, trim);\r\n    }\r\n\r\n    /**\r\n     * Tests whether comments are supported by this format.\r\n     *\r\n     * Note that the comment introducer character is only recognized at the start of a line.\r\n     *\r\n     * @return {@code true} is comments are supported, {@code false} otherwise\r\n     */\r\n    public boolean isCommentMarkerSet() {\r\n        return commentMarker != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether the next characters constitute a delimiter\r\n     *\r\n     * @param ch\r\n     *            the current char\r\n     * @param charSeq\r\n     *            the match char sequence\r\n     * @param startIndex\r\n     *            where start to match\r\n     * @param delimiter\r\n     *            the delimiter\r\n     * @param delimiterLength\r\n     *            the delimiter length\r\n     * @return true if the match is successful\r\n     */\r\n    private boolean isDelimiter(final char ch, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength) {\r\n        if (ch != delimiter[0]) {\r\n            return false;\r\n        }\r\n        final int len = charSeq.length();\r\n        if (startIndex + delimiterLength > len) {\r\n            return false;\r\n        }\r\n        for (int i = 1; i < delimiterLength; i++) {\r\n            if (charSeq.charAt(startIndex + i) != delimiter[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests whether escape are being processed.\r\n     *\r\n     * @return {@code true} if escapes are processed\r\n     */\r\n    public boolean isEscapeCharacterSet() {\r\n        return escapeCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether a nullString has been defined.\r\n     *\r\n     * @return {@code true} if a nullString is defined\r\n     */\r\n    public boolean isNullStringSet() {\r\n        return nullString != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether a quoteChar has been defined.\r\n     *\r\n     * @return {@code true} if a quoteChar is defined\r\n     */\r\n    public boolean isQuoteCharacterSet() {\r\n        return quoteCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Parses the specified content.\r\n     *\r\n     * <p>\r\n     * See also the various static parse methods on {@link CSVParser}.\r\n     * </p>\r\n     *\r\n     * @param reader the input stream\r\n     * @return a parser over a stream of {@link CSVRecord}s.\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    public CSVParser parse(final Reader reader) throws IOException {\r\n        return new CSVParser(reader, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out the output.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     */\r\n    public CSVPrinter print(final Appendable out) throws IOException {\r\n        return new CSVPrinter(out, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\r\n        // The writer will be closed when close() is called.\r\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\r\n    }\r\n\r\n    /**\r\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated as needed. Useful when one wants to\r\n     * avoid creating CSVPrinters. Trims the value if {@link #getTrim()} is true.\r\n     *\r\n     * @param value     value to output.\r\n     * @param out       where to print the value.\r\n     * @param newRecord if this a new record.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\r\n        // null values are considered empty\r\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\r\n        CharSequence charSequence;\r\n        if (value == null) {\r\n            // https://issues.apache.org/jira/browse/CSV-203\r\n            if (null == nullString) {\r\n                charSequence = EMPTY;\r\n            } else if (QuoteMode.ALL == quoteMode) {\r\n                charSequence = quotedNullString;\r\n            } else {\r\n                charSequence = nullString;\r\n            }\r\n        } else if (value instanceof CharSequence) {\r\n            charSequence = (CharSequence) value;\r\n        } else if (value instanceof Reader) {\r\n            print((Reader) value, out, newRecord);\r\n            return;\r\n        } else {\r\n            charSequence = value.toString();\r\n        }\r\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\r\n        print(value, charSequence, out, newRecord);\r\n    }\r\n\r\n    private synchronized void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\r\n        final int offset = 0;\r\n        final int len = value.length();\r\n        if (!newRecord) {\r\n            out.append(getDelimiterString());\r\n        }\r\n        if (object == null) {\r\n            out.append(value);\r\n        } else if (isQuoteCharacterSet()) {\r\n            // the original object is needed so can check for Number\r\n            printWithQuotes(object, value, out, newRecord);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(value, out);\r\n        } else {\r\n            out.append(value, offset, len);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output, returns a {@code CSVPrinter} which the caller MUST close.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\r\n        return print(Files.newBufferedWriter(out, charset));\r\n    }\r\n\r\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\r\n        // Reader is never null\r\n        if (!newRecord) {\r\n            append(getDelimiterString(), out);\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            printWithQuotes(reader, out);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(reader, out);\r\n        } else if (out instanceof Writer) {\r\n            IOUtils.copyLarge(reader, (Writer) out);\r\n        } else {\r\n            IOUtils.copy(reader, out);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Prints to the {@link System#out}.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @return a printer to {@link System#out}.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    public CSVPrinter printer() throws IOException {\r\n        return new CSVPrinter(System.out, this);\r\n    }\r\n\r\n    /**\r\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\r\n     *\r\n     * @param appendable where to write\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void println(final Appendable appendable) throws IOException {\r\n        if (getTrailingDelimiter()) {\r\n            append(getDelimiterString(), appendable);\r\n        }\r\n        if (recordSeparator != null) {\r\n            append(recordSeparator, appendable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the record separator.\r\n     *\r\n     * <p>\r\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing\r\n     * the record, so there is no need to call {@link #println(Appendable)}.\r\n     * </p>\r\n     *\r\n     * @param appendable    where to write.\r\n     * @param values values to output.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException {\r\n        for (int i = 0; i < values.length; i++) {\r\n            print(values[i], appendable, i == 0);\r\n        }\r\n        println(appendable);\r\n    }\r\n\r\n    /*\r\n     * Note: Must only be called if escaping is enabled, otherwise will generate NPE.\r\n     */\r\n    private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int end = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n\r\n        while (pos < end) {\r\n            char c = charSeq.charAt(pos);\r\n            final boolean isDelimiterStart = isDelimiter(c, charSeq, pos, delim, delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    appendable.append(charSeq, start, pos);\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                appendable.append(escape);\r\n                appendable.append(c);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        pos++;\r\n                        c = charSeq.charAt(pos);\r\n                        appendable.append(escape);\r\n                        appendable.append(c);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            appendable.append(charSeq, start, pos);\r\n        }\r\n    }\r\n\r\n    private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n\r\n        @SuppressWarnings(\"resource\") // Temp reader on input reader.\r\n        final ExtendedBufferedReader bufferedReader = new ExtendedBufferedReader(reader);\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        int c;\r\n        while (-1 != (c = bufferedReader.read())) {\r\n            builder.append((char) c);\r\n            final boolean isDelimiterStart = isDelimiter((char) c, builder.toString() + new String(bufferedReader.lookAhead(delimLength - 1)), pos, delim,\r\n                    delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    append(builder.substring(start, pos), appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                append(escape, appendable);\r\n                append((char) c, appendable);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        c = bufferedReader.read();\r\n                        append(escape, appendable);\r\n                        append((char) c, appendable);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            append(builder.substring(start, pos), appendable);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\r\n     */\r\n    // the original object is needed so can check for Number\r\n    private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\r\n        boolean quote = false;\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int len = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char quoteChar = getQuoteCharacter().charValue();\r\n        // If escape char not specified, default to the quote char\r\n        // This avoids having to keep checking whether there is an escape character\r\n        // at the cost of checking against quote twice\r\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\r\n\r\n        QuoteMode quoteModePolicy = getQuoteMode();\r\n        if (quoteModePolicy == null) {\r\n            quoteModePolicy = QuoteMode.MINIMAL;\r\n        }\r\n        switch (quoteModePolicy) {\r\n        case ALL:\r\n        case ALL_NON_NULL:\r\n            quote = true;\r\n            break;\r\n        case NON_NUMERIC:\r\n            quote = !(object instanceof Number);\r\n            break;\r\n        case NONE:\r\n            // Use the existing escaping code\r\n            printWithEscapes(charSeq, out);\r\n            return;\r\n        case MINIMAL:\r\n            if (len <= 0) {\r\n                // always quote an empty token that is the first\r\n                // on the line, as it may be the only thing on the\r\n                // line. If it were not quoted in that case,\r\n                // an empty line has no tokens.\r\n                if (newRecord) {\r\n                    quote = true;\r\n                }\r\n            } else {\r\n                char c = charSeq.charAt(pos);\r\n\r\n                if (c <= COMMENT) {\r\n                    // Some other chars at the start of a value caused the parser to fail, so for now\r\n                    // encapsulate if we start in anything less than '#'. We are being conservative\r\n                    // by including the default comment char too.\r\n                    quote = true;\r\n                } else {\r\n                    while (pos < len) {\r\n                        c = charSeq.charAt(pos);\r\n                        if (c == LF || c == CR || c == quoteChar || c == escapeChar || isDelimiter(c, charSeq, pos, delim, delimLength)) {\r\n                            quote = true;\r\n                            break;\r\n                        }\r\n                        pos++;\r\n                    }\r\n\r\n                    if (!quote) {\r\n                        pos = len - 1;\r\n                        c = charSeq.charAt(pos);\r\n                        // Some other chars at the end caused the parser to fail, so for now\r\n                        // encapsulate if we end in anything less than ' '\r\n                        if (isTrimChar(c)) {\r\n                            quote = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!quote) {\r\n                // no encapsulation needed - write out the original value\r\n                out.append(charSeq, start, len);\r\n                return;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\r\n        }\r\n\r\n        if (!quote) {\r\n            // no encapsulation needed - write out the original value\r\n            out.append(charSeq, start, len);\r\n            return;\r\n        }\r\n\r\n        // we hit something that needed encapsulation\r\n        out.append(quoteChar);\r\n\r\n        // Pick up where we left off: pos should be positioned on the first character that caused\r\n        // the need for encapsulation.\r\n        while (pos < len) {\r\n            final char c = charSeq.charAt(pos);\r\n            if (c == quoteChar || c == escapeChar) {\r\n                // write out the chunk up until this point\r\n                out.append(charSeq, start, pos);\r\n                out.append(escapeChar); // now output the escape\r\n                start = pos; // and restart with the matched char\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write the last segment\r\n        out.append(charSeq, start, pos);\r\n        out.append(quoteChar);\r\n    }\r\n\r\n    /**\r\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\r\n     *\r\n     * @param reader What to print\r\n     * @param appendable Where to print it\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {\r\n\r\n        if (getQuoteMode() == QuoteMode.NONE) {\r\n            printWithEscapes(reader, appendable);\r\n            return;\r\n        }\r\n\r\n        int pos = 0;\r\n\r\n        final char quote = getQuoteCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        append(quote, appendable);\r\n\r\n        int c;\r\n        while (-1 != (c = reader.read())) {\r\n            builder.append((char) c);\r\n            if (c == quote) {\r\n                // write out segment up until this char\r\n                if (pos > 0) {\r\n                    append(builder.substring(0, pos), appendable);\r\n                    append(quote, appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n\r\n                append((char) c, appendable);\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > 0) {\r\n            append(builder.substring(0, pos), appendable);\r\n        }\r\n\r\n        append(quote, appendable);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        final StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\r\n        if (isEscapeCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\r\n        }\r\n        if (quoteMode != null) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\r\n        }\r\n        if (isCommentMarkerSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\r\n        }\r\n        if (isNullStringSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"NullString=<\").append(nullString).append('>');\r\n        }\r\n        if (recordSeparator != null) {\r\n            sb.append(' ');\r\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\r\n        }\r\n        if (getIgnoreEmptyLines()) {\r\n            sb.append(\" EmptyLines:ignored\");\r\n        }\r\n        if (getIgnoreSurroundingSpaces()) {\r\n            sb.append(\" SurroundingSpaces:ignored\");\r\n        }\r\n        if (getIgnoreHeaderCase()) {\r\n            sb.append(\" IgnoreHeaderCase:ignored\");\r\n        }\r\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\r\n        if (headerComments != null) {\r\n            sb.append(' ');\r\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\r\n        }\r\n        if (headers != null) {\r\n            sb.append(' ');\r\n            sb.append(\"Header:\").append(Arrays.toString(headers));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    String trim(final String value) {\r\n        return getTrim() ? value.trim() : value;\r\n    }\r\n\r\n    /**\r\n     * Verifies the validity and consistency of the attributes, and throws an {@link IllegalArgumentException} if necessary.\r\n     * <p>\r\n     * Because an instance can be used for both writing an parsing, not all conditions can be tested here. For example allowMissingColumnNames is only used for\r\n     * parsing, so it cannot be used here.\r\n     * </p>\r\n     *\r\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.\r\n     */\r\n    private void validate() throws IllegalArgumentException {\r\n        if (containsLineBreak(delimiter)) {\r\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n        }\r\n\r\n        if (quoteCharacter != null && contains(delimiter, quoteCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && contains(delimiter, escapeCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\r\n        }\r\n\r\n        if (commentMarker != null && contains(delimiter, commentMarker.charValue())) {\r\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\r\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\r\n        }\r\n\r\n        // Validate headers\r\n        if (headers != null && duplicateHeaderMode != DuplicateHeaderMode.ALLOW_ALL) {\r\n            final Set<String> dupCheckSet = new HashSet<>(headers.length);\r\n            final boolean emptyDuplicatesAllowed = duplicateHeaderMode == DuplicateHeaderMode.ALLOW_EMPTY;\r\n            for (final String header : headers) {\r\n                final boolean blank = isBlank(header);\r\n                // Sanitise all empty headers to the empty string \"\" when checking duplicates\r\n                final boolean containsHeader = !dupCheckSet.add(blank ? \"\" : header);\r\n                if (containsHeader && !(blank && emptyDuplicatesAllowed)) {\r\n                    throw new IllegalArgumentException(\r\n                        String.format(\r\n                            \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\r\n                            header, Arrays.toString(headers)));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} that allows duplicate header names.\r\n     *\r\n     * @return a new {@code CSVFormat} that allows duplicate header names\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean) Builder#setAllowDuplicateHeaderNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames() {\r\n        return builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     *\r\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n        final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\r\n        return builder().setDuplicateHeaderMode(mode).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @see Builder#setAllowMissingColumnNames(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames() {\r\n        return builder().setAllowMissingColumnNames(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\r\n     *\r\n     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause\r\n     *                                an {@link IllegalArgumentException} to be thrown.\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n        return builder().setAllowMissingColumnNames(allowMissingColumnNames).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to flush on close.\r\n     *\r\n     * @param autoFlush whether to flush on close.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setAutoFlush(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\r\n        return builder().setAutoFlush(autoFlush).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final char commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final Character commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the delimiter of the format set to the specified character.\r\n     *\r\n     * @param delimiter the delimiter character\r\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setDelimiter(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withDelimiter(final char delimiter) {\r\n        return builder().setDelimiter(delimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final char escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final Character escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} using the first record as header.\r\n     *\r\n     * <p>\r\n     * Calling this method is equivalent to calling:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\r\n     * </pre>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but using the first record as header.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(String...) Builder#setHeader()}.{@link Builder#setSkipHeaderRecord(boolean) setSkipHeaderRecord(true)}.\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withFirstRecordAsHeader() {\r\n        // @formatter:off\r\n        return builder()\r\n                .setHeader()\r\n                .setSkipHeaderRecord(true)\r\n                .build();\r\n        // @formatter:on\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format defined by the enum class.\r\n     *\r\n     * <p>\r\n     * Example:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * public enum Header {\r\n     *     Name, Email, Phone\r\n     * }\r\n     *\r\n     * CSVFormat format = aformat.withHeader(Header.class);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setHeader(String...)\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(Class)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\r\n        return builder().setHeader(headerEnum).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(resultSet);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSet)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\r\n        return builder().setHeader(resultSet).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(metaData);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSetMetaData)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n        return builder().setHeader(resultSetMetaData).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file\r\n     * with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @deprecated Use {@link Builder#setHeader(String...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final String... header) {\r\n        return builder().setHeader(header).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.\r\n     * This setting is ignored by the parser.\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n     * </pre>\r\n     *\r\n     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeaderComments(Object...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeaderComments(final Object... headerComments) {\r\n        return builder().setHeaderComments(headerComments).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @see Builder#setIgnoreEmptyLines(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines() {\r\n        return builder().setIgnoreEmptyLines(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty\r\n     *                         lines to empty records.\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n        return builder().setIgnoreEmptyLines(ignoreEmptyLines).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that will ignore case header name.\r\n     * @see Builder#setIgnoreHeaderCase(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean) Builder#setIgnoreHeaderCase(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase() {\r\n        return builder().setIgnoreHeaderCase(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether header names should be accessed ignoring case.\r\n     *\r\n     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n        return builder().setIgnoreHeaderCase(ignoreHeaderCase).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\r\n     * @see Builder#setIgnoreSurroundingSpaces(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean) Builder#setIgnoreSurroundingSpaces(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces() {\r\n        return builder().setIgnoreSurroundingSpaces(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n        return builder().setIgnoreSurroundingSpaces(ignoreSurroundingSpaces).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with conversions to and from null for strings on input and output.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\r\n     * @deprecated Use {@link Builder#setNullString(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withNullString(final String nullString) {\r\n        return builder().setNullString(nullString).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final char quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character, use {@code null} to disable.\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final Character quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\r\n     *\r\n     * @param quoteMode the quote policy to use for output.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\r\n     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuoteMode(final QuoteMode quoteMode) {\r\n        return builder().setQuoteMode(quoteMode).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified character.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @deprecated Use {@link Builder#setRecordSeparator(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified String.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with skipping the header record set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean) Builder#setSkipHeaderRecord(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord() {\r\n        return builder().setSkipHeaderRecord(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to skip the header record.\r\n     *\r\n     * @param skipHeaderRecord whether to skip the header record.\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setHeader(String...)\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n        return builder().setSkipHeaderRecord(skipHeaderRecord).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows\r\n     * and LF on Linux.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSystemRecordSeparator() {\r\n        return builder().setRecordSeparator(System.lineSeparator()).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} to add a trailing delimiter.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean) Builder#setTrailingDelimiter(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter() {\r\n        return builder().setTrailingDelimiter(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to add a trailing delimiter.\r\n     *\r\n     * @param trailingDelimiter whether to add a trailing delimiter.\r\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\r\n        return builder().setTrailingDelimiter(trailingDelimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean) Builder#setTrim(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim() {\r\n        return builder().setTrim(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @param trim whether to trim leading and trailing blanks.\r\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim(final boolean trim) {\r\n        return builder().setTrim(trim).build();\r\n    }\r\n}\r",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 81b6f1936..275c0dae0 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1383,12 +1383,12 @@ private CSVFormat(final Builder builder) {\n      * @param nullString              the line separator to use for output.\r\n      * @param headerComments          the comments to be printed by the Printer before the actual CSV data.\r\n      * @param header                  the header\r\n-     * @param skipHeaderRecord        TODO Doc me.\r\n-     * @param allowMissingColumnNames TODO Doc me.\r\n-     * @param ignoreHeaderCase        TODO Doc me.\r\n-     * @param trim                    TODO Doc me.\r\n-     * @param trailingDelimiter       TODO Doc me.\r\n-     * @param autoFlush               TODO Doc me.\r\n+     * @param skipHeaderRecord        if {@code true} the header row will be skipped\r\n+     * @param allowMissingColumnNames if {@code true} the missing column names are allowed when parsing the header line\r\n+     * @param ignoreHeaderCase        if {@code true} header names will be accessed ignoring case when parsing input\r\n+     * @param trim                    if {@code true} next record value will be trimmed\r\n+     * @param trailingDelimiter       if {@code true} the trailing delimiter wil be added before record separator (if set)\r\n+     * @param autoFlush               if {@code true} the underlying stream will be flushed before closing\r\n      * @param duplicateHeaderMode     the behavior when handling duplicate headers\r\n      * @throws IllegalArgumentException if the delimiter is a line break character.\r\n      */\r\n@@ -1601,7 +1601,7 @@ public boolean getIgnoreEmptyLines() {\n     /**\r\n      * Gets whether header names will be accessed ignoring case when parsing input.\r\n      *\r\n-     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\r\n+     * @return {@code true} if header names cases are ignored, {@code false} if they are case-sensitive.\r\n      * @since 1.3\r\n      */\r\n     public boolean getIgnoreHeaderCase() {\r\n@@ -1797,7 +1797,7 @@ public CSVPrinter print(final Appendable out) throws IOException {\n     }\r\n \r\n     /**\r\n-     * Prints to the specified output.\r\n+     * Prints to the specified {@code File} with given {@code Charset}.\r\n      *\r\n      * <p>\r\n      * See also {@link CSVPrinter}.\r\n@@ -1869,7 +1869,8 @@ private synchronized void print(final Object object, final CharSequence value, f\n     }\r\n \r\n     /**\r\n-     * Prints to the specified output, returns a {@code CSVPrinter} which the caller MUST close.\r\n+     * Prints to the specified {@code Path} with given {@code Charset},\r\n+     * returns a {@code CSVPrinter} which the caller MUST close.\r\n      *\r\n      * <p>\r\n      * See also {@link CSVPrinter}.\r\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertAll;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVRecordTest2 {\n\n    @Test\n    public void testDuplicateHeaderGet() throws IOException {\n        final String csv = \"A,A,B,B\\n1,2,5,6\\n\";\n        final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader().build();\n        try (final CSVParser parser = CSVParser.parse(csv, format)) {\n            final CSVRecord record = parser.nextRecord();\n            assertAll(\"Test that it gets the last instance of a column when there are duplicate headings\",\n                () -> assertEquals(\"2\", record.get(\"A\")),\n                () -> assertEquals(\"6\", record.get(\"B\"))\n            );\n        }\n    }\n\n    @Test\n    public void testDuplicateHeaderToMap() throws IOException {\n        final String csv = \"A,A,B,B\\n1,2,5,6\\n\";\n        final CSVFormat format = CSVFormat.DEFAULT.builder().setHeader().build();\n        try (final CSVParser parser = CSVParser.parse(csv, format)) {\n            final CSVRecord record = parser.nextRecord();\n            final Map<String, String> map = record.toMap();\n            assertAll(\"Test that it gets the last instance of a column when there are duplicate headings\",\n                () -> assertEquals(\"2\", map.get(\"A\")),\n                () -> assertEquals(\"6\", map.get(\"B\"))\n            );\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * <p>\n * Note: Support for {@link Serializable} is scheduled to be removed in version 2.0.\n * In version 1.8 the mapping between the column header and the column index was\n * removed from the serialised state. The class maintains serialization compatibility\n * with versions pre-1.8 for the record values; these must be accessed by index\n * following deserialization. There will be loss of any functionally linked to the header\n * mapping when transferring serialised forms pre-1.8 to 1.8 and vice versa.\n * </p>\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final long serialVersionUID = 1L;\n\n    private final long characterPosition;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    /** The parser that originates this record. This is not serialized. */\n    private final transient CSVParser parser;\n\n    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber,\n            final long characterPosition) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;\n        this.parser = parser;\n        this.comment = comment;\n        this.characterPosition = characterPosition;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e == null ? null : e.name());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name. If multiple instances of the header name exists, only the last occurence is returned.\n     *\n     * <p>\n     * Note: This requires a field mapping obtained from the original parser.\n     * A check using {@link #isMapped(String)} should be used to determine if a\n     * mapping exists from the provided {@code name} to a field index. In this case an\n     * exception will only be thrown if the record does not contain a field corresponding\n     * to the mapping, that is the record length is not consistent with the mapping size.\n     * </p>\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isMapped(String)\n     * @see #isConsistent()\n     * @see #getParser()\n     * @see CSVFormat.Builder#setNullString(String)\n     */\n    public String get(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        if (headerMap == null) {\n            throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = headerMap.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                headerMap.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream.\n     */\n    public long getCharacterPosition() {\n        return characterPosition;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    private Map<String, Integer> getHeaderMapRaw() {\n        return parser == null ? null : parser.getHeaderMapRaw();\n    }\n\n    /**\n     * Returns the parser.\n     *\n     * <p>\n     * Note: The parser is not part of the serialized state of the record. A null check\n     * should be used when the record may have originated from a serialized form.\n     * </p>\n     *\n     * @return the parser.\n     * @since 1.7\n     */\n    public CSVParser getParser() {\n        return parser;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3\n     */\n    public boolean hasComment() {\n        return comment != null;\n    }\n\n    /**\n     * Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap == null || headerMap.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap != null && headerMap.containsKey(name);\n    }\n\n    /**\n     * Checks whether a column with given index has a value.\n     *\n     * @param index\n     *         a column index (0-based)\n     * @return whether a column with given index has a value\n     */\n    public boolean isSet(final int index) {\n        return 0 <= index && index < values.length;\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    @Override\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param <M> the map type\n     * @param map The Map to populate.\n     * @return the given map.\n     * @since 1.9.0\n     */\n    public <M extends Map<String, String>> M putIn(final M map) {\n        if (getHeaderMapRaw() == null) {\n            return map;\n        }\n        getHeaderMapRaw().forEach((key, value) -> {\n            if (value < values.length) {\n                map.put(key, values[value]);\n            }\n        });\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Returns a sequential ordered stream whose elements are the values.\n     *\n     * @return the new stream.\n     * @since 1.9.0\n     */\n    public Stream<String> stream() {\n        return Stream.of(values);\n    }\n\n    /**\n     * Converts the values to a new List.\n     * <p>\n     * Editing the list does not update this instance.\n     * </p>\n     *\n     * @return a new List\n     * @since 1.9.0\n     */\n    public List<String> toList() {\n        return stream().collect(Collectors.toList());\n    }\n\n    /**\n     * Copies this record into a new Map of header name to record value. If multiple instances of a header name exists,\n     * only the last occurence is mapped.\n     *\n     * <p>\n     * Editing the map does not update this instance.\n     * </p>\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new LinkedHashMap<>(values.length));\n    }\n\n    /**\n     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.\n     */\n    @Override\n    public String toString() {\n        return \"CSVRecord [comment='\" + comment + \"', recordNumber=\" + recordNumber + \", values=\" +\n            Arrays.toString(values) + \"]\";\n    }\n\n    /**\n     * Gets the values for this record. This is not a copy.\n     *\n     * @return the values for this record.\n     * @since 1.10.0\n     */\n    public String[] values() {\n        return values;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex 0e70ad751..71d5f9534 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -88,7 +88,7 @@ public String get(final int i) {\n     }\n \n     /**\n-     * Returns a value by name. If multiple instances of the header name exists, only the last occurence is returned.\n+     * Returns a value by name. If multiple instances of the header name exists, only the last occurrence is returned.\n      *\n      * <p>\n      * Note: This requires a field mapping obtained from the original parser.\n@@ -312,7 +312,7 @@ public List<String> toList() {\n \n     /**\n      * Copies this record into a new Map of header name to record value. If multiple instances of a header name exists,\n-     * only the last occurence is mapped.\n+     * only the last occurrence is mapped.\n      *\n      * <p>\n      * Editing the map does not update this instance.\n"
      }
    ]
  },
  {
    "pr_number": 309,
    "title": "Document duplicate header behavior",
    "state": "closed",
    "created_at": "2023-02-23T00:02:23Z",
    "merge_commit_sha": "bc61b750d85e9ac1b4a45e210fad81498b7b8959",
    "base_sha": "420cd15cac9be508930570cb48eee63e25ad5d78",
    "head_sha": "7f335011ba5392ddd09a878320010017c26a47ca",
    "user_login": "SethFalco",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.StringReader;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVRecordTest2 {\n\n    private CSVRecord recordWithDuplicateHeaders;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        final String rowData = \"A,B,C\";\n        final String headerData = \"first,second,first\";\n        try (final CSVParser parser = CSVFormat.DEFAULT.withHeader(headerData.split(\",\")).parse(new StringReader(rowData))) {\n            recordWithDuplicateHeaders = parser.iterator().next();\n        }\n    }\n\n    @Test\n    public void testGetStringWithDuplicateHeaders() {\n        // The last occurrence of the header \"first\" should be returned\n        assertEquals(\"C\", recordWithDuplicateHeaders.get(\"first\"));\n    }\n\n    @Test\n    public void testToMapWithDuplicateHeaders() {\n        // The map should contain the last occurrence of the header \"first\"\n        final Map<String, String> map = recordWithDuplicateHeaders.toMap();\n        assertEquals(\"C\", map.get(\"first\"));\n        assertEquals(\"B\", map.get(\"second\"));\n    }\n\n    @Test\n    public void testGetStringWithInvalidHeader() {\n        // Test with a header that does not exist\n        assertThrows(IllegalArgumentException.class, () -> recordWithDuplicateHeaders.get(\"nonexistent\"));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * <p>\n * Note: Support for {@link Serializable} is scheduled to be removed in version 2.0.\n * In version 1.8 the mapping between the column header and the column index was\n * removed from the serialised state. The class maintains serialization compatibility\n * with versions pre-1.8 for the record values; these must be accessed by index\n * following deserialization. There will be loss of any functionally linked to the header\n * mapping when transferring serialised forms pre-1.8 to 1.8 and vice versa.\n * </p>\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final long serialVersionUID = 1L;\n\n    private final long characterPosition;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    /** The parser that originates this record. This is not serialized. */\n    private final transient CSVParser parser;\n\n    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber,\n            final long characterPosition) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;\n        this.parser = parser;\n        this.comment = comment;\n        this.characterPosition = characterPosition;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e == null ? null : e.name());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * <p>\n     * Note: This requires a field mapping obtained from the original parser.\n     * A check using {@link #isMapped(String)} should be used to determine if a\n     * mapping exists from the provided {@code name} to a field index. In this case an\n     * exception will only be thrown if the record does not contain a field corresponding\n     * to the mapping, that is the record length is not consistent with the mapping size.\n     * </p>\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isMapped(String)\n     * @see #isConsistent()\n     * @see #getParser()\n     * @see CSVFormat.Builder#setNullString(String)\n     */\n    public String get(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        if (headerMap == null) {\n            throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = headerMap.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                headerMap.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream.\n     */\n    public long getCharacterPosition() {\n        return characterPosition;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    private Map<String, Integer> getHeaderMapRaw() {\n        return parser == null ? null : parser.getHeaderMapRaw();\n    }\n\n    /**\n     * Returns the parser.\n     *\n     * <p>\n     * Note: The parser is not part of the serialized state of the record. A null check\n     * should be used when the record may have originated from a serialized form.\n     * </p>\n     *\n     * @return the parser.\n     * @since 1.7\n     */\n    public CSVParser getParser() {\n        return parser;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3\n     */\n    public boolean hasComment() {\n        return comment != null;\n    }\n\n    /**\n     * Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap == null || headerMap.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap != null && headerMap.containsKey(name);\n    }\n\n    /**\n     * Checks whether a column with given index has a value.\n     *\n     * @param index\n     *         a column index (0-based)\n     * @return whether a column with given index has a value\n     */\n    public boolean isSet(final int index) {\n        return 0 <= index && index < values.length;\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    @Override\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param <M> the map type\n     * @param map The Map to populate.\n     * @return the given map.\n     * @since 1.9.0\n     */\n    public <M extends Map<String, String>> M putIn(final M map) {\n        if (getHeaderMapRaw() == null) {\n            return map;\n        }\n        getHeaderMapRaw().forEach((key, value) -> {\n            if (value < values.length) {\n                map.put(key, values[value]);\n            }\n        });\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Returns a sequential ordered stream whose elements are the values.\n     *\n     * @return the new stream.\n     * @since 1.9.0\n     */\n    public Stream<String> stream() {\n        return Stream.of(values);\n    }\n\n    /**\n     * Converts the values to a new List.\n     * <p>\n     * Editing the list does not update this instance.\n     * </p>\n     *\n     * @return a new List\n     * @since 1.9.0\n     */\n    public List<String> toList() {\n        return stream().collect(Collectors.toList());\n    }\n\n    /**\n     * Copies this record into a new Map of header name to record value.\n     * <p>\n     * Editing the map does not update this instance.\n     * </p>\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new LinkedHashMap<>(values.length));\n    }\n\n    /**\n     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.\n     */\n    @Override\n    public String toString() {\n        return \"CSVRecord [comment='\" + comment + \"', recordNumber=\" + recordNumber + \", values=\" +\n            Arrays.toString(values) + \"]\";\n    }\n\n    /**\n     * Gets the values for this record. This is not a copy.\n     *\n     * @return the values for this record.\n     * @since 1.10.0\n     */\n    public String[] values() {\n        return values;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex 5524d9e84..0e70ad751 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -88,7 +88,7 @@ public String get(final int i) {\n     }\n \n     /**\n-     * Returns a value by name.\n+     * Returns a value by name. If multiple instances of the header name exists, only the last occurence is returned.\n      *\n      * <p>\n      * Note: This requires a field mapping obtained from the original parser.\n@@ -311,7 +311,9 @@ public List<String> toList() {\n     }\n \n     /**\n-     * Copies this record into a new Map of header name to record value.\n+     * Copies this record into a new Map of header name to record value. If multiple instances of a header name exists,\n+     * only the last occurence is mapped.\n+     *\n      * <p>\n      * Editing the map does not update this instance.\n      * </p>\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVRecordTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 295,
    "title": "[CSV-141] Add support for trailing text after the closing quote, and EOF without a final closing quote, for Excel compatibility",
    "state": "closed",
    "created_at": "2022-12-27T03:17:09Z",
    "merge_commit_sha": "b1bdb99c427716381eee074eba0450e5f9189cca",
    "base_sha": "534916e25e9f4a519833ca7ecdfcf57d73ca3abc",
    "head_sha": "d0ea9e3a000aa358a4960df6cfc8abd735a3d165",
    "user_login": "DamjanJovanovic",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testSetAllowEofWithoutClosingQuote() {\n        CSVFormat format = CSVFormat.DEFAULT.builder().setAllowEofWithoutClosingQuote(true).build();\n        assertTrue(format.getAllowEofWithoutClosingQuote());\n\n        format = CSVFormat.DEFAULT.builder().setAllowEofWithoutClosingQuote(false).build();\n        assertFalse(format.getAllowEofWithoutClosingQuote());\n    }\n\n    @Test\n    public void testSetAllowTrailingText() {\n        CSVFormat format = CSVFormat.DEFAULT.builder().setAllowTrailingText(true).build();\n        assertTrue(format.getAllowTrailingText());\n\n        format = CSVFormat.DEFAULT.builder().setAllowTrailingText(false).build();\n        assertFalse(format.getAllowTrailingText());\n    }\n\n    @Test\n    public void testEqualsAllowEofWithoutClosingQuote() {\n        CSVFormat right = CSVFormat.DEFAULT.builder().setAllowEofWithoutClosingQuote(true).build();\n        CSVFormat left = right.builder().setAllowEofWithoutClosingQuote(false).build();\n        assertNotEquals(right, left);\n    }\n\n    @Test\n    public void testEqualsAllowTrailingText() {\n        CSVFormat right = CSVFormat.DEFAULT.builder().setAllowTrailingText(true).build();\n        CSVFormat left = right.builder().setAllowTrailingText(false).build();\n        assertNotEquals(right, left);\n    }\n\n    @Test\n    public void testHashCodeWithAllowEofWithoutClosingQuote() {\n        CSVFormat format = CSVFormat.DEFAULT.builder().setAllowEofWithoutClosingQuote(true).build();\n        int hashCode1 = format.hashCode();\n\n        format = format.builder().setAllowEofWithoutClosingQuote(false).build();\n        int hashCode2 = format.hashCode();\n\n        assertNotEquals(hashCode1, hashCode2);\n    }\n\n    @Test\n    public void testHashCodeWithAllowTrailingText() {\n        CSVFormat format = CSVFormat.DEFAULT.builder().setAllowTrailingText(true).build();\n        int hashCode1 = format.hashCode();\n\n        format = format.builder().setAllowTrailingText(false).build();\n        int hashCode2 = format.hashCode();\n\n        assertNotEquals(hashCode1, hashCode2);\n    }\n\n    @Test\n    public void testToStringWithAllowEofWithoutClosingQuote() {\n        CSVFormat format = CSVFormat.DEFAULT.builder().setAllowEofWithoutClosingQuote(true).build();\n        String toString1 = format.toString();\n\n        format = format.builder().setAllowEofWithoutClosingQuote(false).build();\n        String toString2 = format.toString();\n\n        assertNotEquals(toString1, toString2);\n    }\n\n    @Test\n    public void testToStringWithAllowTrailingText() {\n        CSVFormat format = CSVFormat.DEFAULT.builder().setAllowTrailingText(true).build();\n        String toString1 = format.toString();\n\n        format = format.builder().setAllowTrailingText(false).build();\n        String toString2 = format.toString();\n\n        assertNotEquals(toString1, toString2);\n    }\n}",
        "file_content": "/*\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n * this work for additional information regarding copyright ownership.\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n * (the \"License\"); you may not use this file except in compliance with\r\n * the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage org.apache.commons.csv;\r\n\r\nimport static org.apache.commons.csv.Constants.BACKSLASH;\r\nimport static org.apache.commons.csv.Constants.COMMA;\r\nimport static org.apache.commons.csv.Constants.COMMENT;\r\nimport static org.apache.commons.csv.Constants.CR;\r\nimport static org.apache.commons.csv.Constants.CRLF;\r\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\r\nimport static org.apache.commons.csv.Constants.EMPTY;\r\nimport static org.apache.commons.csv.Constants.LF;\r\nimport static org.apache.commons.csv.Constants.PIPE;\r\nimport static org.apache.commons.csv.Constants.SP;\r\nimport static org.apache.commons.csv.Constants.TAB;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Serializable;\r\nimport java.io.StringWriter;\r\nimport java.io.Writer;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.Arrays;\r\nimport java.util.HashSet;\r\nimport java.util.Objects;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Specifies the format of a CSV file for parsing and writing.\r\n *\r\n * <h2>Using predefined formats</h2>\r\n *\r\n * <p>\r\n * You can use one of the predefined formats:\r\n * </p>\r\n *\r\n * <ul>\r\n * <li>{@link #DEFAULT}</li>\r\n * <li>{@link #EXCEL}</li>\r\n * <li>{@link #INFORMIX_UNLOAD}</li>\r\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\r\n * <li>{@link #MYSQL}</li>\r\n * <li>{@link #RFC4180}</li>\r\n * <li>{@link #ORACLE}</li>\r\n * <li>{@link #POSTGRESQL_CSV}</li>\r\n * <li>{@link #POSTGRESQL_TEXT}</li>\r\n * <li>{@link #TDF}</li>\r\n * </ul>\r\n *\r\n * <p>\r\n * For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\r\n * </pre>\r\n *\r\n * <p>\r\n * The {@link CSVParser} provides static methods to parse other input types, for example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\r\n * </pre>\r\n *\r\n * <h2>Defining formats</h2>\r\n *\r\n * <p>\r\n * You can extend a format by calling the {@code set} methods. For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\r\n * </pre>\r\n *\r\n * <h2>Defining column names</h2>\r\n *\r\n * <p>\r\n * To define the column names you want to use to access records, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * Calling {@link Builder#setHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and assumes that your CSV source does not\r\n * contain a first record that also defines column names.\r\n *\r\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\r\n * {@link Builder#setSkipHeaderRecord(boolean)} with {@code true}.\r\n * </p>\r\n *\r\n * <h2>Parsing</h2>\r\n *\r\n * <p>\r\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * Reader in = ...;\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\r\n * </pre>\r\n *\r\n * <p>\r\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\r\n * </p>\r\n *\r\n * <h2>Referencing columns safely</h2>\r\n *\r\n * <p>\r\n * If your source contains a header record, you can simplify your code and safely reference columns, by using {@link Builder#setHeader(String...)} with no\r\n * arguments:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader();\r\n * </pre>\r\n *\r\n * <p>\r\n * This causes the parser to read the first record and use its values as column names.\r\n *\r\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\r\n * </p>\r\n *\r\n * <pre>\r\n * String value = record.get(&quot;Col1&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * This makes your code impervious to changes in column order in the CSV file.\r\n * </p>\r\n *\r\n * <h2>Serialization</h2>\r\n * <p>\r\n *   This class implements the {@link Serializable} interface with the following caveats:\r\n * </p>\r\n * <ul>\r\n *   <li>This class will no longer implement Serializable in 2.0.</li>\r\n *   <li>Serialization is not supported from one version to the next.</li>\r\n * </ul>\r\n * <p>\r\n *   The {@code serialVersionUID} values are:\r\n * </p>\r\n * <ul>\r\n *   <li>Version 1.10.0: {@code 2L}</li>\r\n *   <li>Version 1.9.0 through 1.0: {@code 1L}</li>\r\n * </ul>\r\n *\r\n * <h2>Notes</h2>\r\n * <p>\r\n * This class is immutable.\r\n * </p>\r\n * <p>\r\n * Not all settings are used for both parsing and writing.\r\n * </p>\r\n */\r\npublic final class CSVFormat implements Serializable {\r\n\r\n    /**\r\n     * Builds CSVFormat instances.\r\n     *\r\n     * @since 1.9.0\r\n     */\r\n    public static class Builder {\r\n\r\n        /**\r\n         * Creates a new default builder.\r\n         *\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create() {\r\n            return new Builder(CSVFormat.DEFAULT);\r\n        }\r\n\r\n        /**\r\n         * Creates a new builder for the given format.\r\n         *\r\n         * @param csvFormat the source format.\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create(final CSVFormat csvFormat) {\r\n            return new Builder(csvFormat);\r\n        }\r\n\r\n        private boolean allowMissingColumnNames;\r\n\r\n        private boolean autoFlush;\r\n\r\n        private Character commentMarker;\r\n\r\n        private String delimiter;\r\n\r\n        private DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n        private Character escapeCharacter;\r\n\r\n        private String[] headerComments;\r\n\r\n        private String[] headers;\r\n\r\n        private boolean ignoreEmptyLines;\r\n\r\n        private boolean ignoreHeaderCase;\r\n\r\n        private boolean ignoreSurroundingSpaces;\r\n\r\n        private String nullString;\r\n\r\n        private Character quoteCharacter;\r\n\r\n        private String quotedNullString;\r\n\r\n        private QuoteMode quoteMode;\r\n\r\n        private String recordSeparator;\r\n\r\n        private boolean skipHeaderRecord;\r\n\r\n        private boolean trailingDelimiter;\r\n\r\n        private boolean trim;\r\n\r\n        private Builder(final CSVFormat csvFormat) {\r\n            this.delimiter = csvFormat.delimiter;\r\n            this.quoteCharacter = csvFormat.quoteCharacter;\r\n            this.quoteMode = csvFormat.quoteMode;\r\n            this.commentMarker = csvFormat.commentMarker;\r\n            this.escapeCharacter = csvFormat.escapeCharacter;\r\n            this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;\r\n            this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;\r\n            this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;\r\n            this.recordSeparator = csvFormat.recordSeparator;\r\n            this.nullString = csvFormat.nullString;\r\n            this.headerComments = csvFormat.headerComments;\r\n            this.headers = csvFormat.headers;\r\n            this.skipHeaderRecord = csvFormat.skipHeaderRecord;\r\n            this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;\r\n            this.trailingDelimiter = csvFormat.trailingDelimiter;\r\n            this.trim = csvFormat.trim;\r\n            this.autoFlush = csvFormat.autoFlush;\r\n            this.quotedNullString = csvFormat.quotedNullString;\r\n            this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;\r\n        }\r\n\r\n        /**\r\n         * Builds a new CSVFormat instance.\r\n         *\r\n         * @return a new CSVFormat instance.\r\n         */\r\n        public CSVFormat build() {\r\n            return new CSVFormat(this);\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior, true to allow, false to disallow.\r\n         *\r\n         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n         * @return This instance.\r\n         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.\r\n         */\r\n        @Deprecated\r\n        public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n            setDuplicateHeaderMode(allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\r\n         * {@link IllegalArgumentException} to be thrown.\r\n         *\r\n         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\r\n         *                                cause an {@link IllegalArgumentException} to be thrown.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n            this.allowMissingColumnNames = allowMissingColumnNames;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to flush on close.\r\n         *\r\n         * @param autoFlush whether to flush on close.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAutoFlush(final boolean autoFlush) {\r\n            this.autoFlush = autoFlush;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final char commentMarker) {\r\n            setCommentMarker(Character.valueOf(commentMarker));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final Character commentMarker) {\r\n            if (isLineBreak(commentMarker)) {\r\n                throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\r\n            }\r\n            this.commentMarker = commentMarker;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final char delimiter) {\r\n            return setDelimiter(String.valueOf(delimiter));\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final String delimiter) {\r\n            if (containsLineBreak(delimiter)) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n            }\r\n            if (delimiter.isEmpty()) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be empty\");\r\n            }\r\n            this.delimiter = delimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior.\r\n         *\r\n         * @param duplicateHeaderMode the duplicate header names behavior\r\n         * @return This instance.\r\n         * @since 1.10.0\r\n         */\r\n        public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {\r\n          this.duplicateHeaderMode = Objects.requireNonNull(duplicateHeaderMode, \"duplicateHeaderMode\");\r\n          return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final char escapeCharacter) {\r\n            setEscape(Character.valueOf(escapeCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final Character escapeCharacter) {\r\n            if (isLineBreak(escapeCharacter)) {\r\n                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\r\n            }\r\n            this.escapeCharacter = escapeCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header defined by the given {@link Enum} class.\r\n         *\r\n         * <p>\r\n         * Example:\r\n         * </p>\r\n         *\r\n         * <pre>\r\n         * public enum HeaderEnum {\r\n         *     Name, Email, Phone\r\n         * }\r\n         *\r\n         * Builder builder = builder.setHeader(HeaderEnum.class);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {\r\n            String[] header = null;\r\n            if (headerEnum != null) {\r\n                final Enum<?>[] enumValues = headerEnum.getEnumConstants();\r\n                header = new String[enumValues.length];\r\n                Arrays.setAll(header, i -> enumValues[i].name());\r\n            }\r\n            return setHeader(header);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSet);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSet resultSet) throws SQLException {\r\n            return setHeader(resultSet != null ? resultSet.getMetaData() : null);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSetMetaData);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n            String[] labels = null;\r\n            if (resultSetMetaData != null) {\r\n                final int columnCount = resultSetMetaData.getColumnCount();\r\n                labels = new String[columnCount];\r\n                for (int i = 0; i < columnCount; i++) {\r\n                    labels[i] = resultSetMetaData.getColumnLabel(i + 1);\r\n                }\r\n            }\r\n            return setHeader(labels);\r\n        }\r\n\r\n        /**\r\n         * Sets the header to the given values. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final String... header) {\r\n            this.headers = CSVFormat.clone(header);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final Object... headerComments) {\r\n            this.headerComments = CSVFormat.clone(toStringArray(headerComments));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * Builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final String... headerComments) {\r\n            this.headerComments = CSVFormat.clone(headerComments);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty\r\n         * records.\r\n         *\r\n         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate\r\n         *                         empty lines to empty records.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n            this.ignoreEmptyLines = ignoreEmptyLines;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         *\r\n         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n            this.ignoreHeaderCase = ignoreHeaderCase;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         *\r\n         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         *\r\n         * <ul>\r\n         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n         * </ul>\r\n         *\r\n         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         * @return This instance.\r\n         */\r\n        public Builder setNullString(final String nullString) {\r\n            this.nullString = nullString;\r\n            this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character.\r\n         *\r\n         * @param quoteCharacter the quote character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final char quoteCharacter) {\r\n            setQuote(Character.valueOf(quoteCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character, use {@code null} to disable.\r\n         *\r\n         * @param quoteCharacter the quote character, use {@code null} to disable.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final Character quoteCharacter) {\r\n            if (isLineBreak(quoteCharacter)) {\r\n                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\r\n            }\r\n            this.quoteCharacter = quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote policy to use for output.\r\n         *\r\n         * @param quoteMode the quote policy to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuoteMode(final QuoteMode quoteMode) {\r\n            this.quoteMode = quoteMode;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final char recordSeparator) {\r\n            this.recordSeparator = String.valueOf(recordSeparator);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final String recordSeparator) {\r\n            this.recordSeparator = recordSeparator;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to skip the header record.\r\n         *\r\n         * @param skipHeaderRecord whether to skip the header record.\r\n         * @return This instance.\r\n         */\r\n        public Builder setSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n            this.skipHeaderRecord = skipHeaderRecord;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to add a trailing delimiter.\r\n         *\r\n         * @param trailingDelimiter whether to add a trailing delimiter.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrailingDelimiter(final boolean trailingDelimiter) {\r\n            this.trailingDelimiter = trailingDelimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to trim leading and trailing blanks.\r\n         *\r\n         * @param trim whether to trim leading and trailing blanks.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrim(final boolean trim) {\r\n            this.trim = trim;\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Predefines formats.\r\n     *\r\n     * @since 1.2\r\n     */\r\n    public enum Predefined {\r\n\r\n        /**\r\n         * @see CSVFormat#DEFAULT\r\n         */\r\n        Default(CSVFormat.DEFAULT),\r\n\r\n        /**\r\n         * @see CSVFormat#EXCEL\r\n         */\r\n        Excel(CSVFormat.EXCEL),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD\r\n         * @since 1.3\r\n         */\r\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\r\n         * @since 1.3\r\n         */\r\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_CSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_TSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MYSQL\r\n         */\r\n        MySQL(CSVFormat.MYSQL),\r\n\r\n        /**\r\n         * @see CSVFormat#ORACLE\r\n         */\r\n        Oracle(CSVFormat.ORACLE),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         * @since 1.5\r\n         */\r\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         */\r\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\r\n\r\n        /**\r\n         * @see CSVFormat#RFC4180\r\n         */\r\n        RFC4180(CSVFormat.RFC4180),\r\n\r\n        /**\r\n         * @see CSVFormat#TDF\r\n         */\r\n        TDF(CSVFormat.TDF);\r\n\r\n        private final CSVFormat format;\r\n\r\n        Predefined(final CSVFormat format) {\r\n            this.format = format;\r\n        }\r\n\r\n        /**\r\n         * Gets the format.\r\n         *\r\n         * @return the format.\r\n         */\r\n        public CSVFormat getFormat() {\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing\r\n     * empty lines.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Default\r\n     */\r\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false,\r\n            false, false, false, DuplicateHeaderMode.ALLOW_ALL);\r\n\r\n    /**\r\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is locale dependent, it might be necessary\r\n     * to customize this format to accommodate to your regional settings.\r\n     *\r\n     * <p>\r\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setAllowMissingColumnNames(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     * <p>\r\n     * Note: This is currently like {@link #RFC4180} plus {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)} and\r\n     * {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(false)}.\r\n     * </p>\r\n     *\r\n     * @see Predefined#Excel\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat EXCEL = DEFAULT.builder()\r\n            .setIgnoreEmptyLines(false)\r\n            .setAllowMissingColumnNames(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.builder()\r\n            .setDelimiter(PIPE)\r\n            .setEscape(BACKSLASH)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with {@code '\"'}. A header line with field\r\n     * names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format. Values are double quoted only if needed and special\r\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\r\n     *          documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_TSV = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\r\n     *      -data.html</a>\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MYSQL = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default Oracle format used by the SQL*Loader utility.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\r\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\r\n     * {@code \"\"}. Values are trimmed.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setTrim()}</li>\r\n     * <li>{@code setSystemRecordSeparator()}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.MINIMAL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Oracle\r\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\r\n     * @since 1.6\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat ORACLE = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setTrim(true)\r\n            .setRecordSeparator(System.lineSeparator())\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\r\n     * characters are not escaped. The default NULL string is {@code \"\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape(null)}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(null)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(EMPTY)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL text format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#RFC4180\r\n     */\r\n    public static final CSVFormat RFC4180 = DEFAULT.builder().setIgnoreEmptyLines(false).build();\r\n\r\n    private static final long serialVersionUID = 2L;\r\n\r\n    /**\r\n     * Tab-delimited format.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreSurroundingSpaces(true)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#TDF\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat TDF = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setIgnoreSurroundingSpaces(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Null-safe clone of an array.\r\n     *\r\n     * @param <T>    The array element type.\r\n     * @param values the source array\r\n     * @return the cloned array.\r\n     */\r\n    @SafeVarargs\r\n    static <T> T[] clone(final T... values) {\r\n        return values == null ? null : values.clone();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains the search char.\r\n     *\r\n     * @param source the string to check.\r\n     * @param searchCh the character to search.\r\n     *\r\n     * @return true if {@code c} contains a line break character\r\n     */\r\n    private static boolean contains(final String source, final char searchCh) {\r\n        return Objects.requireNonNull(source, \"source\").indexOf(searchCh) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains a line break character.\r\n     *\r\n     * @param source the string to check.\r\n     *\r\n     * @return true if {@code c} contains a line break character.\r\n     */\r\n    private static boolean containsLineBreak(final String source) {\r\n        return contains(source, CR) || contains(source, LF);\r\n    }\r\n\r\n    static boolean isBlank(final String value) {\r\n        return value == null || value.trim().isEmpty();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check.\r\n     *\r\n     * @return true if {@code c} is a line break character.\r\n     */\r\n    private static boolean isLineBreak(final char c) {\r\n        return c == LF || c == CR;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check, may be null.\r\n     *\r\n     * @return true if {@code c} is a line break character (and not null).\r\n     */\r\n    private static boolean isLineBreak(final Character c) {\r\n        return c != null && isLineBreak(c.charValue());\r\n    }\r\n\r\n    /** Same test as in as {@link String#trim()}. */\r\n    private static boolean isTrimChar(final char ch) {\r\n        return ch <= SP;\r\n    }\r\n\r\n    /** Same test as in as {@link String#trim()}. */\r\n    private static boolean isTrimChar(final CharSequence charSequence, final int pos) {\r\n        return isTrimChar(charSequence.charAt(pos));\r\n    }\r\n\r\n    /**\r\n     * Creates a new CSV format with the specified delimiter.\r\n     *\r\n     * <p>\r\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.\r\n     * </p>\r\n     *\r\n     * @param delimiter the char used for value separation, must not be a line break character\r\n     * @return a new CSV format.\r\n     * @throws IllegalArgumentException if the delimiter is a line break character\r\n     *\r\n     * @see #DEFAULT\r\n     * @see #RFC4180\r\n     * @see #MYSQL\r\n     * @see #EXCEL\r\n     * @see #TDF\r\n     */\r\n    public static CSVFormat newFormat(final char delimiter) {\r\n        return new CSVFormat(String.valueOf(delimiter), null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false,\r\n                DuplicateHeaderMode.ALLOW_ALL);\r\n    }\r\n\r\n    static String[] toStringArray(final Object[] values) {\r\n        if (values == null) {\r\n            return null;\r\n        }\r\n        final String[] strings = new String[values.length];\r\n        Arrays.setAll(strings, i -> Objects.toString(values[i], null));\r\n        return strings;\r\n    }\r\n\r\n    static CharSequence trim(final CharSequence charSequence) {\r\n        if (charSequence instanceof String) {\r\n            return ((String) charSequence).trim();\r\n        }\r\n        final int count = charSequence.length();\r\n        int len = count;\r\n        int pos = 0;\r\n\r\n        while (pos < len && isTrimChar(charSequence, pos)) {\r\n            pos++;\r\n        }\r\n        while (pos < len && isTrimChar(charSequence, len - 1)) {\r\n            len--;\r\n        }\r\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\r\n    }\r\n\r\n    /**\r\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\r\n     *\r\n     * @param format name\r\n     * @return one of the predefined formats\r\n     * @since 1.2\r\n     */\r\n    public static CSVFormat valueOf(final String format) {\r\n        return CSVFormat.Predefined.valueOf(format).getFormat();\r\n    }\r\n\r\n    private final DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n    private final boolean allowMissingColumnNames;\r\n\r\n    private final boolean autoFlush;\r\n\r\n    private final Character commentMarker; // null if commenting is disabled\r\n\r\n    private final String delimiter;\r\n\r\n    private final Character escapeCharacter; // null if escaping is disabled\r\n\r\n    private final String[] headers; // array of header column names\r\n\r\n    private final String[] headerComments; // array of header comment lines\r\n\r\n    private final boolean ignoreEmptyLines;\r\n\r\n    private final boolean ignoreHeaderCase; // should ignore header names case\r\n\r\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\r\n\r\n    private final String nullString; // the string to be used for null values\r\n\r\n    private final Character quoteCharacter; // null if quoting is disabled\r\n\r\n    private final String quotedNullString;\r\n\r\n    private final QuoteMode quoteMode;\r\n\r\n    private final String recordSeparator; // for outputs\r\n\r\n    private final boolean skipHeaderRecord;\r\n\r\n    private final boolean trailingDelimiter;\r\n\r\n    private final boolean trim;\r\n\r\n    private CSVFormat(final Builder builder) {\r\n        this.delimiter = builder.delimiter;\r\n        this.quoteCharacter = builder.quoteCharacter;\r\n        this.quoteMode = builder.quoteMode;\r\n        this.commentMarker = builder.commentMarker;\r\n        this.escapeCharacter = builder.escapeCharacter;\r\n        this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = builder.allowMissingColumnNames;\r\n        this.ignoreEmptyLines = builder.ignoreEmptyLines;\r\n        this.recordSeparator = builder.recordSeparator;\r\n        this.nullString = builder.nullString;\r\n        this.headerComments = builder.headerComments;\r\n        this.headers = builder.headers;\r\n        this.skipHeaderRecord = builder.skipHeaderRecord;\r\n        this.ignoreHeaderCase = builder.ignoreHeaderCase;\r\n        this.trailingDelimiter = builder.trailingDelimiter;\r\n        this.trim = builder.trim;\r\n        this.autoFlush = builder.autoFlush;\r\n        this.quotedNullString = builder.quotedNullString;\r\n        this.duplicateHeaderMode = builder.duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    /**\r\n     * Creates a customized CSV format.\r\n     *\r\n     * @param delimiter               the char used for value separation, must not be a line break character.\r\n     * @param quoteChar               the Character used as value encapsulation marker, may be {@code null} to disable.\r\n     * @param quoteMode               the quote mode.\r\n     * @param commentStart            the Character used for comment identification, may be {@code null} to disable.\r\n     * @param escape                  the Character used to escape special characters in values, may be {@code null} to disable.\r\n     * @param ignoreSurroundingSpaces {@code true} when whitespaces enclosing values should be ignored.\r\n     * @param ignoreEmptyLines        {@code true} when the parser should skip empty lines.\r\n     * @param recordSeparator         the line separator to use for output.\r\n     * @param nullString              the line separator to use for output.\r\n     * @param headerComments          the comments to be printed by the Printer before the actual CSV data.\r\n     * @param header                  the header\r\n     * @param skipHeaderRecord        TODO Doc me.\r\n     * @param allowMissingColumnNames TODO Doc me.\r\n     * @param ignoreHeaderCase        TODO Doc me.\r\n     * @param trim                    TODO Doc me.\r\n     * @param trailingDelimiter       TODO Doc me.\r\n     * @param autoFlush               TODO Doc me.\r\n     * @param duplicateHeaderMode     the behavior when handling duplicate headers\r\n     * @throws IllegalArgumentException if the delimiter is a line break character.\r\n     */\r\n    private CSVFormat(final String delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape,\r\n            final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\r\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames,\r\n            final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush,\r\n            final DuplicateHeaderMode duplicateHeaderMode) {\r\n        this.delimiter = delimiter;\r\n        this.quoteCharacter = quoteChar;\r\n        this.quoteMode = quoteMode;\r\n        this.commentMarker = commentStart;\r\n        this.escapeCharacter = escape;\r\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = allowMissingColumnNames;\r\n        this.ignoreEmptyLines = ignoreEmptyLines;\r\n        this.recordSeparator = recordSeparator;\r\n        this.nullString = nullString;\r\n        this.headerComments = toStringArray(headerComments);\r\n        this.headers = clone(header);\r\n        this.skipHeaderRecord = skipHeaderRecord;\r\n        this.ignoreHeaderCase = ignoreHeaderCase;\r\n        this.trailingDelimiter = trailingDelimiter;\r\n        this.trim = trim;\r\n        this.autoFlush = autoFlush;\r\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n        this.duplicateHeaderMode = duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    private void append(final char c, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(c);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    private void append(final CharSequence csq, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(csq);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    /**\r\n     * Creates a new Builder for this instance.\r\n     *\r\n     * @return a new Builder.\r\n     */\r\n    public Builder builder() {\r\n        return Builder.create(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a copy of this instance.\r\n     *\r\n     * @return a copy of this instance.\r\n     */\r\n    CSVFormat copy() {\r\n        return builder().build();\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(final Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null || getClass() != obj.getClass()) {\r\n            return false;\r\n        }\r\n        final CSVFormat other = (CSVFormat) obj;\r\n        return duplicateHeaderMode == other.duplicateHeaderMode && allowMissingColumnNames == other.allowMissingColumnNames &&\r\n                autoFlush == other.autoFlush && Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) &&\r\n                Objects.equals(escapeCharacter, other.escapeCharacter) && Arrays.equals(headers, other.headers) &&\r\n                Arrays.equals(headerComments, other.headerComments) && ignoreEmptyLines == other.ignoreEmptyLines &&\r\n                ignoreHeaderCase == other.ignoreHeaderCase && ignoreSurroundingSpaces == other.ignoreSurroundingSpaces &&\r\n                Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) && quoteMode == other.quoteMode &&\r\n                Objects.equals(quotedNullString, other.quotedNullString) && Objects.equals(recordSeparator, other.recordSeparator) &&\r\n                skipHeaderRecord == other.skipHeaderRecord && trailingDelimiter == other.trailingDelimiter && trim == other.trim;\r\n    }\r\n\r\n    /**\r\n     * Formats the specified values.\r\n     *\r\n     * @param values the values to format\r\n     * @return the formatted values\r\n     */\r\n    public String format(final Object... values) {\r\n        final StringWriter out = new StringWriter();\r\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\r\n            csvPrinter.printRecord(values);\r\n            final String res = out.toString();\r\n            final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\r\n            return res.substring(0, len);\r\n        } catch (final IOException e) {\r\n            // should not happen because a StringWriter does not do IO.\r\n            throw new IllegalStateException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether duplicate names are allowed in the headers.\r\n     *\r\n     * @return whether duplicate header names are allowed\r\n     * @since 1.7\r\n     * @deprecated Use {@link #getDuplicateHeaderMode()}.\r\n     */\r\n    @Deprecated\r\n    public boolean getAllowDuplicateHeaderNames() {\r\n        return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;\r\n    }\r\n\r\n    /**\r\n     * Gets whether missing column names are allowed when parsing the header line.\r\n     *\r\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an {@link IllegalArgumentException}.\r\n     */\r\n    public boolean getAllowMissingColumnNames() {\r\n        return allowMissingColumnNames;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to flush on close.\r\n     *\r\n     * @return whether to flush on close.\r\n     * @since 1.6\r\n     */\r\n    public boolean getAutoFlush() {\r\n        return autoFlush;\r\n    }\r\n\r\n    /**\r\n     * Gets the character marking the start of a line comment.\r\n     *\r\n     * @return the comment start marker, may be {@code null}\r\n     */\r\n    public Character getCommentMarker() {\r\n        return commentMarker;\r\n    }\r\n\r\n    /**\r\n     * Gets the first character delimiting the values (typically ';', ',' or '\\t').\r\n     *\r\n     * @return the first delimiter character.\r\n     * @deprecated Use {@link #getDelimiterString()}.\r\n     */\r\n    @Deprecated\r\n    public char getDelimiter() {\r\n        return delimiter.charAt(0);\r\n    }\r\n\r\n    /**\r\n     * Gets the character delimiting the values (typically \";\", \",\" or \"\\t\").\r\n     *\r\n     * @return the delimiter.\r\n     * @since 1.9.0\r\n     */\r\n    public String getDelimiterString() {\r\n        return delimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets how duplicate headers are handled.\r\n     *\r\n     * @return if duplicate header values are allowed, allowed conditionally, or disallowed.\r\n     * @since 1.10.0\r\n     */\r\n    public DuplicateHeaderMode getDuplicateHeaderMode() {\r\n        return duplicateHeaderMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the escape character.\r\n     *\r\n     * @return the escape character, may be {@code null}\r\n     */\r\n    public Character getEscapeCharacter() {\r\n        return escapeCharacter;\r\n    }\r\n\r\n    /**\r\n     * Gets a copy of the header array.\r\n     *\r\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\r\n     */\r\n    public String[] getHeader() {\r\n        return headers != null ? headers.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Gets a copy of the header comment array.\r\n     *\r\n     * @return a copy of the header comment array; {@code null} if disabled.\r\n     */\r\n    public String[] getHeaderComments() {\r\n        return headerComments != null ? headerComments.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Gets whether empty lines between records are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty records.\r\n     */\r\n    public boolean getIgnoreEmptyLines() {\r\n        return ignoreEmptyLines;\r\n    }\r\n\r\n    /**\r\n     * Gets whether header names will be accessed ignoring case when parsing input.\r\n     *\r\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\r\n     * @since 1.3\r\n     */\r\n    public boolean getIgnoreHeaderCase() {\r\n        return ignoreHeaderCase;\r\n    }\r\n\r\n    /**\r\n     * Gets whether spaces around values are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\r\n     */\r\n    public boolean getIgnoreSurroundingSpaces() {\r\n        return ignoreSurroundingSpaces;\r\n    }\r\n\r\n    /**\r\n     * Gets the String to convert to and from {@code null}.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     */\r\n    public String getNullString() {\r\n        return nullString;\r\n    }\r\n\r\n    /**\r\n     * Gets the character used to encapsulate values containing special characters.\r\n     *\r\n     * @return the quoteChar character, may be {@code null}\r\n     */\r\n    public Character getQuoteCharacter() {\r\n        return quoteCharacter;\r\n    }\r\n\r\n    /**\r\n     * Gets the quote policy output fields.\r\n     *\r\n     * @return the quote policy\r\n     */\r\n    public QuoteMode getQuoteMode() {\r\n        return quoteMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the record separator delimiting output records.\r\n     *\r\n     * @return the record separator\r\n     */\r\n    public String getRecordSeparator() {\r\n        return recordSeparator;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to skip the header record.\r\n     *\r\n     * @return whether to skip the header record.\r\n     */\r\n    public boolean getSkipHeaderRecord() {\r\n        return skipHeaderRecord;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to add a trailing delimiter.\r\n     *\r\n     * @return whether to add a trailing delimiter.\r\n     * @since 1.3\r\n     */\r\n    public boolean getTrailingDelimiter() {\r\n        return trailingDelimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to trim leading and trailing blanks. This is used by {@link #print(Object, Appendable, boolean)} Also by\r\n     * {CSVParser#addRecordValue(boolean)}\r\n     *\r\n     * @return whether to trim leading and trailing blanks.\r\n     */\r\n    public boolean getTrim() {\r\n        return trim;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + Arrays.hashCode(headers);\r\n        result = prime * result + Arrays.hashCode(headerComments);\r\n        return prime * result + Objects.hash(duplicateHeaderMode, allowMissingColumnNames, autoFlush, commentMarker, delimiter, escapeCharacter,\r\n                ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator,\r\n                skipHeaderRecord, trailingDelimiter, trim);\r\n    }\r\n\r\n    /**\r\n     * Tests whether comments are supported by this format.\r\n     *\r\n     * Note that the comment introducer character is only recognized at the start of a line.\r\n     *\r\n     * @return {@code true} is comments are supported, {@code false} otherwise\r\n     */\r\n    public boolean isCommentMarkerSet() {\r\n        return commentMarker != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether the next characters constitute a delimiter\r\n     *\r\n     * @param ch\r\n     *            the current char\r\n     * @param charSeq\r\n     *            the match char sequence\r\n     * @param startIndex\r\n     *            where start to match\r\n     * @param delimiter\r\n     *            the delimiter\r\n     * @param delimiterLength\r\n     *            the delimiter length\r\n     * @return true if the match is successful\r\n     */\r\n    private boolean isDelimiter(final char ch, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength) {\r\n        if (ch != delimiter[0]) {\r\n            return false;\r\n        }\r\n        final int len = charSeq.length();\r\n        if (startIndex + delimiterLength > len) {\r\n            return false;\r\n        }\r\n        for (int i = 1; i < delimiterLength; i++) {\r\n            if (charSeq.charAt(startIndex + i) != delimiter[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests whether escape are being processed.\r\n     *\r\n     * @return {@code true} if escapes are processed\r\n     */\r\n    public boolean isEscapeCharacterSet() {\r\n        return escapeCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether a nullString has been defined.\r\n     *\r\n     * @return {@code true} if a nullString is defined\r\n     */\r\n    public boolean isNullStringSet() {\r\n        return nullString != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether a quoteChar has been defined.\r\n     *\r\n     * @return {@code true} if a quoteChar is defined\r\n     */\r\n    public boolean isQuoteCharacterSet() {\r\n        return quoteCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Parses the specified content.\r\n     *\r\n     * <p>\r\n     * See also the various static parse methods on {@link CSVParser}.\r\n     * </p>\r\n     *\r\n     * @param reader the input stream\r\n     * @return a parser over a stream of {@link CSVRecord}s.\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    public CSVParser parse(final Reader reader) throws IOException {\r\n        return new CSVParser(reader, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out the output.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     */\r\n    public CSVPrinter print(final Appendable out) throws IOException {\r\n        return new CSVPrinter(out, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\r\n        // The writer will be closed when close() is called.\r\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\r\n    }\r\n\r\n    /**\r\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated as needed. Useful when one wants to\r\n     * avoid creating CSVPrinters. Trims the value if {@link #getTrim()} is true.\r\n     *\r\n     * @param value     value to output.\r\n     * @param out       where to print the value.\r\n     * @param newRecord if this a new record.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\r\n        // null values are considered empty\r\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\r\n        CharSequence charSequence;\r\n        if (value == null) {\r\n            // https://issues.apache.org/jira/browse/CSV-203\r\n            if (null == nullString) {\r\n                charSequence = EMPTY;\r\n            } else if (QuoteMode.ALL == quoteMode) {\r\n                charSequence = quotedNullString;\r\n            } else {\r\n                charSequence = nullString;\r\n            }\r\n        } else if (value instanceof CharSequence) {\r\n            charSequence = (CharSequence) value;\r\n        } else if (value instanceof Reader) {\r\n            print((Reader) value, out, newRecord);\r\n            return;\r\n        } else {\r\n            charSequence = value.toString();\r\n        }\r\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\r\n        print(value, charSequence, out, newRecord);\r\n    }\r\n\r\n    private synchronized void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\r\n        final int offset = 0;\r\n        final int len = value.length();\r\n        if (!newRecord) {\r\n            out.append(getDelimiterString());\r\n        }\r\n        if (object == null) {\r\n            out.append(value);\r\n        } else if (isQuoteCharacterSet()) {\r\n            // the original object is needed so can check for Number\r\n            printWithQuotes(object, value, out, newRecord);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(value, out);\r\n        } else {\r\n            out.append(value, offset, len);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output, returns a {@code CSVPrinter} which the caller MUST close.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\r\n        return print(Files.newBufferedWriter(out, charset));\r\n    }\r\n\r\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\r\n        // Reader is never null\r\n        if (!newRecord) {\r\n            append(getDelimiterString(), out);\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            printWithQuotes(reader, out);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(reader, out);\r\n        } else if (out instanceof Writer) {\r\n            IOUtils.copyLarge(reader, (Writer) out);\r\n        } else {\r\n            IOUtils.copy(reader, out);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Prints to the {@link System#out}.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @return a printer to {@link System#out}.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    public CSVPrinter printer() throws IOException {\r\n        return new CSVPrinter(System.out, this);\r\n    }\r\n\r\n    /**\r\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\r\n     *\r\n     * @param appendable where to write\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void println(final Appendable appendable) throws IOException {\r\n        if (getTrailingDelimiter()) {\r\n            append(getDelimiterString(), appendable);\r\n        }\r\n        if (recordSeparator != null) {\r\n            append(recordSeparator, appendable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the record separator.\r\n     *\r\n     * <p>\r\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing\r\n     * the record, so there is no need to call {@link #println(Appendable)}.\r\n     * </p>\r\n     *\r\n     * @param appendable    where to write.\r\n     * @param values values to output.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException {\r\n        for (int i = 0; i < values.length; i++) {\r\n            print(values[i], appendable, i == 0);\r\n        }\r\n        println(appendable);\r\n    }\r\n\r\n    /*\r\n     * Note: Must only be called if escaping is enabled, otherwise will generate NPE.\r\n     */\r\n    private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int end = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n\r\n        while (pos < end) {\r\n            char c = charSeq.charAt(pos);\r\n            final boolean isDelimiterStart = isDelimiter(c, charSeq, pos, delim, delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    appendable.append(charSeq, start, pos);\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                appendable.append(escape);\r\n                appendable.append(c);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        pos++;\r\n                        c = charSeq.charAt(pos);\r\n                        appendable.append(escape);\r\n                        appendable.append(c);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            appendable.append(charSeq, start, pos);\r\n        }\r\n    }\r\n\r\n    private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n\r\n        @SuppressWarnings(\"resource\") // Temp reader on input reader.\r\n        final ExtendedBufferedReader bufferedReader = new ExtendedBufferedReader(reader);\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        int c;\r\n        while (-1 != (c = bufferedReader.read())) {\r\n            builder.append((char) c);\r\n            final boolean isDelimiterStart = isDelimiter((char) c, builder.toString() + new String(bufferedReader.lookAhead(delimLength - 1)), pos, delim,\r\n                    delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    append(builder.substring(start, pos), appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                append(escape, appendable);\r\n                append((char) c, appendable);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        c = bufferedReader.read();\r\n                        append(escape, appendable);\r\n                        append((char) c, appendable);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            append(builder.substring(start, pos), appendable);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\r\n     */\r\n    // the original object is needed so can check for Number\r\n    private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\r\n        boolean quote = false;\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int len = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char quoteChar = getQuoteCharacter().charValue();\r\n        // If escape char not specified, default to the quote char\r\n        // This avoids having to keep checking whether there is an escape character\r\n        // at the cost of checking against quote twice\r\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\r\n\r\n        QuoteMode quoteModePolicy = getQuoteMode();\r\n        if (quoteModePolicy == null) {\r\n            quoteModePolicy = QuoteMode.MINIMAL;\r\n        }\r\n        switch (quoteModePolicy) {\r\n        case ALL:\r\n        case ALL_NON_NULL:\r\n            quote = true;\r\n            break;\r\n        case NON_NUMERIC:\r\n            quote = !(object instanceof Number);\r\n            break;\r\n        case NONE:\r\n            // Use the existing escaping code\r\n            printWithEscapes(charSeq, out);\r\n            return;\r\n        case MINIMAL:\r\n            if (len <= 0) {\r\n                // always quote an empty token that is the first\r\n                // on the line, as it may be the only thing on the\r\n                // line. If it were not quoted in that case,\r\n                // an empty line has no tokens.\r\n                if (newRecord) {\r\n                    quote = true;\r\n                }\r\n            } else {\r\n                char c = charSeq.charAt(pos);\r\n\r\n                if (c <= COMMENT) {\r\n                    // Some other chars at the start of a value caused the parser to fail, so for now\r\n                    // encapsulate if we start in anything less than '#'. We are being conservative\r\n                    // by including the default comment char too.\r\n                    quote = true;\r\n                } else {\r\n                    while (pos < len) {\r\n                        c = charSeq.charAt(pos);\r\n                        if (c == LF || c == CR || c == quoteChar || c == escapeChar || isDelimiter(c, charSeq, pos, delim, delimLength)) {\r\n                            quote = true;\r\n                            break;\r\n                        }\r\n                        pos++;\r\n                    }\r\n\r\n                    if (!quote) {\r\n                        pos = len - 1;\r\n                        c = charSeq.charAt(pos);\r\n                        // Some other chars at the end caused the parser to fail, so for now\r\n                        // encapsulate if we end in anything less than ' '\r\n                        if (isTrimChar(c)) {\r\n                            quote = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!quote) {\r\n                // no encapsulation needed - write out the original value\r\n                out.append(charSeq, start, len);\r\n                return;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\r\n        }\r\n\r\n        if (!quote) {\r\n            // no encapsulation needed - write out the original value\r\n            out.append(charSeq, start, len);\r\n            return;\r\n        }\r\n\r\n        // we hit something that needed encapsulation\r\n        out.append(quoteChar);\r\n\r\n        // Pick up where we left off: pos should be positioned on the first character that caused\r\n        // the need for encapsulation.\r\n        while (pos < len) {\r\n            final char c = charSeq.charAt(pos);\r\n            if (c == quoteChar || c == escapeChar) {\r\n                // write out the chunk up until this point\r\n                out.append(charSeq, start, pos);\r\n                out.append(escapeChar); // now output the escape\r\n                start = pos; // and restart with the matched char\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write the last segment\r\n        out.append(charSeq, start, pos);\r\n        out.append(quoteChar);\r\n    }\r\n\r\n    /**\r\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\r\n     *\r\n     * @param reader What to print\r\n     * @param appendable Where to print it\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {\r\n\r\n        if (getQuoteMode() == QuoteMode.NONE) {\r\n            printWithEscapes(reader, appendable);\r\n            return;\r\n        }\r\n\r\n        int pos = 0;\r\n\r\n        final char quote = getQuoteCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        append(quote, appendable);\r\n\r\n        int c;\r\n        while (-1 != (c = reader.read())) {\r\n            builder.append((char) c);\r\n            if (c == quote) {\r\n                // write out segment up until this char\r\n                if (pos > 0) {\r\n                    append(builder.substring(0, pos), appendable);\r\n                    append(quote, appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n\r\n                append((char) c, appendable);\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > 0) {\r\n            append(builder.substring(0, pos), appendable);\r\n        }\r\n\r\n        append(quote, appendable);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        final StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\r\n        if (isEscapeCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\r\n        }\r\n        if (quoteMode != null) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\r\n        }\r\n        if (isCommentMarkerSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\r\n        }\r\n        if (isNullStringSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"NullString=<\").append(nullString).append('>');\r\n        }\r\n        if (recordSeparator != null) {\r\n            sb.append(' ');\r\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\r\n        }\r\n        if (getIgnoreEmptyLines()) {\r\n            sb.append(\" EmptyLines:ignored\");\r\n        }\r\n        if (getIgnoreSurroundingSpaces()) {\r\n            sb.append(\" SurroundingSpaces:ignored\");\r\n        }\r\n        if (getIgnoreHeaderCase()) {\r\n            sb.append(\" IgnoreHeaderCase:ignored\");\r\n        }\r\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\r\n        if (headerComments != null) {\r\n            sb.append(' ');\r\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\r\n        }\r\n        if (headers != null) {\r\n            sb.append(' ');\r\n            sb.append(\"Header:\").append(Arrays.toString(headers));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    String trim(final String value) {\r\n        return getTrim() ? value.trim() : value;\r\n    }\r\n\r\n    /**\r\n     * Verifies the validity and consistency of the attributes, and throws an {@link IllegalArgumentException} if necessary.\r\n     * <p>\r\n     * Because an instance can be used for both writing an parsing, not all conditions can be tested here. For example allowMissingColumnNames is only used for\r\n     * parsing, so it cannot be used here.\r\n     * </p>\r\n     *\r\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.\r\n     */\r\n    private void validate() throws IllegalArgumentException {\r\n        if (containsLineBreak(delimiter)) {\r\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n        }\r\n\r\n        if (quoteCharacter != null && contains(delimiter, quoteCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && contains(delimiter, escapeCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\r\n        }\r\n\r\n        if (commentMarker != null && contains(delimiter, commentMarker.charValue())) {\r\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\r\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\r\n        }\r\n\r\n        // Validate headers\r\n        if (headers != null && duplicateHeaderMode != DuplicateHeaderMode.ALLOW_ALL) {\r\n            final Set<String> dupCheckSet = new HashSet<>(headers.length);\r\n            final boolean emptyDuplicatesAllowed = duplicateHeaderMode == DuplicateHeaderMode.ALLOW_EMPTY;\r\n            for (final String header : headers) {\r\n                final boolean blank = isBlank(header);\r\n                // Sanitise all empty headers to the empty string \"\" when checking duplicates\r\n                final boolean containsHeader = !dupCheckSet.add(blank ? \"\" : header);\r\n                if (containsHeader && !(blank && emptyDuplicatesAllowed)) {\r\n                    throw new IllegalArgumentException(\r\n                        String.format(\r\n                            \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\r\n                            header, Arrays.toString(headers)));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} that allows duplicate header names.\r\n     *\r\n     * @return a new {@code CSVFormat} that allows duplicate header names\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean) Builder#setAllowDuplicateHeaderNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames() {\r\n        return builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     *\r\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n        final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\r\n        return builder().setDuplicateHeaderMode(mode).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @see Builder#setAllowMissingColumnNames(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames() {\r\n        return builder().setAllowMissingColumnNames(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\r\n     *\r\n     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause\r\n     *                                an {@link IllegalArgumentException} to be thrown.\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n        return builder().setAllowMissingColumnNames(allowMissingColumnNames).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to flush on close.\r\n     *\r\n     * @param autoFlush whether to flush on close.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setAutoFlush(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\r\n        return builder().setAutoFlush(autoFlush).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final char commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final Character commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the delimiter of the format set to the specified character.\r\n     *\r\n     * @param delimiter the delimiter character\r\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setDelimiter(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withDelimiter(final char delimiter) {\r\n        return builder().setDelimiter(delimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final char escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final Character escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} using the first record as header.\r\n     *\r\n     * <p>\r\n     * Calling this method is equivalent to calling:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\r\n     * </pre>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but using the first record as header.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(String...) Builder#setHeader()}.{@link Builder#setSkipHeaderRecord(boolean) setSkipHeaderRecord(true)}.\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withFirstRecordAsHeader() {\r\n        // @formatter:off\r\n        return builder()\r\n                .setHeader()\r\n                .setSkipHeaderRecord(true)\r\n                .build();\r\n        // @formatter:on\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format defined by the enum class.\r\n     *\r\n     * <p>\r\n     * Example:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * public enum Header {\r\n     *     Name, Email, Phone\r\n     * }\r\n     *\r\n     * CSVFormat format = aformat.withHeader(Header.class);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setHeader(String...)\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(Class)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\r\n        return builder().setHeader(headerEnum).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(resultSet);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSet)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\r\n        return builder().setHeader(resultSet).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(metaData);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSetMetaData)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n        return builder().setHeader(resultSetMetaData).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file\r\n     * with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @deprecated Use {@link Builder#setHeader(String...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final String... header) {\r\n        return builder().setHeader(header).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.\r\n     * This setting is ignored by the parser.\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n     * </pre>\r\n     *\r\n     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeaderComments(Object...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeaderComments(final Object... headerComments) {\r\n        return builder().setHeaderComments(headerComments).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @see Builder#setIgnoreEmptyLines(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines() {\r\n        return builder().setIgnoreEmptyLines(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty\r\n     *                         lines to empty records.\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n        return builder().setIgnoreEmptyLines(ignoreEmptyLines).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that will ignore case header name.\r\n     * @see Builder#setIgnoreHeaderCase(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean) Builder#setIgnoreHeaderCase(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase() {\r\n        return builder().setIgnoreHeaderCase(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether header names should be accessed ignoring case.\r\n     *\r\n     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n        return builder().setIgnoreHeaderCase(ignoreHeaderCase).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\r\n     * @see Builder#setIgnoreSurroundingSpaces(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean) Builder#setIgnoreSurroundingSpaces(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces() {\r\n        return builder().setIgnoreSurroundingSpaces(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n        return builder().setIgnoreSurroundingSpaces(ignoreSurroundingSpaces).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with conversions to and from null for strings on input and output.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\r\n     * @deprecated Use {@link Builder#setNullString(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withNullString(final String nullString) {\r\n        return builder().setNullString(nullString).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final char quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character, use {@code null} to disable.\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final Character quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\r\n     *\r\n     * @param quoteMode the quote policy to use for output.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\r\n     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuoteMode(final QuoteMode quoteMode) {\r\n        return builder().setQuoteMode(quoteMode).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified character.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @deprecated Use {@link Builder#setRecordSeparator(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified String.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with skipping the header record set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean) Builder#setSkipHeaderRecord(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord() {\r\n        return builder().setSkipHeaderRecord(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to skip the header record.\r\n     *\r\n     * @param skipHeaderRecord whether to skip the header record.\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setHeader(String...)\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n        return builder().setSkipHeaderRecord(skipHeaderRecord).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows\r\n     * and LF on Linux.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSystemRecordSeparator() {\r\n        return builder().setRecordSeparator(System.lineSeparator()).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} to add a trailing delimiter.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean) Builder#setTrailingDelimiter(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter() {\r\n        return builder().setTrailingDelimiter(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to add a trailing delimiter.\r\n     *\r\n     * @param trailingDelimiter whether to add a trailing delimiter.\r\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\r\n        return builder().setTrailingDelimiter(trailingDelimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean) Builder#setTrim(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim() {\r\n        return builder().setTrim(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @param trim whether to trim leading and trailing blanks.\r\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim(final boolean trim) {\r\n        return builder().setTrim(trim).build();\r\n    }\r\n}\r",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 81b6f1936..280f99f24 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -206,8 +206,12 @@ public static Builder create(final CSVFormat csvFormat) {\n             return new Builder(csvFormat);\r\n         }\r\n \r\n+        private boolean allowEofWithoutClosingQuote;\r\n+\r\n         private boolean allowMissingColumnNames;\r\n \r\n+        private boolean allowTrailingText;\r\n+\r\n         private boolean autoFlush;\r\n \r\n         private Character commentMarker;\r\n@@ -264,6 +268,8 @@ private Builder(final CSVFormat csvFormat) {\n             this.autoFlush = csvFormat.autoFlush;\r\n             this.quotedNullString = csvFormat.quotedNullString;\r\n             this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;\r\n+            this.allowTrailingText = csvFormat.allowTrailingText;\r\n+            this.allowEofWithoutClosingQuote = csvFormat.allowEofWithoutClosingQuote;\r\n         }\r\n \r\n         /**\r\n@@ -288,6 +294,19 @@ public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNa\n             return this;\r\n         }\r\n \r\n+        /**\r\n+         * Sets whether the last field on the last line, if quoted, can have no closing quote when the file ends, {@code true} if this is ok,\r\n+         * {@code false} if {@link IOException} should be thrown.\r\n+         *\r\n+         * @param allowEofWithoutClosingQuote whether to allow the last field on the last line to have a missing closing quote when the file ends,\r\n+         *                                    {@code true} if so, or {@code false} to cause an {@link IOException} to be thrown.\r\n+         * @since 1.10.0\r\n+         */\r\n+        public Builder setAllowEofWithoutClosingQuote(final boolean allowEofWithoutClosingQuote) {\r\n+            this.allowEofWithoutClosingQuote = allowEofWithoutClosingQuote;\r\n+            return this;\r\n+        }\r\n+\r\n         /**\r\n          * Sets the parser missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\r\n          * {@link IllegalArgumentException} to be thrown.\r\n@@ -301,6 +320,20 @@ public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames)\n             return this;\r\n         }\r\n \r\n+        /**\r\n+         * Sets whether to allow trailing text in a quoted field, after the closing quote.\r\n+         *\r\n+         * @param allowTrailingText the trailing text behavior, {@code true} to append that text to the field contents, {@code false} to throw\r\n+         *        an {@link IOException}.\r\n+         *\r\n+         * @return This instance.\r\n+         * @since 1.10.0\r\n+         */\r\n+        public Builder setAllowTrailingText(final boolean allowTrailingText) {\r\n+            this.allowTrailingText = allowTrailingText;\r\n+            return this;\r\n+        }\r\n+\r\n         /**\r\n          * Sets whether to flush on close.\r\n          *\r\n@@ -810,7 +843,7 @@ public CSVFormat getFormat() {\n      * @see Predefined#Default\r\n      */\r\n     public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false,\r\n-            false, false, false, DuplicateHeaderMode.ALLOW_ALL);\r\n+            false, false, false, DuplicateHeaderMode.ALLOW_ALL, false, false);\r\n \r\n     /**\r\n      * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is locale dependent, it might be necessary\r\n@@ -834,6 +867,8 @@ public CSVFormat getFormat() {\n      * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n      * <li>{@code setAllowMissingColumnNames(true)}</li>\r\n      * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n+     * <li>{@code setAllowTrailingText(true)}</li>\r\n+     * <li>{@code setAllowEofWithoutClosingQuote(true)}</li>\r\n      * </ul>\r\n      * <p>\r\n      * Note: This is currently like {@link #RFC4180} plus {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)} and\r\n@@ -846,6 +881,8 @@ public CSVFormat getFormat() {\n     public static final CSVFormat EXCEL = DEFAULT.builder()\r\n             .setIgnoreEmptyLines(false)\r\n             .setAllowMissingColumnNames(true)\r\n+            .setAllowTrailingText(true)\r\n+            .setAllowEofWithoutClosingQuote(true)\r\n             .build();\r\n     // @formatter:on\r\n \r\n@@ -1268,7 +1305,7 @@ private static boolean isTrimChar(final CharSequence charSequence, final int pos\n      */\r\n     public static CSVFormat newFormat(final char delimiter) {\r\n         return new CSVFormat(String.valueOf(delimiter), null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false,\r\n-                DuplicateHeaderMode.ALLOW_ALL);\r\n+                DuplicateHeaderMode.ALLOW_ALL, false, false);\r\n     }\r\n \r\n     static String[] toStringArray(final Object[] values) {\r\n@@ -1310,8 +1347,12 @@ public static CSVFormat valueOf(final String format) {\n \r\n     private final DuplicateHeaderMode duplicateHeaderMode;\r\n \r\n+    private final boolean allowEofWithoutClosingQuote;\r\n+\r\n     private final boolean allowMissingColumnNames;\r\n \r\n+    private final boolean allowTrailingText;\r\n+\r\n     private final boolean autoFlush;\r\n \r\n     private final Character commentMarker; // null if commenting is disabled\r\n@@ -1366,6 +1407,8 @@ private CSVFormat(final Builder builder) {\n         this.autoFlush = builder.autoFlush;\r\n         this.quotedNullString = builder.quotedNullString;\r\n         this.duplicateHeaderMode = builder.duplicateHeaderMode;\r\n+        this.allowTrailingText = builder.allowTrailingText;\r\n+        this.allowEofWithoutClosingQuote = builder.allowEofWithoutClosingQuote;\r\n         validate();\r\n     }\r\n \r\n@@ -1396,7 +1439,7 @@ private CSVFormat(final String delimiter, final Character quoteChar, final Quote\n             final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\r\n             final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames,\r\n             final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush,\r\n-            final DuplicateHeaderMode duplicateHeaderMode) {\r\n+            final DuplicateHeaderMode duplicateHeaderMode, final boolean allowTrailingText, final boolean allowEofWithoutClosingQuote) {\r\n         this.delimiter = delimiter;\r\n         this.quoteCharacter = quoteChar;\r\n         this.quoteMode = quoteMode;\r\n@@ -1416,6 +1459,8 @@ private CSVFormat(final String delimiter, final Character quoteChar, final Quote\n         this.autoFlush = autoFlush;\r\n         this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n         this.duplicateHeaderMode = duplicateHeaderMode;\r\n+        this.allowTrailingText = allowTrailingText;\r\n+        this.allowEofWithoutClosingQuote = allowEofWithoutClosingQuote;\r\n         validate();\r\n     }\r\n \r\n@@ -1469,7 +1514,8 @@ public boolean equals(final Object obj) {\n                 ignoreHeaderCase == other.ignoreHeaderCase && ignoreSurroundingSpaces == other.ignoreSurroundingSpaces &&\r\n                 Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) && quoteMode == other.quoteMode &&\r\n                 Objects.equals(quotedNullString, other.quotedNullString) && Objects.equals(recordSeparator, other.recordSeparator) &&\r\n-                skipHeaderRecord == other.skipHeaderRecord && trailingDelimiter == other.trailingDelimiter && trim == other.trim;\r\n+                skipHeaderRecord == other.skipHeaderRecord && trailingDelimiter == other.trailingDelimiter && trim == other.trim &&\r\n+                allowTrailingText == other.allowTrailingText && allowEofWithoutClosingQuote == other.allowEofWithoutClosingQuote;\r\n     }\r\n \r\n     /**\r\n@@ -1503,6 +1549,16 @@ public boolean getAllowDuplicateHeaderNames() {\n         return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;\r\n     }\r\n \r\n+    /**\r\n+     * Gets whether the file can end before the last field on the last line, if quoted, has a closing quote.\r\n+     *\r\n+     * @return {@code true} if so, {@code false} to throw an {@link IOException}.\r\n+     * @since 1.10.0\r\n+     */\r\n+    public boolean getAllowEofWithoutClosingQuote() {\r\n+        return allowEofWithoutClosingQuote;\r\n+    }\r\n+\r\n     /**\r\n      * Gets whether missing column names are allowed when parsing the header line.\r\n      *\r\n@@ -1512,6 +1568,16 @@ public boolean getAllowMissingColumnNames() {\n         return allowMissingColumnNames;\r\n     }\r\n \r\n+    /**\r\n+     * Gets whether quoted fields allow trailing text after the closing quote.\r\n+     *\r\n+     * @return {@code true} if allowed, {@code false} to throw an {@link IOException}.\r\n+     * @since 1.10.0\r\n+     */\r\n+    public boolean getAllowTrailingText() {\r\n+        return allowTrailingText;\r\n+    }\r\n+\r\n     /**\r\n      * Gets whether to flush on close.\r\n      *\r\n@@ -1692,9 +1758,9 @@ public int hashCode() {\n         int result = 1;\r\n         result = prime * result + Arrays.hashCode(headers);\r\n         result = prime * result + Arrays.hashCode(headerComments);\r\n-        return prime * result + Objects.hash(duplicateHeaderMode, allowMissingColumnNames, autoFlush, commentMarker, delimiter, escapeCharacter,\r\n-                ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator,\r\n-                skipHeaderRecord, trailingDelimiter, trim);\r\n+        return prime * result + Objects.hash(duplicateHeaderMode, allowEofWithoutClosingQuote, allowMissingColumnNames, allowTrailingText,\r\n+                autoFlush, commentMarker, delimiter, escapeCharacter, ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces,\r\n+                nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator, skipHeaderRecord, trailingDelimiter, trim);\r\n     }\r\n \r\n     /**\r\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/Lexer.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\nimport static org.apache.commons.csv.TokenMatchers.matches;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class LexerTest2 {\n\n    private CSVFormat formatWithEscaping;\n\n    @SuppressWarnings(\"resource\")\n    private Lexer createLexer(final String input, final CSVFormat format) {\n        return new Lexer(format, new ExtendedBufferedReader(new StringReader(input)));\n    }\n\n    @BeforeEach\n    public void setUp() {\n        formatWithEscaping = CSVFormat.DEFAULT.withEscape('\\\\');\n    }\n\n    @Test\n    public void testAllowTrailingText() throws IOException {\n        final String code = \"\\\"value\\\" trailing text\";\n        final CSVFormat format = CSVFormat.DEFAULT.withAllowTrailingText(true);\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"value trailing text\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n\n    @Test\n    public void testDisallowTrailingText() {\n        final String code = \"\\\"value\\\" trailing text\";\n        final CSVFormat format = CSVFormat.DEFAULT.withAllowTrailingText(false);\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThrows(IOException.class, () -> parser.nextToken(new Token()));\n        }\n    }\n\n    @Test\n    public void testAllowEofWithoutClosingQuote() throws IOException {\n        final String code = \"\\\"value\";\n        final CSVFormat format = CSVFormat.DEFAULT.withAllowEofWithoutClosingQuote(true);\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"value\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n\n    @Test\n    public void testDisallowEofWithoutClosingQuote() {\n        final String code = \"\\\"value\";\n        final CSVFormat format = CSVFormat.DEFAULT.withAllowEofWithoutClosingQuote(false);\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThrows(IOException.class, () -> parser.nextToken(new Token()));\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport static org.apache.commons.csv.Token.Type.COMMENT;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Token.Type.INVALID;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.IOException;\n\n/**\n * Lexical analyzer.\n */\nfinal class Lexer implements Closeable {\n\n    private static final String CR_STRING = Character.toString(CR);\n    private static final String LF_STRING = Character.toString(LF);\n\n    /**\n     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char[] delimiter;\n    private final char[] delimiterBuf;\n    private final char[] escapeDelimiterBuf;\n    private final char escape;\n    private final char quoteChar;\n    private final char commentStart;\n\n    private final boolean ignoreSurroundingSpaces;\n    private final boolean ignoreEmptyLines;\n\n    /** The input stream */\n    private final ExtendedBufferedReader reader;\n    private String firstEol;\n\n    private boolean isLastTokenDelimiter;\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n        this.reader = reader;\n        this.delimiter = format.getDelimiterString().toCharArray();\n        this.escape = mapNullToDisabled(format.getEscapeCharacter());\n        this.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\n        this.commentStart = mapNullToDisabled(format.getCommentMarker());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n        this.delimiterBuf = new char[delimiter.length - 1];\n        this.escapeDelimiterBuf = new char[2 * delimiter.length - 1];\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        reader.close();\n    }\n\n    /**\n     * Returns the current character position\n     *\n     * @return the current character position\n     */\n    long getCharacterPosition() {\n        return reader.getPosition();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        return reader.getCurrentLineNumber();\n    }\n\n    String getFirstEol(){\n        return firstEol;\n    }\n\n    boolean isClosed() {\n        return reader.isClosed();\n    }\n\n    boolean isCommentStart(final int ch) {\n        return ch == commentStart;\n    }\n\n    /**\n     * Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n     *\n     * @param ch\n     *             the current character.\n     * @return true if the next characters constitute a delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isDelimiter(final int ch) throws IOException {\n        isLastTokenDelimiter = false;\n        if (ch != delimiter[0]) {\n            return false;\n        }\n        if (delimiter.length == 1) {\n            isLastTokenDelimiter = true;\n            return true;\n        }\n        reader.lookAhead(delimiterBuf);\n        for (int i = 0; i < delimiterBuf.length; i++) {\n            if (delimiterBuf[i] != delimiter[i+1]) {\n                return false;\n            }\n        }\n        final int count = reader.read(delimiterBuf, 0, delimiterBuf.length);\n        isLastTokenDelimiter = count != END_OF_STREAM;\n        return isLastTokenDelimiter;\n    }\n\n    /**\n     * Tests if the given character indicates end of file.\n     *\n     * @return true if the given character indicates end of file.\n     */\n    boolean isEndOfFile(final int ch) {\n        return ch == END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character is the escape character.\n     *\n     * @return true if the given character is the escape character.\n     */\n    boolean isEscape(final int ch) {\n        return ch == escape;\n    }\n\n    /**\n     * Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n     *\n     * For example, for delimiter \"[|]\" and escape '!', return true if the next characters constitute \"![!|!]\".\n     *\n     * @return true if the next characters constitute a escape delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isEscapeDelimiter() throws IOException {\n        reader.lookAhead(escapeDelimiterBuf);\n        if (escapeDelimiterBuf[0] != delimiter[0]) {\n            return false;\n        }\n        for (int i = 1; i < delimiter.length; i++) {\n            if (escapeDelimiterBuf[2 * i] != delimiter[i] || escapeDelimiterBuf[2 * i - 1] != escape) {\n                return false;\n            }\n        }\n        final int count = reader.read(escapeDelimiterBuf, 0, escapeDelimiterBuf.length);\n        return count != END_OF_STREAM;\n    }\n\n    private boolean isMetaChar(final int ch) {\n        return ch == escape || ch == quoteChar || ch == commentStart;\n    }\n\n    boolean isQuoteChar(final int ch) {\n        return ch == quoteChar;\n    }\n\n    /**\n     * Tests if the current character represents the start of a line: a CR, LF or is at the start of the file.\n     *\n     * @param ch the character to check\n     * @return true if the character is at the start of a line.\n     */\n    boolean isStartOfLine(final int ch) {\n        return ch == LF || ch == CR || ch == UNDEFINED;\n    }\n\n    private char mapNullToDisabled(final Character c) {\n        return c == null ? DISABLED : c.charValue();\n    }\n\n    /**\n     * Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token\n     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n     * @return the next token found.\n     * @throws IOException on stream access error.\n     */\n    Token nextToken(final Token token) throws IOException {\n\n        // get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n\n        // read the next char and set eol\n        int c = reader.read();\n        /*\n         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n         * - they are equivalent here.\n         */\n        boolean eol = readEndOfLine(c);\n\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol && isStartOfLine(lastChar)) {\n                // go on char ahead ...\n                lastChar = c;\n                c = reader.read();\n                eol = readEndOfLine(c);\n                // reached end of file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type = EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // did we reach eof during the last iteration already ? EOF\n        if (isEndOfFile(lastChar) || !isLastTokenDelimiter && isEndOfFile(c)) {\n            token.type = EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n            final String line = reader.readLine();\n            if (line == null) {\n                token.type = EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n            final String comment = line.trim();\n            token.content.append(comment);\n            token.type = COMMENT;\n            return token;\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (Character.isWhitespace((char)c) && !isDelimiter(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n\n    /**\n     * Parses an encapsulated token.\n     * <p>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n     */\n    private Token parseEncapsulatedToken(final Token token) throws IOException {\n        token.isQuoted = true;\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        int c;\n        while (true) {\n            c = reader.read();\n\n            if (isEscape(c)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) c).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n            } else if (isQuoteChar(c)) {\n                if (isQuoteChar(reader.lookAhead())) {\n                    // double or escaped encapsulator -> add single encapsulator to token\n                    c = reader.read();\n                    token.content.append((char) c);\n                } else {\n                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                    while (true) {\n                        c = reader.read();\n                        if (isDelimiter(c)) {\n                            token.type = TOKEN;\n                            return token;\n                        }\n                        if (isEndOfFile(c)) {\n                            token.type = EOF;\n                            token.isReady = true; // There is data at EOF\n                            return token;\n                        }\n                        if (readEndOfLine(c)) {\n                            token.type = EORECORD;\n                            return token;\n                        }\n                        if (!Character.isWhitespace((char)c)) {\n                            // error invalid char between token and next delimiter\n                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                    \") invalid char between encapsulated token and delimiter\");\n                        }\n                    }\n                }\n            } else if (isEndOfFile(c)) {\n                // error condition (end of file before end of token)\n                throw new IOException(\"(startline \" + startLineNumber +\n                        \") EOF reached before encapsulated token finished\");\n            } else {\n                // consume character\n                token.content.append((char) c);\n            }\n        }\n    }\n\n    /**\n     * Parses a simple token.\n     * <p>\n     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>end of line has been reached (EORECORD)</li>\n     * <li>end of stream has been reached (EOF)</li>\n     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token\n     *            the current token\n     * @param ch\n     *            the current character\n     * @return the filled token\n     * @throws IOException\n     *             on stream access error\n     */\n    private Token parseSimpleToken(final Token token, int ch) throws IOException {\n        // Faster to use while(true)+break than while(token.type == INVALID)\n        while (true) {\n            if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                break;\n            }\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                break;\n            }\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                break;\n            }\n            // continue\n            if (isEscape(ch)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) ch).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read(); // continue\n        }\n\n        if (ignoreSurroundingSpaces) {\n            trimTrailingSpaces(token.content);\n        }\n\n        return token;\n    }\n\n    /**\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     */\n    boolean readEndOfLine(int ch) throws IOException {\n        // check if we have \\r\\n...\n        if (ch == CR && reader.lookAhead() == LF) {\n            // note: does not change ch outside of this method!\n            ch = reader.read();\n            // Save the EOL state\n            if (firstEol == null) {\n                this.firstEol = Constants.CRLF;\n            }\n        }\n        // save EOL state here.\n        if (firstEol == null) {\n            if (ch == LF) {\n                this.firstEol = LF_STRING;\n            } else if (ch == CR) {\n                this.firstEol = CR_STRING;\n            }\n        }\n\n        return ch == LF || ch == CR;\n    }\n\n    // TODO escape handling needs more work\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link Constants#END_OF_STREAM} if char following the escape is\n     *      invalid.\n     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n     *      the escape character is not allowed at end of stream\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int ch = reader.read();\n        switch (ch) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return ch;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isMetaChar(ch)) {\n                return ch;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return END_OF_STREAM;\n        }\n    }\n\n    void trimTrailingSpaces(final StringBuilder buffer) {\n        int length = buffer.length();\n        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n            length = length - 1;\n        }\n        if (length != buffer.length()) {\n            buffer.setLength(length);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex 06b2c9c22..c43c52ed5 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -57,6 +57,8 @@ final class Lexer implements Closeable {\n \n     private final boolean ignoreSurroundingSpaces;\n     private final boolean ignoreEmptyLines;\n+    private final boolean allowTrailingText;\n+    private final boolean allowEofWithoutClosingQuote;\n \n     /** The input stream */\n     private final ExtendedBufferedReader reader;\n@@ -72,6 +74,8 @@ final class Lexer implements Closeable {\n         this.commentStart = mapNullToDisabled(format.getCommentMarker());\n         this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n         this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n+        this.allowTrailingText = format.getAllowTrailingText();\n+        this.allowEofWithoutClosingQuote = format.getAllowEofWithoutClosingQuote();\n         this.delimiterBuf = new char[delimiter.length - 1];\n         this.escapeDelimiterBuf = new char[2 * delimiter.length - 1];\n     }\n@@ -364,17 +368,27 @@ private Token parseEncapsulatedToken(final Token token) throws IOException {\n                             token.type = EORECORD;\n                             return token;\n                         }\n-                        if (!Character.isWhitespace((char)c)) {\n-                            // error invalid char between token and next delimiter\n-                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n-                                    \") invalid char between encapsulated token and delimiter\");\n+                        if (allowTrailingText) {\n+                            token.content.append((char) c);\n+                        } else {\n+                            if (!Character.isWhitespace((char)c)) {\n+                                // error invalid char between token and next delimiter\n+                                throw new IOException(\"(line \" + getCurrentLineNumber() +\n+                                        \") invalid char between encapsulated token and delimiter\");\n+                            }\n                         }\n                     }\n                 }\n             } else if (isEndOfFile(c)) {\n-                // error condition (end of file before end of token)\n-                throw new IOException(\"(startline \" + startLineNumber +\n-                        \") EOF reached before encapsulated token finished\");\n+                if (allowEofWithoutClosingQuote) {\n+                    token.type = EOF;\n+                    token.isReady = true; // There is data at EOF\n+                    return token;\n+                } else {\n+                    // error condition (end of file before end of token)\n+                    throw new IOException(\"(startline \" + startLineNumber +\n+                            \") EOF reached before encapsulated token finished\");\n+                }\n             } else {\n                 // consume character\n                 token.content.append((char) c);\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/LexerTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 279,
    "title": "CSVParser: Identify duplicates in null, empty and blank header names",
    "state": "closed",
    "created_at": "2022-10-25T16:20:02Z",
    "merge_commit_sha": "5a7b030537ac799c0a16e23336731d0fd49ae1f9",
    "base_sha": "8ad07df0d453a8066c708a0ff0edce1fdcd474cc",
    "head_sha": "69aa686187379af315bec1ca067f1b558f06ccf6",
    "user_login": "aherbert",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.CSVFormat.RFC4180;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    /**\n     * Test for the updated Javadoc comment in setAllowMissingColumnNames method.\n     */\n    @Test\n    public void testSetAllowMissingColumnNames() {\n        CSVFormat.Builder builder = CSVFormat.DEFAULT.builder();\n        CSVFormat format = builder.setAllowMissingColumnNames(true).build();\n        assertEquals(true, format.getAllowMissingColumnNames());\n\n        format = builder.setAllowMissingColumnNames(false).build();\n        assertEquals(false, format.getAllowMissingColumnNames());\n    }\n\n    /**\n     * Test for the updated Javadoc comment in setIgnoreHeaderCase method.\n     */\n    @Test\n    public void testSetIgnoreHeaderCase() {\n        CSVFormat.Builder builder = CSVFormat.DEFAULT.builder();\n        CSVFormat format = builder.setIgnoreHeaderCase(true).build();\n        assertEquals(true, format.getIgnoreHeaderCase());\n\n        format = builder.setIgnoreHeaderCase(false).build();\n        assertEquals(false, format.getIgnoreHeaderCase());\n    }\n\n    /**\n     * Test for the updated Javadoc comment in getIgnoreHeaderCase method.\n     */\n    @Test\n    public void testGetIgnoreHeaderCase() {\n        CSVFormat format = CSVFormat.DEFAULT.builder().setIgnoreHeaderCase(true).build();\n        assertEquals(true, format.getIgnoreHeaderCase());\n\n        format = CSVFormat.DEFAULT.builder().setIgnoreHeaderCase(false).build();\n        assertEquals(false, format.getIgnoreHeaderCase());\n    }\n}",
        "file_content": "/*\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n * this work for additional information regarding copyright ownership.\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n * (the \"License\"); you may not use this file except in compliance with\r\n * the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage org.apache.commons.csv;\r\n\r\nimport static org.apache.commons.csv.Constants.BACKSLASH;\r\nimport static org.apache.commons.csv.Constants.COMMA;\r\nimport static org.apache.commons.csv.Constants.COMMENT;\r\nimport static org.apache.commons.csv.Constants.CR;\r\nimport static org.apache.commons.csv.Constants.CRLF;\r\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\r\nimport static org.apache.commons.csv.Constants.EMPTY;\r\nimport static org.apache.commons.csv.Constants.LF;\r\nimport static org.apache.commons.csv.Constants.PIPE;\r\nimport static org.apache.commons.csv.Constants.SP;\r\nimport static org.apache.commons.csv.Constants.TAB;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Serializable;\r\nimport java.io.StringWriter;\r\nimport java.io.Writer;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.Arrays;\r\nimport java.util.HashSet;\r\nimport java.util.Objects;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Specifies the format of a CSV file for parsing and writing.\r\n *\r\n * <h2>Using predefined formats</h2>\r\n *\r\n * <p>\r\n * You can use one of the predefined formats:\r\n * </p>\r\n *\r\n * <ul>\r\n * <li>{@link #DEFAULT}</li>\r\n * <li>{@link #EXCEL}</li>\r\n * <li>{@link #INFORMIX_UNLOAD}</li>\r\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\r\n * <li>{@link #MYSQL}</li>\r\n * <li>{@link #RFC4180}</li>\r\n * <li>{@link #ORACLE}</li>\r\n * <li>{@link #POSTGRESQL_CSV}</li>\r\n * <li>{@link #POSTGRESQL_TEXT}</li>\r\n * <li>{@link #TDF}</li>\r\n * </ul>\r\n *\r\n * <p>\r\n * For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\r\n * </pre>\r\n *\r\n * <p>\r\n * The {@link CSVParser} provides static methods to parse other input types, for example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\r\n * </pre>\r\n *\r\n * <h2>Defining formats</h2>\r\n *\r\n * <p>\r\n * You can extend a format by calling the {@code set} methods. For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\r\n * </pre>\r\n *\r\n * <h2>Defining column names</h2>\r\n *\r\n * <p>\r\n * To define the column names you want to use to access records, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * Calling {@link Builder#setHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and assumes that your CSV source does not\r\n * contain a first record that also defines column names.\r\n *\r\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\r\n * {@link Builder#setSkipHeaderRecord(boolean)} with {@code true}.\r\n * </p>\r\n *\r\n * <h2>Parsing</h2>\r\n *\r\n * <p>\r\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * Reader in = ...;\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\r\n * </pre>\r\n *\r\n * <p>\r\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\r\n * </p>\r\n *\r\n * <h2>Referencing columns safely</h2>\r\n *\r\n * <p>\r\n * If your source contains a header record, you can simplify your code and safely reference columns, by using {@link Builder#setHeader(String...)} with no\r\n * arguments:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader();\r\n * </pre>\r\n *\r\n * <p>\r\n * This causes the parser to read the first record and use its values as column names.\r\n *\r\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\r\n * </p>\r\n *\r\n * <pre>\r\n * String value = record.get(&quot;Col1&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * This makes your code impervious to changes in column order in the CSV file.\r\n * </p>\r\n *\r\n * <h2>Serialization</h2>\r\n * <p>\r\n *   This class implements the {@link Serializable} interface with the following caveats:\r\n * </p>\r\n * <ul>\r\n *   <li>This class will no longer implement Serializable in 2.0.</li>\r\n *   <li>Serialization is not supported from one version to the next.</li>\r\n * </ul>\r\n * <p>\r\n *   The {@code serialVersionUID} values are:\r\n * </p>\r\n * <ul>\r\n *   <li>Version 1.10.0: {@code 2L}</li>\r\n *   <li>Version 1.9.0 through 1.0: {@code 1L}</li>\r\n * </ul>\r\n *\r\n * <h2>Notes</h2>\r\n * <p>\r\n * This class is immutable.\r\n * </p>\r\n * <p>\r\n * Not all settings are used for both parsing and writing.\r\n * </p>\r\n */\r\npublic final class CSVFormat implements Serializable {\r\n\r\n    /**\r\n     * Builds CSVFormat instances.\r\n     *\r\n     * @since 1.9.0\r\n     */\r\n    public static class Builder {\r\n\r\n        /**\r\n         * Creates a new default builder.\r\n         *\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create() {\r\n            return new Builder(CSVFormat.DEFAULT);\r\n        }\r\n\r\n        /**\r\n         * Creates a new builder for the given format.\r\n         *\r\n         * @param csvFormat the source format.\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create(final CSVFormat csvFormat) {\r\n            return new Builder(csvFormat);\r\n        }\r\n\r\n        private boolean allowMissingColumnNames;\r\n\r\n        private boolean autoFlush;\r\n\r\n        private Character commentMarker;\r\n\r\n        private String delimiter;\r\n\r\n        private DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n        private Character escapeCharacter;\r\n\r\n        private String[] headerComments;\r\n\r\n        private String[] headers;\r\n\r\n        private boolean ignoreEmptyLines;\r\n\r\n        private boolean ignoreHeaderCase;\r\n\r\n        private boolean ignoreSurroundingSpaces;\r\n\r\n        private String nullString;\r\n\r\n        private Character quoteCharacter;\r\n\r\n        private String quotedNullString;\r\n\r\n        private QuoteMode quoteMode;\r\n\r\n        private String recordSeparator;\r\n\r\n        private boolean skipHeaderRecord;\r\n\r\n        private boolean trailingDelimiter;\r\n\r\n        private boolean trim;\r\n\r\n        private Builder(final CSVFormat csvFormat) {\r\n            this.delimiter = csvFormat.delimiter;\r\n            this.quoteCharacter = csvFormat.quoteCharacter;\r\n            this.quoteMode = csvFormat.quoteMode;\r\n            this.commentMarker = csvFormat.commentMarker;\r\n            this.escapeCharacter = csvFormat.escapeCharacter;\r\n            this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;\r\n            this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;\r\n            this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;\r\n            this.recordSeparator = csvFormat.recordSeparator;\r\n            this.nullString = csvFormat.nullString;\r\n            this.headerComments = csvFormat.headerComments;\r\n            this.headers = csvFormat.headers;\r\n            this.skipHeaderRecord = csvFormat.skipHeaderRecord;\r\n            this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;\r\n            this.trailingDelimiter = csvFormat.trailingDelimiter;\r\n            this.trim = csvFormat.trim;\r\n            this.autoFlush = csvFormat.autoFlush;\r\n            this.quotedNullString = csvFormat.quotedNullString;\r\n            this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;\r\n        }\r\n\r\n        /**\r\n         * Builds a new CSVFormat instance.\r\n         *\r\n         * @return a new CSVFormat instance.\r\n         */\r\n        public CSVFormat build() {\r\n            return new CSVFormat(this);\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior, true to allow, false to disallow.\r\n         *\r\n         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n         * @return This instance.\r\n         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.\r\n         */\r\n        @Deprecated\r\n        public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n            setDuplicateHeaderMode(allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the missing column names parser behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\r\n         * {@link IllegalArgumentException} to be thrown.\r\n         *\r\n         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\r\n         *                                cause an {@link IllegalArgumentException} to be thrown.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n            this.allowMissingColumnNames = allowMissingColumnNames;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to flush on close.\r\n         *\r\n         * @param autoFlush whether to flush on close.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAutoFlush(final boolean autoFlush) {\r\n            this.autoFlush = autoFlush;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final char commentMarker) {\r\n            setCommentMarker(Character.valueOf(commentMarker));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final Character commentMarker) {\r\n            if (isLineBreak(commentMarker)) {\r\n                throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\r\n            }\r\n            this.commentMarker = commentMarker;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final char delimiter) {\r\n            return setDelimiter(String.valueOf(delimiter));\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final String delimiter) {\r\n            if (containsLineBreak(delimiter)) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n            }\r\n            if (delimiter.isEmpty()) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be empty\");\r\n            }\r\n            this.delimiter = delimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior.\r\n         *\r\n         * @param duplicateHeaderMode the duplicate header names behavior\r\n         * @return This instance.\r\n         * @since 1.10.0\r\n         */\r\n        public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {\r\n          this.duplicateHeaderMode = Objects.requireNonNull(duplicateHeaderMode, \"duplicateHeaderMode\");\r\n          return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final char escapeCharacter) {\r\n            setEscape(Character.valueOf(escapeCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final Character escapeCharacter) {\r\n            if (isLineBreak(escapeCharacter)) {\r\n                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\r\n            }\r\n            this.escapeCharacter = escapeCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header defined by the given {@link Enum} class.\r\n         *\r\n         * <p>\r\n         * Example:\r\n         * </p>\r\n         *\r\n         * <pre>\r\n         * public enum HeaderEnum {\r\n         *     Name, Email, Phone\r\n         * }\r\n         *\r\n         * Builder builder = builder.setHeader(HeaderEnum.class);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {\r\n            String[] header = null;\r\n            if (headerEnum != null) {\r\n                final Enum<?>[] enumValues = headerEnum.getEnumConstants();\r\n                header = new String[enumValues.length];\r\n                Arrays.setAll(header, i -> enumValues[i].name());\r\n            }\r\n            return setHeader(header);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSet);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSet resultSet) throws SQLException {\r\n            return setHeader(resultSet != null ? resultSet.getMetaData() : null);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSetMetaData);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n            String[] labels = null;\r\n            if (resultSetMetaData != null) {\r\n                final int columnCount = resultSetMetaData.getColumnCount();\r\n                labels = new String[columnCount];\r\n                for (int i = 0; i < columnCount; i++) {\r\n                    labels[i] = resultSetMetaData.getColumnLabel(i + 1);\r\n                }\r\n            }\r\n            return setHeader(labels);\r\n        }\r\n\r\n        /**\r\n         * Sets the header to the given values. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final String... header) {\r\n            this.headers = CSVFormat.clone(header);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final Object... headerComments) {\r\n            this.headerComments = CSVFormat.clone(toStringArray(headerComments));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * Builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final String... headerComments) {\r\n            this.headerComments = CSVFormat.clone(headerComments);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty\r\n         * records.\r\n         *\r\n         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate\r\n         *                         empty lines to empty records.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n            this.ignoreEmptyLines = ignoreEmptyLines;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         *\r\n         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n            this.ignoreHeaderCase = ignoreHeaderCase;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         *\r\n         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         *\r\n         * <ul>\r\n         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n         * </ul>\r\n         *\r\n         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         * @return This instance.\r\n         */\r\n        public Builder setNullString(final String nullString) {\r\n            this.nullString = nullString;\r\n            this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character.\r\n         *\r\n         * @param quoteCharacter the quote character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final char quoteCharacter) {\r\n            setQuote(Character.valueOf(quoteCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character, use {@code null} to disable.\r\n         *\r\n         * @param quoteCharacter the quote character, use {@code null} to disable.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final Character quoteCharacter) {\r\n            if (isLineBreak(quoteCharacter)) {\r\n                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\r\n            }\r\n            this.quoteCharacter = quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote policy to use for output.\r\n         *\r\n         * @param quoteMode the quote policy to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuoteMode(final QuoteMode quoteMode) {\r\n            this.quoteMode = quoteMode;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final char recordSeparator) {\r\n            this.recordSeparator = String.valueOf(recordSeparator);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final String recordSeparator) {\r\n            this.recordSeparator = recordSeparator;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to skip the header record.\r\n         *\r\n         * @param skipHeaderRecord whether to skip the header record.\r\n         * @return This instance.\r\n         */\r\n        public Builder setSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n            this.skipHeaderRecord = skipHeaderRecord;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to add a trailing delimiter.\r\n         *\r\n         * @param trailingDelimiter whether to add a trailing delimiter.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrailingDelimiter(final boolean trailingDelimiter) {\r\n            this.trailingDelimiter = trailingDelimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to trim leading and trailing blanks.\r\n         *\r\n         * @param trim whether to trim leading and trailing blanks.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrim(final boolean trim) {\r\n            this.trim = trim;\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Predefines formats.\r\n     *\r\n     * @since 1.2\r\n     */\r\n    public enum Predefined {\r\n\r\n        /**\r\n         * @see CSVFormat#DEFAULT\r\n         */\r\n        Default(CSVFormat.DEFAULT),\r\n\r\n        /**\r\n         * @see CSVFormat#EXCEL\r\n         */\r\n        Excel(CSVFormat.EXCEL),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD\r\n         * @since 1.3\r\n         */\r\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\r\n         * @since 1.3\r\n         */\r\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_CSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_TSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MYSQL\r\n         */\r\n        MySQL(CSVFormat.MYSQL),\r\n\r\n        /**\r\n         * @see CSVFormat#ORACLE\r\n         */\r\n        Oracle(CSVFormat.ORACLE),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         * @since 1.5\r\n         */\r\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         */\r\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\r\n\r\n        /**\r\n         * @see CSVFormat#RFC4180\r\n         */\r\n        RFC4180(CSVFormat.RFC4180),\r\n\r\n        /**\r\n         * @see CSVFormat#TDF\r\n         */\r\n        TDF(CSVFormat.TDF);\r\n\r\n        private final CSVFormat format;\r\n\r\n        Predefined(final CSVFormat format) {\r\n            this.format = format;\r\n        }\r\n\r\n        /**\r\n         * Gets the format.\r\n         *\r\n         * @return the format.\r\n         */\r\n        public CSVFormat getFormat() {\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing\r\n     * empty lines.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Default\r\n     */\r\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false,\r\n            false, false, false, DuplicateHeaderMode.ALLOW_ALL);\r\n\r\n    /**\r\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is locale dependent, it might be necessary\r\n     * to customize this format to accommodate to your regional settings.\r\n     *\r\n     * <p>\r\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setAllowMissingColumnNames(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     * <p>\r\n     * Note: This is currently like {@link #RFC4180} plus {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)} and\r\n     * {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(false)}.\r\n     * </p>\r\n     *\r\n     * @see Predefined#Excel\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat EXCEL = DEFAULT.builder()\r\n            .setIgnoreEmptyLines(false)\r\n            .setAllowMissingColumnNames(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.builder()\r\n            .setDelimiter(PIPE)\r\n            .setEscape(BACKSLASH)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with {@code '\"'}. A header line with field\r\n     * names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format. Values are double quoted only if needed and special\r\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\r\n     *          documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_TSV = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\r\n     *      -data.html</a>\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MYSQL = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default Oracle format used by the SQL*Loader utility.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\r\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\r\n     * {@code \"\"}. Values are trimmed.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setTrim()}</li>\r\n     * <li>{@code setSystemRecordSeparator()}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.MINIMAL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Oracle\r\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\r\n     * @since 1.6\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat ORACLE = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setTrim(true)\r\n            .setRecordSeparator(System.lineSeparator())\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\r\n     * characters are not escaped. The default NULL string is {@code \"\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape(null)}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(null)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(EMPTY)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL text format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(Constants.SQL_NULL_STRING)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#RFC4180\r\n     */\r\n    public static final CSVFormat RFC4180 = DEFAULT.builder().setIgnoreEmptyLines(false).build();\r\n\r\n    private static final long serialVersionUID = 2L;\r\n\r\n    /**\r\n     * Tab-delimited format.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreSurroundingSpaces(true)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#TDF\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat TDF = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setIgnoreSurroundingSpaces(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Null-safe clone of an array.\r\n     *\r\n     * @param <T>    The array element type.\r\n     * @param values the source array\r\n     * @return the cloned array.\r\n     */\r\n    @SafeVarargs\r\n    static <T> T[] clone(final T... values) {\r\n        return values == null ? null : values.clone();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains the search char.\r\n     *\r\n     * @param source the string to check.\r\n     * @param searchCh the character to search.\r\n     *\r\n     * @return true if {@code c} contains a line break character\r\n     */\r\n    private static boolean contains(final String source, final char searchCh) {\r\n        return Objects.requireNonNull(source, \"source\").indexOf(searchCh) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains a line break character.\r\n     *\r\n     * @param source the string to check.\r\n     *\r\n     * @return true if {@code c} contains a line break character.\r\n     */\r\n    private static boolean containsLineBreak(final String source) {\r\n        return contains(source, CR) || contains(source, LF);\r\n    }\r\n\r\n    static boolean isBlank(final String value) {\r\n        return value == null || value.trim().isEmpty();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check.\r\n     *\r\n     * @return true if {@code c} is a line break character.\r\n     */\r\n    private static boolean isLineBreak(final char c) {\r\n        return c == LF || c == CR;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check, may be null.\r\n     *\r\n     * @return true if {@code c} is a line break character (and not null).\r\n     */\r\n    private static boolean isLineBreak(final Character c) {\r\n        return c != null && isLineBreak(c.charValue());\r\n    }\r\n\r\n    /** Same test as in as {@link String#trim()}. */\r\n    private static boolean isTrimChar(final char ch) {\r\n        return ch <= SP;\r\n    }\r\n\r\n    /** Same test as in as {@link String#trim()}. */\r\n    private static boolean isTrimChar(final CharSequence charSequence, final int pos) {\r\n        return isTrimChar(charSequence.charAt(pos));\r\n    }\r\n\r\n    /**\r\n     * Creates a new CSV format with the specified delimiter.\r\n     *\r\n     * <p>\r\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.\r\n     * </p>\r\n     *\r\n     * @param delimiter the char used for value separation, must not be a line break character\r\n     * @return a new CSV format.\r\n     * @throws IllegalArgumentException if the delimiter is a line break character\r\n     *\r\n     * @see #DEFAULT\r\n     * @see #RFC4180\r\n     * @see #MYSQL\r\n     * @see #EXCEL\r\n     * @see #TDF\r\n     */\r\n    public static CSVFormat newFormat(final char delimiter) {\r\n        return new CSVFormat(String.valueOf(delimiter), null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false,\r\n                DuplicateHeaderMode.ALLOW_ALL);\r\n    }\r\n\r\n    static String[] toStringArray(final Object[] values) {\r\n        if (values == null) {\r\n            return null;\r\n        }\r\n        final String[] strings = new String[values.length];\r\n        Arrays.setAll(strings, i -> Objects.toString(values[i], null));\r\n        return strings;\r\n    }\r\n\r\n    static CharSequence trim(final CharSequence charSequence) {\r\n        if (charSequence instanceof String) {\r\n            return ((String) charSequence).trim();\r\n        }\r\n        final int count = charSequence.length();\r\n        int len = count;\r\n        int pos = 0;\r\n\r\n        while (pos < len && isTrimChar(charSequence, pos)) {\r\n            pos++;\r\n        }\r\n        while (pos < len && isTrimChar(charSequence, len - 1)) {\r\n            len--;\r\n        }\r\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\r\n    }\r\n\r\n    /**\r\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\r\n     *\r\n     * @param format name\r\n     * @return one of the predefined formats\r\n     * @since 1.2\r\n     */\r\n    public static CSVFormat valueOf(final String format) {\r\n        return CSVFormat.Predefined.valueOf(format).getFormat();\r\n    }\r\n\r\n    private final DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n    private final boolean allowMissingColumnNames;\r\n\r\n    private final boolean autoFlush;\r\n\r\n    private final Character commentMarker; // null if commenting is disabled\r\n\r\n    private final String delimiter;\r\n\r\n    private final Character escapeCharacter; // null if escaping is disabled\r\n\r\n    private final String[] headers; // array of header column names\r\n\r\n    private final String[] headerComments; // array of header comment lines\r\n\r\n    private final boolean ignoreEmptyLines;\r\n\r\n    private final boolean ignoreHeaderCase; // should ignore header names case\r\n\r\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\r\n\r\n    private final String nullString; // the string to be used for null values\r\n\r\n    private final Character quoteCharacter; // null if quoting is disabled\r\n\r\n    private final String quotedNullString;\r\n\r\n    private final QuoteMode quoteMode;\r\n\r\n    private final String recordSeparator; // for outputs\r\n\r\n    private final boolean skipHeaderRecord;\r\n\r\n    private final boolean trailingDelimiter;\r\n\r\n    private final boolean trim;\r\n\r\n    private CSVFormat(final Builder builder) {\r\n        this.delimiter = builder.delimiter;\r\n        this.quoteCharacter = builder.quoteCharacter;\r\n        this.quoteMode = builder.quoteMode;\r\n        this.commentMarker = builder.commentMarker;\r\n        this.escapeCharacter = builder.escapeCharacter;\r\n        this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = builder.allowMissingColumnNames;\r\n        this.ignoreEmptyLines = builder.ignoreEmptyLines;\r\n        this.recordSeparator = builder.recordSeparator;\r\n        this.nullString = builder.nullString;\r\n        this.headerComments = builder.headerComments;\r\n        this.headers = builder.headers;\r\n        this.skipHeaderRecord = builder.skipHeaderRecord;\r\n        this.ignoreHeaderCase = builder.ignoreHeaderCase;\r\n        this.trailingDelimiter = builder.trailingDelimiter;\r\n        this.trim = builder.trim;\r\n        this.autoFlush = builder.autoFlush;\r\n        this.quotedNullString = builder.quotedNullString;\r\n        this.duplicateHeaderMode = builder.duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    /**\r\n     * Creates a customized CSV format.\r\n     *\r\n     * @param delimiter               the char used for value separation, must not be a line break character.\r\n     * @param quoteChar               the Character used as value encapsulation marker, may be {@code null} to disable.\r\n     * @param quoteMode               the quote mode.\r\n     * @param commentStart            the Character used for comment identification, may be {@code null} to disable.\r\n     * @param escape                  the Character used to escape special characters in values, may be {@code null} to disable.\r\n     * @param ignoreSurroundingSpaces {@code true} when whitespaces enclosing values should be ignored.\r\n     * @param ignoreEmptyLines        {@code true} when the parser should skip empty lines.\r\n     * @param recordSeparator         the line separator to use for output.\r\n     * @param nullString              the line separator to use for output.\r\n     * @param headerComments          the comments to be printed by the Printer before the actual CSV data.\r\n     * @param header                  the header\r\n     * @param skipHeaderRecord        TODO Doc me.\r\n     * @param allowMissingColumnNames TODO Doc me.\r\n     * @param ignoreHeaderCase        TODO Doc me.\r\n     * @param trim                    TODO Doc me.\r\n     * @param trailingDelimiter       TODO Doc me.\r\n     * @param autoFlush               TODO Doc me.\r\n     * @param duplicateHeaderMode     the behavior when handling duplicate headers\r\n     * @throws IllegalArgumentException if the delimiter is a line break character.\r\n     */\r\n    private CSVFormat(final String delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape,\r\n            final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\r\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames,\r\n            final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush,\r\n            final DuplicateHeaderMode duplicateHeaderMode) {\r\n        this.delimiter = delimiter;\r\n        this.quoteCharacter = quoteChar;\r\n        this.quoteMode = quoteMode;\r\n        this.commentMarker = commentStart;\r\n        this.escapeCharacter = escape;\r\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = allowMissingColumnNames;\r\n        this.ignoreEmptyLines = ignoreEmptyLines;\r\n        this.recordSeparator = recordSeparator;\r\n        this.nullString = nullString;\r\n        this.headerComments = toStringArray(headerComments);\r\n        this.headers = clone(header);\r\n        this.skipHeaderRecord = skipHeaderRecord;\r\n        this.ignoreHeaderCase = ignoreHeaderCase;\r\n        this.trailingDelimiter = trailingDelimiter;\r\n        this.trim = trim;\r\n        this.autoFlush = autoFlush;\r\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n        this.duplicateHeaderMode = duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    private void append(final char c, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(c);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    private void append(final CharSequence csq, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(csq);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    /**\r\n     * Creates a new Builder for this instance.\r\n     *\r\n     * @return a new Builder.\r\n     */\r\n    public Builder builder() {\r\n        return Builder.create(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a copy of this instance.\r\n     *\r\n     * @return a copy of this instance.\r\n     */\r\n    CSVFormat copy() {\r\n        return builder().build();\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(final Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null || getClass() != obj.getClass()) {\r\n            return false;\r\n        }\r\n        final CSVFormat other = (CSVFormat) obj;\r\n        return duplicateHeaderMode == other.duplicateHeaderMode && allowMissingColumnNames == other.allowMissingColumnNames &&\r\n                autoFlush == other.autoFlush && Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) &&\r\n                Objects.equals(escapeCharacter, other.escapeCharacter) && Arrays.equals(headers, other.headers) &&\r\n                Arrays.equals(headerComments, other.headerComments) && ignoreEmptyLines == other.ignoreEmptyLines &&\r\n                ignoreHeaderCase == other.ignoreHeaderCase && ignoreSurroundingSpaces == other.ignoreSurroundingSpaces &&\r\n                Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) && quoteMode == other.quoteMode &&\r\n                Objects.equals(quotedNullString, other.quotedNullString) && Objects.equals(recordSeparator, other.recordSeparator) &&\r\n                skipHeaderRecord == other.skipHeaderRecord && trailingDelimiter == other.trailingDelimiter && trim == other.trim;\r\n    }\r\n\r\n    /**\r\n     * Formats the specified values.\r\n     *\r\n     * @param values the values to format\r\n     * @return the formatted values\r\n     */\r\n    public String format(final Object... values) {\r\n        final StringWriter out = new StringWriter();\r\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\r\n            csvPrinter.printRecord(values);\r\n            final String res = out.toString();\r\n            final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\r\n            return res.substring(0, len);\r\n        } catch (final IOException e) {\r\n            // should not happen because a StringWriter does not do IO.\r\n            throw new IllegalStateException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether duplicate names are allowed in the headers.\r\n     *\r\n     * @return whether duplicate header names are allowed\r\n     * @since 1.7\r\n     * @deprecated Use {@link #getDuplicateHeaderMode()}.\r\n     */\r\n    @Deprecated\r\n    public boolean getAllowDuplicateHeaderNames() {\r\n        return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;\r\n    }\r\n\r\n    /**\r\n     * Gets whether missing column names are allowed when parsing the header line.\r\n     *\r\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an {@link IllegalArgumentException}.\r\n     */\r\n    public boolean getAllowMissingColumnNames() {\r\n        return allowMissingColumnNames;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to flush on close.\r\n     *\r\n     * @return whether to flush on close.\r\n     * @since 1.6\r\n     */\r\n    public boolean getAutoFlush() {\r\n        return autoFlush;\r\n    }\r\n\r\n    /**\r\n     * Gets the character marking the start of a line comment.\r\n     *\r\n     * @return the comment start marker, may be {@code null}\r\n     */\r\n    public Character getCommentMarker() {\r\n        return commentMarker;\r\n    }\r\n\r\n    /**\r\n     * Gets the first character delimiting the values (typically ';', ',' or '\\t').\r\n     *\r\n     * @return the first delimiter character.\r\n     * @deprecated Use {@link #getDelimiterString()}.\r\n     */\r\n    @Deprecated\r\n    public char getDelimiter() {\r\n        return delimiter.charAt(0);\r\n    }\r\n\r\n    /**\r\n     * Gets the character delimiting the values (typically \";\", \",\" or \"\\t\").\r\n     *\r\n     * @return the delimiter.\r\n     * @since 1.9.0\r\n     */\r\n    public String getDelimiterString() {\r\n        return delimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets how duplicate headers are handled.\r\n     *\r\n     * @return if duplicate header values are allowed, allowed conditionally, or disallowed.\r\n     * @since 1.10.0\r\n     */\r\n    public DuplicateHeaderMode getDuplicateHeaderMode() {\r\n        return duplicateHeaderMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the escape character.\r\n     *\r\n     * @return the escape character, may be {@code null}\r\n     */\r\n    public Character getEscapeCharacter() {\r\n        return escapeCharacter;\r\n    }\r\n\r\n    /**\r\n     * Gets a copy of the header array.\r\n     *\r\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\r\n     */\r\n    public String[] getHeader() {\r\n        return headers != null ? headers.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Gets a copy of the header comment array.\r\n     *\r\n     * @return a copy of the header comment array; {@code null} if disabled.\r\n     */\r\n    public String[] getHeaderComments() {\r\n        return headerComments != null ? headerComments.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Gets whether empty lines between records are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty records.\r\n     */\r\n    public boolean getIgnoreEmptyLines() {\r\n        return ignoreEmptyLines;\r\n    }\r\n\r\n    /**\r\n     * Gets whether header names will be accessed ignoring case.\r\n     *\r\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\r\n     * @since 1.3\r\n     */\r\n    public boolean getIgnoreHeaderCase() {\r\n        return ignoreHeaderCase;\r\n    }\r\n\r\n    /**\r\n     * Gets whether spaces around values are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\r\n     */\r\n    public boolean getIgnoreSurroundingSpaces() {\r\n        return ignoreSurroundingSpaces;\r\n    }\r\n\r\n    /**\r\n     * Gets the String to convert to and from {@code null}.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     */\r\n    public String getNullString() {\r\n        return nullString;\r\n    }\r\n\r\n    /**\r\n     * Gets the character used to encapsulate values containing special characters.\r\n     *\r\n     * @return the quoteChar character, may be {@code null}\r\n     */\r\n    public Character getQuoteCharacter() {\r\n        return quoteCharacter;\r\n    }\r\n\r\n    /**\r\n     * Gets the quote policy output fields.\r\n     *\r\n     * @return the quote policy\r\n     */\r\n    public QuoteMode getQuoteMode() {\r\n        return quoteMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the record separator delimiting output records.\r\n     *\r\n     * @return the record separator\r\n     */\r\n    public String getRecordSeparator() {\r\n        return recordSeparator;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to skip the header record.\r\n     *\r\n     * @return whether to skip the header record.\r\n     */\r\n    public boolean getSkipHeaderRecord() {\r\n        return skipHeaderRecord;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to add a trailing delimiter.\r\n     *\r\n     * @return whether to add a trailing delimiter.\r\n     * @since 1.3\r\n     */\r\n    public boolean getTrailingDelimiter() {\r\n        return trailingDelimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets whether to trim leading and trailing blanks. This is used by {@link #print(Object, Appendable, boolean)} Also by\r\n     * {CSVParser#addRecordValue(boolean)}\r\n     *\r\n     * @return whether to trim leading and trailing blanks.\r\n     */\r\n    public boolean getTrim() {\r\n        return trim;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + Arrays.hashCode(headers);\r\n        result = prime * result + Arrays.hashCode(headerComments);\r\n        return prime * result + Objects.hash(duplicateHeaderMode, allowMissingColumnNames, autoFlush, commentMarker, delimiter, escapeCharacter,\r\n                ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator,\r\n                skipHeaderRecord, trailingDelimiter, trim);\r\n    }\r\n\r\n    /**\r\n     * Tests whether comments are supported by this format.\r\n     *\r\n     * Note that the comment introducer character is only recognized at the start of a line.\r\n     *\r\n     * @return {@code true} is comments are supported, {@code false} otherwise\r\n     */\r\n    public boolean isCommentMarkerSet() {\r\n        return commentMarker != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether the next characters constitute a delimiter\r\n     *\r\n     * @param ch\r\n     *            the current char\r\n     * @param charSeq\r\n     *            the match char sequence\r\n     * @param startIndex\r\n     *            where start to match\r\n     * @param delimiter\r\n     *            the delimiter\r\n     * @param delimiterLength\r\n     *            the delimiter length\r\n     * @return true if the match is successful\r\n     */\r\n    private boolean isDelimiter(final char ch, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength) {\r\n        if (ch != delimiter[0]) {\r\n            return false;\r\n        }\r\n        final int len = charSeq.length();\r\n        if (startIndex + delimiterLength > len) {\r\n            return false;\r\n        }\r\n        for (int i = 1; i < delimiterLength; i++) {\r\n            if (charSeq.charAt(startIndex + i) != delimiter[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests whether escape are being processed.\r\n     *\r\n     * @return {@code true} if escapes are processed\r\n     */\r\n    public boolean isEscapeCharacterSet() {\r\n        return escapeCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether a nullString has been defined.\r\n     *\r\n     * @return {@code true} if a nullString is defined\r\n     */\r\n    public boolean isNullStringSet() {\r\n        return nullString != null;\r\n    }\r\n\r\n    /**\r\n     * Tests whether a quoteChar has been defined.\r\n     *\r\n     * @return {@code true} if a quoteChar is defined\r\n     */\r\n    public boolean isQuoteCharacterSet() {\r\n        return quoteCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Parses the specified content.\r\n     *\r\n     * <p>\r\n     * See also the various static parse methods on {@link CSVParser}.\r\n     * </p>\r\n     *\r\n     * @param reader the input stream\r\n     * @return a parser over a stream of {@link CSVRecord}s.\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    public CSVParser parse(final Reader reader) throws IOException {\r\n        return new CSVParser(reader, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out the output.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     */\r\n    public CSVPrinter print(final Appendable out) throws IOException {\r\n        return new CSVPrinter(out, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\r\n        // The writer will be closed when close() is called.\r\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\r\n    }\r\n\r\n    /**\r\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated as needed. Useful when one wants to\r\n     * avoid creating CSVPrinters. Trims the value if {@link #getTrim()} is true.\r\n     *\r\n     * @param value     value to output.\r\n     * @param out       where to print the value.\r\n     * @param newRecord if this a new record.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\r\n        // null values are considered empty\r\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\r\n        CharSequence charSequence;\r\n        if (value == null) {\r\n            // https://issues.apache.org/jira/browse/CSV-203\r\n            if (null == nullString) {\r\n                charSequence = EMPTY;\r\n            } else if (QuoteMode.ALL == quoteMode) {\r\n                charSequence = quotedNullString;\r\n            } else {\r\n                charSequence = nullString;\r\n            }\r\n        } else if (value instanceof CharSequence) {\r\n            charSequence = (CharSequence) value;\r\n        } else if (value instanceof Reader) {\r\n            print((Reader) value, out, newRecord);\r\n            return;\r\n        } else {\r\n            charSequence = value.toString();\r\n        }\r\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\r\n        print(value, charSequence, out, newRecord);\r\n    }\r\n\r\n    private synchronized void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\r\n        final int offset = 0;\r\n        final int len = value.length();\r\n        if (!newRecord) {\r\n            out.append(getDelimiterString());\r\n        }\r\n        if (object == null) {\r\n            out.append(value);\r\n        } else if (isQuoteCharacterSet()) {\r\n            // the original object is needed so can check for Number\r\n            printWithQuotes(object, value, out, newRecord);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(value, out);\r\n        } else {\r\n            out.append(value, offset, len);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output, returns a {@code CSVPrinter} which the caller MUST close.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\r\n        return print(Files.newBufferedWriter(out, charset));\r\n    }\r\n\r\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\r\n        // Reader is never null\r\n        if (!newRecord) {\r\n            append(getDelimiterString(), out);\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            printWithQuotes(reader, out);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(reader, out);\r\n        } else if (out instanceof Writer) {\r\n            IOUtils.copyLarge(reader, (Writer) out);\r\n        } else {\r\n            IOUtils.copy(reader, out);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Prints to the {@link System#out}.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @return a printer to {@link System#out}.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    public CSVPrinter printer() throws IOException {\r\n        return new CSVPrinter(System.out, this);\r\n    }\r\n\r\n    /**\r\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\r\n     *\r\n     * @param appendable where to write\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void println(final Appendable appendable) throws IOException {\r\n        if (getTrailingDelimiter()) {\r\n            append(getDelimiterString(), appendable);\r\n        }\r\n        if (recordSeparator != null) {\r\n            append(recordSeparator, appendable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the record separator.\r\n     *\r\n     * <p>\r\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing\r\n     * the record, so there is no need to call {@link #println(Appendable)}.\r\n     * </p>\r\n     *\r\n     * @param appendable    where to write.\r\n     * @param values values to output.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException {\r\n        for (int i = 0; i < values.length; i++) {\r\n            print(values[i], appendable, i == 0);\r\n        }\r\n        println(appendable);\r\n    }\r\n\r\n    /*\r\n     * Note: Must only be called if escaping is enabled, otherwise will generate NPE.\r\n     */\r\n    private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int end = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n\r\n        while (pos < end) {\r\n            char c = charSeq.charAt(pos);\r\n            final boolean isDelimiterStart = isDelimiter(c, charSeq, pos, delim, delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    appendable.append(charSeq, start, pos);\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                appendable.append(escape);\r\n                appendable.append(c);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        pos++;\r\n                        c = charSeq.charAt(pos);\r\n                        appendable.append(escape);\r\n                        appendable.append(c);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            appendable.append(charSeq, start, pos);\r\n        }\r\n    }\r\n\r\n    private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n\r\n        @SuppressWarnings(\"resource\") // Temp reader on input reader.\r\n        final ExtendedBufferedReader bufferedReader = new ExtendedBufferedReader(reader);\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        int c;\r\n        while (-1 != (c = bufferedReader.read())) {\r\n            builder.append((char) c);\r\n            final boolean isDelimiterStart = isDelimiter((char) c, builder.toString() + new String(bufferedReader.lookAhead(delimLength - 1)), pos, delim,\r\n                    delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    append(builder.substring(start, pos), appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                append(escape, appendable);\r\n                append((char) c, appendable);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        c = bufferedReader.read();\r\n                        append(escape, appendable);\r\n                        append((char) c, appendable);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            append(builder.substring(start, pos), appendable);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\r\n     */\r\n    // the original object is needed so can check for Number\r\n    private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\r\n        boolean quote = false;\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int len = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char quoteChar = getQuoteCharacter().charValue();\r\n        // If escape char not specified, default to the quote char\r\n        // This avoids having to keep checking whether there is an escape character\r\n        // at the cost of checking against quote twice\r\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\r\n\r\n        QuoteMode quoteModePolicy = getQuoteMode();\r\n        if (quoteModePolicy == null) {\r\n            quoteModePolicy = QuoteMode.MINIMAL;\r\n        }\r\n        switch (quoteModePolicy) {\r\n        case ALL:\r\n        case ALL_NON_NULL:\r\n            quote = true;\r\n            break;\r\n        case NON_NUMERIC:\r\n            quote = !(object instanceof Number);\r\n            break;\r\n        case NONE:\r\n            // Use the existing escaping code\r\n            printWithEscapes(charSeq, out);\r\n            return;\r\n        case MINIMAL:\r\n            if (len <= 0) {\r\n                // always quote an empty token that is the first\r\n                // on the line, as it may be the only thing on the\r\n                // line. If it were not quoted in that case,\r\n                // an empty line has no tokens.\r\n                if (newRecord) {\r\n                    quote = true;\r\n                }\r\n            } else {\r\n                char c = charSeq.charAt(pos);\r\n\r\n                if (c <= COMMENT) {\r\n                    // Some other chars at the start of a value caused the parser to fail, so for now\r\n                    // encapsulate if we start in anything less than '#'. We are being conservative\r\n                    // by including the default comment char too.\r\n                    quote = true;\r\n                } else {\r\n                    while (pos < len) {\r\n                        c = charSeq.charAt(pos);\r\n                        if (c == LF || c == CR || c == quoteChar || c == escapeChar || isDelimiter(c, charSeq, pos, delim, delimLength)) {\r\n                            quote = true;\r\n                            break;\r\n                        }\r\n                        pos++;\r\n                    }\r\n\r\n                    if (!quote) {\r\n                        pos = len - 1;\r\n                        c = charSeq.charAt(pos);\r\n                        // Some other chars at the end caused the parser to fail, so for now\r\n                        // encapsulate if we end in anything less than ' '\r\n                        if (isTrimChar(c)) {\r\n                            quote = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!quote) {\r\n                // no encapsulation needed - write out the original value\r\n                out.append(charSeq, start, len);\r\n                return;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\r\n        }\r\n\r\n        if (!quote) {\r\n            // no encapsulation needed - write out the original value\r\n            out.append(charSeq, start, len);\r\n            return;\r\n        }\r\n\r\n        // we hit something that needed encapsulation\r\n        out.append(quoteChar);\r\n\r\n        // Pick up where we left off: pos should be positioned on the first character that caused\r\n        // the need for encapsulation.\r\n        while (pos < len) {\r\n            final char c = charSeq.charAt(pos);\r\n            if (c == quoteChar || c == escapeChar) {\r\n                // write out the chunk up until this point\r\n                out.append(charSeq, start, pos);\r\n                out.append(escapeChar); // now output the escape\r\n                start = pos; // and restart with the matched char\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write the last segment\r\n        out.append(charSeq, start, pos);\r\n        out.append(quoteChar);\r\n    }\r\n\r\n    /**\r\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\r\n     *\r\n     * @param reader What to print\r\n     * @param appendable Where to print it\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {\r\n\r\n        if (getQuoteMode() == QuoteMode.NONE) {\r\n            printWithEscapes(reader, appendable);\r\n            return;\r\n        }\r\n\r\n        int pos = 0;\r\n\r\n        final char quote = getQuoteCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        append(quote, appendable);\r\n\r\n        int c;\r\n        while (-1 != (c = reader.read())) {\r\n            builder.append((char) c);\r\n            if (c == quote) {\r\n                // write out segment up until this char\r\n                if (pos > 0) {\r\n                    append(builder.substring(0, pos), appendable);\r\n                    append(quote, appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n\r\n                append((char) c, appendable);\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > 0) {\r\n            append(builder.substring(0, pos), appendable);\r\n        }\r\n\r\n        append(quote, appendable);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        final StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\r\n        if (isEscapeCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\r\n        }\r\n        if (quoteMode != null) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\r\n        }\r\n        if (isCommentMarkerSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\r\n        }\r\n        if (isNullStringSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"NullString=<\").append(nullString).append('>');\r\n        }\r\n        if (recordSeparator != null) {\r\n            sb.append(' ');\r\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\r\n        }\r\n        if (getIgnoreEmptyLines()) {\r\n            sb.append(\" EmptyLines:ignored\");\r\n        }\r\n        if (getIgnoreSurroundingSpaces()) {\r\n            sb.append(\" SurroundingSpaces:ignored\");\r\n        }\r\n        if (getIgnoreHeaderCase()) {\r\n            sb.append(\" IgnoreHeaderCase:ignored\");\r\n        }\r\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\r\n        if (headerComments != null) {\r\n            sb.append(' ');\r\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\r\n        }\r\n        if (headers != null) {\r\n            sb.append(' ');\r\n            sb.append(\"Header:\").append(Arrays.toString(headers));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    String trim(final String value) {\r\n        return getTrim() ? value.trim() : value;\r\n    }\r\n\r\n    /**\r\n     * Verifies the validity and consistency of the attributes, and throws an {@link IllegalArgumentException} if necessary.\r\n     * <p>\r\n     * Because an instance can be used for both writing an parsing, not all conditions can be tested here. For example allowMissingColumnNames is only used for\r\n     * parsing, so it cannot be used here.\r\n     * </p>\r\n     *\r\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.\r\n     */\r\n    private void validate() throws IllegalArgumentException {\r\n        if (containsLineBreak(delimiter)) {\r\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n        }\r\n\r\n        if (quoteCharacter != null && contains(delimiter, quoteCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && contains(delimiter, escapeCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\r\n        }\r\n\r\n        if (commentMarker != null && contains(delimiter, commentMarker.charValue())) {\r\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\r\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\r\n        }\r\n\r\n        // Validate headers\r\n        if (headers != null && duplicateHeaderMode != DuplicateHeaderMode.ALLOW_ALL) {\r\n            final Set<String> dupCheckSet = new HashSet<>(headers.length);\r\n            final boolean emptyDuplicatesAllowed = duplicateHeaderMode == DuplicateHeaderMode.ALLOW_EMPTY;\r\n            for (String header : headers) {\r\n                final boolean blank = isBlank(header);\r\n                // Sanitise all empty headers to the empty string \"\" when checking duplicates\r\n                final boolean containsHeader = !dupCheckSet.add(blank ? \"\" : header);\r\n                if (containsHeader && !(blank && emptyDuplicatesAllowed)) {\r\n                    throw new IllegalArgumentException(\r\n                        String.format(\r\n                            \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\r\n                            header, Arrays.toString(headers)));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} that allows duplicate header names.\r\n     *\r\n     * @return a new {@code CSVFormat} that allows duplicate header names\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean) Builder#setAllowDuplicateHeaderNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames() {\r\n        return builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     *\r\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n        final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\r\n        return builder().setDuplicateHeaderMode(mode).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @see Builder#setAllowMissingColumnNames(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames() {\r\n        return builder().setAllowMissingColumnNames(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\r\n     *\r\n     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause\r\n     *                                an {@link IllegalArgumentException} to be thrown.\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n        return builder().setAllowMissingColumnNames(allowMissingColumnNames).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to flush on close.\r\n     *\r\n     * @param autoFlush whether to flush on close.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setAutoFlush(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\r\n        return builder().setAutoFlush(autoFlush).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final char commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final Character commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the delimiter of the format set to the specified character.\r\n     *\r\n     * @param delimiter the delimiter character\r\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setDelimiter(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withDelimiter(final char delimiter) {\r\n        return builder().setDelimiter(delimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final char escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final Character escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} using the first record as header.\r\n     *\r\n     * <p>\r\n     * Calling this method is equivalent to calling:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\r\n     * </pre>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but using the first record as header.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(String...) Builder#setHeader()}.{@link Builder#setSkipHeaderRecord(boolean) setSkipHeaderRecord(true)}.\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withFirstRecordAsHeader() {\r\n        // @formatter:off\r\n        return builder()\r\n                .setHeader()\r\n                .setSkipHeaderRecord(true)\r\n                .build();\r\n        // @formatter:on\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format defined by the enum class.\r\n     *\r\n     * <p>\r\n     * Example:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * public enum Header {\r\n     *     Name, Email, Phone\r\n     * }\r\n     *\r\n     * CSVFormat format = aformat.withHeader(Header.class);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setHeader(String...)\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(Class)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\r\n        return builder().setHeader(headerEnum).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(resultSet);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSet)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\r\n        return builder().setHeader(resultSet).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(metaData);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSetMetaData)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n        return builder().setHeader(resultSetMetaData).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file\r\n     * with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @deprecated Use {@link Builder#setHeader(String...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final String... header) {\r\n        return builder().setHeader(header).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.\r\n     * This setting is ignored by the parser.\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n     * </pre>\r\n     *\r\n     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeaderComments(Object...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeaderComments(final Object... headerComments) {\r\n        return builder().setHeaderComments(headerComments).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @see Builder#setIgnoreEmptyLines(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines() {\r\n        return builder().setIgnoreEmptyLines(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty\r\n     *                         lines to empty records.\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n        return builder().setIgnoreEmptyLines(ignoreEmptyLines).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that will ignore case header name.\r\n     * @see Builder#setIgnoreHeaderCase(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean) Builder#setIgnoreHeaderCase(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase() {\r\n        return builder().setIgnoreHeaderCase(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether header names should be accessed ignoring case.\r\n     *\r\n     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n        return builder().setIgnoreHeaderCase(ignoreHeaderCase).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\r\n     * @see Builder#setIgnoreSurroundingSpaces(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean) Builder#setIgnoreSurroundingSpaces(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces() {\r\n        return builder().setIgnoreSurroundingSpaces(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n        return builder().setIgnoreSurroundingSpaces(ignoreSurroundingSpaces).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with conversions to and from null for strings on input and output.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\r\n     * @deprecated Use {@link Builder#setNullString(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withNullString(final String nullString) {\r\n        return builder().setNullString(nullString).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final char quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character, use {@code null} to disable.\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final Character quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\r\n     *\r\n     * @param quoteMode the quote policy to use for output.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\r\n     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuoteMode(final QuoteMode quoteMode) {\r\n        return builder().setQuoteMode(quoteMode).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified character.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @deprecated Use {@link Builder#setRecordSeparator(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified String.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with skipping the header record set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean) Builder#setSkipHeaderRecord(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord() {\r\n        return builder().setSkipHeaderRecord(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to skip the header record.\r\n     *\r\n     * @param skipHeaderRecord whether to skip the header record.\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setHeader(String...)\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n        return builder().setSkipHeaderRecord(skipHeaderRecord).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows\r\n     * and LF on Linux.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSystemRecordSeparator() {\r\n        return builder().setRecordSeparator(System.lineSeparator()).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} to add a trailing delimiter.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean) Builder#setTrailingDelimiter(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter() {\r\n        return builder().setTrailingDelimiter(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to add a trailing delimiter.\r\n     *\r\n     * @param trailingDelimiter whether to add a trailing delimiter.\r\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\r\n        return builder().setTrailingDelimiter(trailingDelimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean) Builder#setTrim(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim() {\r\n        return builder().setTrim(true).build();\r\n    }\r\n\r\n    /**\r\n     * Builds a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @param trim whether to trim leading and trailing blanks.\r\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim(final boolean trim) {\r\n        return builder().setTrim(trim).build();\r\n    }\r\n}\r",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 954f08cb5..1626a6a90 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -289,7 +289,7 @@ public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNa\n         }\r\n \r\n         /**\r\n-         * Sets the missing column names parser behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\r\n+         * Sets the parser missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\r\n          * {@link IllegalArgumentException} to be thrown.\r\n          *\r\n          * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\r\n@@ -564,7 +564,7 @@ public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n         }\r\n \r\n         /**\r\n-         * Sets the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n+         * Sets the parser case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n          *\r\n          * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n          * @return This instance.\r\n@@ -1599,7 +1599,7 @@ public boolean getIgnoreEmptyLines() {\n     }\r\n \r\n     /**\r\n-     * Gets whether header names will be accessed ignoring case.\r\n+     * Gets whether header names will be accessed ignoring case when parsing input.\r\n      *\r\n      * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\r\n      * @since 1.3\r\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport java.io.StringReader;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVParserTest2 {\n\n    @Test\n    public void testDuplicateHeadersWithMissingColumnNames() {\n        // Test case to ensure IllegalArgumentException is thrown when duplicate headers with missing column names are not allowed\n        String csvData = \"a,,a\\n1,2,3\\nx,y,z\";\n        assertThrows(IllegalArgumentException.class, () -> {\n            CSVParser.parse(csvData, CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames(false));\n        });\n    }\n\n    @Test\n    public void testDuplicateHeadersWithAllowedMissingColumnNames() {\n        // Test case to ensure no exception is thrown when duplicate headers with missing column names are allowed\n        String csvData = \"a,,a\\n1,2,3\\nx,y,z\";\n        try (CSVParser parser = CSVParser.parse(csvData, CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames(true))) {\n            parser.getRecords();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Test failed: Exception should not be thrown when missing column names are allowed\", e);\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.UncheckedIOException;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n\n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n\n            return this.current != null;\n        }\n\n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n\n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n\n            return next;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Header information based on name and position.\n     */\n    private static final class Headers {\n\n        /**\n         * Header column positions (0-based)\n         */\n        final Map<String, Integer> headerMap;\n\n        /**\n         * Header names in column order\n         */\n        final List<String> headerNames;\n\n        Headers(final Map<String, Integer> headerMap, final List<String> headerNames) {\n            this.headerMap = headerMap;\n            this.headerNames = headerNames;\n        }\n    }\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        return parse(file.toPath(), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        Objects.requireNonNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates and returns a parser for the given {@link Path}, which the caller MUST close.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(path, \"path\");\n        Objects.requireNonNull(format, \"format\");\n        return parse(Files.newInputStream(path), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(string, \"string\");\n        Objects.requireNonNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates and returns a parser for the given URL, which the caller MUST close.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(url, \"url\");\n        Objects.requireNonNull(charset, \"charset\");\n        Objects.requireNonNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private String headerComment;\n\n    private String trailerComment;\n\n    private final CSVFormat format;\n\n    private final Headers headers;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Constructs a new instance using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Constructs a new instance using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n        throws IOException {\n        Objects.requireNonNull(reader, \"reader\");\n        Objects.requireNonNull(format, \"format\");\n\n        this.format = format.copy();\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headers = createHeaders();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.format.trim(this.reusableToken.content.toString());\n        if (lastRecord && input.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        this.recordList.add(handleNull(input));\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    private Map<String, Integer> createEmptyHeaderMap() {\n        return this.format.getIgnoreHeaderCase() ?\n                new TreeMap<>(String.CASE_INSENSITIVE_ORDER) :\n                new LinkedHashMap<>();\n    }\n\n    /**\n     * Creates the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Headers createHeaders() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        List<String> headerNames = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = createEmptyHeaderMap();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                    headerComment = nextRecord.getComment();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    final CSVRecord nextRecord = this.nextRecord();\n                    if (nextRecord != null) {\n                        headerComment = nextRecord.getComment();\n                    }\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean blankHeader = CSVFormat.isBlank(header);\n                    if (blankHeader && !this.format.getAllowMissingColumnNames()) {\n                        throw new IllegalArgumentException(\n                            \"A header name is missing in \" + Arrays.toString(headerRecord));\n                    }\n\n                    final boolean containsHeader = header != null && hdrMap.containsKey(header);\n                    final DuplicateHeaderMode headerMode = this.format.getDuplicateHeaderMode();\n                    final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\n                    final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\n\n                    if (containsHeader && !duplicatesAllowed && !(blankHeader && emptyDuplicatesAllowed)) {\n                        throw new IllegalArgumentException(\n                            String.format(\n                                \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\n                                header, Arrays.toString(headerRecord)));\n                    }\n                    if (header != null) {\n                        hdrMap.put(header, Integer.valueOf(i));\n                        if (headerNames == null) {\n                            headerNames = new ArrayList<>(headerRecord.length);\n                        }\n                        headerNames.add(header);\n                    }\n                }\n            }\n        }\n        if (headerNames == null) {\n            headerNames = Collections.emptyList(); // immutable\n        } else {\n            headerNames = Collections.unmodifiableList(headerNames);\n        }\n        return new Headers(hdrMap, headerNames);\n    }\n\n    /**\n     * Gets the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Gets the header comment, if any.\n     * The header comment appears before the header record.\n     *\n     * @return the header comment for this stream, or null if no comment is available.\n     * @since 1.10.0\n     */\n    public String getHeaderComment() {\n        return headerComment;\n    }\n\n    /**\n     * Gets a copy of the header map as defined in the CSVFormat's header.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * <p>\n     * Note: The map can only provide a one-to-one mapping when the format did not\n     * contain null or duplicate column names.\n     * </p>\n     *\n     * @return a copy of the header map.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        if (this.headers.headerMap == null) {\n            return null;\n        }\n        final Map<String, Integer> map = createEmptyHeaderMap();\n        map.putAll(this.headers.headerMap);\n        return map;\n    }\n\n    /**\n     * Gets the underlying header map.\n     *\n     * @return the underlying header map.\n     */\n    Map<String, Integer> getHeaderMapRaw() {\n        return this.headers.headerMap;\n    }\n\n    /**\n     * Gets a read-only list of header names that iterates in column order as defined in the CSVFormat's header.\n     * <p>\n     * Note: The list provides strings that can be used as keys in the header map.\n     * The list will not contain null column names if they were present in the input\n     * format.\n     * </p>\n     *\n     * @return read-only list of header names that iterates in column order.\n     * @see #getHeaderMap()\n     * @since 1.7\n     */\n    public List<String> getHeaderNames() {\n        return Collections.unmodifiableList(headers.headerNames);\n    }\n\n    /**\n     * Gets the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws UncheckedIOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() {\n        return stream().collect(Collectors.toList());\n    }\n\n    /**\n     * Gets the trailer comment, if any.\n     * Trailer comments are located between the last record and EOF\n     *\n     * @return the trailer comment for this stream, or null if no comment is available.\n     * @since 1.10.0\n     */\n    public String getTrailerComment() {\n        return trailerComment;\n    }\n\n    /**\n     * Handle whether input is parsed as null\n     *\n     * @param input\n     *           the cell data to further processed\n     * @return null if input is parsed as null, or input itself if input isn't parsed as null\n     */\n    private String handleNull(final String input) {\n        final boolean isQuoted = this.reusableToken.isQuoted;\n        final String nullString = format.getNullString();\n        final boolean strictQuoteMode = isStrictQuoteMode();\n        if (input.equals(nullString)) {\n            // nullString = NULL(String), distinguish between \"NULL\" and NULL in ALL_NON_NULL or NON_NUMERIC quote mode\n            return strictQuoteMode && isQuoted ? input : null;\n        }\n        // don't set nullString, distinguish between \"\" and ,, (absent values) in All_NON_NULL or NON_NUMERIC quote mode\n        return strictQuoteMode && nullString == null && input.isEmpty() && !isQuoted ? null : input;\n    }\n\n    /**\n     * Checks whether there is a header comment.\n     * The header comment appears before the header record.\n     * Note that if the parser's format has been given an explicit header\n     * (with {@link CSVFormat.Builder#setHeader(String... )} or another overload)\n     * and the header record is not being skipped\n     * ({@link CSVFormat.Builder#setSkipHeaderRecord} is false) then any initial comments\n     * will be associated with the first record, not the header.\n     *\n     * @return true if this parser has seen a header comment, false otherwise\n     * @since 1.10.0\n     */\n    public boolean hasHeaderComment() {\n        return headerComment != null;\n    }\n\n    /**\n     * Checks whether there is a trailer comment.\n     * Trailer comments are located between the last record and EOF.\n     * The trailer comments will only be available after the parser has\n     * finished processing this stream.\n     *\n     * @return true if this parser has seen a trailer comment, false otherwise\n     * @since 1.10.0\n     */\n    public boolean hasTrailerComment() {\n        return trailerComment != null;\n    }\n\n    /**\n     * Tests whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Tests whether the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or {@link QuoteMode#NON_NUMERIC}.\n     *\n     * @return true if the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or\n     *         {@link QuoteMode#NON_NUMERIC}.\n     */\n    private boolean isStrictQuoteMode() {\n        return this.format.getQuoteMode() == QuoteMode.ALL_NON_NULL ||\n               this.format.getQuoteMode() == QuoteMode.NON_NUMERIC;\n    }\n\n    /**\n     * Returns the record iterator.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed, the iterator will not yield any more records.\n     * A call to {@link Iterator#hasNext()} will return {@code false} and\n     * a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     * <p>\n     * If it is necessary to construct an iterator which is usable after the\n     * parser is closed, one option is to extract all records as a list with\n     * {@link #getRecords()}, and return an iterator to that list.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                } else if (sb != null) {\n                    trailerComment = sb.toString();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this, this.recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment,\n                this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a sequential {@code Stream} with this collection as its source.\n     * <p>\n     * If the parser is closed, the stream will not produce any more values.\n     * See the comments in {@link #iterator()}.\n     * </p>\n     * @return a sequential {@code Stream} with this collection as its source.\n     * @since 1.9.0\n     */\n    public Stream<CSVRecord> stream() {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator(), Spliterator.ORDERED), false);\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 451b7c9f6..96e77a77d 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -499,6 +499,8 @@ private Headers createHeaders() throws IOException {\n \n             // build the name to index mappings\n             if (headerRecord != null) {\n+                // Track an occurrence of a null, empty or blank header.\n+                boolean observedMissing = false;\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean blankHeader = CSVFormat.isBlank(header);\n@@ -507,7 +509,7 @@ private Headers createHeaders() throws IOException {\n                             \"A header name is missing in \" + Arrays.toString(headerRecord));\n                     }\n \n-                    final boolean containsHeader = header != null && hdrMap.containsKey(header);\n+                    final boolean containsHeader = blankHeader ? observedMissing : hdrMap.containsKey(header);\n                     final DuplicateHeaderMode headerMode = this.format.getDuplicateHeaderMode();\n                     final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\n                     final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\n@@ -518,6 +520,7 @@ private Headers createHeaders() throws IOException {\n                                 \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\n                                 header, Arrays.toString(headerRecord)));\n                     }\n+                    observedMissing |= blankHeader;\n                     if (header != null) {\n                         hdrMap.put(header, Integer.valueOf(i));\n                         if (headerNames == null) {\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVDuplicateHeaderTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 270,
    "title": "[CSV-274] Add comments to iterator() and stream()",
    "state": "closed",
    "created_at": "2022-10-05T19:57:22Z",
    "merge_commit_sha": "d46919da2651a797662a937c9870cb04ac4037c2",
    "base_sha": "f36e0f590b3882a810eefac04c092f83011526a4",
    "head_sha": "5fbd3538566a0629f3d02dd8458d9b54a6013975",
    "user_login": "pedro-w",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.StringReader;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVParserTest2 {\n\n    @Test\n    public void testIteratorHasNextAfterClose() throws Exception {\n        final String csvData = \"a,b,c\\n1,2,3\\nx,y,z\";\n        final Iterator<CSVRecord> records;\n        try (final CSVParser parser = CSVParser.parse(csvData, CSVFormat.DEFAULT)) {\n            records = parser.iterator();\n            assertTrue(records.hasNext());\n        }\n        assertFalse(records.hasNext());\n    }\n\n    @Test\n    public void testIteratorNextAfterClose() throws Exception {\n        final String csvData = \"a,b,c\\n1,2,3\\nx,y,z\";\n        final Iterator<CSVRecord> records;\n        try (final CSVParser parser = CSVParser.parse(csvData, CSVFormat.DEFAULT)) {\n            records = parser.iterator();\n            assertTrue(records.hasNext());\n        }\n        assertThrows(NoSuchElementException.class, records::next);\n    }\n\n    @Test\n    public void testStreamAfterClose() throws Exception {\n        final String csvData = \"a,b,c\\n1,2,3\\nx,y,z\";\n        final Stream<CSVRecord> stream;\n        try (final CSVParser parser = CSVParser.parse(csvData, CSVFormat.DEFAULT)) {\n            stream = parser.stream();\n            assertTrue(stream.iterator().hasNext());\n        }\n        assertFalse(stream.iterator().hasNext());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.UncheckedIOException;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n\n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n\n            return this.current != null;\n        }\n\n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n\n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n\n            return next;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Header information based on name and position.\n     */\n    private static final class Headers {\n        /**\n         * Header column positions (0-based)\n         */\n        final Map<String, Integer> headerMap;\n\n        /**\n         * Header names in column order\n         */\n        final List<String> headerNames;\n\n        Headers(final Map<String, Integer> headerMap, final List<String> headerNames) {\n            this.headerMap = headerMap;\n            this.headerNames = headerNames;\n        }\n    }\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        return parse(file.toPath(), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        Objects.requireNonNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates and returns a parser for the given {@link Path}, which the caller MUST close.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(path, \"path\");\n        Objects.requireNonNull(format, \"format\");\n        return parse(Files.newInputStream(path), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(string, \"string\");\n        Objects.requireNonNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates and returns a parser for the given URL, which the caller MUST close.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(url, \"url\");\n        Objects.requireNonNull(charset, \"charset\");\n        Objects.requireNonNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private String headerComment;\n\n    private String trailerComment;\n\n    private final CSVFormat format;\n\n    private final Headers headers;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n        throws IOException {\n        Objects.requireNonNull(reader, \"reader\");\n        Objects.requireNonNull(format, \"format\");\n\n        this.format = format.copy();\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headers = createHeaders();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        this.recordList.add(handleNull(inputClean));\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    private Map<String, Integer> createEmptyHeaderMap() {\n        return this.format.getIgnoreHeaderCase() ?\n                new TreeMap<>(String.CASE_INSENSITIVE_ORDER) :\n                new LinkedHashMap<>();\n    }\n\n    /**\n     * Creates the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Headers createHeaders() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        List<String> headerNames = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = createEmptyHeaderMap();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                    headerComment = nextRecord.getComment();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    final CSVRecord nextRecord = this.nextRecord();\n                    if (nextRecord != null) {\n                        headerComment = nextRecord.getComment();\n                    }\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (emptyHeader && !this.format.getAllowMissingColumnNames()) {\n                        throw new IllegalArgumentException(\n                            \"A header name is missing in \" + Arrays.toString(headerRecord));\n                    }\n\n                    final boolean containsHeader = header != null && hdrMap.containsKey(header);\n                    final DuplicateHeaderMode headerMode = this.format.getDuplicateHeaderMode();\n                    final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\n                    final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\n\n                    if (containsHeader && !duplicatesAllowed && !(emptyHeader && emptyDuplicatesAllowed)) {\n                        throw new IllegalArgumentException(\n                            String.format(\n                                \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\n                                header, Arrays.toString(headerRecord)));\n                    }\n                    if (header != null) {\n                        hdrMap.put(header, Integer.valueOf(i));\n                        if (headerNames == null) {\n                            headerNames = new ArrayList<>(headerRecord.length);\n                        }\n                        headerNames.add(header);\n                    }\n                }\n            }\n        }\n        if (headerNames == null) {\n            headerNames = Collections.emptyList(); //immutable\n        } else {\n            headerNames = Collections.unmodifiableList(headerNames);\n        }\n        return new Headers(hdrMap, headerNames);\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns the header comment, if any.\n     * The header comment appears before the header record.\n     *\n     * @return the header comment for this stream, or null if no comment is available.\n     * @since 1.10.0\n     */\n    public String getHeaderComment() {\n        return headerComment;\n    }\n\n    /**\n     * Returns a copy of the header map.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * <p>\n     * Note: The map can only provide a one-to-one mapping when the format did not\n     * contain null or duplicate column names.\n     * </p>\n     *\n     * @return a copy of the header map.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        if (this.headers.headerMap == null) {\n            return null;\n        }\n        final Map<String, Integer> map = createEmptyHeaderMap();\n        map.putAll(this.headers.headerMap);\n        return map;\n    }\n\n    /**\n     * Returns the header map.\n     *\n     * @return the header map.\n     */\n    Map<String, Integer> getHeaderMapRaw() {\n        return this.headers.headerMap;\n    }\n\n    /**\n     * Returns a read-only list of header names that iterates in column order.\n     * <p>\n     * Note: The list provides strings that can be used as keys in the header map.\n     * The list will not contain null column names if they were present in the input\n     * format.\n     * </p>\n     *\n     * @return read-only list of header names that iterates in column order.\n     * @see #getHeaderMap()\n     * @since 1.7\n     */\n    public List<String> getHeaderNames() {\n        return Collections.unmodifiableList(headers.headerNames);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws UncheckedIOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() {\n        return stream().collect(Collectors.toList());\n    }\n\n    /**\n     * Returns the trailer comment, if any.\n     * Trailer comments are located between the last record and EOF\n     *\n     * @return the trailer comment for this stream, or null if no comment is available.\n     * @since 1.10.0\n     */\n    public String getTrailerComment() {\n        return trailerComment;\n    }\n\n    /**\n     * Handle whether input is parsed as null\n     *\n     * @param input\n     *           the cell data to further processed\n     * @return null if input is parsed as null, or input itself if input isn't parsed as null\n     */\n    private String handleNull(final String input) {\n        final boolean isQuoted = this.reusableToken.isQuoted;\n        final String nullString = format.getNullString();\n        final boolean strictQuoteMode = isStrictQuoteMode();\n        if (input.equals(nullString)) {\n            // nullString = NULL(String), distinguish between \"NULL\" and NULL in ALL_NON_NULL or NON_NUMERIC quote mode\n            return strictQuoteMode && isQuoted ? input : null;\n        }\n        // don't set nullString, distinguish between \"\" and ,, (absent values) in All_NON_NULL or NON_NUMERIC quote mode\n        return strictQuoteMode && nullString == null && input.isEmpty() && !isQuoted ? null : input;\n    }\n\n    /**\n     * Checks whether there is a header comment.\n     * The header comment appears before the header record.\n     * Note that if the parser's format has been given an explicit header\n     * (with {@link CSVFormat.Builder#setHeader(String... )} or another overload)\n     * and the header record is not being skipped\n     * ({@link CSVFormat.Builder#setSkipHeaderRecord} is false) then any initial comments\n     * will be associated with the first record, not the header.\n     *\n     * @return true if this parser has seen a header comment, false otherwise\n     * @since 1.10.0\n     */\n    public boolean hasHeaderComment() {\n        return headerComment != null;\n    }\n\n    /**\n     * Checks whether there is a trailer comment.\n     * Trailer comments are located between the last record and EOF.\n     * The trailer comments will only be available after the parser has\n     * finished processing this stream.\n     *\n     * @return true if this parser has seen a trailer comment, false otherwise\n     * @since 1.10.0\n     */\n    public boolean hasTrailerComment() {\n        return trailerComment != null;\n    }\n\n    /**\n     * Tests whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Tests whether the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or {@link QuoteMode#NON_NUMERIC}.\n     *\n     * @return true if the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or\n     *         {@link QuoteMode#NON_NUMERIC}.\n     */\n    private boolean isStrictQuoteMode() {\n        return this.format.getQuoteMode() == QuoteMode.ALL_NON_NULL ||\n               this.format.getQuoteMode() == QuoteMode.NON_NUMERIC;\n    }\n\n    /**\n     * Returns the record iterator.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                } else if (sb != null) {\n                    trailerComment = sb.toString();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this, this.recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment,\n                this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a sequential {@code Stream} with this collection as its source.\n     *\n     * @return a sequential {@code Stream} with this collection as its source.\n     * @since 1.9.0\n     */\n    public Stream<CSVRecord> stream() {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator(), Spliterator.ORDERED), false);\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex bff55a00d..fd4c3a909 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -734,9 +734,16 @@ private boolean isStrictQuoteMode() {\n      * {@link IllegalStateException}.\n      * </p>\n      * <p>\n-     * If the parser is closed a call to {@link Iterator#next()} will throw a\n+     * If the parser is closed, the iterator will not yield any more records.\n+     * A call to {@link Iterator#hasNext()} will return {@code false} and\n+     * a call to {@link Iterator#next()} will throw a\n      * {@link NoSuchElementException}.\n      * </p>\n+     * <p>\n+     * If it is necessary to construct an iterator which is usable after the\n+     * parser is closed, one option is to extract all records as a list with\n+     * {@link getRecords()}, and return an iterator to that list.\n+     * </p>\n      */\n     @Override\n     public Iterator<CSVRecord> iterator() {\n@@ -799,7 +806,10 @@ CSVRecord nextRecord() throws IOException {\n \n     /**\n      * Returns a sequential {@code Stream} with this collection as its source.\n-     *\n+     * <p>\n+     * If the parser is closed, the stream will not produce any more values.\n+     * See the comments in {@link iterator()}.\n+     * </p>\n      * @return a sequential {@code Stream} with this collection as its source.\n      * @since 1.9.0\n      */\n"
      }
    ]
  },
  {
    "pr_number": 266,
    "title": "Validate input to setDelimiter(String) for empty string",
    "state": "closed",
    "created_at": "2022-09-27T10:33:00Z",
    "merge_commit_sha": "23c39b158e13ee835ae77ed3e39de0d54a0600cd",
    "base_sha": "048d507de95b3aaabac5ecc29878390601b47ff3",
    "head_sha": "1da75703a46305dbdf45b29e6d886533769c2a3c",
    "user_login": "mykolaf",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testDelimiterCannotBeEmpty() {\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setDelimiter(\"\").build());\n    }\n}",
        "file_content": "/*\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n * this work for additional information regarding copyright ownership.\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n * (the \"License\"); you may not use this file except in compliance with\r\n * the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage org.apache.commons.csv;\r\n\r\nimport static org.apache.commons.csv.Constants.BACKSLASH;\r\nimport static org.apache.commons.csv.Constants.COMMA;\r\nimport static org.apache.commons.csv.Constants.COMMENT;\r\nimport static org.apache.commons.csv.Constants.CR;\r\nimport static org.apache.commons.csv.Constants.CRLF;\r\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\r\nimport static org.apache.commons.csv.Constants.EMPTY;\r\nimport static org.apache.commons.csv.Constants.LF;\r\nimport static org.apache.commons.csv.Constants.PIPE;\r\nimport static org.apache.commons.csv.Constants.SP;\r\nimport static org.apache.commons.csv.Constants.TAB;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Serializable;\r\nimport java.io.StringWriter;\r\nimport java.io.Writer;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.Arrays;\r\nimport java.util.HashSet;\r\nimport java.util.Objects;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Specifies the format of a CSV file and parses input.\r\n *\r\n * <h2>Using predefined formats</h2>\r\n *\r\n * <p>\r\n * You can use one of the predefined formats:\r\n * </p>\r\n *\r\n * <ul>\r\n * <li>{@link #DEFAULT}</li>\r\n * <li>{@link #EXCEL}</li>\r\n * <li>{@link #INFORMIX_UNLOAD}</li>\r\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\r\n * <li>{@link #MYSQL}</li>\r\n * <li>{@link #RFC4180}</li>\r\n * <li>{@link #ORACLE}</li>\r\n * <li>{@link #POSTGRESQL_CSV}</li>\r\n * <li>{@link #POSTGRESQL_TEXT}</li>\r\n * <li>{@link #TDF}</li>\r\n * </ul>\r\n *\r\n * <p>\r\n * For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\r\n * </pre>\r\n *\r\n * <p>\r\n * The {@link CSVParser} provides static methods to parse other input types, for example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\r\n * </pre>\r\n *\r\n * <h2>Defining formats</h2>\r\n *\r\n * <p>\r\n * You can extend a format by calling the {@code set} methods. For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\r\n * </pre>\r\n *\r\n * <h2>Defining column names</h2>\r\n *\r\n * <p>\r\n * To define the column names you want to use to access records, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * Calling {@link Builder#setHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and assumes that your CSV source does not\r\n * contain a first record that also defines column names.\r\n *\r\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\r\n * {@link Builder#setSkipHeaderRecord(boolean)} with {@code true}.\r\n * </p>\r\n *\r\n * <h2>Parsing</h2>\r\n *\r\n * <p>\r\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * Reader in = ...;\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\r\n * </pre>\r\n *\r\n * <p>\r\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\r\n * </p>\r\n *\r\n * <h2>Referencing columns safely</h2>\r\n *\r\n * <p>\r\n * If your source contains a header record, you can simplify your code and safely reference columns, by using {@link Builder#setHeader(String...)} with no\r\n * arguments:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader();\r\n * </pre>\r\n *\r\n * <p>\r\n * This causes the parser to read the first record and use its values as column names.\r\n *\r\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\r\n * </p>\r\n *\r\n * <pre>\r\n * String value = record.get(&quot;Col1&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * This makes your code impervious to changes in column order in the CSV file.\r\n * </p>\r\n *\r\n * <h2>Notes</h2>\r\n *\r\n * <p>\r\n * This class is immutable.\r\n * </p>\r\n */\r\npublic final class CSVFormat implements Serializable {\r\n\r\n    /**\r\n     * Builds CSVFormat instances.\r\n     *\r\n     * @since 1.9.0\r\n     */\r\n    public static class Builder {\r\n\r\n        /**\r\n         * Creates a new default builder.\r\n         *\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create() {\r\n            return new Builder(CSVFormat.DEFAULT);\r\n        }\r\n\r\n        /**\r\n         * Creates a new builder for the given format.\r\n         *\r\n         * @param csvFormat the source format.\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create(final CSVFormat csvFormat) {\r\n            return new Builder(csvFormat);\r\n        }\r\n\r\n        private boolean allowMissingColumnNames;\r\n\r\n        private boolean autoFlush;\r\n\r\n        private Character commentMarker;\r\n\r\n        private String delimiter;\r\n\r\n        private DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n        private Character escapeCharacter;\r\n\r\n        private String[] headerComments;\r\n\r\n        private String[] headers;\r\n\r\n        private boolean ignoreEmptyLines;\r\n\r\n        private boolean ignoreHeaderCase;\r\n\r\n        private boolean ignoreSurroundingSpaces;\r\n\r\n        private String nullString;\r\n\r\n        private Character quoteCharacter;\r\n\r\n        private String quotedNullString;\r\n\r\n        private QuoteMode quoteMode;\r\n\r\n        private String recordSeparator;\r\n\r\n        private boolean skipHeaderRecord;\r\n\r\n        private boolean trailingDelimiter;\r\n\r\n        private boolean trim;\r\n\r\n        private Builder(final CSVFormat csvFormat) {\r\n            this.delimiter = csvFormat.delimiter;\r\n            this.quoteCharacter = csvFormat.quoteCharacter;\r\n            this.quoteMode = csvFormat.quoteMode;\r\n            this.commentMarker = csvFormat.commentMarker;\r\n            this.escapeCharacter = csvFormat.escapeCharacter;\r\n            this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;\r\n            this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;\r\n            this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;\r\n            this.recordSeparator = csvFormat.recordSeparator;\r\n            this.nullString = csvFormat.nullString;\r\n            this.headerComments = csvFormat.headerComments;\r\n            this.headers = csvFormat.header;\r\n            this.skipHeaderRecord = csvFormat.skipHeaderRecord;\r\n            this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;\r\n            this.trailingDelimiter = csvFormat.trailingDelimiter;\r\n            this.trim = csvFormat.trim;\r\n            this.autoFlush = csvFormat.autoFlush;\r\n            this.quotedNullString = csvFormat.quotedNullString;\r\n            this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;\r\n        }\r\n\r\n        /**\r\n         * Builds a new CSVFormat instance.\r\n         *\r\n         * @return a new CSVFormat instance.\r\n         */\r\n        public CSVFormat build() {\r\n            return new CSVFormat(this);\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior, true to allow, false to disallow.\r\n         *\r\n         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n         * @return This instance.\r\n         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.\r\n         */\r\n        @Deprecated\r\n        public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n            final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\r\n            setDuplicateHeaderMode(mode);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\r\n         * {@link IllegalArgumentException} to be thrown.\r\n         *\r\n         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\r\n         *                                cause an {@link IllegalArgumentException} to be thrown.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n            this.allowMissingColumnNames = allowMissingColumnNames;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to flush on close.\r\n         *\r\n         * @param autoFlush whether to flush on close.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAutoFlush(final boolean autoFlush) {\r\n            this.autoFlush = autoFlush;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final char commentMarker) {\r\n            setCommentMarker(Character.valueOf(commentMarker));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final Character commentMarker) {\r\n            if (isLineBreak(commentMarker)) {\r\n                throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\r\n            }\r\n            this.commentMarker = commentMarker;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final char delimiter) {\r\n            return setDelimiter(String.valueOf(delimiter));\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final String delimiter) {\r\n            if (containsLineBreak(delimiter)) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n            }\r\n            this.delimiter = delimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior.\r\n         *\r\n         * @param duplicateHeaderMode the duplicate header names behavior\r\n         * @return This instance.\r\n         */\r\n        public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {\r\n          this.duplicateHeaderMode = duplicateHeaderMode;\r\n          return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final char escapeCharacter) {\r\n            setEscape(Character.valueOf(escapeCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final Character escapeCharacter) {\r\n            if (isLineBreak(escapeCharacter)) {\r\n                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\r\n            }\r\n            this.escapeCharacter = escapeCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header defined by the given {@link Enum} class.\r\n         *\r\n         * <p>\r\n         * Example:\r\n         * </p>\r\n         *\r\n         * <pre>\r\n         * public enum HeaderEnum {\r\n         *     Name, Email, Phone\r\n         * }\r\n         *\r\n         * Builder builder = builder.setHeader(HeaderEnum.class);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {\r\n            String[] header = null;\r\n            if (headerEnum != null) {\r\n                final Enum<?>[] enumValues = headerEnum.getEnumConstants();\r\n                header = new String[enumValues.length];\r\n                Arrays.setAll(header, i -> enumValues[i].name());\r\n            }\r\n            return setHeader(header);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSet);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSet resultSet) throws SQLException {\r\n            return setHeader(resultSet != null ? resultSet.getMetaData() : null);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSetMetaData);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n            String[] labels = null;\r\n            if (resultSetMetaData != null) {\r\n                final int columnCount = resultSetMetaData.getColumnCount();\r\n                labels = new String[columnCount];\r\n                for (int i = 0; i < columnCount; i++) {\r\n                    labels[i] = resultSetMetaData.getColumnLabel(i + 1);\r\n                }\r\n            }\r\n            return setHeader(labels);\r\n        }\r\n\r\n        /**\r\n         * Sets the header to the given values. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final String... header) {\r\n            this.headers = CSVFormat.clone(header);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final Object... headerComments) {\r\n            this.headerComments = CSVFormat.clone(toStringArray(headerComments));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * Builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final String... headerComments) {\r\n            this.headerComments = CSVFormat.clone(headerComments);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty\r\n         * records.\r\n         *\r\n         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate\r\n         *                         empty lines to empty records.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n            this.ignoreEmptyLines = ignoreEmptyLines;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         *\r\n         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n            this.ignoreHeaderCase = ignoreHeaderCase;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         *\r\n         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         *\r\n         * <ul>\r\n         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n         * </ul>\r\n         *\r\n         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         * @return This instance.\r\n         */\r\n        public Builder setNullString(final String nullString) {\r\n            this.nullString = nullString;\r\n            this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character.\r\n         *\r\n         * @param quoteCharacter the quote character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final char quoteCharacter) {\r\n            setQuote(Character.valueOf(quoteCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character, use {@code null} to disable.\r\n         *\r\n         * @param quoteCharacter the quote character, use {@code null} to disable.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final Character quoteCharacter) {\r\n            if (isLineBreak(quoteCharacter)) {\r\n                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\r\n            }\r\n            this.quoteCharacter = quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote policy to use for output.\r\n         *\r\n         * @param quoteMode the quote policy to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuoteMode(final QuoteMode quoteMode) {\r\n            this.quoteMode = quoteMode;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final char recordSeparator) {\r\n            this.recordSeparator = String.valueOf(recordSeparator);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final String recordSeparator) {\r\n            this.recordSeparator = recordSeparator;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to skip the header record.\r\n         *\r\n         * @param skipHeaderRecord whether to skip the header record.\r\n         * @return This instance.\r\n         */\r\n        public Builder setSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n            this.skipHeaderRecord = skipHeaderRecord;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to add a trailing delimiter.\r\n         *\r\n         * @param trailingDelimiter whether to add a trailing delimiter.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrailingDelimiter(final boolean trailingDelimiter) {\r\n            this.trailingDelimiter = trailingDelimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to trim leading and trailing blanks.\r\n         *\r\n         * @param trim whether to trim leading and trailing blanks.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrim(final boolean trim) {\r\n            this.trim = trim;\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Predefines formats.\r\n     *\r\n     * @since 1.2\r\n     */\r\n    public enum Predefined {\r\n\r\n        /**\r\n         * @see CSVFormat#DEFAULT\r\n         */\r\n        Default(CSVFormat.DEFAULT),\r\n\r\n        /**\r\n         * @see CSVFormat#EXCEL\r\n         */\r\n        Excel(CSVFormat.EXCEL),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD\r\n         * @since 1.3\r\n         */\r\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\r\n         * @since 1.3\r\n         */\r\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_CSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_TSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MYSQL\r\n         */\r\n        MySQL(CSVFormat.MYSQL),\r\n\r\n        /**\r\n         * @see CSVFormat#ORACLE\r\n         */\r\n        Oracle(CSVFormat.ORACLE),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         * @since 1.5\r\n         */\r\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         */\r\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\r\n\r\n        /**\r\n         * @see CSVFormat#RFC4180\r\n         */\r\n        RFC4180(CSVFormat.RFC4180),\r\n\r\n        /**\r\n         * @see CSVFormat#TDF\r\n         */\r\n        TDF(CSVFormat.TDF);\r\n\r\n        private final CSVFormat format;\r\n\r\n        Predefined(final CSVFormat format) {\r\n            this.format = format;\r\n        }\r\n\r\n        /**\r\n         * Gets the format.\r\n         *\r\n         * @return the format.\r\n         */\r\n        public CSVFormat getFormat() {\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing\r\n     * empty lines.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Default\r\n     */\r\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false,\r\n            false, false, false, DuplicateHeaderMode.ALLOW_ALL);\r\n\r\n    /**\r\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is locale dependent, it might be necessary\r\n     * to customize this format to accommodate to your regional settings.\r\n     *\r\n     * <p>\r\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setAllowMissingColumnNames(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     * <p>\r\n     * Note: This is currently like {@link #RFC4180} plus {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)} and\r\n     * {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(false)}.\r\n     * </p>\r\n     *\r\n     * @see Predefined#Excel\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat EXCEL = DEFAULT.builder()\r\n            .setIgnoreEmptyLines(false)\r\n            .setAllowMissingColumnNames(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.builder()\r\n            .setDelimiter(PIPE)\r\n            .setEscape(BACKSLASH)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with {@code '\"'}. A header line with field\r\n     * names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format. Values are double quoted only if needed and special\r\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\r\n     *          documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_TSV = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\r\n     *      -data.html</a>\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MYSQL = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(\"\\\\N\")\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default Oracle format used by the SQL*Loader utility.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\r\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\r\n     * {@code \"\"}. Values are trimmed.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setTrim()}</li>\r\n     * <li>{@code setSystemRecordSeparator()}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.MINIMAL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Oracle\r\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\r\n     * @since 1.6\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat ORACLE = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setNullString(\"\\\\N\")\r\n            .setTrim(true)\r\n            .setRecordSeparator(System.lineSeparator())\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\r\n     * characters are not escaped. The default NULL string is {@code \"\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape(null)}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(null)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(EMPTY)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL text format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(\"\\\\N\")\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#RFC4180\r\n     */\r\n    public static final CSVFormat RFC4180 = DEFAULT.builder().setIgnoreEmptyLines(false).build();\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    /**\r\n     * Tab-delimited format.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreSurroundingSpaces(true)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#TDF\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat TDF = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setIgnoreSurroundingSpaces(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Null-safe clone of an array.\r\n     *\r\n     * @param <T>    The array element type.\r\n     * @param values the source array\r\n     * @return the cloned array.\r\n     */\r\n    @SafeVarargs\r\n    static <T> T[] clone(final T... values) {\r\n        return values == null ? null : values.clone();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains the search char.\r\n     *\r\n     * @param source the string to check.\r\n     * @param searchCh the character to search.\r\n     *\r\n     * @return true if {@code c} contains a line break character\r\n     */\r\n    private static boolean contains(final String source, final char searchCh) {\r\n        return Objects.requireNonNull(source, \"source\").indexOf(searchCh) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains a line break character.\r\n     *\r\n     * @param source the string to check.\r\n     *\r\n     * @return true if {@code c} contains a line break character.\r\n     */\r\n    private static boolean containsLineBreak(final String source) {\r\n        return contains(source, CR) || contains(source, LF);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check.\r\n     *\r\n     * @return true if {@code c} is a line break character.\r\n     */\r\n    private static boolean isLineBreak(final char c) {\r\n        return c == LF || c == CR;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check, may be null.\r\n     *\r\n     * @return true if {@code c} is a line break character (and not null).\r\n     */\r\n    private static boolean isLineBreak(final Character c) {\r\n        return c != null && isLineBreak(c.charValue());\r\n    }\r\n\r\n    /**\r\n     * Creates a new CSV format with the specified delimiter.\r\n     *\r\n     * <p>\r\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.\r\n     * </p>\r\n     *\r\n     * @param delimiter the char used for value separation, must not be a line break character\r\n     * @return a new CSV format.\r\n     * @throws IllegalArgumentException if the delimiter is a line break character\r\n     *\r\n     * @see #DEFAULT\r\n     * @see #RFC4180\r\n     * @see #MYSQL\r\n     * @see #EXCEL\r\n     * @see #TDF\r\n     */\r\n    public static CSVFormat newFormat(final char delimiter) {\r\n        return new CSVFormat(String.valueOf(delimiter), null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false,\r\n                DuplicateHeaderMode.ALLOW_ALL);\r\n    }\r\n\r\n    static String[] toStringArray(final Object[] values) {\r\n        if (values == null) {\r\n            return null;\r\n        }\r\n        final String[] strings = new String[values.length];\r\n        Arrays.setAll(strings, i -> Objects.toString(values[i], null));\r\n        return strings;\r\n    }\r\n\r\n    static CharSequence trim(final CharSequence charSequence) {\r\n        if (charSequence instanceof String) {\r\n            return ((String) charSequence).trim();\r\n        }\r\n        final int count = charSequence.length();\r\n        int len = count;\r\n        int pos = 0;\r\n\r\n        while (pos < len && charSequence.charAt(pos) <= SP) {\r\n            pos++;\r\n        }\r\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\r\n            len--;\r\n        }\r\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\r\n    }\r\n\r\n    /**\r\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\r\n     *\r\n     * @param format name\r\n     * @return one of the predefined formats\r\n     * @since 1.2\r\n     */\r\n    public static CSVFormat valueOf(final String format) {\r\n        return CSVFormat.Predefined.valueOf(format).getFormat();\r\n    }\r\n\r\n    private final DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n    private final boolean allowMissingColumnNames;\r\n\r\n    private final boolean autoFlush;\r\n\r\n    private final Character commentMarker; // null if commenting is disabled\r\n\r\n    private final String delimiter;\r\n\r\n    private final Character escapeCharacter; // null if escaping is disabled\r\n\r\n    private final String[] header; // array of header column names\r\n\r\n    private final String[] headerComments; // array of header comment lines\r\n\r\n    private final boolean ignoreEmptyLines;\r\n\r\n    private final boolean ignoreHeaderCase; // should ignore header names case\r\n\r\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\r\n\r\n    private final String nullString; // the string to be used for null values\r\n\r\n    private final Character quoteCharacter; // null if quoting is disabled\r\n\r\n    private final String quotedNullString;\r\n\r\n    private final QuoteMode quoteMode;\r\n\r\n    private final String recordSeparator; // for outputs\r\n\r\n    private final boolean skipHeaderRecord;\r\n\r\n    private final boolean trailingDelimiter;\r\n\r\n    private final boolean trim;\r\n\r\n    private CSVFormat(final Builder builder) {\r\n        this.delimiter = builder.delimiter;\r\n        this.quoteCharacter = builder.quoteCharacter;\r\n        this.quoteMode = builder.quoteMode;\r\n        this.commentMarker = builder.commentMarker;\r\n        this.escapeCharacter = builder.escapeCharacter;\r\n        this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = builder.allowMissingColumnNames;\r\n        this.ignoreEmptyLines = builder.ignoreEmptyLines;\r\n        this.recordSeparator = builder.recordSeparator;\r\n        this.nullString = builder.nullString;\r\n        this.headerComments = builder.headerComments;\r\n        this.header = builder.headers;\r\n        this.skipHeaderRecord = builder.skipHeaderRecord;\r\n        this.ignoreHeaderCase = builder.ignoreHeaderCase;\r\n        this.trailingDelimiter = builder.trailingDelimiter;\r\n        this.trim = builder.trim;\r\n        this.autoFlush = builder.autoFlush;\r\n        this.quotedNullString = builder.quotedNullString;\r\n        this.duplicateHeaderMode = builder.duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    /**\r\n     * Creates a customized CSV format.\r\n     *\r\n     * @param delimiter               the char used for value separation, must not be a line break character.\r\n     * @param quoteChar               the Character used as value encapsulation marker, may be {@code null} to disable.\r\n     * @param quoteMode               the quote mode.\r\n     * @param commentStart            the Character used for comment identification, may be {@code null} to disable.\r\n     * @param escape                  the Character used to escape special characters in values, may be {@code null} to disable.\r\n     * @param ignoreSurroundingSpaces {@code true} when whitespaces enclosing values should be ignored.\r\n     * @param ignoreEmptyLines        {@code true} when the parser should skip empty lines.\r\n     * @param recordSeparator         the line separator to use for output.\r\n     * @param nullString              the line separator to use for output.\r\n     * @param headerComments          the comments to be printed by the Printer before the actual CSV data.\r\n     * @param header                  the header\r\n     * @param skipHeaderRecord        TODO Doc me.\r\n     * @param allowMissingColumnNames TODO Doc me.\r\n     * @param ignoreHeaderCase        TODO Doc me.\r\n     * @param trim                    TODO Doc me.\r\n     * @param trailingDelimiter       TODO Doc me.\r\n     * @param autoFlush               TODO Doc me.\r\n     * @param duplicateHeaderMode     the behavior when handling duplicate headers\r\n     * @throws IllegalArgumentException if the delimiter is a line break character.\r\n     */\r\n    private CSVFormat(final String delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape,\r\n            final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\r\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames,\r\n            final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush,\r\n            final DuplicateHeaderMode duplicateHeaderMode) {\r\n        this.delimiter = delimiter;\r\n        this.quoteCharacter = quoteChar;\r\n        this.quoteMode = quoteMode;\r\n        this.commentMarker = commentStart;\r\n        this.escapeCharacter = escape;\r\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = allowMissingColumnNames;\r\n        this.ignoreEmptyLines = ignoreEmptyLines;\r\n        this.recordSeparator = recordSeparator;\r\n        this.nullString = nullString;\r\n        this.headerComments = toStringArray(headerComments);\r\n        this.header = clone(header);\r\n        this.skipHeaderRecord = skipHeaderRecord;\r\n        this.ignoreHeaderCase = ignoreHeaderCase;\r\n        this.trailingDelimiter = trailingDelimiter;\r\n        this.trim = trim;\r\n        this.autoFlush = autoFlush;\r\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n        this.duplicateHeaderMode = duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    private void append(final char c, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(c);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    private void append(final CharSequence csq, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(csq);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    /**\r\n     * Creates a new Builder for this instance.\r\n     *\r\n     * @return a new Builder.\r\n     */\r\n    public Builder builder() {\r\n        return Builder.create(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a copy of this instance.\r\n     *\r\n     * @return a copy of this instance.\r\n     */\r\n    CSVFormat copy() {\r\n        return builder().build();\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(final Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null || getClass() != obj.getClass()) {\r\n            return false;\r\n        }\r\n        final CSVFormat other = (CSVFormat) obj;\r\n        return duplicateHeaderMode == other.duplicateHeaderMode && allowMissingColumnNames == other.allowMissingColumnNames &&\r\n                autoFlush == other.autoFlush && Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) &&\r\n                Objects.equals(escapeCharacter, other.escapeCharacter) && Arrays.equals(header, other.header) &&\r\n                Arrays.equals(headerComments, other.headerComments) && ignoreEmptyLines == other.ignoreEmptyLines &&\r\n                ignoreHeaderCase == other.ignoreHeaderCase && ignoreSurroundingSpaces == other.ignoreSurroundingSpaces &&\r\n                Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) && quoteMode == other.quoteMode &&\r\n                Objects.equals(quotedNullString, other.quotedNullString) && Objects.equals(recordSeparator, other.recordSeparator) &&\r\n                skipHeaderRecord == other.skipHeaderRecord && trailingDelimiter == other.trailingDelimiter && trim == other.trim;\r\n    }\r\n\r\n    /**\r\n     * Formats the specified values.\r\n     *\r\n     * @param values the values to format\r\n     * @return the formatted values\r\n     */\r\n    public String format(final Object... values) {\r\n        final StringWriter out = new StringWriter();\r\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\r\n            csvPrinter.printRecord(values);\r\n            final String res = out.toString();\r\n            final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\r\n            return res.substring(0, len);\r\n        } catch (final IOException e) {\r\n            // should not happen because a StringWriter does not do IO.\r\n            throw new IllegalStateException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if and only if duplicate names are allowed in the headers.\r\n     *\r\n     * @return whether duplicate header names are allowed\r\n     * @since 1.7\r\n     * @deprecated Use {@link #getDuplicateHeaderMode()}.\r\n     */\r\n    @Deprecated\r\n    public boolean getAllowDuplicateHeaderNames() {\r\n        return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether missing column names are allowed when parsing the header line.\r\n     *\r\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an {@link IllegalArgumentException}.\r\n     */\r\n    public boolean getAllowMissingColumnNames() {\r\n        return allowMissingColumnNames;\r\n    }\r\n\r\n    /**\r\n     * Returns whether to flush on close.\r\n     *\r\n     * @return whether to flush on close.\r\n     * @since 1.6\r\n     */\r\n    public boolean getAutoFlush() {\r\n        return autoFlush;\r\n    }\r\n\r\n    /**\r\n     * Returns the character marking the start of a line comment.\r\n     *\r\n     * @return the comment start marker, may be {@code null}\r\n     */\r\n    public Character getCommentMarker() {\r\n        return commentMarker;\r\n    }\r\n\r\n    /**\r\n     * Returns the first character delimiting the values (typically ';', ',' or '\\t').\r\n     *\r\n     * @return the first delimiter character.\r\n     * @deprecated Use {@link #getDelimiterString()}.\r\n     */\r\n    @Deprecated\r\n    public char getDelimiter() {\r\n        return delimiter.charAt(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the character delimiting the values (typically \";\", \",\" or \"\\t\").\r\n     *\r\n     * @return the delimiter.\r\n     */\r\n    public String getDelimiterString() {\r\n        return delimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets how duplicate headers are handled.\r\n     *\r\n     * @return if duplicate header values are allowed, allowed conditionally, or disallowed.\r\n     * @since 1.9.0\r\n     */\r\n    public DuplicateHeaderMode getDuplicateHeaderMode() {\r\n        return duplicateHeaderMode;\r\n    }\r\n\r\n    /**\r\n     * Returns the escape character.\r\n     *\r\n     * @return the escape character, may be {@code null}\r\n     */\r\n    public Character getEscapeCharacter() {\r\n        return escapeCharacter;\r\n    }\r\n\r\n    /**\r\n     * Returns a copy of the header array.\r\n     *\r\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\r\n     */\r\n    public String[] getHeader() {\r\n        return header != null ? header.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Returns a copy of the header comment array.\r\n     *\r\n     * @return a copy of the header comment array; {@code null} if disabled.\r\n     */\r\n    public String[] getHeaderComments() {\r\n        return headerComments != null ? headerComments.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether empty lines between records are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty records.\r\n     */\r\n    public boolean getIgnoreEmptyLines() {\r\n        return ignoreEmptyLines;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether header names will be accessed ignoring case.\r\n     *\r\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\r\n     * @since 1.3\r\n     */\r\n    public boolean getIgnoreHeaderCase() {\r\n        return ignoreHeaderCase;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether spaces around values are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\r\n     */\r\n    public boolean getIgnoreSurroundingSpaces() {\r\n        return ignoreSurroundingSpaces;\r\n    }\r\n\r\n    /**\r\n     * Gets the String to convert to and from {@code null}.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     */\r\n    public String getNullString() {\r\n        return nullString;\r\n    }\r\n\r\n    /**\r\n     * Returns the character used to encapsulate values containing special characters.\r\n     *\r\n     * @return the quoteChar character, may be {@code null}\r\n     */\r\n    public Character getQuoteCharacter() {\r\n        return quoteCharacter;\r\n    }\r\n\r\n    /**\r\n     * Returns the quote policy output fields.\r\n     *\r\n     * @return the quote policy\r\n     */\r\n    public QuoteMode getQuoteMode() {\r\n        return quoteMode;\r\n    }\r\n\r\n    /**\r\n     * Returns the record separator delimiting output records.\r\n     *\r\n     * @return the record separator\r\n     */\r\n    public String getRecordSeparator() {\r\n        return recordSeparator;\r\n    }\r\n\r\n    /**\r\n     * Returns whether to skip the header record.\r\n     *\r\n     * @return whether to skip the header record.\r\n     */\r\n    public boolean getSkipHeaderRecord() {\r\n        return skipHeaderRecord;\r\n    }\r\n\r\n    /**\r\n     * Returns whether to add a trailing delimiter.\r\n     *\r\n     * @return whether to add a trailing delimiter.\r\n     * @since 1.3\r\n     */\r\n    public boolean getTrailingDelimiter() {\r\n        return trailingDelimiter;\r\n    }\r\n\r\n    /**\r\n     * Returns whether to trim leading and trailing blanks. This is used by {@link #print(Object, Appendable, boolean)} Also by\r\n     * {CSVParser#addRecordValue(boolean)}\r\n     *\r\n     * @return whether to trim leading and trailing blanks.\r\n     */\r\n    public boolean getTrim() {\r\n        return trim;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + Arrays.hashCode(header);\r\n        result = prime * result + Arrays.hashCode(headerComments);\r\n        return prime * result + Objects.hash(duplicateHeaderMode, allowMissingColumnNames, autoFlush, commentMarker, delimiter, escapeCharacter,\r\n                ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator,\r\n                skipHeaderRecord, trailingDelimiter, trim);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether comments are supported by this format.\r\n     *\r\n     * Note that the comment introducer character is only recognized at the start of a line.\r\n     *\r\n     * @return {@code true} is comments are supported, {@code false} otherwise\r\n     */\r\n    public boolean isCommentMarkerSet() {\r\n        return commentMarker != null;\r\n    }\r\n\r\n    /**\r\n     * Matches whether the next characters constitute a delimiter\r\n     *\r\n     * @param ch\r\n     *            the current char\r\n     * @param charSeq\r\n     *            the match char sequence\r\n     * @param startIndex\r\n     *            where start to match\r\n     * @param delimiter\r\n     *            the delimiter\r\n     * @param delimiterLength\r\n     *            the delimiter length\r\n     * @return true if the match is successful\r\n     */\r\n    private boolean isDelimiter(final char ch, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength) {\r\n        if (ch != delimiter[0]) {\r\n            return false;\r\n        }\r\n        final int len = charSeq.length();\r\n        if (startIndex + delimiterLength > len) {\r\n            return false;\r\n        }\r\n        for (int i = 1; i < delimiterLength; i++) {\r\n            if (charSeq.charAt(startIndex + i) != delimiter[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns whether escape are being processed.\r\n     *\r\n     * @return {@code true} if escapes are processed\r\n     */\r\n    public boolean isEscapeCharacterSet() {\r\n        return escapeCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Returns whether a nullString has been defined.\r\n     *\r\n     * @return {@code true} if a nullString is defined\r\n     */\r\n    public boolean isNullStringSet() {\r\n        return nullString != null;\r\n    }\r\n\r\n    /**\r\n     * Returns whether a quoteChar has been defined.\r\n     *\r\n     * @return {@code true} if a quoteChar is defined\r\n     */\r\n    public boolean isQuoteCharacterSet() {\r\n        return quoteCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Parses the specified content.\r\n     *\r\n     * <p>\r\n     * See also the various static parse methods on {@link CSVParser}.\r\n     * </p>\r\n     *\r\n     * @param reader the input stream\r\n     * @return a parser over a stream of {@link CSVRecord}s.\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    public CSVParser parse(final Reader reader) throws IOException {\r\n        return new CSVParser(reader, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out the output.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     */\r\n    public CSVPrinter print(final Appendable out) throws IOException {\r\n        return new CSVPrinter(out, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\r\n        // The writer will be closed when close() is called.\r\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\r\n    }\r\n\r\n    /**\r\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated as needed. Useful when one wants to\r\n     * avoid creating CSVPrinters. Trims the value if {@link #getTrim()} is true.\r\n     *\r\n     * @param value     value to output.\r\n     * @param out       where to print the value.\r\n     * @param newRecord if this a new record.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\r\n        // null values are considered empty\r\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\r\n        CharSequence charSequence;\r\n        if (value == null) {\r\n            // https://issues.apache.org/jira/browse/CSV-203\r\n            if (null == nullString) {\r\n                charSequence = EMPTY;\r\n            } else if (QuoteMode.ALL == quoteMode) {\r\n                charSequence = quotedNullString;\r\n            } else {\r\n                charSequence = nullString;\r\n            }\r\n        } else if (value instanceof CharSequence) {\r\n            charSequence = (CharSequence) value;\r\n        } else if (value instanceof Reader) {\r\n            print((Reader) value, out, newRecord);\r\n            return;\r\n        } else {\r\n            charSequence = value.toString();\r\n        }\r\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\r\n        print(value, charSequence, out, newRecord);\r\n    }\r\n\r\n    private synchronized void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\r\n        final int offset = 0;\r\n        final int len = value.length();\r\n        if (!newRecord) {\r\n            out.append(getDelimiterString());\r\n        }\r\n        if (object == null) {\r\n            out.append(value);\r\n        } else if (isQuoteCharacterSet()) {\r\n            // the original object is needed so can check for Number\r\n            printWithQuotes(object, value, out, newRecord);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(value, out);\r\n        } else {\r\n            out.append(value, offset, len);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output, returns a {@code CSVPrinter} which the caller MUST close.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\r\n        return print(Files.newBufferedWriter(out, charset));\r\n    }\r\n\r\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\r\n        // Reader is never null\r\n        if (!newRecord) {\r\n            append(getDelimiterString(), out);\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            printWithQuotes(reader, out);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(reader, out);\r\n        } else if (out instanceof Writer) {\r\n            IOUtils.copyLarge(reader, (Writer) out);\r\n        } else {\r\n            IOUtils.copy(reader, out);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Prints to the {@link System#out}.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @return a printer to {@link System#out}.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    public CSVPrinter printer() throws IOException {\r\n        return new CSVPrinter(System.out, this);\r\n    }\r\n\r\n    /**\r\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\r\n     *\r\n     * @param appendable where to write\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void println(final Appendable appendable) throws IOException {\r\n        if (getTrailingDelimiter()) {\r\n            append(getDelimiterString(), appendable);\r\n        }\r\n        if (recordSeparator != null) {\r\n            append(recordSeparator, appendable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the record separator.\r\n     *\r\n     * <p>\r\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing\r\n     * the record, so there is no need to call {@link #println(Appendable)}.\r\n     * </p>\r\n     *\r\n     * @param appendable    where to write.\r\n     * @param values values to output.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException {\r\n        for (int i = 0; i < values.length; i++) {\r\n            print(values[i], appendable, i == 0);\r\n        }\r\n        println(appendable);\r\n    }\r\n\r\n    /*\r\n     * Note: Must only be called if escaping is enabled, otherwise will generate NPE.\r\n     */\r\n    private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int end = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n\r\n        while (pos < end) {\r\n            char c = charSeq.charAt(pos);\r\n            final boolean isDelimiterStart = isDelimiter(c, charSeq, pos, delim, delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    appendable.append(charSeq, start, pos);\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                appendable.append(escape);\r\n                appendable.append(c);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        pos++;\r\n                        c = charSeq.charAt(pos);\r\n                        appendable.append(escape);\r\n                        appendable.append(c);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            appendable.append(charSeq, start, pos);\r\n        }\r\n    }\r\n\r\n    private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n\r\n        @SuppressWarnings(\"resource\") // Temp reader on input reader.\r\n        final ExtendedBufferedReader bufferedReader = new ExtendedBufferedReader(reader);\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        int c;\r\n        while (-1 != (c = bufferedReader.read())) {\r\n            builder.append((char) c);\r\n            final boolean isDelimiterStart = isDelimiter((char) c, builder.toString() + new String(bufferedReader.lookAhead(delimLength - 1)), pos, delim,\r\n                    delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    append(builder.substring(start, pos), appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                append(escape, appendable);\r\n                append((char) c, appendable);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        c = bufferedReader.read();\r\n                        append(escape, appendable);\r\n                        append((char) c, appendable);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            append(builder.substring(start, pos), appendable);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\r\n     */\r\n    // the original object is needed so can check for Number\r\n    private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\r\n        boolean quote = false;\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int len = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char quoteChar = getQuoteCharacter().charValue();\r\n        // If escape char not specified, default to the quote char\r\n        // This avoids having to keep checking whether there is an escape character\r\n        // at the cost of checking against quote twice\r\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\r\n\r\n        QuoteMode quoteModePolicy = getQuoteMode();\r\n        if (quoteModePolicy == null) {\r\n            quoteModePolicy = QuoteMode.MINIMAL;\r\n        }\r\n        switch (quoteModePolicy) {\r\n        case ALL:\r\n        case ALL_NON_NULL:\r\n            quote = true;\r\n            break;\r\n        case NON_NUMERIC:\r\n            quote = !(object instanceof Number);\r\n            break;\r\n        case NONE:\r\n            // Use the existing escaping code\r\n            printWithEscapes(charSeq, out);\r\n            return;\r\n        case MINIMAL:\r\n            if (len <= 0) {\r\n                // always quote an empty token that is the first\r\n                // on the line, as it may be the only thing on the\r\n                // line. If it were not quoted in that case,\r\n                // an empty line has no tokens.\r\n                if (newRecord) {\r\n                    quote = true;\r\n                }\r\n            } else {\r\n                char c = charSeq.charAt(pos);\r\n\r\n                if (c <= COMMENT) {\r\n                    // Some other chars at the start of a value caused the parser to fail, so for now\r\n                    // encapsulate if we start in anything less than '#'. We are being conservative\r\n                    // by including the default comment char too.\r\n                    quote = true;\r\n                } else {\r\n                    while (pos < len) {\r\n                        c = charSeq.charAt(pos);\r\n                        if (c == LF || c == CR || c == quoteChar || c == escapeChar || isDelimiter(c, charSeq, pos, delim, delimLength)) {\r\n                            quote = true;\r\n                            break;\r\n                        }\r\n                        pos++;\r\n                    }\r\n\r\n                    if (!quote) {\r\n                        pos = len - 1;\r\n                        c = charSeq.charAt(pos);\r\n                        // Some other chars at the end caused the parser to fail, so for now\r\n                        // encapsulate if we end in anything less than ' '\r\n                        if (c <= SP) {\r\n                            quote = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!quote) {\r\n                // no encapsulation needed - write out the original value\r\n                out.append(charSeq, start, len);\r\n                return;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\r\n        }\r\n\r\n        if (!quote) {\r\n            // no encapsulation needed - write out the original value\r\n            out.append(charSeq, start, len);\r\n            return;\r\n        }\r\n\r\n        // we hit something that needed encapsulation\r\n        out.append(quoteChar);\r\n\r\n        // Pick up where we left off: pos should be positioned on the first character that caused\r\n        // the need for encapsulation.\r\n        while (pos < len) {\r\n            final char c = charSeq.charAt(pos);\r\n            if (c == quoteChar || c == escapeChar) {\r\n                // write out the chunk up until this point\r\n                out.append(charSeq, start, pos);\r\n                out.append(escapeChar); // now output the escape\r\n                start = pos; // and restart with the matched char\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write the last segment\r\n        out.append(charSeq, start, pos);\r\n        out.append(quoteChar);\r\n    }\r\n\r\n    /**\r\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\r\n     *\r\n     * @param reader What to print\r\n     * @param appendable Where to print it\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {\r\n\r\n        if (getQuoteMode() == QuoteMode.NONE) {\r\n            printWithEscapes(reader, appendable);\r\n            return;\r\n        }\r\n\r\n        int pos = 0;\r\n\r\n        final char quote = getQuoteCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        append(quote, appendable);\r\n\r\n        int c;\r\n        while (-1 != (c = reader.read())) {\r\n            builder.append((char) c);\r\n            if (c == quote) {\r\n                // write out segment up until this char\r\n                if (pos > 0) {\r\n                    append(builder.substring(0, pos), appendable);\r\n                    append(quote, appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n\r\n                append((char) c, appendable);\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > 0) {\r\n            append(builder.substring(0, pos), appendable);\r\n        }\r\n\r\n        append(quote, appendable);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        final StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\r\n        if (isEscapeCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\r\n        }\r\n        if (quoteMode != null) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\r\n        }\r\n        if (isCommentMarkerSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\r\n        }\r\n        if (isNullStringSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"NullString=<\").append(nullString).append('>');\r\n        }\r\n        if (recordSeparator != null) {\r\n            sb.append(' ');\r\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\r\n        }\r\n        if (getIgnoreEmptyLines()) {\r\n            sb.append(\" EmptyLines:ignored\");\r\n        }\r\n        if (getIgnoreSurroundingSpaces()) {\r\n            sb.append(\" SurroundingSpaces:ignored\");\r\n        }\r\n        if (getIgnoreHeaderCase()) {\r\n            sb.append(\" IgnoreHeaderCase:ignored\");\r\n        }\r\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\r\n        if (headerComments != null) {\r\n            sb.append(' ');\r\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\r\n        }\r\n        if (header != null) {\r\n            sb.append(' ');\r\n            sb.append(\"Header:\").append(Arrays.toString(header));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    /**\r\n     * Verifies the validity and consistency of the attributes, and throws an IllegalArgumentException if necessary.\r\n     *\r\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.\r\n     */\r\n    private void validate() throws IllegalArgumentException {\r\n        if (containsLineBreak(delimiter)) {\r\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n        }\r\n\r\n        if (quoteCharacter != null && contains(delimiter, quoteCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && contains(delimiter, escapeCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\r\n        }\r\n\r\n        if (commentMarker != null && contains(delimiter, commentMarker.charValue())) {\r\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\r\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\r\n        }\r\n\r\n        // validate header\r\n        if (header != null && duplicateHeaderMode != DuplicateHeaderMode.ALLOW_ALL) {\r\n            final Set<String> dupCheck = new HashSet<>();\r\n            for (final String hdr : header) {\r\n                if (!dupCheck.add(hdr)) {\r\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} that allows duplicate header names.\r\n     *\r\n     * @return a new {@code CSVFormat} that allows duplicate header names\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean) Builder#setAllowDuplicateHeaderNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames() {\r\n        return builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     *\r\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n        final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\r\n        return builder().setDuplicateHeaderMode(mode).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @see Builder#setAllowMissingColumnNames(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames() {\r\n        return builder().setAllowMissingColumnNames(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\r\n     *\r\n     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause\r\n     *                                an {@link IllegalArgumentException} to be thrown.\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n        return builder().setAllowMissingColumnNames(allowMissingColumnNames).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with whether to flush on close.\r\n     *\r\n     * @param autoFlush whether to flush on close.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setAutoFlush(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\r\n        return builder().setAutoFlush(autoFlush).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final char commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final Character commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\r\n     *\r\n     * @param delimiter the delimiter character\r\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setDelimiter(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withDelimiter(final char delimiter) {\r\n        return builder().setDelimiter(delimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final char escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final Character escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} using the first record as header.\r\n     *\r\n     * <p>\r\n     * Calling this method is equivalent to calling:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\r\n     * </pre>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but using the first record as header.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(String...) Builder#setHeader()}.{@link Builder#setSkipHeaderRecord(boolean) setSkipHeaderRecord(true)}.\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withFirstRecordAsHeader() {\r\n        // @formatter:off\r\n        return builder()\r\n                .setHeader()\r\n                .setSkipHeaderRecord(true)\r\n                .build();\r\n        // @formatter:on\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\r\n     *\r\n     * <p>\r\n     * Example:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * public enum Header {\r\n     *     Name, Email, Phone\r\n     * }\r\n     *\r\n     * CSVFormat format = aformat.withHeader(Header.class);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setHeader(String...)\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(Class)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\r\n        return builder().setHeader(headerEnum).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(resultSet);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSet)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\r\n        return builder().setHeader(resultSet).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(metaData);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSetMetaData)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n        return builder().setHeader(resultSetMetaData).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file\r\n     * with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @deprecated Use {@link Builder#setHeader(String...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final String... header) {\r\n        return builder().setHeader(header).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.\r\n     * This setting is ignored by the parser.\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n     * </pre>\r\n     *\r\n     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeaderComments(Object...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeaderComments(final Object... headerComments) {\r\n        return builder().setHeaderComments(headerComments).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @see Builder#setIgnoreEmptyLines(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines() {\r\n        return builder().setIgnoreEmptyLines(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty\r\n     *                         lines to empty records.\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n        return builder().setIgnoreEmptyLines(ignoreEmptyLines).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that will ignore case header name.\r\n     * @see Builder#setIgnoreHeaderCase(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean) Builder#setIgnoreHeaderCase(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase() {\r\n        return builder().setIgnoreHeaderCase(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\r\n     *\r\n     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n        return builder().setIgnoreHeaderCase(ignoreHeaderCase).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\r\n     * @see Builder#setIgnoreSurroundingSpaces(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean) Builder#setIgnoreSurroundingSpaces(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces() {\r\n        return builder().setIgnoreSurroundingSpaces(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n        return builder().setIgnoreSurroundingSpaces(ignoreSurroundingSpaces).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\r\n     * @deprecated Use {@link Builder#setNullString(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withNullString(final String nullString) {\r\n        return builder().setNullString(nullString).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final char quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character, use {@code null} to disable.\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final Character quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\r\n     *\r\n     * @param quoteMode the quote policy to use for output.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\r\n     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuoteMode(final QuoteMode quoteMode) {\r\n        return builder().setQuoteMode(quoteMode).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @deprecated Use {@link Builder#setRecordSeparator(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean) Builder#setSkipHeaderRecord(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord() {\r\n        return builder().setSkipHeaderRecord(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\r\n     *\r\n     * @param skipHeaderRecord whether to skip the header record.\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setHeader(String...)\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n        return builder().setSkipHeaderRecord(skipHeaderRecord).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows\r\n     * and LF on Linux.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSystemRecordSeparator() {\r\n        return builder().setRecordSeparator(System.lineSeparator()).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean) Builder#setTrailingDelimiter(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter() {\r\n        return builder().setTrailingDelimiter(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\r\n     *\r\n     * @param trailingDelimiter whether to add a trailing delimiter.\r\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\r\n        return builder().setTrailingDelimiter(trailingDelimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean) Builder#setTrim(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim() {\r\n        return builder().setTrim(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @param trim whether to trim leading and trailing blanks.\r\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim(final boolean trim) {\r\n        return builder().setTrim(trim).build();\r\n    }\r\n}\r",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex ba39b742a..5a47cb8e7 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -346,6 +346,9 @@ public Builder setDelimiter(final String delimiter) {\n             if (containsLineBreak(delimiter)) {\r\n                 throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n             }\r\n+            if (delimiter.isEmpty()) {\r\n+                throw new IllegalArgumentException(\"The delimiter cannot be empty\");\r\n+            }\r\n             this.delimiter = delimiter;\r\n             return this;\r\n         }\r\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 265,
    "title": "CSV-290 - Fix the wrong assumptions in PostgreSQL formats",
    "state": "closed",
    "created_at": "2022-09-25T21:54:02Z",
    "merge_commit_sha": "41a063d2cfd992d526db228e6a237fb7a57b4581",
    "base_sha": "048d507de95b3aaabac5ecc29878390601b47ff3",
    "head_sha": "1ad309fade40c60beafee8eb1a855005e8e6aa7e",
    "user_login": "angusdev",
    "changed_files": [
      {
        "filename": "pom.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.CSVFormat.RFC4180;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testPostgreSQLCsvFormat() {\n        CSVFormat format = CSVFormat.POSTGRESQL_CSV;\n        assertEquals(',', format.getDelimiter());\n        assertNull(format.getEscapeCharacter());\n        assertTrue(format.getIgnoreEmptyLines());\n        assertEquals(Character.valueOf('\"'), format.getQuoteCharacter());\n        assertEquals(LF, format.getRecordSeparator());\n        assertEquals(\"\", format.getNullString());\n        assertEquals(QuoteMode.ALL_NON_NULL, format.getQuoteMode());\n    }\n\n    @Test\n    public void testPostgreSQLTextFormat() {\n        CSVFormat format = CSVFormat.POSTGRESQL_TEXT;\n        assertEquals('\\t', format.getDelimiter());\n        assertEquals(Character.valueOf('\\\\'), format.getEscapeCharacter());\n        assertTrue(format.getIgnoreEmptyLines());\n        assertNull(format.getQuoteCharacter());\n        assertEquals(LF, format.getRecordSeparator());\n        assertEquals(\"\\\\N\", format.getNullString());\n        assertEquals(QuoteMode.ALL_NON_NULL, format.getQuoteMode());\n    }\n\n    @Test\n    public void testPostgreSQLCsvFormatEscapeCharacter() {\n        CSVFormat format = CSVFormat.POSTGRESQL_CSV;\n        assertNull(format.getEscapeCharacter());\n    }\n\n    @Test\n    public void testPostgreSQLTextFormatQuoteCharacter() {\n        CSVFormat format = CSVFormat.POSTGRESQL_TEXT;\n        assertNull(format.getQuoteCharacter());\n    }\n\n    @Test\n    public void testInvalidEscapeCharacter() {\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setEscape(null).build());\n    }\n\n    @Test\n    public void testInvalidQuoteCharacter() {\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.builder().setQuote(null).build());\n    }\n}",
        "file_content": "/*\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n * this work for additional information regarding copyright ownership.\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n * (the \"License\"); you may not use this file except in compliance with\r\n * the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage org.apache.commons.csv;\r\n\r\nimport static org.apache.commons.csv.Constants.BACKSLASH;\r\nimport static org.apache.commons.csv.Constants.COMMA;\r\nimport static org.apache.commons.csv.Constants.COMMENT;\r\nimport static org.apache.commons.csv.Constants.CR;\r\nimport static org.apache.commons.csv.Constants.CRLF;\r\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\r\nimport static org.apache.commons.csv.Constants.EMPTY;\r\nimport static org.apache.commons.csv.Constants.LF;\r\nimport static org.apache.commons.csv.Constants.PIPE;\r\nimport static org.apache.commons.csv.Constants.SP;\r\nimport static org.apache.commons.csv.Constants.TAB;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Serializable;\r\nimport java.io.StringWriter;\r\nimport java.io.Writer;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.Arrays;\r\nimport java.util.HashSet;\r\nimport java.util.Objects;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Specifies the format of a CSV file and parses input.\r\n *\r\n * <h2>Using predefined formats</h2>\r\n *\r\n * <p>\r\n * You can use one of the predefined formats:\r\n * </p>\r\n *\r\n * <ul>\r\n * <li>{@link #DEFAULT}</li>\r\n * <li>{@link #EXCEL}</li>\r\n * <li>{@link #INFORMIX_UNLOAD}</li>\r\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\r\n * <li>{@link #MYSQL}</li>\r\n * <li>{@link #RFC4180}</li>\r\n * <li>{@link #ORACLE}</li>\r\n * <li>{@link #POSTGRESQL_CSV}</li>\r\n * <li>{@link #POSTGRESQL_TEXT}</li>\r\n * <li>{@link #TDF}</li>\r\n * </ul>\r\n *\r\n * <p>\r\n * For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\r\n * </pre>\r\n *\r\n * <p>\r\n * The {@link CSVParser} provides static methods to parse other input types, for example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\r\n * </pre>\r\n *\r\n * <h2>Defining formats</h2>\r\n *\r\n * <p>\r\n * You can extend a format by calling the {@code set} methods. For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\r\n * </pre>\r\n *\r\n * <h2>Defining column names</h2>\r\n *\r\n * <p>\r\n * To define the column names you want to use to access records, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * Calling {@link Builder#setHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and assumes that your CSV source does not\r\n * contain a first record that also defines column names.\r\n *\r\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\r\n * {@link Builder#setSkipHeaderRecord(boolean)} with {@code true}.\r\n * </p>\r\n *\r\n * <h2>Parsing</h2>\r\n *\r\n * <p>\r\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * Reader in = ...;\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\r\n * </pre>\r\n *\r\n * <p>\r\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\r\n * </p>\r\n *\r\n * <h2>Referencing columns safely</h2>\r\n *\r\n * <p>\r\n * If your source contains a header record, you can simplify your code and safely reference columns, by using {@link Builder#setHeader(String...)} with no\r\n * arguments:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader();\r\n * </pre>\r\n *\r\n * <p>\r\n * This causes the parser to read the first record and use its values as column names.\r\n *\r\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\r\n * </p>\r\n *\r\n * <pre>\r\n * String value = record.get(&quot;Col1&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * This makes your code impervious to changes in column order in the CSV file.\r\n * </p>\r\n *\r\n * <h2>Notes</h2>\r\n *\r\n * <p>\r\n * This class is immutable.\r\n * </p>\r\n */\r\npublic final class CSVFormat implements Serializable {\r\n\r\n    /**\r\n     * Builds CSVFormat instances.\r\n     *\r\n     * @since 1.9.0\r\n     */\r\n    public static class Builder {\r\n\r\n        /**\r\n         * Creates a new default builder.\r\n         *\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create() {\r\n            return new Builder(CSVFormat.DEFAULT);\r\n        }\r\n\r\n        /**\r\n         * Creates a new builder for the given format.\r\n         *\r\n         * @param csvFormat the source format.\r\n         * @return a copy of the builder\r\n         */\r\n        public static Builder create(final CSVFormat csvFormat) {\r\n            return new Builder(csvFormat);\r\n        }\r\n\r\n        private boolean allowMissingColumnNames;\r\n\r\n        private boolean autoFlush;\r\n\r\n        private Character commentMarker;\r\n\r\n        private String delimiter;\r\n\r\n        private DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n        private Character escapeCharacter;\r\n\r\n        private String[] headerComments;\r\n\r\n        private String[] headers;\r\n\r\n        private boolean ignoreEmptyLines;\r\n\r\n        private boolean ignoreHeaderCase;\r\n\r\n        private boolean ignoreSurroundingSpaces;\r\n\r\n        private String nullString;\r\n\r\n        private Character quoteCharacter;\r\n\r\n        private String quotedNullString;\r\n\r\n        private QuoteMode quoteMode;\r\n\r\n        private String recordSeparator;\r\n\r\n        private boolean skipHeaderRecord;\r\n\r\n        private boolean trailingDelimiter;\r\n\r\n        private boolean trim;\r\n\r\n        private Builder(final CSVFormat csvFormat) {\r\n            this.delimiter = csvFormat.delimiter;\r\n            this.quoteCharacter = csvFormat.quoteCharacter;\r\n            this.quoteMode = csvFormat.quoteMode;\r\n            this.commentMarker = csvFormat.commentMarker;\r\n            this.escapeCharacter = csvFormat.escapeCharacter;\r\n            this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;\r\n            this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;\r\n            this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;\r\n            this.recordSeparator = csvFormat.recordSeparator;\r\n            this.nullString = csvFormat.nullString;\r\n            this.headerComments = csvFormat.headerComments;\r\n            this.headers = csvFormat.header;\r\n            this.skipHeaderRecord = csvFormat.skipHeaderRecord;\r\n            this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;\r\n            this.trailingDelimiter = csvFormat.trailingDelimiter;\r\n            this.trim = csvFormat.trim;\r\n            this.autoFlush = csvFormat.autoFlush;\r\n            this.quotedNullString = csvFormat.quotedNullString;\r\n            this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;\r\n        }\r\n\r\n        /**\r\n         * Builds a new CSVFormat instance.\r\n         *\r\n         * @return a new CSVFormat instance.\r\n         */\r\n        public CSVFormat build() {\r\n            return new CSVFormat(this);\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior, true to allow, false to disallow.\r\n         *\r\n         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n         * @return This instance.\r\n         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.\r\n         */\r\n        @Deprecated\r\n        public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n            final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\r\n            setDuplicateHeaderMode(mode);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\r\n         * {@link IllegalArgumentException} to be thrown.\r\n         *\r\n         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\r\n         *                                cause an {@link IllegalArgumentException} to be thrown.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n            this.allowMissingColumnNames = allowMissingColumnNames;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to flush on close.\r\n         *\r\n         * @param autoFlush whether to flush on close.\r\n         * @return This instance.\r\n         */\r\n        public Builder setAutoFlush(final boolean autoFlush) {\r\n            this.autoFlush = autoFlush;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final char commentMarker) {\r\n            setCommentMarker(Character.valueOf(commentMarker));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setCommentMarker(final Character commentMarker) {\r\n            if (isLineBreak(commentMarker)) {\r\n                throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\r\n            }\r\n            this.commentMarker = commentMarker;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final char delimiter) {\r\n            return setDelimiter(String.valueOf(delimiter));\r\n        }\r\n\r\n        /**\r\n         * Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setDelimiter(final String delimiter) {\r\n            if (containsLineBreak(delimiter)) {\r\n                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n            }\r\n            this.delimiter = delimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the duplicate header names behavior.\r\n         *\r\n         * @param duplicateHeaderMode the duplicate header names behavior\r\n         * @return This instance.\r\n         */\r\n        public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {\r\n          this.duplicateHeaderMode = duplicateHeaderMode;\r\n          return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final char escapeCharacter) {\r\n            setEscape(Character.valueOf(escapeCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break\r\n         */\r\n        public Builder setEscape(final Character escapeCharacter) {\r\n            if (isLineBreak(escapeCharacter)) {\r\n                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\r\n            }\r\n            this.escapeCharacter = escapeCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header defined by the given {@link Enum} class.\r\n         *\r\n         * <p>\r\n         * Example:\r\n         * </p>\r\n         *\r\n         * <pre>\r\n         * public enum HeaderEnum {\r\n         *     Name, Email, Phone\r\n         * }\r\n         *\r\n         * Builder builder = builder.setHeader(HeaderEnum.class);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {\r\n            String[] header = null;\r\n            if (headerEnum != null) {\r\n                final Enum<?>[] enumValues = headerEnum.getEnumConstants();\r\n                header = new String[enumValues.length];\r\n                Arrays.setAll(header, i -> enumValues[i].name());\r\n            }\r\n            return setHeader(header);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSet);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSet resultSet) throws SQLException {\r\n            return setHeader(resultSet != null ? resultSet.getMetaData() : null);\r\n        }\r\n\r\n        /**\r\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(resultSetMetaData);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n         */\r\n        public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n            String[] labels = null;\r\n            if (resultSetMetaData != null) {\r\n                final int columnCount = resultSetMetaData.getColumnCount();\r\n                labels = new String[columnCount];\r\n                for (int i = 0; i < columnCount; i++) {\r\n                    labels[i] = resultSetMetaData.getColumnLabel(i + 1);\r\n                }\r\n            }\r\n            return setHeader(labels);\r\n        }\r\n\r\n        /**\r\n         * Sets the header to the given values. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeader(final String... header) {\r\n            this.headers = CSVFormat.clone(header);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final Object... headerComments) {\r\n            this.headerComments = CSVFormat.clone(toStringArray(headerComments));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * Builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance.\r\n         */\r\n        public Builder setHeaderComments(final String... headerComments) {\r\n            this.headerComments = CSVFormat.clone(headerComments);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty\r\n         * records.\r\n         *\r\n         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate\r\n         *                         empty lines to empty records.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n            this.ignoreEmptyLines = ignoreEmptyLines;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         *\r\n         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n            this.ignoreHeaderCase = ignoreHeaderCase;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         *\r\n         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         * @return This instance.\r\n         */\r\n        public Builder setIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         *\r\n         * <ul>\r\n         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n         * </ul>\r\n         *\r\n         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         * @return This instance.\r\n         */\r\n        public Builder setNullString(final String nullString) {\r\n            this.nullString = nullString;\r\n            this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character.\r\n         *\r\n         * @param quoteCharacter the quote character.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final char quoteCharacter) {\r\n            setQuote(Character.valueOf(quoteCharacter));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote character, use {@code null} to disable.\r\n         *\r\n         * @param quoteCharacter the quote character, use {@code null} to disable.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuote(final Character quoteCharacter) {\r\n            if (isLineBreak(quoteCharacter)) {\r\n                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\r\n            }\r\n            this.quoteCharacter = quoteCharacter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the quote policy to use for output.\r\n         *\r\n         * @param quoteMode the quote policy to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setQuoteMode(final QuoteMode quoteMode) {\r\n            this.quoteMode = quoteMode;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final char recordSeparator) {\r\n            this.recordSeparator = String.valueOf(recordSeparator);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance.\r\n         */\r\n        public Builder setRecordSeparator(final String recordSeparator) {\r\n            this.recordSeparator = recordSeparator;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to skip the header record.\r\n         *\r\n         * @param skipHeaderRecord whether to skip the header record.\r\n         * @return This instance.\r\n         */\r\n        public Builder setSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n            this.skipHeaderRecord = skipHeaderRecord;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to add a trailing delimiter.\r\n         *\r\n         * @param trailingDelimiter whether to add a trailing delimiter.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrailingDelimiter(final boolean trailingDelimiter) {\r\n            this.trailingDelimiter = trailingDelimiter;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets whether to trim leading and trailing blanks.\r\n         *\r\n         * @param trim whether to trim leading and trailing blanks.\r\n         * @return This instance.\r\n         */\r\n        public Builder setTrim(final boolean trim) {\r\n            this.trim = trim;\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Predefines formats.\r\n     *\r\n     * @since 1.2\r\n     */\r\n    public enum Predefined {\r\n\r\n        /**\r\n         * @see CSVFormat#DEFAULT\r\n         */\r\n        Default(CSVFormat.DEFAULT),\r\n\r\n        /**\r\n         * @see CSVFormat#EXCEL\r\n         */\r\n        Excel(CSVFormat.EXCEL),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD\r\n         * @since 1.3\r\n         */\r\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\r\n\r\n        /**\r\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\r\n         * @since 1.3\r\n         */\r\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_CSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MONGODB_TSV\r\n         * @since 1.7\r\n         */\r\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\r\n\r\n        /**\r\n         * @see CSVFormat#MYSQL\r\n         */\r\n        MySQL(CSVFormat.MYSQL),\r\n\r\n        /**\r\n         * @see CSVFormat#ORACLE\r\n         */\r\n        Oracle(CSVFormat.ORACLE),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         * @since 1.5\r\n         */\r\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\r\n\r\n        /**\r\n         * @see CSVFormat#POSTGRESQL_CSV\r\n         */\r\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\r\n\r\n        /**\r\n         * @see CSVFormat#RFC4180\r\n         */\r\n        RFC4180(CSVFormat.RFC4180),\r\n\r\n        /**\r\n         * @see CSVFormat#TDF\r\n         */\r\n        TDF(CSVFormat.TDF);\r\n\r\n        private final CSVFormat format;\r\n\r\n        Predefined(final CSVFormat format) {\r\n            this.format = format;\r\n        }\r\n\r\n        /**\r\n         * Gets the format.\r\n         *\r\n         * @return the format.\r\n         */\r\n        public CSVFormat getFormat() {\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing\r\n     * empty lines.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Default\r\n     */\r\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false,\r\n            false, false, false, DuplicateHeaderMode.ALLOW_ALL);\r\n\r\n    /**\r\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is locale dependent, it might be necessary\r\n     * to customize this format to accommodate to your regional settings.\r\n     *\r\n     * <p>\r\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setAllowMissingColumnNames(true)}</li>\r\n     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\r\n     * </ul>\r\n     * <p>\r\n     * Note: This is currently like {@link #RFC4180} plus {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)} and\r\n     * {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(false)}.\r\n     * </p>\r\n     *\r\n     * @see Predefined#Excel\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat EXCEL = DEFAULT.builder()\r\n            .setIgnoreEmptyLines(false)\r\n            .setAllowMissingColumnNames(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.builder()\r\n            .setDelimiter(PIPE)\r\n            .setEscape(BACKSLASH)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\r\n     * The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote(\"\\\"\")}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\r\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\r\n     * @since 1.3\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with {@code '\"'}. A header line with field\r\n     * names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\r\n     * <p>\r\n     * <b>Parsing is not supported yet.</b>\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format. Values are double quoted only if needed and special\r\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * <li>{@code setSkipHeaderRecord(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MongoDBCsv\r\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\r\n     *          documentation</a>\r\n     * @since 1.7\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MONGODB_TSV = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .setSkipHeaderRecord(false)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote(null)}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\r\n     *      -data.html</a>\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat MYSQL = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(null)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(\"\\\\N\")\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default Oracle format used by the SQL*Loader utility.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\r\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\r\n     * {@code \"\"}. Values are trimmed.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setTrim()}</li>\r\n     * <li>{@code setSystemRecordSeparator()}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.MINIMAL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#Oracle\r\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\r\n     * @since 1.6\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat ORACLE = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setNullString(\"\\\\N\")\r\n            .setTrim(true)\r\n            .setRecordSeparator(System.lineSeparator())\r\n            .setQuoteMode(QuoteMode.MINIMAL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\r\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setEscape('\"')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder()\r\n            .setDelimiter(COMMA)\r\n            .setEscape(DOUBLE_QUOTE_CHAR)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(EMPTY)\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Default PostgreSQL text format used by the {@code COPY} operation.\r\n     *\r\n     * <p>\r\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\r\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setEscape('\\\\')}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator('\\n')}</li>\r\n     * <li>{@code setNullString(\"\\\\N\")}</li>\r\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#MySQL\r\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\r\n     *          documentation</a>\r\n     * @since 1.5\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setEscape(BACKSLASH)\r\n            .setIgnoreEmptyLines(false)\r\n            .setQuote(DOUBLE_QUOTE_CHAR)\r\n            .setRecordSeparator(LF)\r\n            .setNullString(\"\\\\N\")\r\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n            .build();\r\n    // @formatter:off\r\n\r\n    /**\r\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter(',')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#RFC4180\r\n     */\r\n    public static final CSVFormat RFC4180 = DEFAULT.builder().setIgnoreEmptyLines(false).build();\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    /**\r\n     * Tab-delimited format.\r\n     *\r\n     * <p>\r\n     * The {@link Builder} settings are:\r\n     * </p>\r\n     * <ul>\r\n     * <li>{@code setDelimiter('\\t')}</li>\r\n     * <li>{@code setQuote('\"')}</li>\r\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\r\n     * <li>{@code setIgnoreSurroundingSpaces(true)}</li>\r\n     * </ul>\r\n     *\r\n     * @see Predefined#TDF\r\n     */\r\n    // @formatter:off\r\n    public static final CSVFormat TDF = DEFAULT.builder()\r\n            .setDelimiter(TAB)\r\n            .setIgnoreSurroundingSpaces(true)\r\n            .build();\r\n    // @formatter:on\r\n\r\n    /**\r\n     * Null-safe clone of an array.\r\n     *\r\n     * @param <T>    The array element type.\r\n     * @param values the source array\r\n     * @return the cloned array.\r\n     */\r\n    @SafeVarargs\r\n    static <T> T[] clone(final T... values) {\r\n        return values == null ? null : values.clone();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains the search char.\r\n     *\r\n     * @param source the string to check.\r\n     * @param searchCh the character to search.\r\n     *\r\n     * @return true if {@code c} contains a line break character\r\n     */\r\n    private static boolean contains(final String source, final char searchCh) {\r\n        return Objects.requireNonNull(source, \"source\").indexOf(searchCh) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given string contains a line break character.\r\n     *\r\n     * @param source the string to check.\r\n     *\r\n     * @return true if {@code c} contains a line break character.\r\n     */\r\n    private static boolean containsLineBreak(final String source) {\r\n        return contains(source, CR) || contains(source, LF);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check.\r\n     *\r\n     * @return true if {@code c} is a line break character.\r\n     */\r\n    private static boolean isLineBreak(final char c) {\r\n        return c == LF || c == CR;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check, may be null.\r\n     *\r\n     * @return true if {@code c} is a line break character (and not null).\r\n     */\r\n    private static boolean isLineBreak(final Character c) {\r\n        return c != null && isLineBreak(c.charValue());\r\n    }\r\n\r\n    /**\r\n     * Creates a new CSV format with the specified delimiter.\r\n     *\r\n     * <p>\r\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.\r\n     * </p>\r\n     *\r\n     * @param delimiter the char used for value separation, must not be a line break character\r\n     * @return a new CSV format.\r\n     * @throws IllegalArgumentException if the delimiter is a line break character\r\n     *\r\n     * @see #DEFAULT\r\n     * @see #RFC4180\r\n     * @see #MYSQL\r\n     * @see #EXCEL\r\n     * @see #TDF\r\n     */\r\n    public static CSVFormat newFormat(final char delimiter) {\r\n        return new CSVFormat(String.valueOf(delimiter), null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false,\r\n                DuplicateHeaderMode.ALLOW_ALL);\r\n    }\r\n\r\n    static String[] toStringArray(final Object[] values) {\r\n        if (values == null) {\r\n            return null;\r\n        }\r\n        final String[] strings = new String[values.length];\r\n        Arrays.setAll(strings, i -> Objects.toString(values[i], null));\r\n        return strings;\r\n    }\r\n\r\n    static CharSequence trim(final CharSequence charSequence) {\r\n        if (charSequence instanceof String) {\r\n            return ((String) charSequence).trim();\r\n        }\r\n        final int count = charSequence.length();\r\n        int len = count;\r\n        int pos = 0;\r\n\r\n        while (pos < len && charSequence.charAt(pos) <= SP) {\r\n            pos++;\r\n        }\r\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\r\n            len--;\r\n        }\r\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\r\n    }\r\n\r\n    /**\r\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\r\n     *\r\n     * @param format name\r\n     * @return one of the predefined formats\r\n     * @since 1.2\r\n     */\r\n    public static CSVFormat valueOf(final String format) {\r\n        return CSVFormat.Predefined.valueOf(format).getFormat();\r\n    }\r\n\r\n    private final DuplicateHeaderMode duplicateHeaderMode;\r\n\r\n    private final boolean allowMissingColumnNames;\r\n\r\n    private final boolean autoFlush;\r\n\r\n    private final Character commentMarker; // null if commenting is disabled\r\n\r\n    private final String delimiter;\r\n\r\n    private final Character escapeCharacter; // null if escaping is disabled\r\n\r\n    private final String[] header; // array of header column names\r\n\r\n    private final String[] headerComments; // array of header comment lines\r\n\r\n    private final boolean ignoreEmptyLines;\r\n\r\n    private final boolean ignoreHeaderCase; // should ignore header names case\r\n\r\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\r\n\r\n    private final String nullString; // the string to be used for null values\r\n\r\n    private final Character quoteCharacter; // null if quoting is disabled\r\n\r\n    private final String quotedNullString;\r\n\r\n    private final QuoteMode quoteMode;\r\n\r\n    private final String recordSeparator; // for outputs\r\n\r\n    private final boolean skipHeaderRecord;\r\n\r\n    private final boolean trailingDelimiter;\r\n\r\n    private final boolean trim;\r\n\r\n    private CSVFormat(final Builder builder) {\r\n        this.delimiter = builder.delimiter;\r\n        this.quoteCharacter = builder.quoteCharacter;\r\n        this.quoteMode = builder.quoteMode;\r\n        this.commentMarker = builder.commentMarker;\r\n        this.escapeCharacter = builder.escapeCharacter;\r\n        this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = builder.allowMissingColumnNames;\r\n        this.ignoreEmptyLines = builder.ignoreEmptyLines;\r\n        this.recordSeparator = builder.recordSeparator;\r\n        this.nullString = builder.nullString;\r\n        this.headerComments = builder.headerComments;\r\n        this.header = builder.headers;\r\n        this.skipHeaderRecord = builder.skipHeaderRecord;\r\n        this.ignoreHeaderCase = builder.ignoreHeaderCase;\r\n        this.trailingDelimiter = builder.trailingDelimiter;\r\n        this.trim = builder.trim;\r\n        this.autoFlush = builder.autoFlush;\r\n        this.quotedNullString = builder.quotedNullString;\r\n        this.duplicateHeaderMode = builder.duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    /**\r\n     * Creates a customized CSV format.\r\n     *\r\n     * @param delimiter               the char used for value separation, must not be a line break character.\r\n     * @param quoteChar               the Character used as value encapsulation marker, may be {@code null} to disable.\r\n     * @param quoteMode               the quote mode.\r\n     * @param commentStart            the Character used for comment identification, may be {@code null} to disable.\r\n     * @param escape                  the Character used to escape special characters in values, may be {@code null} to disable.\r\n     * @param ignoreSurroundingSpaces {@code true} when whitespaces enclosing values should be ignored.\r\n     * @param ignoreEmptyLines        {@code true} when the parser should skip empty lines.\r\n     * @param recordSeparator         the line separator to use for output.\r\n     * @param nullString              the line separator to use for output.\r\n     * @param headerComments          the comments to be printed by the Printer before the actual CSV data.\r\n     * @param header                  the header\r\n     * @param skipHeaderRecord        TODO Doc me.\r\n     * @param allowMissingColumnNames TODO Doc me.\r\n     * @param ignoreHeaderCase        TODO Doc me.\r\n     * @param trim                    TODO Doc me.\r\n     * @param trailingDelimiter       TODO Doc me.\r\n     * @param autoFlush               TODO Doc me.\r\n     * @param duplicateHeaderMode     the behavior when handling duplicate headers\r\n     * @throws IllegalArgumentException if the delimiter is a line break character.\r\n     */\r\n    private CSVFormat(final String delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape,\r\n            final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\r\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames,\r\n            final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush,\r\n            final DuplicateHeaderMode duplicateHeaderMode) {\r\n        this.delimiter = delimiter;\r\n        this.quoteCharacter = quoteChar;\r\n        this.quoteMode = quoteMode;\r\n        this.commentMarker = commentStart;\r\n        this.escapeCharacter = escape;\r\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\r\n        this.allowMissingColumnNames = allowMissingColumnNames;\r\n        this.ignoreEmptyLines = ignoreEmptyLines;\r\n        this.recordSeparator = recordSeparator;\r\n        this.nullString = nullString;\r\n        this.headerComments = toStringArray(headerComments);\r\n        this.header = clone(header);\r\n        this.skipHeaderRecord = skipHeaderRecord;\r\n        this.ignoreHeaderCase = ignoreHeaderCase;\r\n        this.trailingDelimiter = trailingDelimiter;\r\n        this.trim = trim;\r\n        this.autoFlush = autoFlush;\r\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\r\n        this.duplicateHeaderMode = duplicateHeaderMode;\r\n        validate();\r\n    }\r\n\r\n    private void append(final char c, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(c);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    private void append(final CharSequence csq, final Appendable appendable) throws IOException {\r\n        //try {\r\n            appendable.append(csq);\r\n        //} catch (final IOException e) {\r\n        //    throw new UncheckedIOException(e);\r\n        //}\r\n    }\r\n\r\n    /**\r\n     * Creates a new Builder for this instance.\r\n     *\r\n     * @return a new Builder.\r\n     */\r\n    public Builder builder() {\r\n        return Builder.create(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a copy of this instance.\r\n     *\r\n     * @return a copy of this instance.\r\n     */\r\n    CSVFormat copy() {\r\n        return builder().build();\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(final Object obj) {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (obj == null || getClass() != obj.getClass()) {\r\n            return false;\r\n        }\r\n        final CSVFormat other = (CSVFormat) obj;\r\n        return duplicateHeaderMode == other.duplicateHeaderMode && allowMissingColumnNames == other.allowMissingColumnNames &&\r\n                autoFlush == other.autoFlush && Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) &&\r\n                Objects.equals(escapeCharacter, other.escapeCharacter) && Arrays.equals(header, other.header) &&\r\n                Arrays.equals(headerComments, other.headerComments) && ignoreEmptyLines == other.ignoreEmptyLines &&\r\n                ignoreHeaderCase == other.ignoreHeaderCase && ignoreSurroundingSpaces == other.ignoreSurroundingSpaces &&\r\n                Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) && quoteMode == other.quoteMode &&\r\n                Objects.equals(quotedNullString, other.quotedNullString) && Objects.equals(recordSeparator, other.recordSeparator) &&\r\n                skipHeaderRecord == other.skipHeaderRecord && trailingDelimiter == other.trailingDelimiter && trim == other.trim;\r\n    }\r\n\r\n    /**\r\n     * Formats the specified values.\r\n     *\r\n     * @param values the values to format\r\n     * @return the formatted values\r\n     */\r\n    public String format(final Object... values) {\r\n        final StringWriter out = new StringWriter();\r\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\r\n            csvPrinter.printRecord(values);\r\n            final String res = out.toString();\r\n            final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\r\n            return res.substring(0, len);\r\n        } catch (final IOException e) {\r\n            // should not happen because a StringWriter does not do IO.\r\n            throw new IllegalStateException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if and only if duplicate names are allowed in the headers.\r\n     *\r\n     * @return whether duplicate header names are allowed\r\n     * @since 1.7\r\n     * @deprecated Use {@link #getDuplicateHeaderMode()}.\r\n     */\r\n    @Deprecated\r\n    public boolean getAllowDuplicateHeaderNames() {\r\n        return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether missing column names are allowed when parsing the header line.\r\n     *\r\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an {@link IllegalArgumentException}.\r\n     */\r\n    public boolean getAllowMissingColumnNames() {\r\n        return allowMissingColumnNames;\r\n    }\r\n\r\n    /**\r\n     * Returns whether to flush on close.\r\n     *\r\n     * @return whether to flush on close.\r\n     * @since 1.6\r\n     */\r\n    public boolean getAutoFlush() {\r\n        return autoFlush;\r\n    }\r\n\r\n    /**\r\n     * Returns the character marking the start of a line comment.\r\n     *\r\n     * @return the comment start marker, may be {@code null}\r\n     */\r\n    public Character getCommentMarker() {\r\n        return commentMarker;\r\n    }\r\n\r\n    /**\r\n     * Returns the first character delimiting the values (typically ';', ',' or '\\t').\r\n     *\r\n     * @return the first delimiter character.\r\n     * @deprecated Use {@link #getDelimiterString()}.\r\n     */\r\n    @Deprecated\r\n    public char getDelimiter() {\r\n        return delimiter.charAt(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the character delimiting the values (typically \";\", \",\" or \"\\t\").\r\n     *\r\n     * @return the delimiter.\r\n     */\r\n    public String getDelimiterString() {\r\n        return delimiter;\r\n    }\r\n\r\n    /**\r\n     * Gets how duplicate headers are handled.\r\n     *\r\n     * @return if duplicate header values are allowed, allowed conditionally, or disallowed.\r\n     * @since 1.9.0\r\n     */\r\n    public DuplicateHeaderMode getDuplicateHeaderMode() {\r\n        return duplicateHeaderMode;\r\n    }\r\n\r\n    /**\r\n     * Returns the escape character.\r\n     *\r\n     * @return the escape character, may be {@code null}\r\n     */\r\n    public Character getEscapeCharacter() {\r\n        return escapeCharacter;\r\n    }\r\n\r\n    /**\r\n     * Returns a copy of the header array.\r\n     *\r\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\r\n     */\r\n    public String[] getHeader() {\r\n        return header != null ? header.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Returns a copy of the header comment array.\r\n     *\r\n     * @return a copy of the header comment array; {@code null} if disabled.\r\n     */\r\n    public String[] getHeaderComments() {\r\n        return headerComments != null ? headerComments.clone() : null;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether empty lines between records are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty records.\r\n     */\r\n    public boolean getIgnoreEmptyLines() {\r\n        return ignoreEmptyLines;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether header names will be accessed ignoring case.\r\n     *\r\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\r\n     * @since 1.3\r\n     */\r\n    public boolean getIgnoreHeaderCase() {\r\n        return ignoreHeaderCase;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether spaces around values are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\r\n     */\r\n    public boolean getIgnoreSurroundingSpaces() {\r\n        return ignoreSurroundingSpaces;\r\n    }\r\n\r\n    /**\r\n     * Gets the String to convert to and from {@code null}.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     */\r\n    public String getNullString() {\r\n        return nullString;\r\n    }\r\n\r\n    /**\r\n     * Returns the character used to encapsulate values containing special characters.\r\n     *\r\n     * @return the quoteChar character, may be {@code null}\r\n     */\r\n    public Character getQuoteCharacter() {\r\n        return quoteCharacter;\r\n    }\r\n\r\n    /**\r\n     * Returns the quote policy output fields.\r\n     *\r\n     * @return the quote policy\r\n     */\r\n    public QuoteMode getQuoteMode() {\r\n        return quoteMode;\r\n    }\r\n\r\n    /**\r\n     * Returns the record separator delimiting output records.\r\n     *\r\n     * @return the record separator\r\n     */\r\n    public String getRecordSeparator() {\r\n        return recordSeparator;\r\n    }\r\n\r\n    /**\r\n     * Returns whether to skip the header record.\r\n     *\r\n     * @return whether to skip the header record.\r\n     */\r\n    public boolean getSkipHeaderRecord() {\r\n        return skipHeaderRecord;\r\n    }\r\n\r\n    /**\r\n     * Returns whether to add a trailing delimiter.\r\n     *\r\n     * @return whether to add a trailing delimiter.\r\n     * @since 1.3\r\n     */\r\n    public boolean getTrailingDelimiter() {\r\n        return trailingDelimiter;\r\n    }\r\n\r\n    /**\r\n     * Returns whether to trim leading and trailing blanks. This is used by {@link #print(Object, Appendable, boolean)} Also by\r\n     * {CSVParser#addRecordValue(boolean)}\r\n     *\r\n     * @return whether to trim leading and trailing blanks.\r\n     */\r\n    public boolean getTrim() {\r\n        return trim;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + Arrays.hashCode(header);\r\n        result = prime * result + Arrays.hashCode(headerComments);\r\n        return prime * result + Objects.hash(duplicateHeaderMode, allowMissingColumnNames, autoFlush, commentMarker, delimiter, escapeCharacter,\r\n                ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator,\r\n                skipHeaderRecord, trailingDelimiter, trim);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether comments are supported by this format.\r\n     *\r\n     * Note that the comment introducer character is only recognized at the start of a line.\r\n     *\r\n     * @return {@code true} is comments are supported, {@code false} otherwise\r\n     */\r\n    public boolean isCommentMarkerSet() {\r\n        return commentMarker != null;\r\n    }\r\n\r\n    /**\r\n     * Matches whether the next characters constitute a delimiter\r\n     *\r\n     * @param ch\r\n     *            the current char\r\n     * @param charSeq\r\n     *            the match char sequence\r\n     * @param startIndex\r\n     *            where start to match\r\n     * @param delimiter\r\n     *            the delimiter\r\n     * @param delimiterLength\r\n     *            the delimiter length\r\n     * @return true if the match is successful\r\n     */\r\n    private boolean isDelimiter(final char ch, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength) {\r\n        if (ch != delimiter[0]) {\r\n            return false;\r\n        }\r\n        final int len = charSeq.length();\r\n        if (startIndex + delimiterLength > len) {\r\n            return false;\r\n        }\r\n        for (int i = 1; i < delimiterLength; i++) {\r\n            if (charSeq.charAt(startIndex + i) != delimiter[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns whether escape are being processed.\r\n     *\r\n     * @return {@code true} if escapes are processed\r\n     */\r\n    public boolean isEscapeCharacterSet() {\r\n        return escapeCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Returns whether a nullString has been defined.\r\n     *\r\n     * @return {@code true} if a nullString is defined\r\n     */\r\n    public boolean isNullStringSet() {\r\n        return nullString != null;\r\n    }\r\n\r\n    /**\r\n     * Returns whether a quoteChar has been defined.\r\n     *\r\n     * @return {@code true} if a quoteChar is defined\r\n     */\r\n    public boolean isQuoteCharacterSet() {\r\n        return quoteCharacter != null;\r\n    }\r\n\r\n    /**\r\n     * Parses the specified content.\r\n     *\r\n     * <p>\r\n     * See also the various static parse methods on {@link CSVParser}.\r\n     * </p>\r\n     *\r\n     * @param reader the input stream\r\n     * @return a parser over a stream of {@link CSVRecord}s.\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    public CSVParser parse(final Reader reader) throws IOException {\r\n        return new CSVParser(reader, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out the output.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     */\r\n    public CSVPrinter print(final Appendable out) throws IOException {\r\n        return new CSVPrinter(out, this);\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\r\n        // The writer will be closed when close() is called.\r\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\r\n    }\r\n\r\n    /**\r\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated as needed. Useful when one wants to\r\n     * avoid creating CSVPrinters. Trims the value if {@link #getTrim()} is true.\r\n     *\r\n     * @param value     value to output.\r\n     * @param out       where to print the value.\r\n     * @param newRecord if this a new record.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\r\n        // null values are considered empty\r\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\r\n        CharSequence charSequence;\r\n        if (value == null) {\r\n            // https://issues.apache.org/jira/browse/CSV-203\r\n            if (null == nullString) {\r\n                charSequence = EMPTY;\r\n            } else if (QuoteMode.ALL == quoteMode) {\r\n                charSequence = quotedNullString;\r\n            } else {\r\n                charSequence = nullString;\r\n            }\r\n        } else if (value instanceof CharSequence) {\r\n            charSequence = (CharSequence) value;\r\n        } else if (value instanceof Reader) {\r\n            print((Reader) value, out, newRecord);\r\n            return;\r\n        } else {\r\n            charSequence = value.toString();\r\n        }\r\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\r\n        print(value, charSequence, out, newRecord);\r\n    }\r\n\r\n    private synchronized void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\r\n        final int offset = 0;\r\n        final int len = value.length();\r\n        if (!newRecord) {\r\n            out.append(getDelimiterString());\r\n        }\r\n        if (object == null) {\r\n            out.append(value);\r\n        } else if (isQuoteCharacterSet()) {\r\n            // the original object is needed so can check for Number\r\n            printWithQuotes(object, value, out, newRecord);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(value, out);\r\n        } else {\r\n            out.append(value, offset, len);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints to the specified output, returns a {@code CSVPrinter} which the caller MUST close.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    @SuppressWarnings(\"resource\")\r\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\r\n        return print(Files.newBufferedWriter(out, charset));\r\n    }\r\n\r\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\r\n        // Reader is never null\r\n        if (!newRecord) {\r\n            append(getDelimiterString(), out);\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            printWithQuotes(reader, out);\r\n        } else if (isEscapeCharacterSet()) {\r\n            printWithEscapes(reader, out);\r\n        } else if (out instanceof Writer) {\r\n            IOUtils.copyLarge(reader, (Writer) out);\r\n        } else {\r\n            IOUtils.copy(reader, out);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Prints to the {@link System#out}.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @return a printer to {@link System#out}.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5\r\n     */\r\n    public CSVPrinter printer() throws IOException {\r\n        return new CSVPrinter(System.out, this);\r\n    }\r\n\r\n    /**\r\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\r\n     *\r\n     * @param appendable where to write\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void println(final Appendable appendable) throws IOException {\r\n        if (getTrailingDelimiter()) {\r\n            append(getDelimiterString(), appendable);\r\n        }\r\n        if (recordSeparator != null) {\r\n            append(recordSeparator, appendable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the record separator.\r\n     *\r\n     * <p>\r\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing\r\n     * the record, so there is no need to call {@link #println(Appendable)}.\r\n     * </p>\r\n     *\r\n     * @param appendable    where to write.\r\n     * @param values values to output.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4\r\n     */\r\n    public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException {\r\n        for (int i = 0; i < values.length; i++) {\r\n            print(values[i], appendable, i == 0);\r\n        }\r\n        println(appendable);\r\n    }\r\n\r\n    /*\r\n     * Note: Must only be called if escaping is enabled, otherwise will generate NPE.\r\n     */\r\n    private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int end = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n\r\n        while (pos < end) {\r\n            char c = charSeq.charAt(pos);\r\n            final boolean isDelimiterStart = isDelimiter(c, charSeq, pos, delim, delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    appendable.append(charSeq, start, pos);\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                appendable.append(escape);\r\n                appendable.append(c);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        pos++;\r\n                        c = charSeq.charAt(pos);\r\n                        appendable.append(escape);\r\n                        appendable.append(c);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            appendable.append(charSeq, start, pos);\r\n        }\r\n    }\r\n\r\n    private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {\r\n        int start = 0;\r\n        int pos = 0;\r\n\r\n        @SuppressWarnings(\"resource\") // Temp reader on input reader.\r\n        final ExtendedBufferedReader bufferedReader = new ExtendedBufferedReader(reader);\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char escape = getEscapeCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        int c;\r\n        while (-1 != (c = bufferedReader.read())) {\r\n            builder.append((char) c);\r\n            final boolean isDelimiterStart = isDelimiter((char) c, builder.toString() + new String(bufferedReader.lookAhead(delimLength - 1)), pos, delim,\r\n                    delimLength);\r\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\r\n                // write out segment up until this char\r\n                if (pos > start) {\r\n                    append(builder.substring(start, pos), appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n                if (c == LF) {\r\n                    c = 'n';\r\n                } else if (c == CR) {\r\n                    c = 'r';\r\n                }\r\n\r\n                append(escape, appendable);\r\n                append((char) c, appendable);\r\n\r\n                if (isDelimiterStart) {\r\n                    for (int i = 1; i < delimLength; i++) {\r\n                        c = bufferedReader.read();\r\n                        append(escape, appendable);\r\n                        append((char) c, appendable);\r\n                    }\r\n                }\r\n\r\n                start = pos + 1; // start on the current char after this one\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > start) {\r\n            append(builder.substring(start, pos), appendable);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\r\n     */\r\n    // the original object is needed so can check for Number\r\n    private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\r\n        boolean quote = false;\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int len = charSeq.length();\r\n\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char quoteChar = getQuoteCharacter().charValue();\r\n        // If escape char not specified, default to the quote char\r\n        // This avoids having to keep checking whether there is an escape character\r\n        // at the cost of checking against quote twice\r\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\r\n\r\n        QuoteMode quoteModePolicy = getQuoteMode();\r\n        if (quoteModePolicy == null) {\r\n            quoteModePolicy = QuoteMode.MINIMAL;\r\n        }\r\n        switch (quoteModePolicy) {\r\n        case ALL:\r\n        case ALL_NON_NULL:\r\n            quote = true;\r\n            break;\r\n        case NON_NUMERIC:\r\n            quote = !(object instanceof Number);\r\n            break;\r\n        case NONE:\r\n            // Use the existing escaping code\r\n            printWithEscapes(charSeq, out);\r\n            return;\r\n        case MINIMAL:\r\n            if (len <= 0) {\r\n                // always quote an empty token that is the first\r\n                // on the line, as it may be the only thing on the\r\n                // line. If it were not quoted in that case,\r\n                // an empty line has no tokens.\r\n                if (newRecord) {\r\n                    quote = true;\r\n                }\r\n            } else {\r\n                char c = charSeq.charAt(pos);\r\n\r\n                if (c <= COMMENT) {\r\n                    // Some other chars at the start of a value caused the parser to fail, so for now\r\n                    // encapsulate if we start in anything less than '#'. We are being conservative\r\n                    // by including the default comment char too.\r\n                    quote = true;\r\n                } else {\r\n                    while (pos < len) {\r\n                        c = charSeq.charAt(pos);\r\n                        if (c == LF || c == CR || c == quoteChar || c == escapeChar || isDelimiter(c, charSeq, pos, delim, delimLength)) {\r\n                            quote = true;\r\n                            break;\r\n                        }\r\n                        pos++;\r\n                    }\r\n\r\n                    if (!quote) {\r\n                        pos = len - 1;\r\n                        c = charSeq.charAt(pos);\r\n                        // Some other chars at the end caused the parser to fail, so for now\r\n                        // encapsulate if we end in anything less than ' '\r\n                        if (c <= SP) {\r\n                            quote = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!quote) {\r\n                // no encapsulation needed - write out the original value\r\n                out.append(charSeq, start, len);\r\n                return;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\r\n        }\r\n\r\n        if (!quote) {\r\n            // no encapsulation needed - write out the original value\r\n            out.append(charSeq, start, len);\r\n            return;\r\n        }\r\n\r\n        // we hit something that needed encapsulation\r\n        out.append(quoteChar);\r\n\r\n        // Pick up where we left off: pos should be positioned on the first character that caused\r\n        // the need for encapsulation.\r\n        while (pos < len) {\r\n            final char c = charSeq.charAt(pos);\r\n            if (c == quoteChar || c == escapeChar) {\r\n                // write out the chunk up until this point\r\n                out.append(charSeq, start, pos);\r\n                out.append(escapeChar); // now output the escape\r\n                start = pos; // and restart with the matched char\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write the last segment\r\n        out.append(charSeq, start, pos);\r\n        out.append(quoteChar);\r\n    }\r\n\r\n    /**\r\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\r\n     *\r\n     * @param reader What to print\r\n     * @param appendable Where to print it\r\n     * @throws IOException If an I/O error occurs\r\n     */\r\n    private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {\r\n\r\n        if (getQuoteMode() == QuoteMode.NONE) {\r\n            printWithEscapes(reader, appendable);\r\n            return;\r\n        }\r\n\r\n        int pos = 0;\r\n\r\n        final char quote = getQuoteCharacter().charValue();\r\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n        append(quote, appendable);\r\n\r\n        int c;\r\n        while (-1 != (c = reader.read())) {\r\n            builder.append((char) c);\r\n            if (c == quote) {\r\n                // write out segment up until this char\r\n                if (pos > 0) {\r\n                    append(builder.substring(0, pos), appendable);\r\n                    append(quote, appendable);\r\n                    builder.setLength(0);\r\n                    pos = -1;\r\n                }\r\n\r\n                append((char) c, appendable);\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        // write last segment\r\n        if (pos > 0) {\r\n            append(builder.substring(0, pos), appendable);\r\n        }\r\n\r\n        append(quote, appendable);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        final StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\r\n        if (isEscapeCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\r\n        }\r\n        if (quoteMode != null) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\r\n        }\r\n        if (isCommentMarkerSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\r\n        }\r\n        if (isNullStringSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"NullString=<\").append(nullString).append('>');\r\n        }\r\n        if (recordSeparator != null) {\r\n            sb.append(' ');\r\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\r\n        }\r\n        if (getIgnoreEmptyLines()) {\r\n            sb.append(\" EmptyLines:ignored\");\r\n        }\r\n        if (getIgnoreSurroundingSpaces()) {\r\n            sb.append(\" SurroundingSpaces:ignored\");\r\n        }\r\n        if (getIgnoreHeaderCase()) {\r\n            sb.append(\" IgnoreHeaderCase:ignored\");\r\n        }\r\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\r\n        if (headerComments != null) {\r\n            sb.append(' ');\r\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\r\n        }\r\n        if (header != null) {\r\n            sb.append(' ');\r\n            sb.append(\"Header:\").append(Arrays.toString(header));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    /**\r\n     * Verifies the validity and consistency of the attributes, and throws an IllegalArgumentException if necessary.\r\n     *\r\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.\r\n     */\r\n    private void validate() throws IllegalArgumentException {\r\n        if (containsLineBreak(delimiter)) {\r\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\r\n        }\r\n\r\n        if (quoteCharacter != null && contains(delimiter, quoteCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && contains(delimiter, escapeCharacter.charValue())) {\r\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\r\n        }\r\n\r\n        if (commentMarker != null && contains(delimiter, commentMarker.charValue())) {\r\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\r\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\r\n        }\r\n\r\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\r\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\r\n        }\r\n\r\n        // validate header\r\n        if (header != null && duplicateHeaderMode != DuplicateHeaderMode.ALLOW_ALL) {\r\n            final Set<String> dupCheck = new HashSet<>();\r\n            for (final String hdr : header) {\r\n                if (!dupCheck.add(hdr)) {\r\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} that allows duplicate header names.\r\n     *\r\n     * @return a new {@code CSVFormat} that allows duplicate header names\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean) Builder#setAllowDuplicateHeaderNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames() {\r\n        return builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     *\r\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\r\n        final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\r\n        return builder().setDuplicateHeaderMode(mode).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @see Builder#setAllowMissingColumnNames(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames() {\r\n        return builder().setAllowMissingColumnNames(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\r\n     *\r\n     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause\r\n     *                                an {@link IllegalArgumentException} to be thrown.\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\r\n        return builder().setAllowMissingColumnNames(allowMissingColumnNames).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with whether to flush on close.\r\n     *\r\n     * @param autoFlush whether to flush on close.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setAutoFlush(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\r\n        return builder().setAutoFlush(autoFlush).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final char commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withCommentMarker(final Character commentMarker) {\r\n        return builder().setCommentMarker(commentMarker).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\r\n     *\r\n     * @param delimiter the delimiter character\r\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setDelimiter(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withDelimiter(final char delimiter) {\r\n        return builder().setDelimiter(delimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final char escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withEscape(final Character escape) {\r\n        return builder().setEscape(escape).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} using the first record as header.\r\n     *\r\n     * <p>\r\n     * Calling this method is equivalent to calling:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\r\n     * </pre>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but using the first record as header.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(String...) Builder#setHeader()}.{@link Builder#setSkipHeaderRecord(boolean) setSkipHeaderRecord(true)}.\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withFirstRecordAsHeader() {\r\n        // @formatter:off\r\n        return builder()\r\n                .setHeader()\r\n                .setSkipHeaderRecord(true)\r\n                .build();\r\n        // @formatter:on\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\r\n     *\r\n     * <p>\r\n     * Example:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * public enum Header {\r\n     *     Name, Email, Phone\r\n     * }\r\n     *\r\n     * CSVFormat format = aformat.withHeader(Header.class);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setHeader(String...)\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(Class)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\r\n        return builder().setHeader(headerEnum).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(resultSet);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSet)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\r\n        return builder().setHeader(resultSet).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\r\n     * input file with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(metaData);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeader(ResultSetMetaData)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\r\n        return builder().setHeader(resultSetMetaData).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file\r\n     * with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @deprecated Use {@link Builder#setHeader(String...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeader(final String... header) {\r\n        return builder().setHeader(header).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.\r\n     * This setting is ignored by the parser.\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n     * </pre>\r\n     *\r\n     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeaderComments(Object...)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withHeaderComments(final Object... headerComments) {\r\n        return builder().setHeaderComments(headerComments).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @see Builder#setIgnoreEmptyLines(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines() {\r\n        return builder().setIgnoreEmptyLines(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty\r\n     *                         lines to empty records.\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\r\n        return builder().setIgnoreEmptyLines(ignoreEmptyLines).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that will ignore case header name.\r\n     * @see Builder#setIgnoreHeaderCase(boolean)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean) Builder#setIgnoreHeaderCase(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase() {\r\n        return builder().setIgnoreHeaderCase(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\r\n     *\r\n     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\r\n        return builder().setIgnoreHeaderCase(ignoreHeaderCase).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\r\n     * @see Builder#setIgnoreSurroundingSpaces(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean) Builder#setIgnoreSurroundingSpaces(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces() {\r\n        return builder().setIgnoreSurroundingSpaces(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\r\n        return builder().setIgnoreSurroundingSpaces(ignoreSurroundingSpaces).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\r\n     * @deprecated Use {@link Builder#setNullString(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withNullString(final String nullString) {\r\n        return builder().setNullString(nullString).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final char quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character, use {@code null} to disable.\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(Character)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuote(final Character quoteChar) {\r\n        return builder().setQuote(quoteChar).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\r\n     *\r\n     * @param quoteMode the quote policy to use for output.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\r\n     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withQuoteMode(final QuoteMode quoteMode) {\r\n        return builder().setQuoteMode(quoteMode).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @deprecated Use {@link Builder#setRecordSeparator(char)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\r\n        return builder().setRecordSeparator(recordSeparator).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean) Builder#setSkipHeaderRecord(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord() {\r\n        return builder().setSkipHeaderRecord(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\r\n     *\r\n     * @param skipHeaderRecord whether to skip the header record.\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setHeader(String...)\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\r\n        return builder().setSkipHeaderRecord(skipHeaderRecord).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows\r\n     * and LF on Linux.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withSystemRecordSeparator() {\r\n        return builder().setRecordSeparator(System.lineSeparator()).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean) Builder#setTrailingDelimiter(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter() {\r\n        return builder().setTrailingDelimiter(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\r\n     *\r\n     * @param trailingDelimiter whether to add a trailing delimiter.\r\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\r\n        return builder().setTrailingDelimiter(trailingDelimiter).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean) Builder#setTrim(true)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim() {\r\n        return builder().setTrim(true).build();\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @param trim whether to trim leading and trailing blanks.\r\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean)}\r\n     */\r\n    @Deprecated\r\n    public CSVFormat withTrim(final boolean trim) {\r\n        return builder().setTrim(trim).build();\r\n    }\r\n}\r",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex ba39b742a..27d2f08ef 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1047,7 +1047,7 @@ public CSVFormat getFormat() {\n      *\r\n      * <p>\r\n      * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\r\n-     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\r\n+     * characters are not escaped. The default NULL string is {@code \"\"}.\r\n      * </p>\r\n      *\r\n      * <p>\r\n@@ -1055,7 +1055,7 @@ public CSVFormat getFormat() {\n      * </p>\r\n      * <ul>\r\n      * <li>{@code setDelimiter(',')}</li>\r\n-     * <li>{@code setEscape('\"')}</li>\r\n+     * <li>{@code setEscape(null)}</li>\r\n      * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n      * <li>{@code setQuote('\"')}</li>\r\n      * <li>{@code setRecordSeparator('\\n')}</li>\r\n@@ -1071,7 +1071,7 @@ public CSVFormat getFormat() {\n     // @formatter:off\r\n     public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder()\r\n             .setDelimiter(COMMA)\r\n-            .setEscape(DOUBLE_QUOTE_CHAR)\r\n+            .setEscape(null)\r\n             .setIgnoreEmptyLines(false)\r\n             .setQuote(DOUBLE_QUOTE_CHAR)\r\n             .setRecordSeparator(LF)\r\n@@ -1084,8 +1084,8 @@ public CSVFormat getFormat() {\n      * Default PostgreSQL text format used by the {@code COPY} operation.\r\n      *\r\n      * <p>\r\n-     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\r\n-     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\r\n+     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\r\n+     * characters are escaped with {@code '\\\\'}. The default NULL string is {@code \"\\\\N\"}.\r\n      * </p>\r\n      *\r\n      * <p>\r\n@@ -1095,7 +1095,7 @@ public CSVFormat getFormat() {\n      * <li>{@code setDelimiter('\\t')}</li>\r\n      * <li>{@code setEscape('\\\\')}</li>\r\n      * <li>{@code setIgnoreEmptyLines(false)}</li>\r\n-     * <li>{@code setQuote('\"')}</li>\r\n+     * <li>{@code setQuote(null)}</li>\r\n      * <li>{@code setRecordSeparator('\\n')}</li>\r\n      * <li>{@code setNullString(\"\\\\N\")}</li>\r\n      * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\r\n@@ -1111,7 +1111,7 @@ public CSVFormat getFormat() {\n             .setDelimiter(TAB)\r\n             .setEscape(BACKSLASH)\r\n             .setIgnoreEmptyLines(false)\r\n-            .setQuote(DOUBLE_QUOTE_CHAR)\r\n+            .setQuote(null)\r\n             .setRecordSeparator(LF)\r\n             .setNullString(\"\\\\N\")\r\n             .setQuoteMode(QuoteMode.ALL_NON_NULL)\r\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/issues/JiraCsv290Test.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/resources/org/apache/commons/csv/CSV-290/psql.csv",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/resources/org/apache/commons/csv/CSV-290/psql.tsv",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 257,
    "title": "[CSV-304] Accessors for header/trailer comments",
    "state": "closed",
    "created_at": "2022-09-06T14:31:29Z",
    "merge_commit_sha": "2e851bc96029b60c2f7cbdb10ae1b99207fcda3d",
    "base_sha": "c51b595e345954a286d59ed4e37d5d6d319cc78a",
    "head_sha": "ee7b3a7d34955fecbe829de472d39ec9d3a9b70a",
    "user_login": "pedro-w",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVParserTest2 {\n\n    @Test\n    public void testHeaderComment() throws IOException {\n        final String csvData = \"# This is a header comment\\na,b,c\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withCommentMarker('#').withHeader();\n        try (final CSVParser parser = CSVParser.parse(csvData, format)) {\n            assertTrue(parser.hasHeaderComment());\n            assertEquals(\"This is a header comment\", parser.getHeaderComment());\n        }\n    }\n\n    @Test\n    public void testNoHeaderComment() throws IOException {\n        final String csvData = \"a,b,c\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader();\n        try (final CSVParser parser = CSVParser.parse(csvData, format)) {\n            assertFalse(parser.hasHeaderComment());\n            assertNull(parser.getHeaderComment());\n        }\n    }\n\n    @Test\n    public void testTrailerComment() throws IOException {\n        final String csvData = \"a,b,c\\n1,2,3\\nx,y,z\\n# This is a trailer comment\";\n        final CSVFormat format = CSVFormat.DEFAULT.withCommentMarker('#');\n        try (final CSVParser parser = CSVParser.parse(csvData, format)) {\n            List<CSVRecord> records = parser.getRecords();\n            assertEquals(3, records.size());\n            assertTrue(parser.hasTrailerComment());\n            assertEquals(\"This is a trailer comment\", parser.getTrailerComment());\n        }\n    }\n\n    @Test\n    public void testNoTrailerComment() throws IOException {\n        final String csvData = \"a,b,c\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT;\n        try (final CSVParser parser = CSVParser.parse(csvData, format)) {\n            List<CSVRecord> records = parser.getRecords();\n            assertEquals(3, records.size());\n            assertFalse(parser.hasTrailerComment());\n            assertNull(parser.getTrailerComment());\n        }\n    }\n\n    @Test\n    public void testHeaderAndTrailerComments() throws IOException {\n        final String csvData = \"# Header comment\\na,b,c\\n1,2,3\\nx,y,z\\n# Trailer comment\";\n        final CSVFormat format = CSVFormat.DEFAULT.withCommentMarker('#').withHeader();\n        try (final CSVParser parser = CSVParser.parse(csvData, format)) {\n            assertTrue(parser.hasHeaderComment());\n            assertEquals(\"Header comment\", parser.getHeaderComment());\n            List<CSVRecord> records = parser.getRecords();\n            assertEquals(3, records.size());\n            assertTrue(parser.hasTrailerComment());\n            assertEquals(\"Trailer comment\", parser.getTrailerComment());\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.TreeMap;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n\n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n\n            return this.current != null;\n        }\n\n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n\n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n\n            return next;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Header information based on name and position.\n     */\n    private static final class Headers {\n        /**\n         * Header column positions (0-based)\n         */\n        final Map<String, Integer> headerMap;\n\n        /**\n         * Header names in column order\n         */\n        final List<String> headerNames;\n\n        Headers(final Map<String, Integer> headerMap, final List<String> headerNames) {\n            this.headerMap = headerMap;\n            this.headerNames = headerNames;\n        }\n    }\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        return parse(file.toPath(), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        Objects.requireNonNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates and returns a parser for the given {@link Path}, which the caller MUST close.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(path, \"path\");\n        Objects.requireNonNull(format, \"format\");\n        return parse(Files.newInputStream(path), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(string, \"string\");\n        Objects.requireNonNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates and returns a parser for the given URL, which the caller MUST close.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(url, \"url\");\n        Objects.requireNonNull(charset, \"charset\");\n        Objects.requireNonNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private final CSVFormat format;\n\n    private final Headers headers;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n        throws IOException {\n        Objects.requireNonNull(reader, \"reader\");\n        Objects.requireNonNull(format, \"format\");\n\n        this.format = format.copy();\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headers = createHeaders();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        this.recordList.add(handleNull(inputClean));\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    private Map<String, Integer> createEmptyHeaderMap() {\n        return this.format.getIgnoreHeaderCase() ?\n                new TreeMap<>(String.CASE_INSENSITIVE_ORDER) :\n                new LinkedHashMap<>();\n    }\n\n    /**\n     * Creates the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Headers createHeaders() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        List<String> headerNames = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = createEmptyHeaderMap();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (emptyHeader && !this.format.getAllowMissingColumnNames()) {\n                        throw new IllegalArgumentException(\n                            \"A header name is missing in \" + Arrays.toString(headerRecord));\n                    }\n\n                    final boolean containsHeader = header != null && hdrMap.containsKey(header);\n                    final DuplicateHeaderMode headerMode = this.format.getDuplicateHeaderMode();\n                    final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\n                    final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\n\n                    if (containsHeader && !duplicatesAllowed && !(emptyHeader && emptyDuplicatesAllowed)) {\n                        throw new IllegalArgumentException(\n                            String.format(\n                                \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\n                                header, Arrays.toString(headerRecord)));\n                    }\n                    if (header != null) {\n                        hdrMap.put(header, Integer.valueOf(i));\n                        if (headerNames == null) {\n                            headerNames = new ArrayList<>(headerRecord.length);\n                        }\n                        headerNames.add(header);\n                    }\n                }\n            }\n        }\n        if (headerNames == null) {\n            headerNames = Collections.emptyList(); //immutable\n        } else {\n            headerNames = Collections.unmodifiableList(headerNames);\n        }\n        return new Headers(hdrMap, headerNames);\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * <p>\n     * Note: The map can only provide a one-to-one mapping when the format did not\n     * contain null or duplicate column names.\n     * </p>\n     *\n     * @return a copy of the header map.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        if (this.headers.headerMap == null) {\n            return null;\n        }\n        final Map<String, Integer> map = createEmptyHeaderMap();\n        map.putAll(this.headers.headerMap);\n        return map;\n    }\n\n    /**\n     * Returns the header map.\n     *\n     * @return the header map.\n     */\n    Map<String, Integer> getHeaderMapRaw() {\n        return this.headers.headerMap;\n    }\n\n    /**\n     * Returns a read-only list of header names that iterates in column order.\n     * <p>\n     * Note: The list provides strings that can be used as keys in the header map.\n     * The list will not contain null column names if they were present in the input\n     * format.\n     * </p>\n     *\n     * @return read-only list of header names that iterates in column order.\n     * @see #getHeaderMap()\n     * @since 1.7\n     */\n    public List<String> getHeaderNames() {\n        return Collections.unmodifiableList(headers.headerNames);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Handle whether input is parsed as null\n     *\n     * @param input\n     *           the cell data to further processed\n     * @return null if input is parsed as null, or input itself if input isn't parsed as null\n     */\n    private String handleNull(final String input) {\n        final boolean isQuoted = this.reusableToken.isQuoted;\n        final String nullString = format.getNullString();\n        final boolean strictQuoteMode = isStrictQuoteMode();\n        if (input.equals(nullString)) {\n            // nullString = NULL(String), distinguish between \"NULL\" and NULL in ALL_NON_NULL or NON_NUMERIC quote mode\n            return strictQuoteMode && isQuoted ? input : null;\n        }\n        // don't set nullString, distinguish between \"\" and ,, (absent values) in All_NON_NULL or NON_NUMERIC quote mode\n        return strictQuoteMode && nullString == null && input.isEmpty() && !isQuoted ? null : input;\n    }\n\n    /**\n     * Tests whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Tests whether the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or {@link QuoteMode#NON_NUMERIC}.\n     *\n     * @return true if the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or\n     *         {@link QuoteMode#NON_NUMERIC}.\n     */\n    private boolean isStrictQuoteMode() {\n        return this.format.getQuoteMode() == QuoteMode.ALL_NON_NULL ||\n               this.format.getQuoteMode() == QuoteMode.NON_NUMERIC;\n    }\n\n    /**\n     * Returns the record iterator.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this, this.recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment,\n                this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a sequential {@code Stream} with this collection as its source.\n     *\n     * @return a sequential {@code Stream} with this collection as its source.\n     * @since 1.9.0\n     */\n    public Stream<CSVRecord> stream() {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator(), Spliterator.ORDERED), false);\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 58cdb146b..d92600c18 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -353,6 +353,10 @@ public static CSVParser parse(final URL url, final Charset charset, final CSVFor\n         return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n     }\n \n+    private String headerComment;\n+\n+    private String trailerComment;\n+\n     private final CSVFormat format;\n \n     private final Headers headers;\n@@ -480,10 +484,14 @@ private Headers createHeaders() throws IOException {\n                 final CSVRecord nextRecord = this.nextRecord();\n                 if (nextRecord != null) {\n                     headerRecord = nextRecord.values();\n+                    headerComment = nextRecord.getComment();\n                 }\n             } else {\n                 if (this.format.getSkipHeaderRecord()) {\n-                    this.nextRecord();\n+                    final CSVRecord nextRecord = this.nextRecord();\n+                    if (nextRecord != null) {\n+                        headerComment = nextRecord.getComment();\n+                    }\n                 }\n                 headerRecord = formatHeader;\n             }\n@@ -597,6 +605,57 @@ public List<String> getHeaderNames() {\n         return Collections.unmodifiableList(headers.headerNames);\n     }\n \n+    /**\n+     * Checks whether there is a header comment.\n+     * The header comment appears before the header record.\n+     * Note that if the parser's format has been given an explicit header\n+     * (with {@link CSVFormat.Builder#setHeader(String... )} or another overload)\n+     * and the header record is not being skipped\n+     * ({@link CSVFormat.Builder#setSkipHeaderRecord} is false) then any initial comments\n+     * will be associated with the first record, not the header.\n+     *\n+     * @return true if this parser has seen a header comment, false otherwise\n+     * @since 1.10.0\n+     */\n+    public boolean hasHeaderComment() {\n+        return headerComment != null;\n+    }\n+\n+    /**\n+     * Returns the header comment, if any.\n+     * The header comment appears before the header record.\n+     *\n+     * @return the header comment for this stream, or null if no comment is available.\n+     * @since 1.10.0\n+     */\n+    public String getHeaderComment() {\n+        return headerComment;\n+    }\n+\n+    /**\n+     * Checks whether there is a trailer comment.\n+     * Trailer comments are located between the last record and EOF.\n+     * The trailer comments will only be available after the parser has\n+     * finished processing this stream.\n+     *\n+     * @return true if this parser has seen a trailer comment, false otherwise\n+     * @since 1.10.0\n+     */\n+    public boolean hasTrailerComment() {\n+        return trailerComment != null;\n+    }\n+\n+    /**\n+     * Returns the trailer comment, if any.\n+     * Trailer comments are located between the last record and EOF\n+     *\n+     * @return the trailer comment for this stream, or null if no comment is available.\n+     * @since 1.10.0\n+     */\n+    public String getTrailerComment() {\n+        return trailerComment;\n+    }\n+\n     /**\n      * Returns the current record number in the input stream.\n      *\n@@ -713,6 +772,8 @@ CSVRecord nextRecord() throws IOException {\n             case EOF:\n                 if (this.reusableToken.isReady) {\n                     this.addRecordValue(true);\n+                } else if (sb != null) {\n+                    trailerComment = sb.toString();\n                 }\n                 break;\n             case INVALID:\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 218,
    "title": "CSV-288 Fix for multi-char delimiter not working as expected",
    "state": "closed",
    "created_at": "2022-02-19T09:06:45Z",
    "merge_commit_sha": "c15a06eee95e227fbe5c61849dd12b7bf126016a",
    "base_sha": "94711ebf25d79bd95df8a5e70885325660f94ddc",
    "head_sha": "3a99e2eb3dca28175885b9fb1e4ca6dfefdb4337",
    "user_login": "angusdev",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/Lexer.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\nimport static org.apache.commons.csv.TokenMatchers.matches;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class LexerTest2 {\n\n    private CSVFormat formatWithEscaping;\n\n    @SuppressWarnings(\"resource\")\n    private Lexer createLexer(final String input, final CSVFormat format) {\n        return new Lexer(format, new ExtendedBufferedReader(new StringReader(input)));\n    }\n\n    @BeforeEach\n    public void setUp() {\n        formatWithEscaping = CSVFormat.DEFAULT.withEscape('\\\\');\n    }\n\n    @Test\n    public void testIsLastTokenDelimiterSingleCharDelimiter() throws IOException {\n        final String code = \"a,b,c\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(',');\n        try (final Lexer parser = createLexer(code, format)) {\n            Token token = new Token();\n            parser.nextToken(token);\n            assertTrue(parser.isLastTokenDelimiter);\n        }\n    }\n\n    @Test\n    public void testIsLastTokenDelimiterMultiCharDelimiter() throws IOException {\n        final String code = \"a||b||c\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(\"||\");\n        try (final Lexer parser = createLexer(code, format)) {\n            Token token = new Token();\n            parser.nextToken(token);\n            assertTrue(parser.isLastTokenDelimiter);\n        }\n    }\n\n    @Test\n    public void testNextTokenEOFWithLastTokenDelimiter() throws IOException {\n        final String code = \"a,\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(',');\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n\n    @Test\n    public void testNextTokenEOFWithoutLastTokenDelimiter() throws IOException {\n        final String code = \"a\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(',');\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport static org.apache.commons.csv.Token.Type.COMMENT;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Token.Type.INVALID;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.IOException;\n\n/**\n * Lexical analyzer.\n */\nfinal class Lexer implements Closeable {\n\n    private static final String CR_STRING = Character.toString(CR);\n    private static final String LF_STRING = Character.toString(LF);\n\n    /**\n     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char[] delimiter;\n    private final char[] delimiterBuf;\n    private final char[] escapeDelimiterBuf;\n    private final char escape;\n    private final char quoteChar;\n    private final char commentStart;\n\n    private final boolean ignoreSurroundingSpaces;\n    private final boolean ignoreEmptyLines;\n\n    /** The input stream */\n    private final ExtendedBufferedReader reader;\n    private String firstEol;\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n        this.reader = reader;\n        this.delimiter = format.getDelimiterString().toCharArray();\n        this.escape = mapNullToDisabled(format.getEscapeCharacter());\n        this.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\n        this.commentStart = mapNullToDisabled(format.getCommentMarker());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n        this.delimiterBuf = new char[delimiter.length - 1];\n        this.escapeDelimiterBuf = new char[2 * delimiter.length - 1];\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        reader.close();\n    }\n\n    /**\n     * Returns the current character position\n     *\n     * @return the current character position\n     */\n    long getCharacterPosition() {\n        return reader.getPosition();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        return reader.getCurrentLineNumber();\n    }\n\n    String getFirstEol(){\n        return firstEol;\n    }\n\n    boolean isClosed() {\n        return reader.isClosed();\n    }\n\n    boolean isCommentStart(final int ch) {\n        return ch == commentStart;\n    }\n\n    /**\n     * Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n     *\n     * @param ch\n     *             the current character.\n     * @return true if the next characters constitute a delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isDelimiter(final int ch) throws IOException {\n        if (ch != delimiter[0]) {\n            return false;\n        }\n        if (delimiter.length == 1) {\n          return true;\n        }\n        reader.lookAhead(delimiterBuf);\n        for (int i = 0; i < delimiterBuf.length; i++) {\n            if (delimiterBuf[i] != delimiter[i+1]) {\n                return false;\n            }\n        }\n        final int count = reader.read(delimiterBuf, 0, delimiterBuf.length);\n        return count != END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character indicates end of file.\n     *\n     * @return true if the given character indicates end of file.\n     */\n    boolean isEndOfFile(final int ch) {\n        return ch == END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character is the escape character.\n     *\n     * @return true if the given character is the escape character.\n     */\n    boolean isEscape(final int ch) {\n        return ch == escape;\n    }\n\n    /**\n     * Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n     *\n     * For example, for delimiter \"[|]\" and escape '!', return true if the next characters constitute \"![!|!]\".\n     *\n     * @return true if the next characters constitute a escape delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isEscapeDelimiter() throws IOException {\n        reader.lookAhead(escapeDelimiterBuf);\n        if (escapeDelimiterBuf[0] != delimiter[0]) {\n            return false;\n        }\n        for (int i = 1; i < delimiter.length; i++) {\n            if (escapeDelimiterBuf[2 * i] != delimiter[i] || escapeDelimiterBuf[2 * i - 1] != escape) {\n                return false;\n            }\n        }\n        final int count = reader.read(escapeDelimiterBuf, 0, escapeDelimiterBuf.length);\n        return count != END_OF_STREAM;\n    }\n\n    private boolean isMetaChar(final int ch) {\n        return ch == escape || ch == quoteChar || ch == commentStart;\n    }\n\n    boolean isQuoteChar(final int ch) {\n        return ch == quoteChar;\n    }\n\n    /**\n     * Tests if the current character represents the start of a line: a CR, LF or is at the start of the file.\n     *\n     * @param ch the character to check\n     * @return true if the character is at the start of a line.\n     */\n    boolean isStartOfLine(final int ch) {\n        return ch == LF || ch == CR || ch == UNDEFINED;\n    }\n\n    private char mapNullToDisabled(final Character c) {\n        return c == null ? DISABLED : c.charValue();\n    }\n\n    /**\n     * Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token\n     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n     * @return the next token found.\n     * @throws java.io.IOException on stream access error.\n     */\n    Token nextToken(final Token token) throws IOException {\n\n        // get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n\n        // read the next char and set eol\n        int c = reader.read();\n        /*\n         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n         * - they are equivalent here.\n         */\n        boolean eol = readEndOfLine(c);\n\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol && isStartOfLine(lastChar)) {\n                // go on char ahead ...\n                lastChar = c;\n                c = reader.read();\n                eol = readEndOfLine(c);\n                // reached end of file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type = EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // did we reach eof during the last iteration already ? EOF\n        if (isEndOfFile(lastChar) || !isDelimiter(lastChar) && isEndOfFile(c)) {\n            token.type = EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n            final String line = reader.readLine();\n            if (line == null) {\n                token.type = EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n            final String comment = line.trim();\n            token.content.append(comment);\n            token.type = COMMENT;\n            return token;\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (Character.isWhitespace((char)c) && !isDelimiter(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n\n    /**\n     * Parses an encapsulated token.\n     * <p>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n     */\n    private Token parseEncapsulatedToken(final Token token) throws IOException {\n        token.isQuoted = true;\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        int c;\n        while (true) {\n            c = reader.read();\n\n            if (isEscape(c)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) c).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n            } else if (isQuoteChar(c)) {\n                if (isQuoteChar(reader.lookAhead())) {\n                    // double or escaped encapsulator -> add single encapsulator to token\n                    c = reader.read();\n                    token.content.append((char) c);\n                } else {\n                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                    while (true) {\n                        c = reader.read();\n                        if (isDelimiter(c)) {\n                            token.type = TOKEN;\n                            return token;\n                        }\n                        if (isEndOfFile(c)) {\n                            token.type = EOF;\n                            token.isReady = true; // There is data at EOF\n                            return token;\n                        }\n                        if (readEndOfLine(c)) {\n                            token.type = EORECORD;\n                            return token;\n                        }\n                        if (!Character.isWhitespace((char)c)) {\n                            // error invalid char between token and next delimiter\n                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                    \") invalid char between encapsulated token and delimiter\");\n                        }\n                    }\n                }\n            } else if (isEndOfFile(c)) {\n                // error condition (end of file before end of token)\n                throw new IOException(\"(startline \" + startLineNumber +\n                        \") EOF reached before encapsulated token finished\");\n            } else {\n                // consume character\n                token.content.append((char) c);\n            }\n        }\n    }\n\n    /**\n     * Parses a simple token.\n     * <p>\n     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>end of line has been reached (EORECORD)</li>\n     * <li>end of stream has been reached (EOF)</li>\n     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token\n     *            the current token\n     * @param ch\n     *            the current character\n     * @return the filled token\n     * @throws IOException\n     *             on stream access error\n     */\n    private Token parseSimpleToken(final Token token, int ch) throws IOException {\n        // Faster to use while(true)+break than while(token.type == INVALID)\n        while (true) {\n            if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                break;\n            }\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                break;\n            }\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                break;\n            }\n            // continue\n            if (isEscape(ch)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) ch).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read(); // continue\n        }\n\n        if (ignoreSurroundingSpaces) {\n            trimTrailingSpaces(token.content);\n        }\n\n        return token;\n    }\n\n    /**\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     */\n    boolean readEndOfLine(int ch) throws IOException {\n        // check if we have \\r\\n...\n        if (ch == CR && reader.lookAhead() == LF) {\n            // note: does not change ch outside of this method!\n            ch = reader.read();\n            // Save the EOL state\n            if (firstEol == null) {\n                this.firstEol = Constants.CRLF;\n            }\n        }\n        // save EOL state here.\n        if (firstEol == null) {\n            if (ch == LF) {\n                this.firstEol = LF_STRING;\n            } else if (ch == CR) {\n                this.firstEol = CR_STRING;\n            }\n        }\n\n        return ch == LF || ch == CR;\n    }\n\n    // TODO escape handling needs more work\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link Constants#END_OF_STREAM} if char following the escape is\n     *      invalid.\n     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n     *      the escape character is not allowed at end of stream\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int ch = reader.read();\n        switch (ch) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return ch;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isMetaChar(ch)) {\n                return ch;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return END_OF_STREAM;\n        }\n    }\n\n    void trimTrailingSpaces(final StringBuilder buffer) {\n        int length = buffer.length();\n        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n            length = length - 1;\n        }\n        if (length != buffer.length()) {\n            buffer.setLength(length);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex edd9576ce..f424039b1 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -62,6 +62,8 @@ final class Lexer implements Closeable {\n     private final ExtendedBufferedReader reader;\n     private String firstEol;\n \n+    private boolean isLastTokenDelimiter;\n+\n     Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n         this.reader = reader;\n         this.delimiter = format.getDelimiterString().toCharArray();\n@@ -124,11 +126,13 @@ boolean isCommentStart(final int ch) {\n      * @throws IOException If an I/O error occurs.\n      */\n     boolean isDelimiter(final int ch) throws IOException {\n+        isLastTokenDelimiter = false;\n         if (ch != delimiter[0]) {\n             return false;\n         }\n         if (delimiter.length == 1) {\n-          return true;\n+            isLastTokenDelimiter = true;\n+            return true;\n         }\n         reader.lookAhead(delimiterBuf);\n         for (int i = 0; i < delimiterBuf.length; i++) {\n@@ -137,7 +141,8 @@ boolean isDelimiter(final int ch) throws IOException {\n             }\n         }\n         final int count = reader.read(delimiterBuf, 0, delimiterBuf.length);\n-        return count != END_OF_STREAM;\n+        isLastTokenDelimiter = count != END_OF_STREAM;\n+        return isLastTokenDelimiter;\n     }\n \n     /**\n@@ -243,7 +248,7 @@ Token nextToken(final Token token) throws IOException {\n         }\n \n         // did we reach eof during the last iteration already ? EOF\n-        if (isEndOfFile(lastChar) || !isDelimiter(lastChar) && isEndOfFile(c)) {\n+        if (isEndOfFile(lastChar) || !isLastTokenDelimiter && isEndOfFile(c)) {\n             token.type = EOF;\n             // don't set token.isReady here because no content\n             return token;\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/issues/JiraCsv288Test.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 172,
    "title": "Minor changes",
    "state": "closed",
    "created_at": "2021-07-31T07:26:28Z",
    "merge_commit_sha": "4e90cdfdafa3ad4fa1946cd72c7cb968dad39279",
    "base_sha": "9482924309bdc585d4f49c740626f292640c9500",
    "head_sha": "df7bc5243a934dbbded1cff9cdabba36300844c6",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVRecordTest2 {\n\n    private Map<String, Integer> headerMap;\n    private CSVRecord recordWithHeader;\n    private String[] values;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        values = new String[] { \"A\", \"B\", \"C\" };\n        final String rowData = StringUtils.join(values, ',');\n        final String[] headers = { \"first\", \"second\", \"third\" };\n        try (final CSVParser parser = CSVFormat.DEFAULT.withHeader(headers).parse(new StringReader(rowData))) {\n            recordWithHeader = parser.iterator().next();\n            headerMap = parser.getHeaderMap();\n        }\n    }\n\n    @Test\n    public void testPutInMapWithLambda() {\n        final Map<String, String> map = new ConcurrentHashMap<>();\n        this.recordWithHeader.putIn(map);\n        this.validateMap(map, false);\n        \n        final TreeMap<String, String> map2 = recordWithHeader.putIn(new TreeMap<>());\n        this.validateMap(map2, false);\n    }\n\n    @Test\n    public void testToMapWithDiamondOperator() {\n        final Map<String, String> map = this.recordWithHeader.toMap();\n        this.validateMap(map, true);\n    }\n\n    private void validateMap(final Map<String, String> map, final boolean allowsNulls) {\n        assertTrue(map.containsKey(\"first\"));\n        assertTrue(map.containsKey(\"second\"));\n        assertTrue(map.containsKey(\"third\"));\n        assertFalse(map.containsKey(\"fourth\"));\n        if (allowsNulls) {\n            assertFalse(map.containsKey(null));\n        }\n        assertEquals(\"A\", map.get(\"first\"));\n        assertEquals(\"B\", map.get(\"second\"));\n        assertEquals(\"C\", map.get(\"third\"));\n        assertNull(map.get(\"fourth\"));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.stream.Stream;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * <p>\n * Note: Support for {@link Serializable} is scheduled to be removed in version 2.0.\n * In version 1.8 the mapping between the column header and the column index was\n * removed from the serialised state. The class maintains serialization compatibility\n * with versions pre-1.8 for the record values; these must be accessed by index\n * following deserialization. There will be loss of any functionally linked to the header\n * mapping when transferring serialised forms pre-1.8 to 1.8 and vice versa.\n * </p>\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final long serialVersionUID = 1L;\n\n    private final long characterPosition;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    /** The parser that originates this record. This is not serialized. */\n    private final transient CSVParser parser;\n\n    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber,\n            final long characterPosition) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : Constants.EMPTY_STRING_ARRAY;\n        this.parser = parser;\n        this.comment = comment;\n        this.characterPosition = characterPosition;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(Objects.toString(e, null));\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * <p>\n     * Note: This requires a field mapping obtained from the original parser.\n     * A check using {@link #isMapped(String)} should be used to determine if a\n     * mapping exists from the provided {@code name} to a field index. In this case an\n     * exception will only be thrown if the record does not contain a field corresponding\n     * to the mapping, that is the record length is not consistent with the mapping size.\n     * </p>\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isMapped(String)\n     * @see #isConsistent()\n     * @see #getParser()\n     * @see CSVFormat.Builder#setNullString(String)\n     */\n    public String get(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        if (headerMap == null) {\n            throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = headerMap.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                headerMap.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream.\n     */\n    public long getCharacterPosition() {\n        return characterPosition;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    private Map<String, Integer> getHeaderMapRaw() {\n        return parser == null ? null : parser.getHeaderMapRaw();\n    }\n\n    /**\n     * Returns the parser.\n     *\n     * <p>\n     * Note: The parser is not part of the serialized state of the record. A null check\n     * should be used when the record may have originated from a serialized form.\n     * </p>\n     *\n     * @return the parser.\n     * @since 1.7\n     */\n    public CSVParser getParser() {\n        return parser;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3\n     */\n    public boolean hasComment() {\n        return comment != null;\n    }\n\n    /**\n     * Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap == null || headerMap.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap != null && headerMap.containsKey(name);\n    }\n\n    /**\n     * Checks whether a column with given index has a value.\n     *\n     * @param index\n     *         a column index (0-based)\n     * @return whether a column with given index has a value\n     */\n    public boolean isSet(final int index) {\n        return 0 <= index && index < values.length;\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    @Override\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param <M> the map type\n     * @param map The Map to populate.\n     * @return the given map.\n     * @since 1.9.0\n     */\n    public <M extends Map<String, String>> M putIn(final M map) {\n        if (getHeaderMapRaw() == null) {\n            return map;\n        }\n        getHeaderMapRaw().entrySet().forEach(entry -> {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        });\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Returns a sequential ordered stream whose elements are the values.\n     *\n     * @return the new stream.\n     * @since 1.9.0\n     */\n    public Stream<String> stream() {\n        return Stream.of(values);\n    }\n\n    /**\n     * Converts the values to a List.\n     *\n     * @return a new List\n     * @since 1.9.0\n     */\n    public List<String> toList() {\n        return Arrays.asList(values);\n    }\n\n    /**\n     * Copies this record into a new Map of header name to record value.\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new LinkedHashMap<String, String>(values.length));\n    }\n\n    /**\n     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.\n     */\n    @Override\n    public String toString() {\n        return \"CSVRecord [comment='\" + comment + \"', recordNumber=\" + recordNumber + \", values=\" +\n            Arrays.toString(values) + \"]\";\n    }\n\n    String[] values() {\n        return values;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex a8aa082f2..e76bbc4c2 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -270,10 +270,10 @@ public <M extends Map<String, String>> M putIn(final M map) {\n         if (getHeaderMapRaw() == null) {\n             return map;\n         }\n-        getHeaderMapRaw().entrySet().forEach(entry -> {\n-            final int col = entry.getValue().intValue();\n+        getHeaderMapRaw().forEach((key, value) -> {\n+            final int col = value;\n             if (col < values.length) {\n-                map.put(entry.getKey(), values[col]);\n+                map.put(key, values[col]);\n             }\n         });\n         return map;\n@@ -314,7 +314,7 @@ public List<String> toList() {\n      * @return A new Map. The map is empty if the record has no headers.\n      */\n     public Map<String, String> toMap() {\n-        return putIn(new LinkedHashMap<String, String>(values.length));\n+        return putIn(new LinkedHashMap<>(values.length));\n     }\n \n     /**\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/Lexer.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\nimport static org.apache.commons.csv.TokenMatchers.matches;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class LexerTest2 {\n\n    private CSVFormat formatWithEscaping;\n\n    @SuppressWarnings(\"resource\")\n    private Lexer createLexer(final String input, final CSVFormat format) {\n        return new Lexer(format, new ExtendedBufferedReader(new StringReader(input)));\n    }\n\n    @BeforeEach\n    public void setUp() {\n        formatWithEscaping = CSVFormat.DEFAULT.withEscape('\\\\');\n    }\n\n    @Test\n    public void testParseSimpleTokenWithEscape() throws IOException {\n        final String code = \"a,\\\\b,c\";\n        final CSVFormat format = formatWithEscaping.withIgnoreEmptyLines(false);\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"b\"));\n            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"c\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n\n    @Test\n    public void testParseSimpleTokenWithEscapeAtEOF() throws IOException {\n        final String code = \"a,\\\\b,c\\\\\";\n        final CSVFormat format = formatWithEscaping.withIgnoreEmptyLines(false);\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"b\"));\n            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"c\"));\n            assertThrows(IOException.class, () -> parser.nextToken(new Token()));\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport static org.apache.commons.csv.Token.Type.COMMENT;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Token.Type.INVALID;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.IOException;\n\n/**\n * Lexical analyzer.\n */\nfinal class Lexer implements Closeable {\n\n    private static final String CR_STRING = Character.toString(CR);\n    private static final String LF_STRING = Character.toString(LF);\n\n    /**\n     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char[] delimiter;\n    private final char[] delimiterBuf;\n    private final char[] escapeDelimiterBuf;\n    private final char escape;\n    private final char quoteChar;\n    private final char commentStart;\n\n    private final boolean ignoreSurroundingSpaces;\n    private final boolean ignoreEmptyLines;\n\n    /** The input stream */\n    private final ExtendedBufferedReader reader;\n    private String firstEol;\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n        this.reader = reader;\n        this.delimiter = format.getDelimiterString().toCharArray();\n        this.escape = mapNullToDisabled(format.getEscapeCharacter());\n        this.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\n        this.commentStart = mapNullToDisabled(format.getCommentMarker());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n        this.delimiterBuf = new char[delimiter.length - 1];\n        this.escapeDelimiterBuf = new char[2 * delimiter.length - 1];\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        reader.close();\n    }\n\n    /**\n     * Returns the current character position\n     *\n     * @return the current character position\n     */\n    long getCharacterPosition() {\n        return reader.getPosition();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        return reader.getCurrentLineNumber();\n    }\n\n    String getFirstEol(){\n        return firstEol;\n    }\n\n    boolean isClosed() {\n        return reader.isClosed();\n    }\n\n    boolean isCommentStart(final int ch) {\n        return ch == commentStart;\n    }\n\n    /**\n     * Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n     *\n     * @param ch\n     *             the current character.\n     * @return true if the next characters constitute a delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isDelimiter(final int ch) throws IOException {\n        if (ch != delimiter[0]) {\n            return false;\n        }\n        if (delimiter.length == 1) {\n          return true;\n        }\n        reader.lookAhead(delimiterBuf);\n        for (int i = 0; i < delimiterBuf.length; i++) {\n            if (delimiterBuf[i] != delimiter[i+1]) {\n                return false;\n            }\n        }\n        final int count = reader.read(delimiterBuf, 0, delimiterBuf.length);\n        return count != END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character indicates end of file.\n     *\n     * @return true if the given character indicates end of file.\n     */\n    boolean isEndOfFile(final int ch) {\n        return ch == END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character is the escape character.\n     *\n     * @return true if the given character is the escape character.\n     */\n    boolean isEscape(final int ch) {\n        return ch == escape;\n    }\n\n    /**\n     * Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n     *\n     * For example, for delimiter \"[|]\" and escape '!', return true if the next characters constitute \"![!|!]\".\n     *\n     * @return true if the next characters constitute a escape delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isEscapeDelimiter() throws IOException {\n        reader.lookAhead(escapeDelimiterBuf);\n        if (escapeDelimiterBuf[0] != delimiter[0]) {\n            return false;\n        }\n        for (int i = 1; i < delimiter.length; i++) {\n            if (escapeDelimiterBuf[2 * i] != delimiter[i] || escapeDelimiterBuf[2 * i - 1] != escape) {\n                return false;\n            }\n        }\n        final int count = reader.read(escapeDelimiterBuf, 0, escapeDelimiterBuf.length);\n        return count != END_OF_STREAM;\n    }\n\n    private boolean isMetaChar(final int ch) {\n        return ch == escape || ch == quoteChar || ch == commentStart;\n    }\n\n    boolean isQuoteChar(final int ch) {\n        return ch == quoteChar;\n    }\n\n    /**\n     * Tests if the current character represents the start of a line: a CR, LF or is at the start of the file.\n     *\n     * @param ch the character to check\n     * @return true if the character is at the start of a line.\n     */\n    boolean isStartOfLine(final int ch) {\n        return ch == LF || ch == CR || ch == UNDEFINED;\n    }\n\n    private char mapNullToDisabled(final Character c) {\n        return c == null ? DISABLED : c.charValue();\n    }\n\n    /**\n     * Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token\n     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n     * @return the next token found.\n     * @throws java.io.IOException on stream access error.\n     */\n    Token nextToken(final Token token) throws IOException {\n\n        // get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n\n        // read the next char and set eol\n        int c = reader.read();\n        /*\n         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n         * - they are equivalent here.\n         */\n        boolean eol = readEndOfLine(c);\n\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol && isStartOfLine(lastChar)) {\n                // go on char ahead ...\n                lastChar = c;\n                c = reader.read();\n                eol = readEndOfLine(c);\n                // reached end of file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type = EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // did we reach eof during the last iteration already ? EOF\n        if (isEndOfFile(lastChar) || !isDelimiter(lastChar) && isEndOfFile(c)) {\n            token.type = EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n            final String line = reader.readLine();\n            if (line == null) {\n                token.type = EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n            final String comment = line.trim();\n            token.content.append(comment);\n            token.type = COMMENT;\n            return token;\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (Character.isWhitespace((char)c) && !isDelimiter(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n\n    /**\n     * Parses an encapsulated token.\n     * <p>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n     */\n    private Token parseEncapsulatedToken(final Token token) throws IOException {\n        token.isQuoted = true;\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        int c;\n        while (true) {\n            c = reader.read();\n\n            if (isEscape(c)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) c).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n            } else if (isQuoteChar(c)) {\n                if (isQuoteChar(reader.lookAhead())) {\n                    // double or escaped encapsulator -> add single encapsulator to token\n                    c = reader.read();\n                    token.content.append((char) c);\n                } else {\n                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                    while (true) {\n                        c = reader.read();\n                        if (isDelimiter(c)) {\n                            token.type = TOKEN;\n                            return token;\n                        }\n                        if (isEndOfFile(c)) {\n                            token.type = EOF;\n                            token.isReady = true; // There is data at EOF\n                            return token;\n                        }\n                        if (readEndOfLine(c)) {\n                            token.type = EORECORD;\n                            return token;\n                        }\n                        if (!Character.isWhitespace((char)c)) {\n                            // error invalid char between token and next delimiter\n                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                    \") invalid char between encapsulated token and delimiter\");\n                        }\n                    }\n                }\n            } else if (isEndOfFile(c)) {\n                // error condition (end of file before end of token)\n                throw new IOException(\"(startline \" + startLineNumber +\n                        \") EOF reached before encapsulated token finished\");\n            } else {\n                // consume character\n                token.content.append((char) c);\n            }\n        }\n    }\n\n    /**\n     * Parses a simple token.\n     * <p>\n     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>end of line has been reached (EORECORD)</li>\n     * <li>end of stream has been reached (EOF)</li>\n     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token\n     *            the current token\n     * @param ch\n     *            the current character\n     * @return the filled token\n     * @throws IOException\n     *             on stream access error\n     */\n    private Token parseSimpleToken(final Token token, int ch) throws IOException {\n        // Faster to use while(true)+break than while(token.type == INVALID)\n        while (true) {\n            if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                break;\n            }\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                break;\n            }\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                break;\n            }\n            if (isEscape(ch)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) ch).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n                ch = reader.read(); // continue\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read(); // continue\n            }\n        }\n\n        if (ignoreSurroundingSpaces) {\n            trimTrailingSpaces(token.content);\n        }\n\n        return token;\n    }\n\n    /**\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     */\n    boolean readEndOfLine(int ch) throws IOException {\n        // check if we have \\r\\n...\n        if (ch == CR && reader.lookAhead() == LF) {\n            // note: does not change ch outside of this method!\n            ch = reader.read();\n            // Save the EOL state\n            if (firstEol == null) {\n                this.firstEol = Constants.CRLF;\n            }\n        }\n        // save EOL state here.\n        if (firstEol == null) {\n            if (ch == LF) {\n                this.firstEol = LF_STRING;\n            } else if (ch == CR) {\n                this.firstEol = CR_STRING;\n            }\n        }\n\n        return ch == LF || ch == CR;\n    }\n\n    // TODO escape handling needs more work\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link Constants#END_OF_STREAM} if char following the escape is\n     *      invalid.\n     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n     *      the escape character is not allowed at end of stream\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int ch = reader.read();\n        switch (ch) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return ch;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isMetaChar(ch)) {\n                return ch;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return END_OF_STREAM;\n        }\n    }\n\n    void trimTrailingSpaces(final StringBuilder buffer) {\n        int length = buffer.length();\n        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n            length = length - 1;\n        }\n        if (length != buffer.length()) {\n            buffer.setLength(length);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex a8afc5016..edd9576ce 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -413,6 +413,7 @@ private Token parseSimpleToken(final Token token, int ch) throws IOException {\n                 token.type = TOKEN;\n                 break;\n             }\n+            // continue\n             if (isEscape(ch)) {\n                 if (isEscapeDelimiter()) {\n                     token.content.append(delimiter);\n@@ -424,11 +425,10 @@ private Token parseSimpleToken(final Token token, int ch) throws IOException {\n                         token.content.append((char) unescaped);\n                     }\n                 }\n-                ch = reader.read(); // continue\n             } else {\n                 token.content.append((char) ch);\n-                ch = reader.read(); // continue\n             }\n+            ch = reader.read(); // continue\n         }\n \n         if (ignoreSurroundingSpaces) {\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVRecordTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 167,
    "title": "CSV-283: Remove Whitespace Check Determines Delimiter Twice",
    "state": "closed",
    "created_at": "2021-07-13T21:07:05Z",
    "merge_commit_sha": "d617b6720a67bef3c1324f3e4a7d2c14716550f8",
    "base_sha": "3627c5ae83226dbe383ed8abb32c1e9c3f51cefe",
    "head_sha": "7c44e66c5b6630f5530420a4c8abebd2e31153e8",
    "user_login": "belugabehr",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/Lexer.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Token.Type.COMMENT;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\nimport static org.apache.commons.csv.TokenMatchers.hasContent;\nimport static org.apache.commons.csv.TokenMatchers.matches;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class LexerTest2 {\n    private CSVFormat formatWithEscaping;\n\n    @BeforeEach\n    public void setUp() {\n        formatWithEscaping = CSVFormat.DEFAULT.withEscape('\\\\');\n    }\n\n    @SuppressWarnings(\"resource\")\n    private Lexer createLexer(final String input, final CSVFormat format) {\n        return new Lexer(format, new ExtendedBufferedReader(new StringReader(input)));\n    }\n\n    @Test\n    public void testIgnoreSurroundingSpacesWithWhitespace() throws IOException {\n        final String code = \"  leadingSpaces, trailingSpaces  ,  surroundingSpaces  ,\";\n        try (final Lexer parser = createLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingSpaces\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingSpaces\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"surroundingSpaces\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n\n    @Test\n    public void testIgnoreSurroundingSpacesWithTabs() throws IOException {\n        final String code = \"\\tleadingTab,\\ttrailingTab\\t,\\tsurroundingTabs\\t,\";\n        try (final Lexer parser = createLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingTab\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingTab\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"surroundingTabs\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n\n    @Test\n    public void testInvalidCharBetweenEncapsulatedTokenAndDelimiter() {\n        final String code = \"\\\"encapsulated\\\"invalid,\";\n        try (final Lexer parser = createLexer(code, CSVFormat.DEFAULT)) {\n            assertThrows(IOException.class, () -> parser.nextToken(new Token()));\n        }\n    }\n\n    @Test\n    public void testWhitespaceHandlingInEncapsulatedToken() throws IOException {\n        final String code = \"\\\"encapsulated\\\" ,\";\n        try (final Lexer parser = createLexer(code, CSVFormat.DEFAULT)) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"encapsulated\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport static org.apache.commons.csv.Token.Type.COMMENT;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Token.Type.INVALID;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.IOException;\n\n/**\n * Lexical analyzer.\n */\nfinal class Lexer implements Closeable {\n\n    private static final String CR_STRING = Character.toString(CR);\n    private static final String LF_STRING = Character.toString(LF);\n\n    /**\n     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char[] delimiter;\n    private final char escape;\n    private final char quoteChar;\n    private final char commentStart;\n\n    private final boolean ignoreSurroundingSpaces;\n    private final boolean ignoreEmptyLines;\n\n    /** The input stream */\n    private final ExtendedBufferedReader reader;\n    private String firstEol;\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n        this.reader = reader;\n        this.delimiter = format.getDelimiterString().toCharArray();\n        this.escape = mapNullToDisabled(format.getEscapeCharacter());\n        this.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\n        this.commentStart = mapNullToDisabled(format.getCommentMarker());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        reader.close();\n    }\n\n    /**\n     * Returns the current character position\n     *\n     * @return the current character position\n     */\n    long getCharacterPosition() {\n        return reader.getPosition();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        return reader.getCurrentLineNumber();\n    }\n\n    String getFirstEol(){\n        return firstEol;\n    }\n\n    boolean isClosed() {\n        return reader.isClosed();\n    }\n\n    boolean isCommentStart(final int ch) {\n        return ch == commentStart;\n    }\n\n    /**\n     * Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#lookAhead(int)}\n     *\n     * @param ch\n     *             the current character.\n     * @return true if the next characters constitute a delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isDelimiter(final int ch) throws IOException {\n        if (ch != delimiter[0]) {\n            return false;\n        }\n        final int len = delimiter.length - 1;\n        final char[] buf = reader.lookAhead(len);\n        for (int i = 0; i < len; i++) {\n            if (buf[i] != delimiter[i+1]) {\n                return false;\n            }\n        }\n        final int count = reader.read(buf, 0, len);\n        return count != END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character indicates end of file.\n     *\n     * @return true if the given character indicates end of file.\n     */\n    boolean isEndOfFile(final int ch) {\n        return ch == END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character is the escape character.\n     *\n     * @return true if the given character is the escape character.\n     */\n    boolean isEscape(final int ch) {\n        return ch == escape;\n    }\n\n    /**\n     * Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#lookAhead(int)}.\n     *\n     * For example, for delimiter \"[|]\" and escape '!', return true if the next characters constitute \"![!|!]\".\n     *\n     * @return true if the next characters constitute a escape delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isEscapeDelimiter() throws IOException {\n        final int len = 2 * delimiter.length - 1;\n        final char[] buf = reader.lookAhead(len);\n        if (buf[0] != delimiter[0]) {\n            return false;\n        }\n        for (int i = 1; i < delimiter.length; i++) {\n            if (buf[2 * i] != delimiter[i] || buf[2 * i - 1] != escape) {\n                return false;\n            }\n        }\n        final int count = reader.read(buf, 0, len);\n        return count != END_OF_STREAM;\n    }\n\n    private boolean isMetaChar(final int ch) {\n        return ch == escape || ch == quoteChar || ch == commentStart;\n    }\n\n    boolean isQuoteChar(final int ch) {\n        return ch == quoteChar;\n    }\n\n    /**\n     * Tests if the current character represents the start of a line: a CR, LF or is at the start of the file.\n     *\n     * @param ch the character to check\n     * @return true if the character is at the start of a line.\n     */\n    boolean isStartOfLine(final int ch) {\n        return ch == LF || ch == CR || ch == UNDEFINED;\n    }\n\n    /**\n     * Tests if the given char is a whitespace character.\n     *\n     * @return true if the given char is a whitespace character.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isWhitespace(final int ch) throws IOException {\n        return !isDelimiter(ch) && Character.isWhitespace((char) ch);\n    }\n\n    private char mapNullToDisabled(final Character c) {\n        return c == null ? DISABLED : c.charValue();\n    }\n\n    /**\n     * Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token\n     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n     * @return the next token found.\n     * @throws java.io.IOException on stream access error.\n     */\n    Token nextToken(final Token token) throws IOException {\n\n        // get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n\n        // read the next char and set eol\n        int c = reader.read();\n        /*\n         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n         * - they are equivalent here.\n         */\n        boolean eol = readEndOfLine(c);\n\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol && isStartOfLine(lastChar)) {\n                // go on char ahead ...\n                lastChar = c;\n                c = reader.read();\n                eol = readEndOfLine(c);\n                // reached end of file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type = EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // did we reach eof during the last iteration already ? EOF\n        if (isEndOfFile(lastChar) || !isDelimiter(lastChar) && isEndOfFile(c)) {\n            token.type = EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n            final String line = reader.readLine();\n            if (line == null) {\n                token.type = EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n            final String comment = line.trim();\n            token.content.append(comment);\n            token.type = COMMENT;\n            return token;\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n\n    /**\n     * Parses an encapsulated token.\n     * <p>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n     */\n    private Token parseEncapsulatedToken(final Token token) throws IOException {\n        token.isQuoted = true;\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        int c;\n        while (true) {\n            c = reader.read();\n\n            if (isEscape(c)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) c).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n            } else if (isQuoteChar(c)) {\n                if (isQuoteChar(reader.lookAhead())) {\n                    // double or escaped encapsulator -> add single encapsulator to token\n                    c = reader.read();\n                    token.content.append((char) c);\n                } else {\n                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                    while (true) {\n                        c = reader.read();\n                        if (isDelimiter(c)) {\n                            token.type = TOKEN;\n                            return token;\n                        }\n                        if (isEndOfFile(c)) {\n                            token.type = EOF;\n                            token.isReady = true; // There is data at EOF\n                            return token;\n                        }\n                        if (readEndOfLine(c)) {\n                            token.type = EORECORD;\n                            return token;\n                        }\n                        if (!isWhitespace(c)) {\n                            // error invalid char between token and next delimiter\n                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                    \") invalid char between encapsulated token and delimiter\");\n                        }\n                    }\n                }\n            } else if (isEndOfFile(c)) {\n                // error condition (end of file before end of token)\n                throw new IOException(\"(startline \" + startLineNumber +\n                        \") EOF reached before encapsulated token finished\");\n            } else {\n                // consume character\n                token.content.append((char) c);\n            }\n        }\n    }\n\n    /**\n     * Parses a simple token.\n     * <p>\n     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>end of line has been reached (EORECORD)</li>\n     * <li>end of stream has been reached (EOF)</li>\n     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token\n     *            the current token\n     * @param ch\n     *            the current character\n     * @return the filled token\n     * @throws IOException\n     *             on stream access error\n     */\n    private Token parseSimpleToken(final Token token, int ch) throws IOException {\n        // Faster to use while(true)+break than while(token.type == INVALID)\n        while (true) {\n            if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                break;\n            }\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                break;\n            }\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                break;\n            }\n            if (isEscape(ch)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) ch).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n                ch = reader.read(); // continue\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read(); // continue\n            }\n        }\n\n        if (ignoreSurroundingSpaces) {\n            trimTrailingSpaces(token.content);\n        }\n\n        return token;\n    }\n\n    /**\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     */\n    boolean readEndOfLine(int ch) throws IOException {\n        // check if we have \\r\\n...\n        if (ch == CR && reader.lookAhead() == LF) {\n            // note: does not change ch outside of this method!\n            ch = reader.read();\n            // Save the EOL state\n            if (firstEol == null) {\n                this.firstEol = Constants.CRLF;\n            }\n        }\n        // save EOL state here.\n        if (firstEol == null) {\n            if (ch == LF) {\n                this.firstEol = LF_STRING;\n            } else if (ch == CR) {\n                this.firstEol = CR_STRING;\n            }\n        }\n\n        return ch == LF || ch == CR;\n    }\n\n    // TODO escape handling needs more work\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link Constants#END_OF_STREAM} if char following the escape is\n     *      invalid.\n     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n     *      the escape character is not allowed at end of stream\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int ch = reader.read();\n        switch (ch) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return ch;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isMetaChar(ch)) {\n                return ch;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return END_OF_STREAM;\n        }\n    }\n\n    void trimTrailingSpaces(final StringBuilder buffer) {\n        int length = buffer.length();\n        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n            length = length - 1;\n        }\n        if (length != buffer.length()) {\n            buffer.setLength(length);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex 1f14543bd..045a35b8a 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -193,16 +193,6 @@ boolean isStartOfLine(final int ch) {\n         return ch == LF || ch == CR || ch == UNDEFINED;\n     }\n \n-    /**\n-     * Tests if the given char is a whitespace character.\n-     *\n-     * @return true if the given char is a whitespace character.\n-     * @throws IOException If an I/O error occurs.\n-     */\n-    boolean isWhitespace(final int ch) throws IOException {\n-        return !isDelimiter(ch) && Character.isWhitespace((char) ch);\n-    }\n-\n     private char mapNullToDisabled(final Character c) {\n         return c == null ? DISABLED : c.charValue();\n     }\n@@ -271,7 +261,7 @@ Token nextToken(final Token token) throws IOException {\n         while (token.type == INVALID) {\n             // ignore whitespaces at beginning of a token\n             if (ignoreSurroundingSpaces) {\n-                while (isWhitespace(c) && !eol) {\n+                while (Character.isWhitespace((char)c) && !isDelimiter(c) && !eol) {\n                     c = reader.read();\n                     eol = readEndOfLine(c);\n                 }\n@@ -364,7 +354,7 @@ private Token parseEncapsulatedToken(final Token token) throws IOException {\n                             token.type = EORECORD;\n                             return token;\n                         }\n-                        if (!isWhitespace(c)) {\n+                        if (!Character.isWhitespace((char)c)) {\n                             // error invalid char between token and next delimiter\n                             throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                     \") invalid char between encapsulated token and delimiter\");\n"
      }
    ]
  },
  {
    "pr_number": 163,
    "title": "CSV-279: Optimize Lexer Delimiter Check for One Character Delimiter",
    "state": "closed",
    "created_at": "2021-07-13T02:26:08Z",
    "merge_commit_sha": "f7c067d9b27f76849838d26f7c5b5dff7901f271",
    "base_sha": "3b959626f4c1ad31a4f8fbdcba513e12fc6f7f3d",
    "head_sha": "7d2bb6a0f152254b04ddd6e975b29bbc6d638068",
    "user_login": "belugabehr",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/Lexer.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\nimport static org.apache.commons.csv.TokenMatchers.matches;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class LexerTest2 {\n\n    private CSVFormat formatWithEscaping;\n\n    @BeforeEach\n    public void setUp() {\n        formatWithEscaping = CSVFormat.DEFAULT.withEscape('\\\\');\n    }\n\n    @SuppressWarnings(\"resource\")\n    private Lexer createLexer(final String input, final CSVFormat format) {\n        return new Lexer(format, new ExtendedBufferedReader(new StringReader(input)));\n    }\n\n    @Test\n    public void testSingleCharacterDelimiter() throws IOException {\n        final String code = \"a,b,c\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(',');\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"b\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"c\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n\n    @Test\n    public void testMultiCharacterDelimiter() throws IOException {\n        final String code = \"a||b||c\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(\"||\");\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"b\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"c\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n\n    @Test\n    public void testSingleCharacterDelimiterWithSpaces() throws IOException {\n        final String code = \"a , b , c \";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(',').withIgnoreSurroundingSpaces();\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"b\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"c\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n\n    @Test\n    public void testMultiCharacterDelimiterWithSpaces() throws IOException {\n        final String code = \"a || b || c \";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(\"||\").withIgnoreSurroundingSpaces();\n        try (final Lexer parser = createLexer(code, format)) {\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"b\"));\n            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"c\"));\n            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport static org.apache.commons.csv.Token.Type.COMMENT;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Token.Type.INVALID;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.IOException;\n\n/**\n * Lexical analyzer.\n */\nfinal class Lexer implements Closeable {\n\n    private static final String CR_STRING = Character.toString(CR);\n    private static final String LF_STRING = Character.toString(LF);\n\n    /**\n     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char[] delimiter;\n    private final char escape;\n    private final char quoteChar;\n    private final char commentStart;\n\n    private final boolean ignoreSurroundingSpaces;\n    private final boolean ignoreEmptyLines;\n\n    /** The input stream */\n    private final ExtendedBufferedReader reader;\n    private String firstEol;\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n        this.reader = reader;\n        this.delimiter = format.getDelimiterString().toCharArray();\n        this.escape = mapNullToDisabled(format.getEscapeCharacter());\n        this.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\n        this.commentStart = mapNullToDisabled(format.getCommentMarker());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        reader.close();\n    }\n\n    /**\n     * Returns the current character position\n     *\n     * @return the current character position\n     */\n    long getCharacterPosition() {\n        return reader.getPosition();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        return reader.getCurrentLineNumber();\n    }\n\n    String getFirstEol(){\n        return firstEol;\n    }\n\n    boolean isClosed() {\n        return reader.isClosed();\n    }\n\n    boolean isCommentStart(final int ch) {\n        return ch == commentStart;\n    }\n\n    /**\n     * Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#lookAhead(int)}\n     *\n     * @param ch\n     *             the current character.\n     * @return true if the next characters constitute a delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isDelimiter(final int ch) throws IOException {\n        if (ch != delimiter[0]) {\n            return false;\n        }\n        final int len = delimiter.length - 1;\n        final char[] buf = reader.lookAhead(len);\n        for (int i = 0; i < len; i++) {\n            if (buf[i] != delimiter[i+1]) {\n                return false;\n            }\n        }\n        final int count = reader.read(buf, 0, len);\n        return count != END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character indicates end of file.\n     *\n     * @return true if the given character indicates end of file.\n     */\n    boolean isEndOfFile(final int ch) {\n        return ch == END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character is the escape character.\n     *\n     * @return true if the given character is the escape character.\n     */\n    boolean isEscape(final int ch) {\n        return ch == escape;\n    }\n\n    /**\n     * Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#lookAhead(int)}.\n     *\n     * For example, for delimiter \"[|]\" and escape '!', return true if the next characters constitute \"![!|!]\".\n     *\n     * @return true if the next characters constitute a escape delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isEscapeDelimiter() throws IOException {\n        final int len = 2 * delimiter.length - 1;\n        final char[] buf = reader.lookAhead(len);\n        if (buf[0] != delimiter[0]) {\n            return false;\n        }\n        for (int i = 1; i < delimiter.length; i++) {\n            if (buf[2 * i] != delimiter[i] || buf[2 * i - 1] != escape) {\n                return false;\n            }\n        }\n        final int count = reader.read(buf, 0, len);\n        return count != END_OF_STREAM;\n    }\n\n    private boolean isMetaChar(final int ch) {\n        return ch == escape || ch == quoteChar || ch == commentStart;\n    }\n\n    boolean isQuoteChar(final int ch) {\n        return ch == quoteChar;\n    }\n\n    /**\n     * Tests if the current character represents the start of a line: a CR, LF or is at the start of the file.\n     *\n     * @param ch the character to check\n     * @return true if the character is at the start of a line.\n     */\n    boolean isStartOfLine(final int ch) {\n        return ch == LF || ch == CR || ch == UNDEFINED;\n    }\n\n    private char mapNullToDisabled(final Character c) {\n        return c == null ? DISABLED : c.charValue();\n    }\n\n    /**\n     * Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token\n     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n     * @return the next token found.\n     * @throws java.io.IOException on stream access error.\n     */\n    Token nextToken(final Token token) throws IOException {\n\n        // get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n\n        // read the next char and set eol\n        int c = reader.read();\n        /*\n         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n         * - they are equivalent here.\n         */\n        boolean eol = readEndOfLine(c);\n\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol && isStartOfLine(lastChar)) {\n                // go on char ahead ...\n                lastChar = c;\n                c = reader.read();\n                eol = readEndOfLine(c);\n                // reached end of file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type = EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // did we reach eof during the last iteration already ? EOF\n        if (isEndOfFile(lastChar) || !isDelimiter(lastChar) && isEndOfFile(c)) {\n            token.type = EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n            final String line = reader.readLine();\n            if (line == null) {\n                token.type = EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n            final String comment = line.trim();\n            token.content.append(comment);\n            token.type = COMMENT;\n            return token;\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (Character.isWhitespace((char)c) && !isDelimiter(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n\n    /**\n     * Parses an encapsulated token.\n     * <p>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n     */\n    private Token parseEncapsulatedToken(final Token token) throws IOException {\n        token.isQuoted = true;\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        int c;\n        while (true) {\n            c = reader.read();\n\n            if (isEscape(c)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) c).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n            } else if (isQuoteChar(c)) {\n                if (isQuoteChar(reader.lookAhead())) {\n                    // double or escaped encapsulator -> add single encapsulator to token\n                    c = reader.read();\n                    token.content.append((char) c);\n                } else {\n                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                    while (true) {\n                        c = reader.read();\n                        if (isDelimiter(c)) {\n                            token.type = TOKEN;\n                            return token;\n                        }\n                        if (isEndOfFile(c)) {\n                            token.type = EOF;\n                            token.isReady = true; // There is data at EOF\n                            return token;\n                        }\n                        if (readEndOfLine(c)) {\n                            token.type = EORECORD;\n                            return token;\n                        }\n                        if (!Character.isWhitespace((char)c)) {\n                            // error invalid char between token and next delimiter\n                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                    \") invalid char between encapsulated token and delimiter\");\n                        }\n                    }\n                }\n            } else if (isEndOfFile(c)) {\n                // error condition (end of file before end of token)\n                throw new IOException(\"(startline \" + startLineNumber +\n                        \") EOF reached before encapsulated token finished\");\n            } else {\n                // consume character\n                token.content.append((char) c);\n            }\n        }\n    }\n\n    /**\n     * Parses a simple token.\n     * <p>\n     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>end of line has been reached (EORECORD)</li>\n     * <li>end of stream has been reached (EOF)</li>\n     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token\n     *            the current token\n     * @param ch\n     *            the current character\n     * @return the filled token\n     * @throws IOException\n     *             on stream access error\n     */\n    private Token parseSimpleToken(final Token token, int ch) throws IOException {\n        // Faster to use while(true)+break than while(token.type == INVALID)\n        while (true) {\n            if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                break;\n            }\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                break;\n            }\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                break;\n            }\n            if (isEscape(ch)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) ch).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n                ch = reader.read(); // continue\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read(); // continue\n            }\n        }\n\n        if (ignoreSurroundingSpaces) {\n            trimTrailingSpaces(token.content);\n        }\n\n        return token;\n    }\n\n    /**\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     */\n    boolean readEndOfLine(int ch) throws IOException {\n        // check if we have \\r\\n...\n        if (ch == CR && reader.lookAhead() == LF) {\n            // note: does not change ch outside of this method!\n            ch = reader.read();\n            // Save the EOL state\n            if (firstEol == null) {\n                this.firstEol = Constants.CRLF;\n            }\n        }\n        // save EOL state here.\n        if (firstEol == null) {\n            if (ch == LF) {\n                this.firstEol = LF_STRING;\n            } else if (ch == CR) {\n                this.firstEol = CR_STRING;\n            }\n        }\n\n        return ch == LF || ch == CR;\n    }\n\n    // TODO escape handling needs more work\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link Constants#END_OF_STREAM} if char following the escape is\n     *      invalid.\n     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n     *      the escape character is not allowed at end of stream\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int ch = reader.read();\n        switch (ch) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return ch;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isMetaChar(ch)) {\n                return ch;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return END_OF_STREAM;\n        }\n    }\n\n    void trimTrailingSpaces(final StringBuilder buffer) {\n        int length = buffer.length();\n        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n            length = length - 1;\n        }\n        if (length != buffer.length()) {\n            buffer.setLength(length);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex 1f14543bd..d15be1f25 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -123,6 +123,9 @@ boolean isDelimiter(final int ch) throws IOException {\n         if (ch != delimiter[0]) {\n             return false;\n         }\n+        if (delimiter.length == 1) {\n+          return true;\n+        }\n         final int len = delimiter.length - 1;\n         final char[] buf = reader.lookAhead(len);\n         for (int i = 0; i < len; i++) {\n"
      }
    ]
  },
  {
    "pr_number": 162,
    "title": "CSV-278: Reuse Buffers in Lexer for Delimiter Detection",
    "state": "closed",
    "created_at": "2021-07-13T00:00:34Z",
    "merge_commit_sha": "3ac702b190fd04c56118cb03aa87577f0a6a86f7",
    "base_sha": "bda783580a223a8505214b386c3fa94e5a8ac6f3",
    "head_sha": "feb90c1538174c66019e3019601d31400f26419d",
    "user_login": "belugabehr",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport java.io.StringReader;\nimport org.junit.jupiter.api.Test;\n\npublic class ExtendedBufferedReaderTest2 {\n\n    private ExtendedBufferedReader createBufferedReader(final String s) {\n        return new ExtendedBufferedReader(new StringReader(s));\n    }\n\n    /**\n     * Test the new lookAhead(char[] buf) method.\n     */\n    @Test\n    public void testLookAheadWithBuffer() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"abcdefg\")) {\n            final char[] buf = new char[3];\n            assertArrayEquals(new char[]{'a', 'b', 'c'}, br.lookAhead(buf));\n            assertEquals('a', br.read());\n            assertArrayEquals(new char[]{'b', 'c', 'd'}, br.lookAhead(buf));\n            assertEquals('b', br.read());\n            assertArrayEquals(new char[]{'c', 'd', 'e'}, br.lookAhead(buf));\n        }\n    }\n\n    /**\n     * Test the new lookAhead(char[] buf) method with end of stream.\n     */\n    @Test\n    public void testLookAheadWithBufferEndOfStream() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"ab\")) {\n            final char[] buf = new char[3];\n            assertArrayEquals(new char[]{'a', 'b', END_OF_STREAM}, br.lookAhead(buf));\n            assertEquals('a', br.read());\n            assertArrayEquals(new char[]{'b', END_OF_STREAM, END_OF_STREAM}, br.lookAhead(buf));\n            assertEquals('b', br.read());\n            assertArrayEquals(new char[]{END_OF_STREAM, END_OF_STREAM, END_OF_STREAM}, br.lookAhead(buf));\n        }\n    }\n\n    /**\n     * Test the new lookAhead(char[] buf) method with empty input.\n     */\n    @Test\n    public void testLookAheadWithBufferEmptyInput() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"\")) {\n            final char[] buf = new char[3];\n            assertArrayEquals(new char[]{END_OF_STREAM, END_OF_STREAM, END_OF_STREAM}, br.lookAhead(buf));\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * A special buffered reader which supports sophisticated read access.\n * <p>\n * In particular the reader supports a look-ahead option, which allows you to see the next char returned by\n * {@link #read()}. This reader also tracks how many characters have been read with {@link #getPosition()}.\n * </p>\n */\nfinal class ExtendedBufferedReader extends BufferedReader {\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The count of EOLs (CR/LF/CRLF) seen so far */\n    private long eolCounter;\n\n    /** The position, which is number of characters read so far */\n    private long position;\n\n    private boolean closed;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(final Reader reader) {\n        super(reader);\n    }\n\n    /**\n     * Closes the stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        // Set ivars before calling super close() in case close() throws an IOException.\n        closed = true;\n        lastChar = END_OF_STREAM;\n        super.close();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        // Check if we are at EOL or EOF or just starting\n        if (lastChar == CR || lastChar == LF || lastChar == UNDEFINED || lastChar == END_OF_STREAM) {\n            return eolCounter; // counter is accurate\n        }\n        return eolCounter + 1; // Allow for counter being incremented only at EOL\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n     * any of the read methods. This will not include a character read using the {@link #lookAhead()} method. If no\n     * character has been read then this will return {@link Constants#UNDEFINED}. If the end of the stream was reached\n     * on the last read then this will return {@link Constants#END_OF_STREAM}.\n     *\n     * @return the last character that was read\n     */\n    int getLastChar() {\n        return lastChar;\n    }\n\n    /**\n     * Gets the character position in the reader.\n     *\n     * @return the current position in the reader (counting characters, not bytes since this is a Reader)\n     */\n    long getPosition() {\n        return this.position;\n    }\n\n    public boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Returns the next character in the current reader without consuming it. So the next call to {@link #read()} will\n     * still return this value. Does not affect line number or last character.\n     *\n     * @return the next character\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    int lookAhead() throws IOException {\n        super.mark(1);\n        final int c = super.read();\n        super.reset();\n\n        return c;\n    }\n\n    /**\n     * Returns the next n characters in the current reader without consuming them. The next call to {@link #read()} will still return the next value. This\n     * doesn't affect line number or last character.\n     *\n     * @param n the number characters look ahead.\n     * @return the next n characters.\n     * @throws IOException If an I/O error occurs\n     */\n    char[] lookAhead(final int n) throws IOException {\n        final char[] buf = new char[n];\n        super.mark(n);\n        super.read(buf, 0, n);\n        super.reset();\n\n        return buf;\n    }\n\n    @Override\n    public int read() throws IOException {\n        final int current = super.read();\n        if (current == CR || current == LF && lastChar != CR ||\n            current == END_OF_STREAM && lastChar != CR && lastChar != LF && lastChar != END_OF_STREAM) {\n            eolCounter++;\n        }\n        lastChar = current;\n        position++;\n        return lastChar;\n    }\n\n    @Override\n    public int read(final char[] buf, final int offset, final int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n\n        final int len = super.read(buf, offset, length);\n\n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n                final char ch = buf[i];\n                if (ch == LF) {\n                    if (CR != (i > offset ? buf[i - 1] : lastChar)) {\n                        eolCounter++;\n                    }\n                } else if (ch == CR) {\n                    eolCounter++;\n                }\n            }\n\n            lastChar = buf[offset + len - 1];\n\n        } else if (len == -1) {\n            lastChar = END_OF_STREAM;\n        }\n\n        position += len;\n        return len;\n    }\n\n    /**\n     * Calls {@link BufferedReader#readLine()} which drops the line terminator(s). This method should only be called\n     * when processing a comment, otherwise information can be lost.\n     * <p>\n     * Increments {@link #eolCounter}.\n     * </p>\n     * <p>\n     * Sets {@link #lastChar} to {@link Constants#END_OF_STREAM} at EOF, otherwise to LF.\n     * </p>\n     *\n     * @return the line that was read, or null if reached EOF.\n     */\n    @Override\n    public String readLine() throws IOException {\n        final String line = super.readLine();\n\n        if (line != null) {\n            lastChar = LF; // needed for detecting start of line\n            eolCounter++;\n        } else {\n            lastChar = END_OF_STREAM;\n        }\n\n        return line;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\nindex 63efb640f..4b3fb4837 100644\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n@@ -132,6 +132,21 @@ int lookAhead() throws IOException {\n      */\n     char[] lookAhead(final int n) throws IOException {\n         final char[] buf = new char[n];\n+        return lookAhead(buf);\n+    }\n+\n+    /**\n+     * Populates the buffer with the next {@code buf.length} characters in the\n+     * current reader without consuming them. The next call to {@link #read()} will\n+     * still return the next value. This doesn't affect line number or last\n+     * character.\n+     *\n+     * @param buf the buffer to fill for the look ahead.\n+     * @return the buffer itself\n+     * @throws IOException If an I/O error occurs\n+     */\n+    char[] lookAhead(final char[] buf) throws IOException {\n+        final int n = buf.length;\n         super.mark(n);\n         super.read(buf, 0, n);\n         super.reset();\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/Lexer.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\nimport static org.apache.commons.csv.TokenMatchers.matches;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class LexerTest2 {\n\n    private CSVFormat formatWithEscaping;\n\n    @BeforeEach\n    public void setUp() {\n        formatWithEscaping = CSVFormat.DEFAULT.withEscape('\\\\');\n    }\n\n    @SuppressWarnings(\"resource\")\n    private Lexer createLexer(final String input, final CSVFormat format) {\n        return new Lexer(format, new ExtendedBufferedReader(new StringReader(input)));\n    }\n\n    @Test\n    public void testIsDelimiterWithMultipleCharacters() throws IOException {\n        final String code = \"a|b|c\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter('|');\n        try (final Lexer lexer = createLexer(code, format)) {\n            assertThat(lexer.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(lexer.nextToken(new Token()), matches(TOKEN, \"b\"));\n            assertThat(lexer.nextToken(new Token()), matches(EOF, \"c\"));\n        }\n    }\n\n    @Test\n    public void testIsEscapeDelimiterWithMultipleCharacters() throws IOException {\n        final String code = \"a!|!b!|!c\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter('|').withEscape('!');\n        try (final Lexer lexer = createLexer(code, format)) {\n            assertThat(lexer.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(lexer.nextToken(new Token()), matches(TOKEN, \"b\"));\n            assertThat(lexer.nextToken(new Token()), matches(EOF, \"c\"));\n        }\n    }\n\n    @Test\n    public void testIsDelimiterWithLookAhead() throws IOException {\n        final String code = \"a,b,c\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(',');\n        try (final Lexer lexer = createLexer(code, format)) {\n            assertThat(lexer.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(lexer.nextToken(new Token()), matches(TOKEN, \"b\"));\n            assertThat(lexer.nextToken(new Token()), matches(EOF, \"c\"));\n        }\n    }\n\n    @Test\n    public void testIsEscapeDelimiterWithLookAhead() throws IOException {\n        final String code = \"a!b!c\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter('b').withEscape('!');\n        try (final Lexer lexer = createLexer(code, format)) {\n            assertThat(lexer.nextToken(new Token()), matches(TOKEN, \"a\"));\n            assertThat(lexer.nextToken(new Token()), matches(EOF, \"c\"));\n        }\n    }\n\n    @Test\n    public void testReadEscapeWithDelimiter() throws IOException {\n        final String code = \"a\\\\,b\\\\,c\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(',').withEscape('\\\\');\n        try (final Lexer lexer = createLexer(code, format)) {\n            assertThat(lexer.nextToken(new Token()), matches(TOKEN, \"a,b,c\"));\n        }\n    }\n\n    @Test\n    public void testReadEscapeWithMultipleCharacters() throws IOException {\n        final String code = \"a\\\\|b\\\\|c\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter('|').withEscape('\\\\');\n        try (final Lexer lexer = createLexer(code, format)) {\n            assertThat(lexer.nextToken(new Token()), matches(TOKEN, \"a|b|c\"));\n        }\n    }\n\n    @Test\n    public void testEscapeDelimiterAtEOF() throws IOException {\n        final String code = \"a!|!\";\n        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter('|').withEscape('!');\n        try (final Lexer lexer = createLexer(code, format)) {\n            assertThrows(IOException.class, () -> lexer.nextToken(new Token()));\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport static org.apache.commons.csv.Token.Type.COMMENT;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Token.Type.INVALID;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.IOException;\n\n/**\n * Lexical analyzer.\n */\nfinal class Lexer implements Closeable {\n\n    private static final String CR_STRING = Character.toString(CR);\n    private static final String LF_STRING = Character.toString(LF);\n\n    /**\n     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char[] delimiter;\n    private final char escape;\n    private final char quoteChar;\n    private final char commentStart;\n\n    private final boolean ignoreSurroundingSpaces;\n    private final boolean ignoreEmptyLines;\n\n    /** The input stream */\n    private final ExtendedBufferedReader reader;\n    private String firstEol;\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n        this.reader = reader;\n        this.delimiter = format.getDelimiterString().toCharArray();\n        this.escape = mapNullToDisabled(format.getEscapeCharacter());\n        this.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\n        this.commentStart = mapNullToDisabled(format.getCommentMarker());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        reader.close();\n    }\n\n    /**\n     * Returns the current character position\n     *\n     * @return the current character position\n     */\n    long getCharacterPosition() {\n        return reader.getPosition();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        return reader.getCurrentLineNumber();\n    }\n\n    String getFirstEol(){\n        return firstEol;\n    }\n\n    boolean isClosed() {\n        return reader.isClosed();\n    }\n\n    boolean isCommentStart(final int ch) {\n        return ch == commentStart;\n    }\n\n    /**\n     * Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#lookAhead(int)}\n     *\n     * @param ch\n     *             the current character.\n     * @return true if the next characters constitute a delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isDelimiter(final int ch) throws IOException {\n        if (ch != delimiter[0]) {\n            return false;\n        }\n        if (delimiter.length == 1) {\n          return true;\n        }\n        final int len = delimiter.length - 1;\n        final char[] buf = reader.lookAhead(len);\n        for (int i = 0; i < len; i++) {\n            if (buf[i] != delimiter[i+1]) {\n                return false;\n            }\n        }\n        final int count = reader.read(buf, 0, len);\n        return count != END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character indicates end of file.\n     *\n     * @return true if the given character indicates end of file.\n     */\n    boolean isEndOfFile(final int ch) {\n        return ch == END_OF_STREAM;\n    }\n\n    /**\n     * Tests if the given character is the escape character.\n     *\n     * @return true if the given character is the escape character.\n     */\n    boolean isEscape(final int ch) {\n        return ch == escape;\n    }\n\n    /**\n     * Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#lookAhead(int)}.\n     *\n     * For example, for delimiter \"[|]\" and escape '!', return true if the next characters constitute \"![!|!]\".\n     *\n     * @return true if the next characters constitute a escape delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isEscapeDelimiter() throws IOException {\n        final int len = 2 * delimiter.length - 1;\n        final char[] buf = reader.lookAhead(len);\n        if (buf[0] != delimiter[0]) {\n            return false;\n        }\n        for (int i = 1; i < delimiter.length; i++) {\n            if (buf[2 * i] != delimiter[i] || buf[2 * i - 1] != escape) {\n                return false;\n            }\n        }\n        final int count = reader.read(buf, 0, len);\n        return count != END_OF_STREAM;\n    }\n\n    private boolean isMetaChar(final int ch) {\n        return ch == escape || ch == quoteChar || ch == commentStart;\n    }\n\n    boolean isQuoteChar(final int ch) {\n        return ch == quoteChar;\n    }\n\n    /**\n     * Tests if the current character represents the start of a line: a CR, LF or is at the start of the file.\n     *\n     * @param ch the character to check\n     * @return true if the character is at the start of a line.\n     */\n    boolean isStartOfLine(final int ch) {\n        return ch == LF || ch == CR || ch == UNDEFINED;\n    }\n\n    private char mapNullToDisabled(final Character c) {\n        return c == null ? DISABLED : c.charValue();\n    }\n\n    /**\n     * Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token\n     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n     * @return the next token found.\n     * @throws java.io.IOException on stream access error.\n     */\n    Token nextToken(final Token token) throws IOException {\n\n        // get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n\n        // read the next char and set eol\n        int c = reader.read();\n        /*\n         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n         * - they are equivalent here.\n         */\n        boolean eol = readEndOfLine(c);\n\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol && isStartOfLine(lastChar)) {\n                // go on char ahead ...\n                lastChar = c;\n                c = reader.read();\n                eol = readEndOfLine(c);\n                // reached end of file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type = EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // did we reach eof during the last iteration already ? EOF\n        if (isEndOfFile(lastChar) || !isDelimiter(lastChar) && isEndOfFile(c)) {\n            token.type = EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n            final String line = reader.readLine();\n            if (line == null) {\n                token.type = EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n            final String comment = line.trim();\n            token.content.append(comment);\n            token.type = COMMENT;\n            return token;\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (Character.isWhitespace((char)c) && !isDelimiter(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n\n    /**\n     * Parses an encapsulated token.\n     * <p>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n     */\n    private Token parseEncapsulatedToken(final Token token) throws IOException {\n        token.isQuoted = true;\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        int c;\n        while (true) {\n            c = reader.read();\n\n            if (isEscape(c)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) c).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n            } else if (isQuoteChar(c)) {\n                if (isQuoteChar(reader.lookAhead())) {\n                    // double or escaped encapsulator -> add single encapsulator to token\n                    c = reader.read();\n                    token.content.append((char) c);\n                } else {\n                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                    while (true) {\n                        c = reader.read();\n                        if (isDelimiter(c)) {\n                            token.type = TOKEN;\n                            return token;\n                        }\n                        if (isEndOfFile(c)) {\n                            token.type = EOF;\n                            token.isReady = true; // There is data at EOF\n                            return token;\n                        }\n                        if (readEndOfLine(c)) {\n                            token.type = EORECORD;\n                            return token;\n                        }\n                        if (!Character.isWhitespace((char)c)) {\n                            // error invalid char between token and next delimiter\n                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                    \") invalid char between encapsulated token and delimiter\");\n                        }\n                    }\n                }\n            } else if (isEndOfFile(c)) {\n                // error condition (end of file before end of token)\n                throw new IOException(\"(startline \" + startLineNumber +\n                        \") EOF reached before encapsulated token finished\");\n            } else {\n                // consume character\n                token.content.append((char) c);\n            }\n        }\n    }\n\n    /**\n     * Parses a simple token.\n     * <p>\n     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>end of line has been reached (EORECORD)</li>\n     * <li>end of stream has been reached (EOF)</li>\n     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token\n     *            the current token\n     * @param ch\n     *            the current character\n     * @return the filled token\n     * @throws IOException\n     *             on stream access error\n     */\n    private Token parseSimpleToken(final Token token, int ch) throws IOException {\n        // Faster to use while(true)+break than while(token.type == INVALID)\n        while (true) {\n            if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                break;\n            }\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                break;\n            }\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                break;\n            }\n            if (isEscape(ch)) {\n                if (isEscapeDelimiter()) {\n                    token.content.append(delimiter);\n                } else {\n                    final int unescaped = readEscape();\n                    if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                        token.content.append((char) ch).append((char) reader.getLastChar());\n                    } else {\n                        token.content.append((char) unescaped);\n                    }\n                }\n                ch = reader.read(); // continue\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read(); // continue\n            }\n        }\n\n        if (ignoreSurroundingSpaces) {\n            trimTrailingSpaces(token.content);\n        }\n\n        return token;\n    }\n\n    /**\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     */\n    boolean readEndOfLine(int ch) throws IOException {\n        // check if we have \\r\\n...\n        if (ch == CR && reader.lookAhead() == LF) {\n            // note: does not change ch outside of this method!\n            ch = reader.read();\n            // Save the EOL state\n            if (firstEol == null) {\n                this.firstEol = Constants.CRLF;\n            }\n        }\n        // save EOL state here.\n        if (firstEol == null) {\n            if (ch == LF) {\n                this.firstEol = LF_STRING;\n            } else if (ch == CR) {\n                this.firstEol = CR_STRING;\n            }\n        }\n\n        return ch == LF || ch == CR;\n    }\n\n    // TODO escape handling needs more work\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link Constants#END_OF_STREAM} if char following the escape is\n     *      invalid.\n     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n     *      the escape character is not allowed at end of stream\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int ch = reader.read();\n        switch (ch) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return ch;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isMetaChar(ch)) {\n                return ch;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return END_OF_STREAM;\n        }\n    }\n\n    void trimTrailingSpaces(final StringBuilder buffer) {\n        int length = buffer.length();\n        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n            length = length - 1;\n        }\n        if (length != buffer.length()) {\n            buffer.setLength(length);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex cfd64fcd3..a8afc5016 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -49,6 +49,8 @@ final class Lexer implements Closeable {\n     private static final char DISABLED = '\\ufffe';\n \n     private final char[] delimiter;\n+    private final char[] delimiterBuf;\n+    private final char[] escapeDelimiterBuf;\n     private final char escape;\n     private final char quoteChar;\n     private final char commentStart;\n@@ -68,6 +70,8 @@ final class Lexer implements Closeable {\n         this.commentStart = mapNullToDisabled(format.getCommentMarker());\n         this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n         this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n+        this.delimiterBuf = new char[delimiter.length - 1];\n+        this.escapeDelimiterBuf = new char[2 * delimiter.length - 1];\n     }\n \n     /**\n@@ -112,7 +116,7 @@ boolean isCommentStart(final int ch) {\n     }\n \n     /**\n-     * Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#lookAhead(int)}\n+     * Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n      *\n      * @param ch\n      *             the current character.\n@@ -126,14 +130,13 @@ boolean isDelimiter(final int ch) throws IOException {\n         if (delimiter.length == 1) {\n           return true;\n         }\n-        final int len = delimiter.length - 1;\n-        final char[] buf = reader.lookAhead(len);\n-        for (int i = 0; i < len; i++) {\n-            if (buf[i] != delimiter[i+1]) {\n+        reader.lookAhead(delimiterBuf);\n+        for (int i = 0; i < delimiterBuf.length; i++) {\n+            if (delimiterBuf[i] != delimiter[i+1]) {\n                 return false;\n             }\n         }\n-        final int count = reader.read(buf, 0, len);\n+        final int count = reader.read(delimiterBuf, 0, delimiterBuf.length);\n         return count != END_OF_STREAM;\n     }\n \n@@ -156,7 +159,7 @@ boolean isEscape(final int ch) {\n     }\n \n     /**\n-     * Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#lookAhead(int)}.\n+     * Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n      *\n      * For example, for delimiter \"[|]\" and escape '!', return true if the next characters constitute \"![!|!]\".\n      *\n@@ -164,17 +167,16 @@ boolean isEscape(final int ch) {\n      * @throws IOException If an I/O error occurs.\n      */\n     boolean isEscapeDelimiter() throws IOException {\n-        final int len = 2 * delimiter.length - 1;\n-        final char[] buf = reader.lookAhead(len);\n-        if (buf[0] != delimiter[0]) {\n+        reader.lookAhead(escapeDelimiterBuf);\n+        if (escapeDelimiterBuf[0] != delimiter[0]) {\n             return false;\n         }\n         for (int i = 1; i < delimiter.length; i++) {\n-            if (buf[2 * i] != delimiter[i] || buf[2 * i - 1] != escape) {\n+            if (escapeDelimiterBuf[2 * i] != delimiter[i] || escapeDelimiterBuf[2 * i - 1] != escape) {\n                 return false;\n             }\n         }\n-        final int count = reader.read(buf, 0, len);\n+        final int count = reader.read(escapeDelimiterBuf, 0, escapeDelimiterBuf.length);\n         return count != END_OF_STREAM;\n     }\n \n"
      }
    ]
  },
  {
    "pr_number": 157,
    "title": "[CSV-271] Missing separator with \"print(object)\" followed by \"printRecord(Object[])\"",
    "state": "closed",
    "created_at": "2021-07-04T16:31:10Z",
    "merge_commit_sha": "2c83a308255d07295c761d7e61f10359b0687b01",
    "base_sha": "dc5d034a47aa1f69612f20ec646b7a2f0050279e",
    "head_sha": "53189e9f220f67edcfd91a9bbfde734558efa933",
    "user_login": "amarlearning",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVPrinterTest2 {\n\n    @Test\n    public void testPrintRecordVarArgs() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n            printer.printRecord(\"a\", \"b\", \"c\");\n            assertEquals(\"a,b,c\\r\\n\", sw.toString());\n        }\n    }\n\n    @Test\n    public void testPrintRecordVarArgsWithSpecialCharacters() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n            printer.printRecord(\"a,b\", \"c\\nd\", \"e\\\"f\\\"\");\n            assertEquals(\"\\\"a,b\\\",\\\"c\\nd\\\",\\\"e\\\"\\\"f\\\"\\\"\\r\\n\", sw.toString());\n        }\n    }\n\n    @Test\n    public void testPrintRecordVarArgsWithNullValues() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n            printer.printRecord(\"a\", null, \"c\");\n            assertEquals(\"a,,c\\r\\n\", sw.toString());\n        }\n    }\n\n    @Test\n    public void testPrintRecordVarArgsWithEmptyValues() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n            printer.printRecord(\"\", \"\", \"\");\n            assertEquals(\",,\\r\\n\", sw.toString());\n        }\n    }\n\n    @Test\n    public void testPrintRecordVarArgsWithMixedValues() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n            printer.printRecord(\"a\", \"\", null, \"d\");\n            assertEquals(\"a,,d\\r\\n\", sw.toString());\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.SP;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.sql.Clob;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.Objects;\n\n/**\n * Prints values in a {@link CSVFormat CSV format}.\n *\n * <p>Values can be appended to the output by calling the {@link #print(Object)} method.\n * Values are printed according to {@link String#valueOf(Object)}.\n * To complete a record the {@link #println()} method has to be called.\n * Comments can be appended by calling {@link #printComment(String)}.\n * However a comment will only be written to the output if the {@link CSVFormat} supports comments.\n * </p>\n *\n * <p>The printer also supports appending a complete record at once by calling {@link #printRecord(Object...)}\n * or {@link #printRecord(Iterable)}.\n * Furthermore {@link #printRecords(Object...)}, {@link #printRecords(Iterable)} and {@link #printRecords(ResultSet)}\n * methods can be used to print several records at once.\n * </p>\n *\n * <p>Example:</p>\n *\n * <pre>\n * try (CSVPrinter printer = new CSVPrinter(new FileWriter(\"csv.txt\"), CSVFormat.EXCEL)) {\n *     printer.printRecord(\"id\", \"userName\", \"firstName\", \"lastName\", \"birthday\");\n *     printer.printRecord(1, \"john73\", \"John\", \"Doe\", LocalDate.of(1973, 9, 15));\n *     printer.println();\n *     printer.printRecord(2, \"mary\", \"Mary\", \"Meyer\", LocalDate.of(1985, 3, 29));\n * } catch (IOException ex) {\n *     ex.printStackTrace();\n * }\n * </pre>\n *\n * <p>This code will write the following to csv.txt:</p>\n * <pre>\n * id,userName,firstName,lastName,birthday\n * 1,john73,John,Doe,1973-09-15\n *\n * 2,mary,Mary,Meyer,1985-03-29\n * </pre>\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n\n    /** The place that the values get written. */\n    private final Appendable out;\n    private final CSVFormat format;\n\n    /** True if we just began a new record. */\n    private boolean newRecord = true;\n\n    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     *\n     * @param out\n     *            stream to which to print. Must not be null.\n     * @param format\n     *            the CSV format. Must not be null.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *             thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(out, \"out\");\n        Objects.requireNonNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n        // It seems a pain to have to track whether the header has already been printed or not.\n        if (format.getHeaderComments() != null) {\n            for (final String line : format.getHeaderComments()) {\n                if (line != null) {\n                    this.printComment(line);\n                }\n            }\n        }\n        if (format.getHeader() != null && !format.getSkipHeaderRecord()) {\n            this.printRecord((Object[]) format.getHeader());\n        }\n    }\n\n    // ======================================================\n    // printing implementation\n    // ======================================================\n\n    @Override\n    public void close() throws IOException {\n        close(false);\n    }\n\n    /**\n     * Closes the underlying stream with an optional flush first.\n     * @param flush whether to flush before the actual close.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.6\n     */\n    public void close(final boolean flush) throws IOException {\n        if (flush || format.getAutoFlush()) {\n            flush();\n        }\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    /**\n     * Gets the target Appendable.\n     *\n     * @return the target Appendable.\n     */\n    public Appendable getOut() {\n        return this.out;\n    }\n\n    /**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void print(final Object value) throws IOException {\n        format.print(value, out, newRecord);\n        newRecord = false;\n    }\n\n    /**\n     * Prints a comment on a new line among the delimiter separated values.\n     *\n     * <p>\n     * Comments will always begin on a new line and occupy at least one full line. The character specified to start\n     * comments and a space will be inserted at the beginning of each new line in the comment.\n     * </p>\n     *\n     * <p>\n     * If comments are disabled in the current CSV format this method does nothing.\n     * </p>\n     *\n     * <p>This method detects line breaks inside the comment string and inserts {@link CSVFormat#getRecordSeparator()}\n     * to start a new line of the comment. Note that this might produce unexpected results for formats that do not use\n     * line breaks as record separator.</p>\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentMarkerSet()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentMarker().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                //$FALL-THROUGH$ break intentionally excluded.\n            case LF:\n                println();\n                out.append(format.getCommentMarker().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    /**\n     * Prints headers for a result set based on its metadata.\n     *\n     * @param resultSet The result set to query for metadata.\n     * @throws IOException If an I/O error occurs.\n     * @throws SQLException If a database access error occurs or this method is called on a closed result set.\n     * @since 1.9.0\n     */\n    public void printHeaders(final ResultSet resultSet) throws IOException, SQLException {\n        printRecord((Object[]) format.builder().setHeader(resultSet).build().getHeader());\n    }\n\n    /**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException {\n        format.println(out);\n        newRecord = true;\n    }\n\n    /**\n     * Prints the given values a single record of delimiter separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints the given values a single record of delimiter separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException {\n        format.printRecord(out, values);\n        newRecord = true;\n    }\n\n    /**\n     * Prints all the objects in the given collection handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given collection only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Iterable)}. If the given collections contains nested collections/arrays those nested elements\n     * will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * List&lt;String[]&gt; data = ...\n     * data.add(new String[]{ \"A\", \"B\", \"C\" });\n     * data.add(new String[]{ \"1\", \"2\", \"3\" });\n     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\n     * </code>\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * </code>\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given array handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given array only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Object...)}. If the given collections contains nested collections/arrays those nested\n     * elements will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * String[][] data = new String[3][]\n     * data[0] = String[]{ \"A\", \"B\", \"C\" };\n     * data[1] = new String[]{ \"1\", \"2\", \"3\" };\n     * data[2] = new String[]{ \"A1\", \"B2\", \"C3\" };\n     * </code>\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * </code>\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Object... values) throws IOException {\n        printRecords(Arrays.asList(values));\n    }\n\n    /**\n     * Prints all the objects in the given JDBC result set.\n     *\n     * @param resultSet\n     *            result set the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                final Object object = resultSet.getObject(i);\n                // TODO Who manages the Clob? The JDBC driver or must we close it? Is it driver-dependent?\n                print(object instanceof Clob ? ((Clob) object).getCharacterStream() : object);\n            }\n            println();\n        }\n    }\n\n    /**\n     * Prints all the objects with metadata in the given JDBC result set based on the header boolean.\n     *\n     * @param resultSet source of row data.\n     * @param printHeader whether to print headers.\n     * @throws IOException If an I/O error occurs\n     * @throws SQLException if a database access error occurs\n     * @since 1.9.0\n     */\n    public void printRecords(final ResultSet resultSet, final boolean printHeader) throws SQLException, IOException {\n        if (printHeader) {\n            printHeaders(resultSet);\n        }\n        printRecords(resultSet);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVPrinter.java b/src/main/java/org/apache/commons/csv/CSVPrinter.java\nindex effb4c1c5..830961e2b 100644\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n@@ -281,8 +281,7 @@ public void printRecord(final Iterable<?> values) throws IOException {\n      *             If an I/O error occurs\n      */\n     public void printRecord(final Object... values) throws IOException {\n-        format.printRecord(out, values);\n-        newRecord = true;\n+        printRecord(Arrays.asList(values));\n     }\n \n     /**\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/issues/JiraCsv271Test.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 127,
    "title": "Minor Improvements",
    "state": "closed",
    "created_at": "2020-12-18T06:53:29Z",
    "merge_commit_sha": "d580c90f73e17aca94204d03c7a472807205997d",
    "base_sha": "8e953c0c17a2fd251e30f6c2673da64e18181e7b",
    "head_sha": "16827955cc02d2d2adf6e12689af2c865c5ce895",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.Reader;\nimport java.io.StringWriter;\nimport java.io.Writer;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testPrintWithQuotesNoEndVariable() throws IOException {\n        CSVFormat format = CSVFormat.DEFAULT.withQuote('\"').withDelimiter(',');\n        StringWriter out = new StringWriter();\n        format.print(\"value\", out, true);\n        assertEquals(\"\\\"value\\\"\", out.toString());\n    }\n\n    @Test\n    public void testPrintWithQuotesWhileLoopChange() throws IOException {\n        CSVFormat format = CSVFormat.DEFAULT.withQuote('\"').withDelimiter(',');\n        StringWriter out = new StringWriter();\n        format.print(\"value,with,commas\", out, true);\n        assertEquals(\"\\\"value,with,commas\\\"\", out.toString());\n    }\n\n    @Test\n    public void testPrintWithQuotesPosChange() throws IOException {\n        CSVFormat format = CSVFormat.DEFAULT.withQuote('\"').withDelimiter(',');\n        StringWriter out = new StringWriter();\n        format.print(\"value ends with space \", out, true);\n        assertEquals(\"\\\"value ends with space \\\"\", out.toString());\n    }\n\n    @Test\n    public void testPrintWithQuotesAppendChange() throws IOException {\n        CSVFormat format = CSVFormat.DEFAULT.withQuote('\"').withDelimiter(',');\n        StringWriter out = new StringWriter();\n        format.print(\"value with \\\"quote\\\"\", out, true);\n        assertEquals(\"\\\"value with \\\"\\\"quote\\\"\\\"\\\"\", out.toString());\n    }\n\n    @Test\n    public void testPrintWithQuotesReader() throws IOException {\n        CSVFormat format = CSVFormat.DEFAULT.withQuote('\"').withDelimiter(',');\n        Reader in = new StringReader(\"value with \\\"quote\\\"\");\n        StringWriter out = new StringWriter();\n        format.print(in, out, true);\n        assertEquals(\"\\\"value with \\\"\\\"quote\\\"\\\"\\\"\", out.toString());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #INFORMIX_UNLOAD}</li>\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #ORACLE}</li>\n * <li>{@link #POSTGRESQL_CSV}</li>\n * <li>{@link #POSTGRESQL_TEXT}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_CSV\n         * @since 1.7\n         */\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_TSV\n         * @since 1.7\n         */\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#ORACLE\n         */\n        Oracle(CSVFormat.ORACLE),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(true)}</li>\n     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false, true);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withAllowMissingColumnNames(true)}</li>\n     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: This is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)} and {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with\n     * {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *      documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a tab-delimited format. Values are double quoted only if needed and special\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *          documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_TSV = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote(null)}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default Oracle format used by the SQL*Loader utility.\n     *\n     * <p>\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\n     * {@code \"\"}. Values are trimmed.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withTrim()}</li>\n     * <li>{@code withSystemRecordSeparator()}</li>\n     * <li>{@code withQuoteMode(QuoteMode.MINIMAL)}</li>\n     * </ul>\n     *\n     * @see Predefined#Oracle\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\n     * @since 1.6\n     */\n    // @formatter:off\n    public static final CSVFormat ORACLE = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withNullString(\"\\\\N\")\n            .withTrim()\n            .withSystemRecordSeparator()\n            .withQuoteMode(QuoteMode.MINIMAL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreSurroundingSpaces(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if {@code c} is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if {@code c} is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false, false, true);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowDuplicateHeaderNames;\n\n    private final boolean allowMissingColumnNames;\n\n    private final boolean autoFlush;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final String quotedNullString;\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter, final boolean autoFlush, final boolean allowDuplicateHeaderNames) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n        this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (trailingDelimiter != other.trailingDelimiter) {\n            return false;\n        }\n        if (autoFlush != other.autoFlush) {\n            return false;\n        }\n        if (trim != other.trim) {\n            return false;\n        }\n        if (allowMissingColumnNames != other.allowMissingColumnNames) {\n            return false;\n        }\n        if (allowDuplicateHeaderNames != other.allowDuplicateHeaderNames) {\n            return false;\n        }\n        if (ignoreHeaderCase != other.ignoreHeaderCase) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (!Objects.equals(quoteCharacter, other.quoteCharacter)) {\n            return false;\n        }\n        if (!Objects.equals(commentMarker, other.commentMarker)) {\n            return false;\n        }\n        if (!Objects.equals(escapeCharacter, other.escapeCharacter)) {\n            return false;\n        }\n        if (!Objects.equals(nullString, other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (!Objects.equals(recordSeparator, other.recordSeparator)) {\n            return false;\n        }\n        if (!Arrays.equals(headerComments, other.headerComments)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            final String res = out.toString();\n            final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\n            return res.substring(0, len);\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns true if and only if duplicate names are allowed in the headers.\n     *\n     * @return whether duplicate header names are allowed\n     * @since 1.7\n     */\n    public boolean getAllowDuplicateHeaderNames() {\n        return allowDuplicateHeaderNames;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     * This is used by {@link #print(Object, Appendable, boolean)}\n     * Also by {CSVParser#addRecordValue(boolean)}\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(delimiter, quoteMode, quoteCharacter, commentMarker, escapeCharacter, nullString,\n            ignoreSurroundingSpaces, ignoreHeaderCase, ignoreEmptyLines, skipHeaderRecord, allowDuplicateHeaderNames,\n            trim, autoFlush, trailingDelimiter, allowMissingColumnNames, recordSeparator, Arrays.hashCode(header),\n            Arrays.hashCode(headerComments));\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     * Trims the value if {@link #getTrim()} is true\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quotedNullString;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        } else {\n            if (value instanceof CharSequence) {\n                charSequence = (CharSequence) value;\n            } else if (value instanceof Reader) {\n                print((Reader) value, out, newRecord);\n                return;\n            } else {\n                charSequence = value.toString();\n            }\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        print(value, charSequence, out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord)\n            throws IOException {\n        final int offset = 0;\n        final int len = value.length();\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printWithQuotes(object, value, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(value, out);\n        } else {\n            out.append(value, offset, len);\n        }\n    }\n\n    /**\n     * Prints to the specified output, returns a {@code CSVPrinter} which the caller MUST close.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out the output.\n     * @param charset A charset.\n     * @return a printer to an output.\n     * @throws IOException thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n        // Reader is never null\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (isQuoteCharacterSet()) {\n            printWithQuotes(reader, out);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(reader, out);\n        } else if (out instanceof Writer) {\n            IOUtils.copyLarge(reader, (Writer) out);\n        } else {\n            IOUtils.copy(reader, out);\n        }\n\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printWithEscapes(final CharSequence value, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n        final int end = value.length();\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    private void printWithEscapes(final Reader reader, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(builder.substring(start, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append((char) c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(builder.substring(start, pos));\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printWithQuotes(final Object object, final CharSequence value, final Appendable out,\n            final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        // If escape char not specified, default to the quote char\n        // This avoids having to keep checking whether there is an escape character\n        // at the cost of checking against quote twice\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(value, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar || c == escapeChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar || c == escapeChar) {\n                // write out the chunk up until this point\n                out.append(value, start, pos);\n                out.append(escapeChar); // now output the escape\n                start = pos; // and restart with the matched char\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\n     *\n     * @throws IOException\n     */\n    private void printWithQuotes(final Reader reader, final Appendable out) throws IOException {\n\n        if (getQuoteMode() == QuoteMode.NONE) {\n            printWithEscapes(reader, out);\n            return;\n        }\n\n        int pos = 0;\n\n        final char quote = getQuoteCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        out.append(quote);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == quote) {\n                // write out segment up until this char\n                if (pos > 0) {\n                    out.append(builder.substring(0, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n\n                out.append(quote);\n                out.append((char) c);\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > 0) {\n            out.append(builder.substring(0, pos));\n        }\n\n        out.append(quote);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (quoteMode != null) {\n            sb.append(' ');\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the validity and consistency of the attributes, and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null && !allowDuplicateHeaderNames) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} that allows duplicate header names.\n     *\n     * @return a new {@code CSVFormat} that allows duplicate header names\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames() {\n        return withAllowDuplicateHeaderNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     *\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces,\n     *        {@code false} to leave the spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line\n     * separator string, typically CR+LF on Windows and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     */\n    public CSVFormat withSystemRecordSeparator() {\n        return withRecordSeparator(System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex cd621bb92..9cfd6b8cf 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1402,7 +1402,6 @@ private void printWithQuotes(final Object object, final CharSequence value, fina\n         int start = 0;\n         int pos = 0;\n         final int len = value.length();\n-        final int end = len;\n \n         final char delimChar = getDelimiter();\n         final char quoteChar = getQuoteCharacter().charValue();\n@@ -1445,7 +1444,7 @@ private void printWithQuotes(final Object object, final CharSequence value, fina\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n-                    while (pos < end) {\n+                    while (pos < len) {\n                         c = value.charAt(pos);\n                         if (c == LF || c == CR || c == quoteChar || c == delimChar || c == escapeChar) {\n                             quote = true;\n@@ -1455,7 +1454,7 @@ private void printWithQuotes(final Object object, final CharSequence value, fina\n                     }\n \n                     if (!quote) {\n-                        pos = end - 1;\n+                        pos = len - 1;\n                         c = value.charAt(pos);\n                         // Some other chars at the end caused the parser to fail, so for now\n                         // encapsulate if we end in anything less than ' '\n@@ -1468,7 +1467,7 @@ private void printWithQuotes(final Object object, final CharSequence value, fina\n \n             if (!quote) {\n                 // no encapsulation needed - write out the original value\n-                out.append(value, start, end);\n+                out.append(value, start, len);\n                 return;\n             }\n             break;\n@@ -1478,7 +1477,7 @@ private void printWithQuotes(final Object object, final CharSequence value, fina\n \n         if (!quote) {\n             // no encapsulation needed - write out the original value\n-            out.append(value, start, end);\n+            out.append(value, start, len);\n             return;\n         }\n \n@@ -1487,7 +1486,7 @@ private void printWithQuotes(final Object object, final CharSequence value, fina\n \n         // Pick up where we left off: pos should be positioned on the first character that caused\n         // the need for encapsulation.\n-        while (pos < end) {\n+        while (pos < len) {\n             final char c = value.charAt(pos);\n             if (c == quoteChar || c == escapeChar) {\n                 // write out the chunk up until this point\n@@ -1507,6 +1506,7 @@ private void printWithQuotes(final Object object, final CharSequence value, fina\n      * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\n      *\n      * @throws IOException\n+     *             If an I/O error occurs\n      */\n     private void printWithQuotes(final Reader reader, final Appendable out) throws IOException {\n \n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVBenchmark.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVFileParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 126,
    "title": "[CSV-267] Minor improvements",
    "state": "closed",
    "created_at": "2020-12-12T07:57:56Z",
    "merge_commit_sha": "64bae1731766dfba45eec76b26e4af837b24effa",
    "base_sha": "e5fbba3eb326bf6443167df90f32560e66fa102a",
    "head_sha": "5c7a6f28c41452b694e5524ebb3ad88d1d8a8095",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.CSVFormat.RFC4180;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testPrintWithEscapesEndWithCRLF() throws IOException {\n        final Reader in = new StringReader(\"x,y,x\\r\\na,?b,c\\r\\n\");\n        final Appendable out = new StringBuilder();\n        final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\n        format.print(in, out, true);\n        assertEquals(\"x?,y?,x?r?na?,??b?,c?r?n\", out.toString());\n    }\n\n    @Test\n    public void testPrintWithEscapesEndWithoutCRLF() throws IOException {\n        final Reader in = new StringReader(\"x,y,x\");\n        final Appendable out = new StringBuilder();\n        final CSVFormat format = CSVFormat.RFC4180.withEscape('?').withDelimiter(',').withQuote(null).withRecordSeparator(CRLF);\n        format.print(in, out, true);\n        assertEquals(\"x?,y?,x\", out.toString());\n    }\n\n    @Test\n    public void testDelimiterSameAsRecordSeparatorThrowsException() {\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat(CR));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #INFORMIX_UNLOAD}</li>\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #ORACLE}</li>\n * <li>{@link #POSTGRESQL_CSV}</li>\n * <li>{@link #POSTGRESQL_TEXT}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_CSV\n         * @since 1.7\n         */\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_TSV\n         * @since 1.7\n         */\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#ORACLE\n         */\n        Oracle(CSVFormat.ORACLE),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(true)}</li>\n     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false, true);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withAllowMissingColumnNames(true)}</li>\n     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: This is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)} and {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with\n     * {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *      documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a tab-delimited format. Values are double quoted only if needed and special\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *          documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_TSV = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote(null)}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default Oracle format used by the SQL*Loader utility.\n     *\n     * <p>\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\n     * {@code \"\"}. Values are trimmed.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withTrim()}</li>\n     * <li>{@code withSystemRecordSeparator()}</li>\n     * <li>{@code withQuoteMode(QuoteMode.MINIMAL)}</li>\n     * </ul>\n     *\n     * @see Predefined#Oracle\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\n     * @since 1.6\n     */\n    // @formatter:off\n    public static final CSVFormat ORACLE = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withNullString(\"\\\\N\")\n            .withTrim()\n            .withSystemRecordSeparator()\n            .withQuoteMode(QuoteMode.MINIMAL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreSurroundingSpaces(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if {@code c} is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if {@code c} is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false, false, true);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowDuplicateHeaderNames;\n\n    private final boolean allowMissingColumnNames;\n\n    private final boolean autoFlush;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final String quotedNullString;\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter, final boolean autoFlush, final boolean allowDuplicateHeaderNames) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n        this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (trailingDelimiter != other.trailingDelimiter) {\n            return false;\n        }\n        if (autoFlush != other.autoFlush) {\n            return false;\n        }\n        if (trim != other.trim) {\n            return false;\n        }\n        if (allowMissingColumnNames != other.allowMissingColumnNames) {\n            return false;\n        }\n        if (allowDuplicateHeaderNames != other.allowDuplicateHeaderNames) {\n            return false;\n        }\n        if (ignoreHeaderCase != other.ignoreHeaderCase) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (!Objects.equals(quoteCharacter, other.quoteCharacter)) {\n            return false;\n        }\n        if (!Objects.equals(commentMarker, other.commentMarker)) {\n            return false;\n        }\n        if (!Objects.equals(escapeCharacter, other.escapeCharacter)) {\n            return false;\n        }\n        if (!Objects.equals(nullString, other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (!Objects.equals(recordSeparator, other.recordSeparator)) {\n            return false;\n        }\n        if (!Arrays.equals(headerComments, other.headerComments)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            final String res = out.toString();\n            final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\n            return res.substring(0, len);\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns true if and only if duplicate names are allowed in the headers.\n     *\n     * @return whether duplicate header names are allowed\n     * @since 1.7\n     */\n    public boolean getAllowDuplicateHeaderNames() {\n        return allowDuplicateHeaderNames;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     * This is used by {@link #print(Object, Appendable, boolean)}\n     * Also by {@link CSVParser#addRecordValue(boolean)}\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(delimiter, quoteMode, quoteCharacter, commentMarker, escapeCharacter, nullString,\n            ignoreSurroundingSpaces, ignoreHeaderCase, ignoreEmptyLines, skipHeaderRecord, allowDuplicateHeaderNames,\n            trim, autoFlush, trailingDelimiter, allowMissingColumnNames, recordSeparator, Arrays.hashCode(header),\n            Arrays.hashCode(headerComments));\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     * Trims the value if {@link #getTrim()} is true\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quotedNullString;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        } else {\n            if (value instanceof CharSequence) {\n                charSequence = (CharSequence) value;\n            } else if (value instanceof Reader) {\n                print((Reader) value, out, newRecord);\n                return;\n            } else {\n                charSequence = value.toString();\n            }\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        print(value, charSequence, out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord)\n            throws IOException {\n        final int offset = 0;\n        final int len = value.length();\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printWithQuotes(object, value, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(value, out);\n        } else {\n            out.append(value, offset, len);\n        }\n    }\n\n    /**\n     * Prints to the specified output, returns a {@code CSVPrinter} which the caller MUST close.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out the output.\n     * @param charset A charset.\n     * @return a printer to an output.\n     * @throws IOException thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n        // Reader is never null\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (isQuoteCharacterSet()) {\n            printWithQuotes(reader, out);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(reader, out);\n        } else if (out instanceof Writer) {\n            IOUtils.copyLarge(reader, (Writer) out);\n        } else {\n            IOUtils.copy(reader, out);\n        }\n\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printWithEscapes(final CharSequence value, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    private void printWithEscapes(final Reader reader, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(builder.substring(start, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append((char) c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(builder.substring(start, pos));\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printWithQuotes(final Object object, final CharSequence value, final Appendable out,\n            final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        // If escape char not specified, default to the quote char\n        // This avoids having to keep checking whether there is an escape character\n        // at the cost of checking against quote twice\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(value, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar || c == escapeChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar || c == escapeChar) {\n                // write out the chunk up until this point\n                out.append(value, start, pos);\n                out.append(escapeChar); // now output the escape\n                start = pos; // and restart with the matched char\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\n     *\n     * @throws IOException\n     */\n    private void printWithQuotes(final Reader reader, final Appendable out) throws IOException {\n\n        if (getQuoteMode() == QuoteMode.NONE) {\n            printWithEscapes(reader, out);\n            return;\n        }\n\n        int pos = 0;\n\n        final char quote = getQuoteCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        out.append(quote);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == quote) {\n                // write out segment up until this char\n                if (pos > 0) {\n                    out.append(builder.substring(0, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n\n                out.append(quote);\n                out.append((char) c);\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > 0) {\n            out.append(builder.substring(0, pos));\n        }\n\n        out.append(quote);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (quoteMode != null) {\n            sb.append(' ');\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null && !allowDuplicateHeaderNames) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} that allows duplicate header names.\n     *\n     * @return a new {@code CSVFormat} that allows duplicate header names\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames() {\n        return withAllowDuplicateHeaderNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     *\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces,\n     *        {@code false} to leave the spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line\n     * separator string, typically CR+LF on Windows and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     */\n    public CSVFormat withSystemRecordSeparator() {\n        return withRecordSeparator(System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex de0fd031a..652b4b9e8 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1051,7 +1051,7 @@ public boolean getTrailingDelimiter() {\n     /**\n      * Returns whether to trim leading and trailing blanks.\n      * This is used by {@link #print(Object, Appendable, boolean)}\n-     * Also by {@link CSVParser#addRecordValue(boolean)}\n+     * Also by {CSVParser#addRecordValue(boolean)}\n      *\n      * @return whether to trim leading and trailing blanks.\n      */\n@@ -1322,8 +1322,7 @@ public void printRecord(final Appendable out, final Object... values) throws IOE\n     private void printWithEscapes(final CharSequence value, final Appendable out) throws IOException {\n         int start = 0;\n         int pos = 0;\n-        final int len = value.length();\n-        final int end = len;\n+        final int end = value.length();\n \n         final char delim = getDelimiter();\n         final char escape = getEscapeCharacter().charValue();\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVRecordTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/PerformanceTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/Utils.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/issues/JiraCsv198Test.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/issues/JiraCsv248Test.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/issues/JiraCsv249Test.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/resources/org/apache/commons/csv/CSVPrinter.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 120,
    "title": "[CSV-265] Update buffer position when reading line comment",
    "state": "closed",
    "created_at": "2020-10-28T14:23:54Z",
    "merge_commit_sha": "a4c6037d0ccfc5b7176d6c522fcc0ab38b9bdd28",
    "base_sha": "27843d8dc0ec6e5af910674bfb4cba4e48b2475b",
    "head_sha": "69d3de8e20e06553ec7df75732d8b483c0beba41",
    "user_login": "king-tyler",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport java.io.StringReader;\nimport org.junit.jupiter.api.Test;\n\npublic class ExtendedBufferedReaderTest2 {\n\n    private ExtendedBufferedReader createBufferedReader(final String s) {\n        return new ExtendedBufferedReader(new StringReader(s));\n    }\n\n    @Test\n    public void testReadLineWithCRLF() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"foo\\r\\nbar\\r\\nbaz\")) {\n            assertEquals(\"foo\", br.readLine());\n            assertEquals(\"bar\", br.readLine());\n            assertEquals(\"baz\", br.readLine());\n            assertNull(br.readLine());\n        }\n    }\n\n    @Test\n    public void testReadLineWithCR() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"foo\\rbar\\rbaz\")) {\n            assertEquals(\"foo\", br.readLine());\n            assertEquals(\"bar\", br.readLine());\n            assertEquals(\"baz\", br.readLine());\n            assertNull(br.readLine());\n        }\n    }\n\n    @Test\n    public void testReadLineWithMixedEOL() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"foo\\rbar\\nbaz\\r\\nqux\")) {\n            assertEquals(\"foo\", br.readLine());\n            assertEquals(\"bar\", br.readLine());\n            assertEquals(\"baz\", br.readLine());\n            assertEquals(\"qux\", br.readLine());\n            assertNull(br.readLine());\n        }\n    }\n\n    @Test\n    public void testReadLineWithOnlyCR() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"\\r\")) {\n            assertEquals(\"\", br.readLine());\n            assertNull(br.readLine());\n        }\n    }\n\n    @Test\n    public void testReadLineWithOnlyLF() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"\\n\")) {\n            assertEquals(\"\", br.readLine());\n            assertNull(br.readLine());\n        }\n    }\n\n    @Test\n    public void testReadLineWithOnlyCRLF() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"\\r\\n\")) {\n            assertEquals(\"\", br.readLine());\n            assertNull(br.readLine());\n        }\n    }\n\n    @Test\n    public void testReadLineWithEmptyString() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"\")) {\n            assertNull(br.readLine());\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * A special buffered reader which supports sophisticated read access.\n * <p>\n * In particular the reader supports a look-ahead option, which allows you to see the next char returned by\n * {@link #read()}. This reader also tracks how many characters have been read with {@link #getPosition()}.\n * </p>\n */\nfinal class ExtendedBufferedReader extends BufferedReader {\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The count of EOLs (CR/LF/CRLF) seen so far */\n    private long eolCounter;\n\n    /** The position, which is number of characters read so far */\n    private long position;\n\n    private boolean closed;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(final Reader reader) {\n        super(reader);\n    }\n\n    /**\n     * Closes the stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        // Set ivars before calling super close() in case close() throws an IOException.\n        closed = true;\n        lastChar = END_OF_STREAM;\n        super.close();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        // Check if we are at EOL or EOF or just starting\n        if (lastChar == CR || lastChar == LF || lastChar == UNDEFINED || lastChar == END_OF_STREAM) {\n            return eolCounter; // counter is accurate\n        }\n        return eolCounter + 1; // Allow for counter being incremented only at EOL\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n     * any of the read methods. This will not include a character read using the {@link #lookAhead()} method. If no\n     * character has been read then this will return {@link Constants#UNDEFINED}. If the end of the stream was reached\n     * on the last read then this will return {@link Constants#END_OF_STREAM}.\n     *\n     * @return the last character that was read\n     */\n    int getLastChar() {\n        return lastChar;\n    }\n\n    /**\n     * Gets the character position in the reader.\n     *\n     * @return the current position in the reader (counting characters, not bytes since this is a Reader)\n     */\n    long getPosition() {\n        return this.position;\n    }\n\n    public boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Returns the next character in the current reader without consuming it. So the next call to {@link #read()} will\n     * still return this value. Does not affect line number or last character.\n     *\n     * @return the next character\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    int lookAhead() throws IOException {\n        super.mark(1);\n        final int c = super.read();\n        super.reset();\n\n        return c;\n    }\n\n    /**\n     * Returns the next n characters in the current reader without consuming them. The next call to {@link #read()} will still return the next value. This\n     * doesn't affect line number or last character.\n     *\n     * @param n the number characters look ahead.\n     * @return the next n characters.\n     * @throws IOException If an I/O error occurs\n     */\n    char[] lookAhead(final int n) throws IOException {\n        final char[] buf = new char[n];\n        return lookAhead(buf);\n    }\n\n    /**\n     * Populates the buffer with the next {@code buf.length} characters in the\n     * current reader without consuming them. The next call to {@link #read()} will\n     * still return the next value. This doesn't affect line number or last\n     * character.\n     *\n     * @param buf the buffer to fill for the look ahead.\n     * @return the buffer itself\n     * @throws IOException If an I/O error occurs\n     */\n    char[] lookAhead(final char[] buf) throws IOException {\n        final int n = buf.length;\n        super.mark(n);\n        super.read(buf, 0, n);\n        super.reset();\n\n        return buf;\n    }\n\n    @Override\n    public int read() throws IOException {\n        final int current = super.read();\n        if (current == CR || current == LF && lastChar != CR ||\n            current == END_OF_STREAM && lastChar != CR && lastChar != LF && lastChar != END_OF_STREAM) {\n            eolCounter++;\n        }\n        lastChar = current;\n        position++;\n        return lastChar;\n    }\n\n    @Override\n    public int read(final char[] buf, final int offset, final int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n\n        final int len = super.read(buf, offset, length);\n\n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n                final char ch = buf[i];\n                if (ch == LF) {\n                    if (CR != (i > offset ? buf[i - 1] : lastChar)) {\n                        eolCounter++;\n                    }\n                } else if (ch == CR) {\n                    eolCounter++;\n                }\n            }\n\n            lastChar = buf[offset + len - 1];\n\n        } else if (len == -1) {\n            lastChar = END_OF_STREAM;\n        }\n\n        position += len;\n        return len;\n    }\n\n    /**\n     * Calls {@link BufferedReader#readLine()} which drops the line terminator(s). This method should only be called\n     * when processing a comment, otherwise information can be lost.\n     * <p>\n     * Increments {@link #eolCounter}.\n     * </p>\n     * <p>\n     * Sets {@link #lastChar} to {@link Constants#END_OF_STREAM} at EOF, otherwise to LF.\n     * </p>\n     *\n     * @return the line that was read, or null if reached EOF.\n     */\n    @Override\n    public String readLine() throws IOException {\n        final String line = super.readLine();\n\n        if (line != null) {\n            lastChar = LF; // needed for detecting start of line\n            eolCounter++;\n        } else {\n            lastChar = END_OF_STREAM;\n        }\n\n        return line;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\nindex 4b3fb4837..1067dd26d 100644\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n@@ -198,29 +198,37 @@ public int read(final char[] buf, final int offset, final int length) throws IOE\n     }\n \n     /**\n-     * Calls {@link BufferedReader#readLine()} which drops the line terminator(s). This method should only be called\n-     * when processing a comment, otherwise information can be lost.\n+     * Gets the next line, dropping the line terminator(s). This method should only be called when processing a\n+     * comment, otherwise information can be lost.\n      * <p>\n-     * Increments {@link #eolCounter}.\n+     * Increments {@link #eolCounter} and updates {@link #position}.\n      * </p>\n      * <p>\n-     * Sets {@link #lastChar} to {@link Constants#END_OF_STREAM} at EOF, otherwise to LF.\n+     * Sets {@link #lastChar} to {@link Constants#END_OF_STREAM} at EOF, otherwise the last EOL character.\n      * </p>\n      *\n      * @return the line that was read, or null if reached EOF.\n      */\n     @Override\n     public String readLine() throws IOException {\n-        final String line = super.readLine();\n-\n-        if (line != null) {\n-            lastChar = LF; // needed for detecting start of line\n-            eolCounter++;\n-        } else {\n-            lastChar = END_OF_STREAM;\n+        if (lookAhead() == END_OF_STREAM) {\n+            return null;\n         }\n-\n-        return line;\n+        final StringBuilder buffer = new StringBuilder();\n+        while (true) {\n+            final int current = read();\n+            if (current == CR) {\n+                final int next = lookAhead();\n+                if (next == LF) {\n+                    read();\n+                }\n+            }\n+            if (current == END_OF_STREAM || current == LF || current == CR) {\n+                break;\n+            }\n+            buffer.append((char) current);\n+        }\n+        return buffer.toString();\n     }\n \n }\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/issues/JiraCsv265Test.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 114,
    "title": "CSV-264: Added DuplicateHeaderMode for flexibility with header strictness.",
    "state": "closed",
    "created_at": "2020-10-02T20:44:51Z",
    "merge_commit_sha": "4fdfc59b1cb668cb110b074742a1e760819f719b",
    "base_sha": "e9e27fb2c59b5566d8355d146588ed6cf1747545",
    "head_sha": "511f2b49f5db1d60866f08664cc09f85427f2c81",
    "user_login": "SethFalco",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.CSVFormat.RFC4180;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.Objects;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testSetDuplicateHeaderMode() {\n        CSVFormat format = CSVFormat.DEFAULT.builder()\n            .setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)\n            .setHeader(\"A\", \"A\")\n            .build();\n        assertEquals(DuplicateHeaderMode.ALLOW_ALL, format.getDuplicateHeaderMode());\n        assertArrayEquals(new String[]{\"A\", \"A\"}, format.getHeader());\n\n        format = CSVFormat.DEFAULT.builder()\n            .setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY)\n            .setHeader(\"A\", \"A\")\n            .build();\n        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, format.getDuplicateHeaderMode());\n        assertArrayEquals(new String[]{\"A\", \"A\"}, format.getHeader());\n\n        assertThrows(IllegalArgumentException.class, () -> {\n            CSVFormat.DEFAULT.builder()\n                .setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW)\n                .setHeader(\"A\", \"A\")\n                .build();\n        });\n    }\n\n    @Test\n    public void testGetDuplicateHeaderMode() {\n        CSVFormat format = CSVFormat.DEFAULT.builder()\n            .setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)\n            .build();\n        assertEquals(DuplicateHeaderMode.ALLOW_ALL, format.getDuplicateHeaderMode());\n\n        format = CSVFormat.DEFAULT.builder()\n            .setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY)\n            .build();\n        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, format.getDuplicateHeaderMode());\n\n        format = CSVFormat.DEFAULT.builder()\n            .setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW)\n            .build();\n        assertEquals(DuplicateHeaderMode.DISALLOW, format.getDuplicateHeaderMode());\n    }\n\n    @Test\n    public void testDeprecatedSetAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.DEFAULT.builder()\n            .setAllowDuplicateHeaderNames(true)\n            .setHeader(\"A\", \"A\")\n            .build();\n        assertEquals(DuplicateHeaderMode.ALLOW_ALL, format.getDuplicateHeaderMode());\n        assertArrayEquals(new String[]{\"A\", \"A\"}, format.getHeader());\n\n        format = CSVFormat.DEFAULT.builder()\n            .setAllowDuplicateHeaderNames(false)\n            .setHeader(\"A\", \"A\")\n            .build();\n        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, format.getDuplicateHeaderMode());\n        assertArrayEquals(new String[]{\"A\", \"A\"}, format.getHeader());\n    }\n\n    @Test\n    public void testDeprecatedGetAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.DEFAULT.builder()\n            .setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)\n            .build();\n        assertTrue(format.getAllowDuplicateHeaderNames());\n\n        format = CSVFormat.DEFAULT.builder()\n            .setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY)\n            .build();\n        assertFalse(format.getAllowDuplicateHeaderNames());\n\n        format = CSVFormat.DEFAULT.builder()\n            .setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW)\n            .build();\n        assertFalse(format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testValidateDuplicateHeaderMode() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            CSVFormat.DEFAULT.builder()\n                .setDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW)\n                .setHeader(\"A\", \"A\")\n                .build();\n        });\n\n        CSVFormat format = CSVFormat.DEFAULT.builder()\n            .setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)\n            .setHeader(\"A\", \"A\")\n            .build();\n        assertArrayEquals(new String[]{\"A\", \"A\"}, format.getHeader());\n\n        format = CSVFormat.DEFAULT.builder()\n            .setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY)\n            .setHeader(\"A\", \"A\")\n            .build();\n        assertArrayEquals(new String[]{\"A\", \"A\"}, format.getHeader());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #INFORMIX_UNLOAD}</li>\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #ORACLE}</li>\n * <li>{@link #POSTGRESQL_CSV}</li>\n * <li>{@link #POSTGRESQL_TEXT}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code set} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link Builder#setHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and assumes that your CSV source does not\n * contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link Builder#setSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using {@link Builder#setHeader(String...)} with no\n * arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Builds CSVFormat instances.\n     *\n     * @since 1.9.0\n     */\n    public static class Builder {\n\n        /**\n         * Creates a new default builder.\n         *\n         * @return a copy of the builder\n         */\n        public static Builder create() {\n            return new Builder(CSVFormat.DEFAULT);\n        }\n\n        /**\n         * Creates a new builder for the given format.\n         *\n         * @param csvFormat the source format.\n         * @return a copy of the builder\n         */\n        public static Builder create(final CSVFormat csvFormat) {\n            return new Builder(csvFormat);\n        }\n\n        private boolean allowDuplicateHeaderNames;\n\n        private boolean allowMissingColumnNames;\n\n        private boolean autoFlush;\n\n        private Character commentMarker;\n\n        private String delimiter;\n\n        private Character escapeCharacter;\n\n        private String[] headerComments;\n\n        private String[] headers;\n\n        private boolean ignoreEmptyLines;\n\n        private boolean ignoreHeaderCase;\n\n        private boolean ignoreSurroundingSpaces;\n\n        private String nullString;\n\n        private Character quoteCharacter;\n\n        private String quotedNullString;\n\n        private QuoteMode quoteMode;\n\n        private String recordSeparator;\n\n        private boolean skipHeaderRecord;\n\n        private boolean trailingDelimiter;\n\n        private boolean trim;\n\n        private Builder(final CSVFormat csvFormat) {\n            this.delimiter = csvFormat.delimiter;\n            this.quoteCharacter = csvFormat.quoteCharacter;\n            this.quoteMode = csvFormat.quoteMode;\n            this.commentMarker = csvFormat.commentMarker;\n            this.escapeCharacter = csvFormat.escapeCharacter;\n            this.ignoreSurroundingSpaces = csvFormat.ignoreSurroundingSpaces;\n            this.allowMissingColumnNames = csvFormat.allowMissingColumnNames;\n            this.ignoreEmptyLines = csvFormat.ignoreEmptyLines;\n            this.recordSeparator = csvFormat.recordSeparator;\n            this.nullString = csvFormat.nullString;\n            this.headerComments = csvFormat.headerComments;\n            this.headers = csvFormat.header;\n            this.skipHeaderRecord = csvFormat.skipHeaderRecord;\n            this.ignoreHeaderCase = csvFormat.ignoreHeaderCase;\n            this.trailingDelimiter = csvFormat.trailingDelimiter;\n            this.trim = csvFormat.trim;\n            this.autoFlush = csvFormat.autoFlush;\n            this.quotedNullString = csvFormat.quotedNullString;\n            this.allowDuplicateHeaderNames = csvFormat.allowDuplicateHeaderNames;\n        }\n\n        /**\n         * Builds a new CSVFormat instance.\n         *\n         * @return a new CSVFormat instance.\n         */\n        public CSVFormat build() {\n            return new CSVFormat(this);\n        }\n\n        /**\n         * Sets the duplicate header names behavior, true to allow, false to disallow.\n         *\n         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n         * @return This instance.\n         */\n        public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n            this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n            return this;\n        }\n\n        /**\n         * Sets the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\n         * {@link IllegalArgumentException} to be thrown.\n         *\n         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\n         *                                cause an {@link IllegalArgumentException} to be thrown.\n         * @return This instance.\n         */\n        public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n            this.allowMissingColumnNames = allowMissingColumnNames;\n            return this;\n        }\n\n        /**\n         * Sets whether to flush on close.\n         *\n         * @param autoFlush whether to flush on close.\n         * @return This instance.\n         */\n        public Builder setAutoFlush(final boolean autoFlush) {\n            this.autoFlush = autoFlush;\n            return this;\n        }\n\n        /**\n         * Sets the comment start marker, use {@code null} to disable.\n         *\n         * Note that the comment start character is only recognized at the start of a line.\n         *\n         * @param commentMarker the comment start marker, use {@code null} to disable.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break\n         */\n        public Builder setCommentMarker(final char commentMarker) {\n            setCommentMarker(Character.valueOf(commentMarker));\n            return this;\n        }\n\n        /**\n         * Sets the comment start marker, use {@code null} to disable.\n         *\n         * Note that the comment start character is only recognized at the start of a line.\n         *\n         * @param commentMarker the comment start marker, use {@code null} to disable.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break\n         */\n        public Builder setCommentMarker(final Character commentMarker) {\n            if (isLineBreak(commentMarker)) {\n                throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n            }\n            this.commentMarker = commentMarker;\n            return this;\n        }\n\n        /**\n         * Sets the delimiter character.\n         *\n         * @param delimiter the delimiter character.\n         * @return This instance.\n         */\n        public Builder setDelimiter(final char delimiter) {\n            return setDelimiter(String.valueOf(delimiter));\n        }\n\n        /**\n         * Sets the delimiter character.\n         *\n         * @param delimiter the delimiter character.\n         * @return This instance.\n         */\n        public Builder setDelimiter(final String delimiter) {\n            if (containsLineBreak(delimiter)) {\n                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n            }\n            this.delimiter = delimiter;\n            return this;\n        }\n\n        /**\n         * Sets the escape character.\n         *\n         * @param escapeCharacter the escape character.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break\n         */\n        public Builder setEscape(final char escapeCharacter) {\n            setEscape(Character.valueOf(escapeCharacter));\n            return this;\n        }\n\n        /**\n         * Sets the escape character.\n         *\n         * @param escapeCharacter the escape character.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break\n         */\n        public Builder setEscape(final Character escapeCharacter) {\n            if (isLineBreak(escapeCharacter)) {\n                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n            }\n            this.escapeCharacter = escapeCharacter;\n            return this;\n        }\n\n        /**\n         * Sets the header defined by the given {@link Enum} class.\n         *\n         * <p>\n         * Example:\n         * </p>\n         *\n         * <pre>\n         * public enum HeaderEnum {\n         *     Name, Email, Phone\n         * }\n         *\n         * Builder builder = builder.setHeader(HeaderEnum.class);\n         * </pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         *\n         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n         * @return This instance.\n         */\n        public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {\n            String[] header = null;\n            if (headerEnum != null) {\n                final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n                header = new String[enumValues.length];\n                for (int i = 0; i < enumValues.length; i++) {\n                    header[i] = enumValues[i].name();\n                }\n            }\n            return setHeader(header);\n        }\n\n        /**\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\n         *\n         * <pre>\n         * builder.setHeader();\n         * </pre>\n         *\n         * or specified manually with:\n         *\n         * <pre>\n         * builder.setHeader(resultSet);\n         * </pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         *\n         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n         * @return This instance.\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\n         */\n        public Builder setHeader(final ResultSet resultSet) throws SQLException {\n            return setHeader(resultSet != null ? resultSet.getMetaData() : null);\n        }\n\n        /**\n         * Sets the header from the result set metadata. The header can either be parsed automatically from the input file with:\n         *\n         * <pre>\n         * builder.setHeader();\n         * </pre>\n         *\n         * or specified manually with:\n         *\n         * <pre>\n         * builder.setHeader(resultSetMetaData);\n         * </pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         *\n         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n         * @return This instance.\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\n         */\n        public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\n            String[] labels = null;\n            if (resultSetMetaData != null) {\n                final int columnCount = resultSetMetaData.getColumnCount();\n                labels = new String[columnCount];\n                for (int i = 0; i < columnCount; i++) {\n                    labels[i] = resultSetMetaData.getColumnLabel(i + 1);\n                }\n            }\n            return setHeader(labels);\n        }\n\n        /**\n         * Sets the header to the given values. The header can either be parsed automatically from the input file with:\n         *\n         * <pre>\n         * builder.setHeader();\n         * </pre>\n         *\n         * or specified manually with:\n         *\n         * <pre>\n         * builder.setHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n         * </pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         *\n         * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n         * @return This instance.\n         */\n        public Builder setHeader(final String... header) {\n            this.headers = CSVFormat.clone(header);\n            return this;\n        }\n\n        /**\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\n         *\n         * <pre>\n         * builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\n         * </pre>\n         *\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\n         * @return This instance.\n         */\n        public Builder setHeaderComments(final Object... headerComments) {\n            this.headerComments = CSVFormat.clone(toStringArray(headerComments));\n            return this;\n        }\n\n        /**\n         * Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\n         *\n         * <pre>\n         * Builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\n         * </pre>\n         *\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\n         * @return This instance.\n         */\n        public Builder setHeaderComments(final String... headerComments) {\n            this.headerComments = CSVFormat.clone(headerComments);\n            return this;\n        }\n\n        /**\n         * Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty\n         * records.\n         *\n         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate\n         *                         empty lines to empty records.\n         * @return This instance.\n         */\n        public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n            this.ignoreEmptyLines = ignoreEmptyLines;\n            return this;\n        }\n\n        /**\n         * Sets the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\n         *\n         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\n         * @return This instance.\n         */\n        public Builder setIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n            this.ignoreHeaderCase = ignoreHeaderCase;\n            return this;\n        }\n\n        /**\n         * Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\n         *\n         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\n         * @return This instance.\n         */\n        public Builder setIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n            return this;\n        }\n\n        /**\n         * Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.\n         *\n         * <ul>\n         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\n         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n         * </ul>\n         *\n         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.\n         * @return This instance.\n         */\n        public Builder setNullString(final String nullString) {\n            this.nullString = nullString;\n            this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n            return this;\n        }\n\n        /**\n         * Sets the quote character.\n         *\n         * @param quoteCharacter the quote character.\n         * @return This instance.\n         */\n        public Builder setQuote(final char quoteCharacter) {\n            setQuote(Character.valueOf(quoteCharacter));\n            return this;\n        }\n\n        /**\n         * Sets the quote character, use {@code null} to disable.\n         *\n         * @param quoteCharacter the quote character, use {@code null} to disable.\n         * @return This instance.\n         */\n        public Builder setQuote(final Character quoteCharacter) {\n            if (isLineBreak(quoteCharacter)) {\n                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n            }\n            this.quoteCharacter = quoteCharacter;\n            return this;\n        }\n\n        /**\n         * Sets the quote policy to use for output.\n         *\n         * @param quoteMode the quote policy to use for output.\n         * @return This instance.\n         */\n        public Builder setQuoteMode(final QuoteMode quoteMode) {\n            this.quoteMode = quoteMode;\n            return this;\n        }\n\n        /**\n         * Sets the record separator to use for output.\n         *\n         * <p>\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\n         * and \"\\r\\n\"\n         * </p>\n         *\n         * @param recordSeparator the record separator to use for output.\n         * @return This instance.\n         */\n        public Builder setRecordSeparator(final char recordSeparator) {\n            this.recordSeparator = String.valueOf(recordSeparator);\n            return this;\n        }\n\n        /**\n         * Sets the record separator to use for output.\n         *\n         * <p>\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\n         * and \"\\r\\n\"\n         * </p>\n         *\n         * @param recordSeparator the record separator to use for output.\n         * @return This instance.\n         */\n        public Builder setRecordSeparator(final String recordSeparator) {\n            this.recordSeparator = recordSeparator;\n            return this;\n        }\n\n        /**\n         * Sets whether to skip the header record.\n         *\n         * @param skipHeaderRecord whether to skip the header record.\n         * @return This instance.\n         */\n        public Builder setSkipHeaderRecord(final boolean skipHeaderRecord) {\n            this.skipHeaderRecord = skipHeaderRecord;\n            return this;\n        }\n\n        /**\n         * Sets whether to add a trailing delimiter.\n         *\n         * @param trailingDelimiter whether to add a trailing delimiter.\n         * @return This instance.\n         */\n        public Builder setTrailingDelimiter(final boolean trailingDelimiter) {\n            this.trailingDelimiter = trailingDelimiter;\n            return this;\n        }\n\n        /**\n         * Sets whether to trim leading and trailing blanks.\n         *\n         * @param trim whether to trim leading and trailing blanks.\n         * @return This instance.\n         */\n        public Builder setTrim(final boolean trim) {\n            this.trim = trim;\n            return this;\n        }\n    }\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_CSV\n         * @since 1.7\n         */\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_TSV\n         * @since 1.7\n         */\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#ORACLE\n         */\n        Oracle(CSVFormat.ORACLE),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter(',')}</li>\n     * <li>{@code setQuote('\"')}</li>\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code setIgnoreEmptyLines(true)}</li>\n     * <li>{@code setAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false,\n            false, false, false, true);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is locale dependent, it might be necessary\n     * to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter(',')}</li>\n     * <li>{@code setQuote('\"')}</li>\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\n     * <li>{@code setAllowMissingColumnNames(true)}</li>\n     * <li>{@code setAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: This is currently like {@link #RFC4180} plus {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)} and\n     * {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(false)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT.builder()\n            .setIgnoreEmptyLines(false)\n            .setAllowMissingColumnNames(true)\n            .build();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\n     * The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter(',')}</li>\n     * <li>{@code setEscape('\\\\')}</li>\n     * <li>{@code setQuote(\"\\\"\")}</li>\n     * <li>{@code setRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.builder()\n            .setDelimiter(PIPE)\n            .setEscape(BACKSLASH)\n            .setQuote(DOUBLE_QUOTE_CHAR)\n            .setRecordSeparator(LF)\n            .build();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special characters are escaped with {@code '\\'}.\n     * The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter(',')}</li>\n     * <li>{@code setQuote(\"\\\"\")}</li>\n     * <li>{@code setRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href= \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.builder()\n            .setDelimiter(COMMA)\n            .setQuote(DOUBLE_QUOTE_CHAR)\n            .setRecordSeparator(LF)\n            .build();\n    // @formatter:on\n\n    /**\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with {@code '\"'}. A header line with field\n     * names is expected.\n     * </p>\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter(',')}</li>\n     * <li>{@code setEscape('\"')}</li>\n     * <li>{@code setQuote('\"')}</li>\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code setSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_CSV = DEFAULT.builder()\n            .setDelimiter(COMMA)\n            .setEscape(DOUBLE_QUOTE_CHAR)\n            .setQuote(DOUBLE_QUOTE_CHAR)\n            .setQuoteMode(QuoteMode.MINIMAL)\n            .setSkipHeaderRecord(false)\n            .build();\n    // @formatter:off\n\n    /**\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a tab-delimited format. Values are double quoted only if needed and special\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter('\\t')}</li>\n     * <li>{@code setEscape('\"')}</li>\n     * <li>{@code setQuote('\"')}</li>\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code setSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *          documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_TSV = DEFAULT.builder()\n            .setDelimiter(TAB)\n            .setEscape(DOUBLE_QUOTE_CHAR)\n            .setQuote(DOUBLE_QUOTE_CHAR)\n            .setQuoteMode(QuoteMode.MINIMAL)\n            .setSkipHeaderRecord(false)\n            .build();\n    // @formatter:off\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter('\\t')}</li>\n     * <li>{@code setEscape('\\\\')}</li>\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\n     * <li>{@code setQuote(null)}</li>\n     * <li>{@code setRecordSeparator('\\n')}</li>\n     * <li>{@code setNullString(\"\\\\N\")}</li>\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT.builder()\n            .setDelimiter(TAB)\n            .setEscape(BACKSLASH)\n            .setIgnoreEmptyLines(false)\n            .setQuote(null)\n            .setRecordSeparator(LF)\n            .setNullString(\"\\\\N\")\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\n            .build();\n    // @formatter:off\n\n    /**\n     * Default Oracle format used by the SQL*Loader utility.\n     *\n     * <p>\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\n     * {@code \"\"}. Values are trimmed.\n     * </p>\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\n     * <li>{@code setEscape('\\\\')}</li>\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\n     * <li>{@code setQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\n     * <li>{@code setNullString(\"\\\\N\")}</li>\n     * <li>{@code setTrim()}</li>\n     * <li>{@code setSystemRecordSeparator()}</li>\n     * <li>{@code setQuoteMode(QuoteMode.MINIMAL)}</li>\n     * </ul>\n     *\n     * @see Predefined#Oracle\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\n     * @since 1.6\n     */\n    // @formatter:off\n    public static final CSVFormat ORACLE = DEFAULT.builder()\n            .setDelimiter(COMMA)\n            .setEscape(BACKSLASH)\n            .setIgnoreEmptyLines(false)\n            .setQuote(DOUBLE_QUOTE_CHAR)\n            .setNullString(\"\\\\N\")\n            .setTrim(true)\n            .setRecordSeparator(System.lineSeparator())\n            .setQuoteMode(QuoteMode.MINIMAL)\n            .build();\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter(',')}</li>\n     * <li>{@code setEscape('\"')}</li>\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\n     * <li>{@code setQuote('\"')}</li>\n     * <li>{@code setRecordSeparator('\\n')}</li>\n     * <li>{@code setNullString(\"\")}</li>\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder()\n            .setDelimiter(COMMA)\n            .setEscape(DOUBLE_QUOTE_CHAR)\n            .setIgnoreEmptyLines(false)\n            .setQuote(DOUBLE_QUOTE_CHAR)\n            .setRecordSeparator(LF)\n            .setNullString(EMPTY)\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\n            .build();\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter('\\t')}</li>\n     * <li>{@code setEscape('\\\\')}</li>\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\n     * <li>{@code setQuote('\"')}</li>\n     * <li>{@code setRecordSeparator('\\n')}</li>\n     * <li>{@code setNullString(\"\\\\N\")}</li>\n     * <li>{@code setQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT.builder()\n            .setDelimiter(TAB)\n            .setEscape(BACKSLASH)\n            .setIgnoreEmptyLines(false)\n            .setQuote(DOUBLE_QUOTE_CHAR)\n            .setRecordSeparator(LF)\n            .setNullString(\"\\\\N\")\n            .setQuoteMode(QuoteMode.ALL_NON_NULL)\n            .build();\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter(',')}</li>\n     * <li>{@code setQuote('\"')}</li>\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code setIgnoreEmptyLines(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.builder().setIgnoreEmptyLines(false).build();\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * The {@link Builder} settings are:\n     * </p>\n     * <ul>\n     * <li>{@code setDelimiter('\\t')}</li>\n     * <li>{@code setQuote('\"')}</li>\n     * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code setIgnoreSurroundingSpaces(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT.builder()\n            .setDelimiter(TAB)\n            .setIgnoreSurroundingSpaces(true)\n            .build();\n    // @formatter:on\n\n    /**\n     * Null-safe clone of an array.\n     *\n     * @param <T>    The array element type.\n     * @param values the source array\n     * @return the cloned array.\n     */\n    @SafeVarargs\n    static <T> T[] clone(final T... values) {\n        return values == null ? null : values.clone();\n    }\n\n    /**\n     * Returns true if the given string contains the search char.\n     *\n     * @param source the string to check.\n     * @param searchCh the character to search.\n     *\n     * @return true if {@code c} contains a line break character\n     */\n    private static boolean contains(final String source, final char searchCh) {\n        return Objects.requireNonNull(source, \"source\").indexOf(searchCh) >= 0;\n    }\n\n    /**\n     * Returns true if the given string contains a line break character.\n     *\n     * @param source the string to check.\n     *\n     * @return true if {@code c} contains a line break character.\n     */\n    private static boolean containsLineBreak(final String source) {\n        return contains(source, CR) || contains(source, LF);\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c the character to check.\n     *\n     * @return true if {@code c} is a line break character.\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c the character to check, may be null.\n     *\n     * @return true if {@code c} is a line break character (and not null).\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.\n     * </p>\n     *\n     * @param delimiter the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(String.valueOf(delimiter), null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false,\n                true);\n    }\n\n    static String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            strings[i] = Objects.toString(values[i], null);\n        }\n        return strings;\n    }\n\n    static CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowDuplicateHeaderNames;\n\n    private final boolean allowMissingColumnNames;\n\n    private final boolean autoFlush;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final String delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final String quotedNullString;\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    private CSVFormat(final Builder builder) {\n        this.delimiter = builder.delimiter;\n        this.quoteCharacter = builder.quoteCharacter;\n        this.quoteMode = builder.quoteMode;\n        this.commentMarker = builder.commentMarker;\n        this.escapeCharacter = builder.escapeCharacter;\n        this.ignoreSurroundingSpaces = builder.ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = builder.allowMissingColumnNames;\n        this.ignoreEmptyLines = builder.ignoreEmptyLines;\n        this.recordSeparator = builder.recordSeparator;\n        this.nullString = builder.nullString;\n        this.headerComments = builder.headerComments;\n        this.header = builder.headers;\n        this.skipHeaderRecord = builder.skipHeaderRecord;\n        this.ignoreHeaderCase = builder.ignoreHeaderCase;\n        this.trailingDelimiter = builder.trailingDelimiter;\n        this.trim = builder.trim;\n        this.autoFlush = builder.autoFlush;\n        this.quotedNullString = builder.quotedNullString;\n        this.allowDuplicateHeaderNames = builder.allowDuplicateHeaderNames;\n        validate();\n    }\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter               the char used for value separation, must not be a line break character.\n     * @param quoteChar               the Character used as value encapsulation marker, may be {@code null} to disable.\n     * @param quoteMode               the quote mode.\n     * @param commentStart            the Character used for comment identification, may be {@code null} to disable.\n     * @param escape                  the Character used to escape special characters in values, may be {@code null} to disable.\n     * @param ignoreSurroundingSpaces {@code true} when whitespaces enclosing values should be ignored.\n     * @param ignoreEmptyLines        {@code true} when the parser should skip empty lines.\n     * @param recordSeparator         the line separator to use for output.\n     * @param nullString              the line separator to use for output.\n     * @param headerComments          the comments to be printed by the Printer before the actual CSV data.\n     * @param header                  the header\n     * @param skipHeaderRecord        TODO Doc me.\n     * @param allowMissingColumnNames TODO Doc me.\n     * @param ignoreHeaderCase        TODO Doc me.\n     * @param trim                    TODO Doc me.\n     * @param trailingDelimiter       TODO Doc me.\n     * @param autoFlush               TODO Doc me.\n     * @param allowDuplicateHeaderNames TODO Doc me.\n     * @throws IllegalArgumentException if the delimiter is a line break character.\n     */\n    private CSVFormat(final String delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape,\n            final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames,\n            final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush,\n            final boolean allowDuplicateHeaderNames) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = clone(header);\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n        this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n        validate();\n    }\n\n    private void append(final char c, final Appendable appendable) throws IOException {\n        //try {\n            appendable.append(c);\n        //} catch (final IOException e) {\n        //    throw new UncheckedIOException(e);\n        //}\n    }\n\n    private void append(final CharSequence csq, final Appendable appendable) throws IOException {\n        //try {\n            appendable.append(csq);\n        //} catch (final IOException e) {\n        //    throw new UncheckedIOException(e);\n        //}\n    }\n\n    /**\n     * Creates a new Builder for this instance.\n     *\n     * @return a new Builder.\n     */\n    public Builder builder() {\n        return Builder.create(this);\n    }\n\n    /**\n     * Creates a copy of this instance.\n     *\n     * @return a copy of this instance.\n     */\n    CSVFormat copy() {\n        return builder().build();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        final CSVFormat other = (CSVFormat) obj;\n        return allowDuplicateHeaderNames == other.allowDuplicateHeaderNames && allowMissingColumnNames == other.allowMissingColumnNames &&\n                autoFlush == other.autoFlush && Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) &&\n                Objects.equals(escapeCharacter, other.escapeCharacter) && Arrays.equals(header, other.header) &&\n                Arrays.equals(headerComments, other.headerComments) && ignoreEmptyLines == other.ignoreEmptyLines &&\n                ignoreHeaderCase == other.ignoreHeaderCase && ignoreSurroundingSpaces == other.ignoreSurroundingSpaces &&\n                Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) && quoteMode == other.quoteMode &&\n                Objects.equals(quotedNullString, other.quotedNullString) && Objects.equals(recordSeparator, other.recordSeparator) &&\n                skipHeaderRecord == other.skipHeaderRecord && trailingDelimiter == other.trailingDelimiter && trim == other.trim;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            final String res = out.toString();\n            final int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\n            return res.substring(0, len);\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns true if and only if duplicate names are allowed in the headers.\n     *\n     * @return whether duplicate header names are allowed\n     * @since 1.7\n     */\n    public boolean getAllowDuplicateHeaderNames() {\n        return allowDuplicateHeaderNames;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the first character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the first delimiter character.\n     * @deprecated Use {@link #getDelimiterString()}.\n     */\n    @Deprecated\n    public char getDelimiter() {\n        return delimiter.charAt(0);\n    }\n\n    /**\n     * Returns the character delimiting the values (typically \";\", \",\" or \"\\t\").\n     *\n     * @return the delimiter.\n     */\n    public String getDelimiterString() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks. This is used by {@link #print(Object, Appendable, boolean)} Also by\n     * {CSVParser#addRecordValue(boolean)}\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + Arrays.hashCode(header);\n        result = prime * result + Arrays.hashCode(headerComments);\n        return prime * result + Objects.hash(allowDuplicateHeaderNames, allowMissingColumnNames, autoFlush, commentMarker, delimiter, escapeCharacter,\n                ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator,\n                skipHeaderRecord, trailingDelimiter, trim);\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Matches whether the next characters constitute a delimiter\n     *\n     * @param ch\n     *            the current char\n     * @param charSeq\n     *            the match char sequence\n     * @param startIndex\n     *            where start to match\n     * @param delimiter\n     *            the delimiter\n     * @param delimiterLength\n     *            the delimiter length\n     * @return true if the match is successful\n     */\n    private boolean isDelimiter(final char ch, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength) {\n        if (ch != delimiter[0]) {\n            return false;\n        }\n        final int len = charSeq.length();\n        if (startIndex + delimiterLength > len) {\n            return false;\n        }\n        for (int i = 1; i < delimiterLength; i++) {\n            if (charSeq.charAt(startIndex + i) != delimiter[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param reader the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException If an I/O error occurs\n     */\n    public CSVParser parse(final Reader reader) throws IOException {\n        return new CSVParser(reader, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out the output.\n     * @return a printer to an output.\n     * @throws IOException thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out     the output.\n     * @param charset A charset.\n     * @return a printer to an output.\n     * @throws IOException thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated as needed. Useful when one wants to\n     * avoid creating CSVPrinters. Trims the value if {@link #getTrim()} is true.\n     *\n     * @param value     value to output.\n     * @param out       where to print the value.\n     * @param newRecord if this a new record.\n     * @throws IOException If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else if (QuoteMode.ALL == quoteMode) {\n                charSequence = quotedNullString;\n            } else {\n                charSequence = nullString;\n            }\n        } else if (value instanceof CharSequence) {\n            charSequence = (CharSequence) value;\n        } else if (value instanceof Reader) {\n            print((Reader) value, out, newRecord);\n            return;\n        } else {\n            charSequence = value.toString();\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        print(value, charSequence, out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\n        final int offset = 0;\n        final int len = value.length();\n        if (!newRecord) {\n            out.append(getDelimiterString());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printWithQuotes(object, value, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(value, out);\n        } else {\n            out.append(value, offset, len);\n        }\n    }\n\n    /**\n     * Prints to the specified output, returns a {@code CSVPrinter} which the caller MUST close.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out     the output.\n     * @param charset A charset.\n     * @return a printer to an output.\n     * @throws IOException thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n        // Reader is never null\n        if (!newRecord) {\n            append(getDelimiterString(), out);\n        }\n        if (isQuoteCharacterSet()) {\n            printWithQuotes(reader, out);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(reader, out);\n        } else if (out instanceof Writer) {\n            IOUtils.copyLarge(reader, (Writer) out);\n        } else {\n            IOUtils.copy(reader, out);\n        }\n\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param appendable where to write\n     * @throws IOException If an I/O error occurs.\n     * @since 1.4\n     */\n    public void println(final Appendable appendable) throws IOException {\n        if (getTrailingDelimiter()) {\n            append(getDelimiterString(), appendable);\n        }\n        if (recordSeparator != null) {\n            append(recordSeparator, appendable);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing\n     * the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param appendable    where to write.\n     * @param values values to output.\n     * @throws IOException If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable appendable, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], appendable, i == 0);\n        }\n        println(appendable);\n    }\n\n    /*\n     * Note: Must only be called if escaping is enabled, otherwise will generate NPE.\n     */\n    private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException {\n        int start = 0;\n        int pos = 0;\n        final int end = charSeq.length();\n\n        final char[] delim = getDelimiterString().toCharArray();\n        final int delimLength = delim.length;\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = charSeq.charAt(pos);\n            final boolean isDelimiterStart = isDelimiter(c, charSeq, pos, delim, delimLength);\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\n                // write out segment up until this char\n                if (pos > start) {\n                    appendable.append(charSeq, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                appendable.append(escape);\n                appendable.append(c);\n\n                if (isDelimiterStart) {\n                    for (int i = 1; i < delimLength; i++) {\n                        pos++;\n                        c = charSeq.charAt(pos);\n                        appendable.append(escape);\n                        appendable.append(c);\n                    }\n                }\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            appendable.append(charSeq, start, pos);\n        }\n    }\n\n    private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {\n        int start = 0;\n        int pos = 0;\n\n        @SuppressWarnings(\"resource\") // Temp reader on input reader.\n        final ExtendedBufferedReader bufferedReader = new ExtendedBufferedReader(reader);\n        final char[] delim = getDelimiterString().toCharArray();\n        final int delimLength = delim.length;\n        final char escape = getEscapeCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        int c;\n        while (-1 != (c = bufferedReader.read())) {\n            builder.append((char) c);\n            final boolean isDelimiterStart = isDelimiter((char) c, builder.toString() + new String(bufferedReader.lookAhead(delimLength - 1)), pos, delim,\n                    delimLength);\n            if (c == CR || c == LF || c == escape || isDelimiterStart) {\n                // write out segment up until this char\n                if (pos > start) {\n                    append(builder.substring(start, pos), appendable);\n                    builder.setLength(0);\n                    pos = -1;\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                append(escape, appendable);\n                append((char) c, appendable);\n\n                if (isDelimiterStart) {\n                    for (int i = 1; i < delimLength; i++) {\n                        c = bufferedReader.read();\n                        append(escape, appendable);\n                        append((char) c, appendable);\n                    }\n                }\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            append(builder.substring(start, pos), appendable);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = 0;\n        int pos = 0;\n        final int len = charSeq.length();\n\n        final char[] delim = getDelimiterString().toCharArray();\n        final int delimLength = delim.length;\n        final char quoteChar = getQuoteCharacter().charValue();\n        // If escape char not specified, default to the quote char\n        // This avoids having to keep checking whether there is an escape character\n        // at the cost of checking against quote twice\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(charSeq, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = charSeq.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < len) {\n                        c = charSeq.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == escapeChar || isDelimiter(c, charSeq, pos, delim, delimLength)) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = len - 1;\n                        c = charSeq.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(charSeq, start, len);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(charSeq, start, len);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < len) {\n            final char c = charSeq.charAt(pos);\n            if (c == quoteChar || c == escapeChar) {\n                // write out the chunk up until this point\n                out.append(charSeq, start, pos);\n                out.append(escapeChar); // now output the escape\n                start = pos; // and restart with the matched char\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(charSeq, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\n     *\n     * @param reader What to print\n     * @param appendable Where to print it\n     * @throws IOException If an I/O error occurs\n     */\n    private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {\n\n        if (getQuoteMode() == QuoteMode.NONE) {\n            printWithEscapes(reader, appendable);\n            return;\n        }\n\n        int pos = 0;\n\n        final char quote = getQuoteCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        append(quote, appendable);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == quote) {\n                // write out segment up until this char\n                if (pos > 0) {\n                    append(builder.substring(0, pos), appendable);\n                    append(quote, appendable);\n                    builder.setLength(0);\n                    pos = -1;\n                }\n\n                append((char) c, appendable);\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > 0) {\n            append(builder.substring(0, pos), appendable);\n        }\n\n        append(quote, appendable);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (quoteMode != null) {\n            sb.append(' ');\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Verifies the validity and consistency of the attributes, and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.\n     */\n    private void validate() throws IllegalArgumentException {\n        if (containsLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && contains(delimiter, quoteCharacter.charValue())) {\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && contains(delimiter, escapeCharacter.charValue())) {\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && contains(delimiter, commentMarker.charValue())) {\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null && !allowDuplicateHeaderNames) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} that allows duplicate header names.\n     *\n     * @return a new {@code CSVFormat} that allows duplicate header names\n     * @since 1.7\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean) Builder#setAllowDuplicateHeaderNames(true)}\n     */\n    @Deprecated\n    public CSVFormat withAllowDuplicateHeaderNames() {\n        return builder().setAllowDuplicateHeaderNames(true).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     *\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     * @since 1.7\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n        return builder().setAllowDuplicateHeaderNames(allowDuplicateHeaderNames).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see Builder#setAllowMissingColumnNames(boolean)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)}\n     */\n    @Deprecated\n    public CSVFormat withAllowMissingColumnNames() {\n        return builder().setAllowMissingColumnNames(true).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause\n     *                                an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return builder().setAllowMissingColumnNames(allowMissingColumnNames).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     * @deprecated Use {@link Builder#setAutoFlush(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return builder().setAutoFlush(autoFlush).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setCommentMarker(char)}\n     */\n    @Deprecated\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return builder().setCommentMarker(commentMarker).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setCommentMarker(Character)}\n     */\n    @Deprecated\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        return builder().setCommentMarker(commentMarker).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setDelimiter(char)}\n     */\n    @Deprecated\n    public CSVFormat withDelimiter(final char delimiter) {\n        return builder().setDelimiter(delimiter).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape the escape character\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setEscape(char)}\n     */\n    @Deprecated\n    public CSVFormat withEscape(final char escape) {\n        return builder().setEscape(escape).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setEscape(Character)}\n     */\n    @Deprecated\n    public CSVFormat withEscape(final Character escape) {\n        return builder().setEscape(escape).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @see Builder#setHeader(String...)\n     * @since 1.3\n     * @deprecated Use {@link Builder#setHeader(String...) Builder#setHeader()}.{@link Builder#setSkipHeaderRecord(boolean) setSkipHeaderRecord(true)}.\n     */\n    @Deprecated\n    public CSVFormat withFirstRecordAsHeader() {\n        // @formatter:off\n        return builder()\n                .setHeader()\n                .setSkipHeaderRecord(true)\n                .build();\n        // @formatter:on\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see Builder#setHeader(String...)\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @since 1.3\n     * @deprecated Use {@link Builder#setHeader(Class)}\n     */\n    @Deprecated\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        return builder().setHeader(headerEnum).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\n     * input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     * @deprecated Use {@link Builder#setHeader(ResultSet)}\n     */\n    @Deprecated\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return builder().setHeader(resultSet).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\n     * input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     * @deprecated Use {@link Builder#setHeader(ResultSetMetaData)}\n     */\n    @Deprecated\n    public CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\n        return builder().setHeader(resultSetMetaData).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file\n     * with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @deprecated Use {@link Builder#setHeader(String...)}\n     */\n    @Deprecated\n    public CSVFormat withHeader(final String... header) {\n        return builder().setHeader(header).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.\n     * This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\n     * </pre>\n     *\n     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setHeaderComments(Object...)}\n     */\n    @Deprecated\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return builder().setHeaderComments(headerComments).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link Builder#setIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(true)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreEmptyLines() {\n        return builder().setIgnoreEmptyLines(true).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty\n     *                         lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return builder().setIgnoreEmptyLines(ignoreEmptyLines).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see Builder#setIgnoreHeaderCase(boolean)\n     * @since 1.3\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean) Builder#setIgnoreHeaderCase(true)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreHeaderCase() {\n        return builder().setIgnoreHeaderCase(true).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return builder().setIgnoreHeaderCase(ignoreHeaderCase).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\n     * @see Builder#setIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean) Builder#setIgnoreSurroundingSpaces(true)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return builder().setIgnoreSurroundingSpaces(true).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return builder().setIgnoreSurroundingSpaces(ignoreSurroundingSpaces).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     * @deprecated Use {@link Builder#setNullString(String)}\n     */\n    @Deprecated\n    public CSVFormat withNullString(final String nullString) {\n        return builder().setNullString(nullString).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar the quote character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setQuote(char)}\n     */\n    @Deprecated\n    public CSVFormat withQuote(final char quoteChar) {\n        return builder().setQuote(quoteChar).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar the quote character, use {@code null} to disable.\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setQuote(Character)}\n     */\n    @Deprecated\n    public CSVFormat withQuote(final Character quoteChar) {\n        return builder().setQuote(quoteChar).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteMode the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)}\n     */\n    @Deprecated\n    public CSVFormat withQuoteMode(final QuoteMode quoteMode) {\n        return builder().setQuoteMode(quoteMode).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\n     * \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator the record separator to use for output.\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @deprecated Use {@link Builder#setRecordSeparator(char)}\n     */\n    @Deprecated\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return builder().setRecordSeparator(recordSeparator).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\n     * \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator the record separator to use for output.\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF\n     * @deprecated Use {@link Builder#setRecordSeparator(String)}\n     */\n    @Deprecated\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return builder().setRecordSeparator(recordSeparator).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @see Builder#setHeader(String...)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean) Builder#setSkipHeaderRecord(true)}\n     */\n    @Deprecated\n    public CSVFormat withSkipHeaderRecord() {\n        return builder().setSkipHeaderRecord(true).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord whether to skip the header record.\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see Builder#setHeader(String...)\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return builder().setSkipHeaderRecord(skipHeaderRecord).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows\n     * and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\n     * \"\\r\\n\"\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}\n     */\n    @Deprecated\n    public CSVFormat withSystemRecordSeparator() {\n        return builder().setRecordSeparator(System.lineSeparator()).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean) Builder#setTrailingDelimiter(true)}\n     */\n    @Deprecated\n    public CSVFormat withTrailingDelimiter() {\n        return builder().setTrailingDelimiter(true).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter whether to add a trailing delimiter.\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return builder().setTrailingDelimiter(trailingDelimiter).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrim(boolean) Builder#setTrim(true)}\n     */\n    @Deprecated\n    public CSVFormat withTrim() {\n        return builder().setTrim(true).build();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\n     *\n     * @param trim whether to trim leading and trailing blanks.\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrim(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withTrim(final boolean trim) {\n        return builder().setTrim(trim).build();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 6bf3ed18a..77a009dc1 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -188,8 +188,6 @@ public static Builder create(final CSVFormat csvFormat) {\n             return new Builder(csvFormat);\n         }\n \n-        private boolean allowDuplicateHeaderNames;\n-\n         private boolean allowMissingColumnNames;\n \n         private boolean autoFlush;\n@@ -198,6 +196,8 @@ public static Builder create(final CSVFormat csvFormat) {\n \n         private String delimiter;\n \n+        private DuplicateHeaderMode duplicateHeaderMode;\n+\n         private Character escapeCharacter;\n \n         private String[] headerComments;\n@@ -245,7 +245,7 @@ private Builder(final CSVFormat csvFormat) {\n             this.trim = csvFormat.trim;\n             this.autoFlush = csvFormat.autoFlush;\n             this.quotedNullString = csvFormat.quotedNullString;\n-            this.allowDuplicateHeaderNames = csvFormat.allowDuplicateHeaderNames;\n+            this.duplicateHeaderMode = csvFormat.duplicateHeaderMode;\n         }\n \n         /**\n@@ -262,12 +262,26 @@ public CSVFormat build() {\n          *\n          * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n          * @return This instance.\n+         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.\n          */\n+        @Deprecated\n         public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n-            this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n+            final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\n+            setDuplicateHeaderMode(mode);\n             return this;\n         }\n \n+        /**\n+         * Sets the duplicate header names behavior.\n+         *\n+         * @param duplicateHeaderMode the duplicate header names behavior\n+         * @return This instance.\n+         */\n+        public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {\n+          this.duplicateHeaderMode = duplicateHeaderMode;\n+          return this;\n+        }\n+\n         /**\n          * Sets the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\n          * {@link IllegalArgumentException} to be thrown.\n@@ -760,7 +774,8 @@ public CSVFormat getFormat() {\n     }\n \n     /**\n-     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.\n+     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing\n+     * empty lines.\n      *\n      * <p>\n      * The {@link Builder} settings are:\n@@ -770,13 +785,13 @@ public CSVFormat getFormat() {\n      * <li>{@code setQuote('\"')}</li>\n      * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\n      * <li>{@code setIgnoreEmptyLines(true)}</li>\n-     * <li>{@code setAllowDuplicateHeaderNames(true)}</li>\n+     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\n      * </ul>\n      *\n      * @see Predefined#Default\n      */\n     public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false,\n-            false, false, false, true);\n+            false, false, false, DuplicateHeaderMode.ALLOW_ALL);\n \n     /**\n      * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is locale dependent, it might be necessary\n@@ -799,7 +814,7 @@ public CSVFormat getFormat() {\n      * <li>{@code setRecordSeparator(\"\\r\\n\")}</li>\n      * <li>{@code setIgnoreEmptyLines(false)}</li>\n      * <li>{@code setAllowMissingColumnNames(true)}</li>\n-     * <li>{@code setAllowDuplicateHeaderNames(true)}</li>\n+     * <li>{@code setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL)}</li>\n      * </ul>\n      * <p>\n      * Note: This is currently like {@link #RFC4180} plus {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)} and\n@@ -1220,7 +1235,7 @@ private static boolean isLineBreak(final Character c) {\n      */\n     public static CSVFormat newFormat(final char delimiter) {\n         return new CSVFormat(String.valueOf(delimiter), null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false,\n-                true);\n+                DuplicateHeaderMode.ALLOW_ALL);\n     }\n \n     static String[] toStringArray(final Object[] values) {\n@@ -1262,7 +1277,7 @@ public static CSVFormat valueOf(final String format) {\n         return CSVFormat.Predefined.valueOf(format).getFormat();\n     }\n \n-    private final boolean allowDuplicateHeaderNames;\n+    private final DuplicateHeaderMode duplicateHeaderMode;\n \n     private final boolean allowMissingColumnNames;\n \n@@ -1319,7 +1334,7 @@ private CSVFormat(final Builder builder) {\n         this.trim = builder.trim;\n         this.autoFlush = builder.autoFlush;\n         this.quotedNullString = builder.quotedNullString;\n-        this.allowDuplicateHeaderNames = builder.allowDuplicateHeaderNames;\n+        this.duplicateHeaderMode = builder.duplicateHeaderMode;\n         validate();\n     }\n \n@@ -1343,14 +1358,14 @@ private CSVFormat(final Builder builder) {\n      * @param trim                    TODO Doc me.\n      * @param trailingDelimiter       TODO Doc me.\n      * @param autoFlush               TODO Doc me.\n-     * @param allowDuplicateHeaderNames TODO Doc me.\n+     * @param duplicateHeaderMode     the behavior when handling duplicate headers\n      * @throws IllegalArgumentException if the delimiter is a line break character.\n      */\n     private CSVFormat(final String delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape,\n             final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n             final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames,\n             final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush,\n-            final boolean allowDuplicateHeaderNames) {\n+            final DuplicateHeaderMode duplicateHeaderMode) {\n         this.delimiter = delimiter;\n         this.quoteCharacter = quoteChar;\n         this.quoteMode = quoteMode;\n@@ -1369,7 +1384,7 @@ private CSVFormat(final String delimiter, final Character quoteChar, final Quote\n         this.trim = trim;\n         this.autoFlush = autoFlush;\n         this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n-        this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n+        this.duplicateHeaderMode = duplicateHeaderMode;\n         validate();\n     }\n \n@@ -1416,7 +1431,7 @@ public boolean equals(final Object obj) {\n             return false;\n         }\n         final CSVFormat other = (CSVFormat) obj;\n-        return allowDuplicateHeaderNames == other.allowDuplicateHeaderNames && allowMissingColumnNames == other.allowMissingColumnNames &&\n+        return duplicateHeaderMode == other.duplicateHeaderMode && allowMissingColumnNames == other.allowMissingColumnNames &&\n                 autoFlush == other.autoFlush && Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) &&\n                 Objects.equals(escapeCharacter, other.escapeCharacter) && Arrays.equals(header, other.header) &&\n                 Arrays.equals(headerComments, other.headerComments) && ignoreEmptyLines == other.ignoreEmptyLines &&\n@@ -1450,9 +1465,21 @@ public String format(final Object... values) {\n      *\n      * @return whether duplicate header names are allowed\n      * @since 1.7\n+     * @deprecated Use {@link #getDuplicateHeaderMode()}.\n      */\n+    @Deprecated\n     public boolean getAllowDuplicateHeaderNames() {\n-        return allowDuplicateHeaderNames;\n+        return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;\n+    }\n+\n+    /**\n+     * Gets how duplicate headers are handled.\n+     *\n+     * @return if duplicate header values are allowed, allowed conditionally, or disallowed.\n+     * @since 1.9.0\n+     */\n+    public DuplicateHeaderMode getDuplicateHeaderMode() {\n+        return duplicateHeaderMode;\n     }\n \n     /**\n@@ -1633,7 +1660,7 @@ public int hashCode() {\n         int result = 1;\n         result = prime * result + Arrays.hashCode(header);\n         result = prime * result + Arrays.hashCode(headerComments);\n-        return prime * result + Objects.hash(allowDuplicateHeaderNames, allowMissingColumnNames, autoFlush, commentMarker, delimiter, escapeCharacter,\n+        return prime * result + Objects.hash(duplicateHeaderMode, allowMissingColumnNames, autoFlush, commentMarker, delimiter, escapeCharacter,\n                 ignoreEmptyLines, ignoreHeaderCase, ignoreSurroundingSpaces, nullString, quoteCharacter, quoteMode, quotedNullString, recordSeparator,\n                 skipHeaderRecord, trailingDelimiter, trim);\n     }\n@@ -2235,7 +2262,7 @@ private void validate() throws IllegalArgumentException {\n         }\n \n         // validate header\n-        if (header != null && !allowDuplicateHeaderNames) {\n+        if (header != null && duplicateHeaderMode != DuplicateHeaderMode.ALLOW_ALL) {\n             final Set<String> dupCheck = new HashSet<>();\n             for (final String hdr : header) {\n                 if (!dupCheck.add(hdr)) {\n@@ -2254,7 +2281,7 @@ private void validate() throws IllegalArgumentException {\n      */\n     @Deprecated\n     public CSVFormat withAllowDuplicateHeaderNames() {\n-        return builder().setAllowDuplicateHeaderNames(true).build();\n+        return builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).build();\n     }\n \n     /**\n@@ -2267,7 +2294,8 @@ public CSVFormat withAllowDuplicateHeaderNames() {\n      */\n     @Deprecated\n     public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n-        return builder().setAllowDuplicateHeaderNames(allowDuplicateHeaderNames).build();\n+        final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\n+        return builder().setDuplicateHeaderMode(mode).build();\n     }\n \n     /**\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.StringReader;\nimport java.util.Iterator;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVParserTest2 {\n\n    @Test\n    public void testDuplicateHeadersModeAllowAll() throws Exception {\n        // Test case for DuplicateHeaderMode.ALLOW_ALL\n        final String csvData = \"a,b,a\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader().withDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL);\n        try (final CSVParser parser = CSVParser.parse(new StringReader(csvData), format)) {\n            final Iterator<CSVRecord> records = parser.iterator();\n            while (records.hasNext()) {\n                final CSVRecord record = records.next();\n                // Validate that records are parsed correctly even with duplicate headers\n                assertNotNull(record);\n            }\n        }\n    }\n\n    @Test\n    public void testDuplicateHeadersModeAllowEmpty() throws Exception {\n        // Test case for DuplicateHeaderMode.ALLOW_EMPTY\n        final String csvData = \"a,,a\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader().withDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_EMPTY);\n        try (final CSVParser parser = CSVParser.parse(new StringReader(csvData), format)) {\n            final Iterator<CSVRecord> records = parser.iterator();\n            while (records.hasNext()) {\n                final CSVRecord record = records.next();\n                // Validate that records are parsed correctly even with empty duplicate headers\n                assertNotNull(record);\n            }\n        }\n    }\n\n    @Test\n    public void testDuplicateHeadersModeDisallow() {\n        // Test case for DuplicateHeaderMode.DISALLOW\n        final String csvData = \"a,b,a\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader().withDuplicateHeaderMode(DuplicateHeaderMode.DISALLOW);\n        assertThrows(IllegalArgumentException.class, () -> {\n            try (final CSVParser parser = CSVParser.parse(new StringReader(csvData), format)) {\n                // This should throw an IllegalArgumentException due to duplicate headers\n                parser.getRecords();\n            }\n        });\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.TreeMap;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n\n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n\n            return this.current != null;\n        }\n\n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n\n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n\n            return next;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Header information based on name and position.\n     */\n    private static final class Headers {\n        /**\n         * Header column positions (0-based)\n         */\n        final Map<String, Integer> headerMap;\n\n        /**\n         * Header names in column order\n         */\n        final List<String> headerNames;\n\n        Headers(final Map<String, Integer> headerMap, final List<String> headerNames) {\n            this.headerMap = headerMap;\n            this.headerNames = headerNames;\n        }\n    }\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        return parse(file.toPath(), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        Objects.requireNonNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates and returns a parser for the given {@link Path}, which the caller MUST close.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(path, \"path\");\n        Objects.requireNonNull(format, \"format\");\n        return parse(Files.newInputStream(path), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(string, \"string\");\n        Objects.requireNonNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates and returns a parser for the given URL, which the caller MUST close.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(url, \"url\");\n        Objects.requireNonNull(charset, \"charset\");\n        Objects.requireNonNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private final CSVFormat format;\n\n    private final Headers headers;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n        throws IOException {\n        Objects.requireNonNull(reader, \"reader\");\n        Objects.requireNonNull(format, \"format\");\n\n        this.format = format.copy();\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headers = createHeaders();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        this.recordList.add(handleNull(inputClean));\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    private Map<String, Integer> createEmptyHeaderMap() {\n        return this.format.getIgnoreHeaderCase() ?\n                new TreeMap<>(String.CASE_INSENSITIVE_ORDER) :\n                new LinkedHashMap<>();\n    }\n\n    /**\n     * Creates the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Headers createHeaders() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        List<String> headerNames = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = createEmptyHeaderMap();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (emptyHeader && !this.format.getAllowMissingColumnNames()) {\n                        throw new IllegalArgumentException(\n                            \"A header name is missing in \" + Arrays.toString(headerRecord));\n                    }\n                    // Note: This will always allow a duplicate header if the header is empty\n                    final boolean containsHeader = header != null && hdrMap.containsKey(header);\n                    if (containsHeader && !emptyHeader && !this.format.getAllowDuplicateHeaderNames()) {\n                        throw new IllegalArgumentException(\n                            String.format(\n                                \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.withAllowDuplicateHeaderNames().\",\n                                header, Arrays.toString(headerRecord)));\n                    }\n                    if (header != null) {\n                        hdrMap.put(header, Integer.valueOf(i));\n                        if (headerNames == null) {\n                            headerNames = new ArrayList<>(headerRecord.length);\n                        }\n                        headerNames.add(header);\n                    }\n                }\n            }\n        }\n        if (headerNames == null) {\n            headerNames = Collections.emptyList(); //immutable\n        } else {\n            headerNames = Collections.unmodifiableList(headerNames);\n        }\n        return new Headers(hdrMap, headerNames);\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * <p>\n     * Note: The map can only provide a one-to-one mapping when the format did not\n     * contain null or duplicate column names.\n     * </p>\n     *\n     * @return a copy of the header map.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        if (this.headers.headerMap == null) {\n            return null;\n        }\n        final Map<String, Integer> map = createEmptyHeaderMap();\n        map.putAll(this.headers.headerMap);\n        return map;\n    }\n\n    /**\n     * Returns the header map.\n     *\n     * @return the header map.\n     */\n    Map<String, Integer> getHeaderMapRaw() {\n        return this.headers.headerMap;\n    }\n\n    /**\n     * Returns a read-only list of header names that iterates in column order.\n     * <p>\n     * Note: The list provides strings that can be used as keys in the header map.\n     * The list will not contain null column names if they were present in the input\n     * format.\n     * </p>\n     *\n     * @return read-only list of header names that iterates in column order.\n     * @see #getHeaderMap()\n     * @since 1.7\n     */\n    public List<String> getHeaderNames() {\n        return Collections.unmodifiableList(headers.headerNames);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Handle whether input is parsed as null\n     *\n     * @param input\n     *           the cell data to further processed\n     * @return null if input is parsed as null, or input itself if input isn't parsed as null\n     */\n    private String handleNull(final String input) {\n        final boolean isQuoted = this.reusableToken.isQuoted;\n        final String nullString = format.getNullString();\n        final boolean strictQuoteMode = isStrictQuoteMode();\n        if (input.equals(nullString)) {\n            // nullString = NULL(String), distinguish between \"NULL\" and NULL in ALL_NON_NULL or NON_NUMERIC quote mode\n            return strictQuoteMode && isQuoted ? input : null;\n        }\n        // don't set nullString, distinguish between \"\" and ,, (absent values) in All_NON_NULL or NON_NUMERIC quote mode\n        return strictQuoteMode && nullString == null && input.isEmpty() && !isQuoted ? null : input;\n    }\n\n    /**\n     * Tests whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Tests whether the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or {@link QuoteMode#NON_NUMERIC}.\n     *\n     * @return true if the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or\n     *         {@link QuoteMode#NON_NUMERIC}.\n     */\n    private boolean isStrictQuoteMode() {\n        return this.format.getQuoteMode() == QuoteMode.ALL_NON_NULL ||\n               this.format.getQuoteMode() == QuoteMode.NON_NUMERIC;\n    }\n\n    /**\n     * Returns the record iterator.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this, this.recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment,\n                this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a sequential {@code Stream} with this collection as its source.\n     *\n     * @return a sequential {@code Stream} with this collection as its source.\n     * @since 1.9.0\n     */\n    public Stream<CSVRecord> stream() {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator(), Spliterator.ORDERED), false);\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 60ecc7374..58cdb146b 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -497,12 +497,16 @@ private Headers createHeaders() throws IOException {\n                         throw new IllegalArgumentException(\n                             \"A header name is missing in \" + Arrays.toString(headerRecord));\n                     }\n-                    // Note: This will always allow a duplicate header if the header is empty\n+\n                     final boolean containsHeader = header != null && hdrMap.containsKey(header);\n-                    if (containsHeader && !emptyHeader && !this.format.getAllowDuplicateHeaderNames()) {\n+                    final DuplicateHeaderMode headerMode = this.format.getDuplicateHeaderMode();\n+                    final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\n+                    final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\n+\n+                    if (containsHeader && !duplicatesAllowed && !(emptyHeader && emptyDuplicatesAllowed)) {\n                         throw new IllegalArgumentException(\n                             String.format(\n-                                \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.withAllowDuplicateHeaderNames().\",\n+                                \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\n                                 header, Arrays.toString(headerRecord)));\n                     }\n                     if (header != null) {\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/DuplicateHeaderMode.java",
        "status": "added",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DuplicateHeaderModeTest {\n\n    @Test\n    public void testAllowAll() {\n        assertEquals(DuplicateHeaderMode.ALLOW_ALL, DuplicateHeaderMode.valueOf(\"ALLOW_ALL\"));\n    }\n\n    @Test\n    public void testAllowEmpty() {\n        assertEquals(DuplicateHeaderMode.ALLOW_EMPTY, DuplicateHeaderMode.valueOf(\"ALLOW_EMPTY\"));\n    }\n\n    @Test\n    public void testDisallow() {\n        assertEquals(DuplicateHeaderMode.DISALLOW, DuplicateHeaderMode.valueOf(\"DISALLOW\"));\n    }\n\n    @Test\n    public void testValues() {\n        DuplicateHeaderMode[] expectedValues = {\n            DuplicateHeaderMode.ALLOW_ALL,\n            DuplicateHeaderMode.ALLOW_EMPTY,\n            DuplicateHeaderMode.DISALLOW\n        };\n        assertArrayEquals(expectedValues, DuplicateHeaderMode.values());\n    }\n}",
        "file_content": null,
        "diff": " a/src/main/java/org/apache/commons/csv/DuplicateHeaderMode.java b/src/main/java/org/apache/commons/csv/DuplicateHeaderMode.java\nnew file mode 100644\nindex 000000000..e623adaa4\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/csv/DuplicateHeaderMode.java\n@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+/**\n+ * Determines how duplicate header fields should be handled\n+ * if {@link CSVFormat#withHeader(String...)} is not null.\n+ *\n+ * @since 1.9.0\n+ */\n+public enum DuplicateHeaderMode {\n+\n+    /**\n+     * Allows all duplicate headers.\n+     */\n+    ALLOW_ALL,\n+\n+    /**\n+     * Allows duplicate headers only if they're empty strings or null.\n+     */\n+    ALLOW_EMPTY,\n+\n+    /**\n+     * Disallows duplicate headers entirely.\n+     */\n+    DISALLOW\n+}\n"
      },
      {
        "filename": "src/site/resources/checkstyle/checkstyle-suppressions.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVFormatTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/issues/JiraCsv264Test.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 71,
    "title": "[CSV-211] CSVFormat.format trims last delimiter if the delimiter is a white space",
    "state": "closed",
    "created_at": "2020-05-18T09:33:31Z",
    "merge_commit_sha": "3eac15fc8d5a1da80119e7389f78b9795e8aa4db",
    "base_sha": "57c77341d42f54b71018931dd4f389d507a30a3c",
    "head_sha": "f25649ce03b2e1f84d50c3024f3ec394cac55246",
    "user_login": "dota17",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.CSVFormat.RFC4180;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testFormatWithRecordSeparator() {\n        CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator(CRLF);\n        assertEquals(\"a,b,c\\r\\n\", format.format(\"a\", \"b\", \"c\"));\n\n        format = CSVFormat.DEFAULT.withRecordSeparator(LF);\n        assertEquals(\"a,b,c\\n\", format.format(\"a\", \"b\", \"c\"));\n\n        format = CSVFormat.DEFAULT.withRecordSeparator(CR);\n        assertEquals(\"a,b,c\\r\", format.format(\"a\", \"b\", \"c\"));\n    }\n\n    @Test\n    public void testFormatWithoutRecordSeparator() {\n        CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator(null);\n        assertEquals(\"a,b,c\", format.format(\"a\", \"b\", \"c\"));\n    }\n\n    @Test\n    public void testFormatWithEmptyRecordSeparator() {\n        CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator(\"\");\n        assertEquals(\"a,b,c\", format.format(\"a\", \"b\", \"c\"));\n    }\n\n    @Test\n    public void testFormatWithCustomRecordSeparator() {\n        CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator(\";\");\n        assertEquals(\"a,b,c;\", format.format(\"a\", \"b\", \"c\"));\n    }\n\n    @Test\n    public void testFormatWithNullValues() {\n        CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator(CRLF);\n        assertEquals(\",\\r\\n\", format.format(null, null));\n    }\n\n    @Test\n    public void testFormatWithIOException() {\n        CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator(CRLF);\n        assertThrows(IllegalStateException.class, () -> {\n            try (StringWriter out = new StringWriter()) {\n                out.close();\n                format.format(out, \"a\", \"b\", \"c\");\n            } catch (IOException e) {\n                throw new IllegalStateException(e);\n            }\n        });\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #INFORMIX_UNLOAD}</li>\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #ORACLE}</li>\n * <li>{@link #POSTGRESQL_CSV}</li>\n * <li>{@link #POSTGRESQL_TEXT}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_CSV\n         * @since 1.7\n         */\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_TSV\n         * @since 1.7\n         */\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#ORACLE\n         */\n        Oracle(CSVFormat.ORACLE),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(true)}</li>\n     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false, true);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withAllowMissingColumnNames(true)}</li>\n     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: This is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)} and {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with\n     * {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *      documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a tab-delimited format. Values are double quoted only if needed and special\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *          documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_TSV = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote(null)}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default Oracle format used by the SQL*Loader utility.\n     *\n     * <p>\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\n     * {@code \"\"}. Values are trimmed.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withTrim()}</li>\n     * <li>{@code withSystemRecordSeparator()}</li>\n     * <li>{@code withQuoteMode(QuoteMode.MINIMAL)}</li>\n     * </ul>\n     *\n     * @see Predefined#Oracle\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\n     * @since 1.6\n     */\n    // @formatter:off\n    public static final CSVFormat ORACLE = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withNullString(\"\\\\N\")\n            .withTrim()\n            .withSystemRecordSeparator()\n            .withQuoteMode(QuoteMode.MINIMAL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreSurroundingSpaces(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if {@code c} is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if {@code c} is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false, false, true);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowDuplicateHeaderNames;\n\n    private final boolean allowMissingColumnNames;\n\n    private final boolean autoFlush;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final String quotedNullString;\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter, final boolean autoFlush, final boolean allowDuplicateHeaderNames) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n        this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (trailingDelimiter != other.trailingDelimiter) {\n            return false;\n        }\n        if (autoFlush != other.autoFlush) {\n            return false;\n        }\n        if (trim != other.trim) {\n            return false;\n        }\n        if (allowMissingColumnNames != other.allowMissingColumnNames) {\n            return false;\n        }\n        if (allowDuplicateHeaderNames != other.allowDuplicateHeaderNames) {\n            return false;\n        }\n        if (ignoreHeaderCase != other.ignoreHeaderCase) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        if (!Arrays.equals(headerComments, other.headerComments)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns true if and only if duplicate names are allowed in the headers.\n     *\n     * @return whether duplicate header names are allowed\n     * @since 1.7\n     */\n    public boolean getAllowDuplicateHeaderNames() {\n        return allowDuplicateHeaderNames;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     * This is used by {@link #print(Object, Appendable, boolean)}\n     * Also by {@link CSVParser#addRecordValue(boolean)}\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + (allowDuplicateHeaderNames ? 1231 : 1237);\n        result = prime * result + (trim ? 1231 : 1237);\n        result = prime * result + (autoFlush ? 1231 : 1237);\n        result = prime * result + (trailingDelimiter ? 1231 : 1237);\n        result = prime * result + (allowMissingColumnNames ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        result = prime * result + Arrays.hashCode(headerComments);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     * Trims the value if {@link #getTrim()} is true\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quotedNullString;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        } else {\n            if (value instanceof CharSequence) {\n                charSequence = (CharSequence) value;\n            } else if (value instanceof Reader) {\n                print((Reader) value, out, newRecord);\n                return;\n            } else {\n                charSequence = value.toString();\n            }\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        print(value, charSequence, out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord)\n            throws IOException {\n        final int offset = 0;\n        final int len = value.length();\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printWithQuotes(object, value, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(value, out);\n        } else {\n            out.append(value, offset, len);\n        }\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n        // Reader is never null\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (isQuoteCharacterSet()) {\n            printWithQuotes(reader, out);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(reader, out);\n        } else if (out instanceof Writer) {\n            IOUtils.copyLarge(reader, (Writer) out);\n        } else {\n            IOUtils.copy(reader, out);\n        }\n\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printWithEscapes(final CharSequence value, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    private void printWithEscapes(final Reader reader, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(builder.substring(start, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append((char) c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(builder.substring(start, pos));\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printWithQuotes(final Object object, final CharSequence value, final Appendable out,\n            final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        // If escape char not specified, default to the quote char\n        // This avoids having to keep checking whether there is an escape character\n        // at the cost of checking against quote twice\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(value, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar || c == escapeChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar || c == escapeChar) {\n                // write out the chunk up until this point\n                out.append(value, start, pos);\n                out.append(escapeChar); // now output the escape\n                start = pos; // and restart with the matched char\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\n     *\n     * @throws IOException\n     */\n    private void printWithQuotes(final Reader reader, final Appendable out) throws IOException {\n\n        if (getQuoteMode() == QuoteMode.NONE) {\n            printWithEscapes(reader, out);\n            return;\n        }\n\n        int pos = 0;\n\n        final char quote = getQuoteCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        out.append(quote);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == quote) {\n                // write out segment up until this char\n                if (pos > 0) {\n                    out.append(builder.substring(0, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n\n                out.append(quote);\n                out.append((char) c);\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > 0) {\n            out.append(builder.substring(0, pos));\n        }\n\n        out.append(quote);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (quoteMode != null) {\n            sb.append(' ');\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null && !allowDuplicateHeaderNames) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} that allows duplicate header names.\n     *\n     * @return a new {@code CSVFormat} that allows duplicate header names\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames() {\n        return withAllowDuplicateHeaderNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     *\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces,\n     *        {@code false} to leave the spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line\n     * separator string, typically CR+LF on Windows and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     */\n    public CSVFormat withSystemRecordSeparator() {\n        return withRecordSeparator(System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 0e068c1d1..e0258f341 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -894,7 +894,9 @@ public String format(final Object... values) {\n         final StringWriter out = new StringWriter();\n         try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n             csvPrinter.printRecord(values);\n-            return out.toString().trim();\n+            String res = out.toString();\n+            int len = recordSeparator != null ? res.length() - recordSeparator.length() : res.length();\n+            return res.substring(0, len);\n         } catch (final IOException e) {\n             // should not happen because a StringWriter does not do IO.\n             throw new IllegalStateException(e);\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/issues/JiraCsv211Test.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 64,
    "title": "Removed invalid Javadoc markup for CSVFormat EXCEL",
    "state": "closed",
    "created_at": "2020-04-01T17:43:54Z",
    "merge_commit_sha": "3c393fedbdee92fe55d3c2ffa801132a91a0882e",
    "base_sha": "cab61c53f12a5cef50c25397a2946b303582193c",
    "head_sha": "1e3117021306ee721d61245731fb94cf38560c02",
    "user_login": "a4ff7810",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.CSVFormat.RFC4180;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    /**\n     * Test to ensure that the default settings are correctly documented.\n     */\n    @Test\n    public void testDefaultSettingsDocumentation() {\n        CSVFormat defaultFormat = CSVFormat.DEFAULT;\n        assertEquals(',', defaultFormat.getDelimiter());\n        assertEquals(Character.valueOf('\"'), defaultFormat.getQuoteCharacter());\n        assertEquals(\"\\r\\n\", defaultFormat.getRecordSeparator());\n        assertEquals(false, defaultFormat.getIgnoreEmptyLines());\n        assertEquals(true, defaultFormat.getAllowMissingColumnNames());\n        assertEquals(true, defaultFormat.getAllowDuplicateHeaderNames());\n    }\n\n    /**\n     * Test to ensure that the delimiter cannot be a line break.\n     */\n    @Test\n    public void testDelimiterCannotBeLineBreak() {\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat(CR));\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.newFormat(LF));\n    }\n\n    /**\n     * Test to ensure that the quote character cannot be a line break.\n     */\n    @Test\n    public void testQuoteCharCannotBeLineBreak() {\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(CR));\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withQuote(LF));\n    }\n\n    /**\n     * Test to ensure that the escape character cannot be a line break.\n     */\n    @Test\n    public void testEscapeCharCannotBeLineBreak() {\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(CR));\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withEscape(LF));\n    }\n\n    /**\n     * Test to ensure that the comment marker cannot be a line break.\n     */\n    @Test\n    public void testCommentMarkerCannotBeLineBreak() {\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withCommentMarker(CR));\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withCommentMarker(LF));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #INFORMIX_UNLOAD}</li>\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #ORACLE}</li>\n * <li>{@link #POSTGRESQL_CSV}</li>\n * <li>{@link #POSTGRESQL_TEXT}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_CSV\n         * @since 1.7\n         */\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_TSV\n         * @since 1.7\n         */\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#ORACLE\n         */\n        Oracle(CSVFormat.ORACLE),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(true)}</li>\n     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false, true);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code {@link #withDelimiter(char) withDelimiter(',')}}</li>\n     * <li>{@code {@link #withQuote(char) withQuote('\"')}}</li>\n     * <li>{@code {@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}}</li>\n     * <li>{@code {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}}</li>\n     * <li>{@code {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}}</li>\n     * <li>{@code {@link #withAllowDuplicateHeaderNames(boolean) withAllowDuplicateHeaderNames(true)}}</li>\n     * </ul>\n     * <p>\n     * Note: This is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)} and {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with\n     * {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *      documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a tab-delimited format. Values are double quoted only if needed and special\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *          documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_TSV = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote(null)}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default Oracle format used by the SQL*Loader utility.\n     *\n     * <p>\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\n     * {@code \"\"}. Values are trimmed.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withTrim()}</li>\n     * <li>{@code withSystemRecordSeparator()}</li>\n     * <li>{@code withQuoteMode(QuoteMode.MINIMAL)}</li>\n     * </ul>\n     *\n     * @see Predefined#Oracle\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\n     * @since 1.6\n     */\n    // @formatter:off\n    public static final CSVFormat ORACLE = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withNullString(\"\\\\N\")\n            .withTrim()\n            .withSystemRecordSeparator()\n            .withQuoteMode(QuoteMode.MINIMAL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreSurroundingSpaces(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if {@code c} is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if {@code c} is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false, false, true);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowDuplicateHeaderNames;\n\n    private final boolean allowMissingColumnNames;\n\n    private final boolean autoFlush;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final String quotedNullString;\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter, final boolean autoFlush, final boolean allowDuplicateHeaderNames) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n        this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (trailingDelimiter != other.trailingDelimiter) {\n            return false;\n        }\n        if (autoFlush != other.autoFlush) {\n            return false;\n        }\n        if (trim != other.trim) {\n            return false;\n        }\n        if (allowMissingColumnNames != other.allowMissingColumnNames) {\n            return false;\n        }\n        if (allowDuplicateHeaderNames != other.allowDuplicateHeaderNames) {\n            return false;\n        }\n        if (ignoreHeaderCase != other.ignoreHeaderCase) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        if (!Arrays.equals(headerComments, other.headerComments)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns true if and only if duplicate names are allowed in the headers.\n     *\n     * @return whether duplicate header names are allowed\n     * @since 1.7\n     */\n    public boolean getAllowDuplicateHeaderNames() {\n        return allowDuplicateHeaderNames;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     * This is used by {@link #print(Object, Appendable, boolean)}\n     * Also by {@link CSVParser#addRecordValue(boolean)}\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + (allowDuplicateHeaderNames ? 1231 : 1237);\n        result = prime * result + (trim ? 1231 : 1237);\n        result = prime * result + (autoFlush ? 1231 : 1237);\n        result = prime * result + (trailingDelimiter ? 1231 : 1237);\n        result = prime * result + (allowMissingColumnNames ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        result = prime * result + Arrays.hashCode(headerComments);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     * Trims the value if {@link #getTrim()} is true\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quotedNullString;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        } else {\n            if (value instanceof CharSequence) {\n                charSequence = (CharSequence) value;\n            } else if (value instanceof Reader) {\n                print((Reader) value, out, newRecord);\n                return;\n            } else {\n                charSequence = value.toString();\n            }\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        print(value, charSequence, out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord)\n            throws IOException {\n        final int offset = 0;\n        final int len = value.length();\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printWithQuotes(object, value, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(value, out);\n        } else {\n            out.append(value, offset, len);\n        }\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n        // Reader is never null\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (isQuoteCharacterSet()) {\n            printWithQuotes(reader, out);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(reader, out);\n        } else if (out instanceof Writer) {\n            IOUtils.copyLarge(reader, (Writer) out);\n        } else {\n            IOUtils.copy(reader, out);\n        }\n\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printWithEscapes(final CharSequence value, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    private void printWithEscapes(final Reader reader, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(builder.substring(start, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append((char) c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(builder.substring(start, pos));\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printWithQuotes(final Object object, final CharSequence value, final Appendable out,\n            final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        // If escape char not specified, default to the quote char\n        // This avoids having to keep checking whether there is an escape character\n        // at the cost of checking against quote twice\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(value, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar || c == escapeChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar || c == escapeChar) {\n                // write out the chunk up until this point\n                out.append(value, start, pos);\n                out.append(escapeChar); // now output the escape\n                start = pos; // and restart with the matched char\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\n     *\n     * @throws IOException\n     */\n    private void printWithQuotes(final Reader reader, final Appendable out) throws IOException {\n\n        if (getQuoteMode() == QuoteMode.NONE) {\n            printWithEscapes(reader, out);\n            return;\n        }\n\n        int pos = 0;\n\n        final char quote = getQuoteCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        out.append(quote);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == quote) {\n                // write out segment up until this char\n                if (pos > 0) {\n                    out.append(builder.substring(0, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n\n                out.append(quote);\n                out.append((char) c);\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > 0) {\n            out.append(builder.substring(0, pos));\n        }\n\n        out.append(quote);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (quoteMode != null) {\n            sb.append(' ');\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null && !allowDuplicateHeaderNames) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} that allows duplicate header names.\n     *\n     * @return a new {@code CSVFormat} that allows duplicate header names\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames() {\n        return withAllowDuplicateHeaderNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     *\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces,\n     *        {@code false} to leave the spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line\n     * separator string, typically CR+LF on Windows and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     */\n    public CSVFormat withSystemRecordSeparator() {\n        return withRecordSeparator(System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 6e9f4fb5a..0e068c1d1 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -284,12 +284,12 @@ public CSVFormat getFormat() {\n      * Settings are:\n      * </p>\n      * <ul>\n-     * <li>{@code {@link #withDelimiter(char) withDelimiter(',')}}</li>\n-     * <li>{@code {@link #withQuote(char) withQuote('\"')}}</li>\n-     * <li>{@code {@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}}</li>\n-     * <li>{@code {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}}</li>\n-     * <li>{@code {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}}</li>\n-     * <li>{@code {@link #withAllowDuplicateHeaderNames(boolean) withAllowDuplicateHeaderNames(true)}}</li>\n+     * <li>{@code withDelimiter(',')}</li>\n+     * <li>{@code withQuote('\"')}</li>\n+     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n+     * <li>{@code withIgnoreEmptyLines(false)}</li>\n+     * <li>{@code withAllowMissingColumnNames(true)}</li>\n+     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n      * </ul>\n      * <p>\n      * Note: This is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n"
      }
    ]
  },
  {
    "pr_number": 61,
    "title": "[CSV-259] CSVFormat.printWithEscapes throws StringIndexOutOfBoundsException when value is Reader",
    "state": "closed",
    "created_at": "2020-03-13T07:58:42Z",
    "merge_commit_sha": "953a6de7224d0535f68f549cc1deefc7fa7d78c1",
    "base_sha": "e503c568a10ae42364a94695b8505bcb4db28969",
    "head_sha": "819c44b96f40a01617025ce8039cb31a3acf6458",
    "user_login": "dota17",
    "changed_files": [
      {
        "filename": "pom.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testPrintWithEscapesReader() throws IOException {\n        // Setup\n        CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\');\n        String input = \"value1,value2\\nvalue3,value4\";\n        StringReader reader = new StringReader(input);\n        StringWriter writer = new StringWriter();\n\n        // Execute\n        format.printWithEscapes(reader, writer);\n\n        // Verify\n        assertEquals(\"value1,value2\\\\nvalue3,value4\", writer.toString());\n    }\n\n    @Test\n    public void testPrintWithEscapesReaderWithLineBreaks() throws IOException {\n        // Setup\n        CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\');\n        String input = \"value1,value2\\rvalue3,value4\";\n        StringReader reader = new StringReader(input);\n        StringWriter writer = new StringWriter();\n\n        // Execute\n        format.printWithEscapes(reader, writer);\n\n        // Verify\n        assertEquals(\"value1,value2\\\\rvalue3,value4\", writer.toString());\n    }\n\n    @Test\n    public void testPrintWithEscapesReaderWithDelimiter() throws IOException {\n        // Setup\n        CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\').withDelimiter(',');\n        String input = \"value1,value2,value3\";\n        StringReader reader = new StringReader(input);\n        StringWriter writer = new StringWriter();\n\n        // Execute\n        format.printWithEscapes(reader, writer);\n\n        // Verify\n        assertEquals(\"value1\\\\,value2\\\\,value3\", writer.toString());\n    }\n\n    @Test\n    public void testPrintWithEscapesReaderWithEscapeCharacter() throws IOException {\n        // Setup\n        CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\');\n        String input = \"value1\\\\value2\";\n        StringReader reader = new StringReader(input);\n        StringWriter writer = new StringWriter();\n\n        // Execute\n        format.printWithEscapes(reader, writer);\n\n        // Verify\n        assertEquals(\"value1\\\\\\\\value2\", writer.toString());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #INFORMIX_UNLOAD}</li>\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #ORACLE}</li>\n * <li>{@link #POSTGRESQL_CSV}</li>\n * <li>{@link #POSTGRESQL_TEXT}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_CSV\n         * @since 1.7\n         */\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_TSV\n         * @since 1.7\n         */\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#ORACLE\n         */\n        Oracle(CSVFormat.ORACLE),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(true)}</li>\n     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false, true);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code {@link #withDelimiter(char) withDelimiter(',')}}</li>\n     * <li>{@code {@link #withQuote(char) withQuote('\"')}}</li>\n     * <li>{@code {@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}}</li>\n     * <li>{@code {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}}</li>\n     * <li>{@code {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}}</li>\n     * <li>{@code {@link #withAllowDuplicateHeaderNames(boolean) withAllowDuplicateHeaderNames(true)}}</li>\n     * </ul>\n     * <p>\n     * Note: This is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)} and {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with\n     * {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *      documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a tab-delimited format. Values are double quoted only if needed and special\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *          documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_TSV = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote(null)}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default Oracle format used by the SQL*Loader utility.\n     *\n     * <p>\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\n     * {@code \"\"}. Values are trimmed.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withTrim()}</li>\n     * <li>{@code withSystemRecordSeparator()}</li>\n     * <li>{@code withQuoteMode(QuoteMode.MINIMAL)}</li>\n     * </ul>\n     *\n     * @see Predefined#Oracle\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\n     * @since 1.6\n     */\n    // @formatter:off\n    public static final CSVFormat ORACLE = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withNullString(\"\\\\N\")\n            .withTrim()\n            .withSystemRecordSeparator()\n            .withQuoteMode(QuoteMode.MINIMAL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreSurroundingSpaces(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if {@code c} is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if {@code c} is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false, false, true);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowDuplicateHeaderNames;\n\n    private final boolean allowMissingColumnNames;\n\n    private final boolean autoFlush;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final String quotedNullString;\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter, final boolean autoFlush, final boolean allowDuplicateHeaderNames) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n        this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (trailingDelimiter != other.trailingDelimiter) {\n            return false;\n        }\n        if (autoFlush != other.autoFlush) {\n            return false;\n        }\n        if (trim != other.trim) {\n            return false;\n        }\n        if (allowMissingColumnNames != other.allowMissingColumnNames) {\n            return false;\n        }\n        if (allowDuplicateHeaderNames != other.allowDuplicateHeaderNames) {\n            return false;\n        }\n        if (ignoreHeaderCase != other.ignoreHeaderCase) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        if (!Arrays.equals(headerComments, other.headerComments)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns true if and only if duplicate names are allowed in the headers.\n     *\n     * @return whether duplicate header names are allowed\n     * @since 1.7\n     */\n    public boolean getAllowDuplicateHeaderNames() {\n        return allowDuplicateHeaderNames;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     * This is used by {@link #print(Object, Appendable, boolean)}\n     * Also by {@link CSVParser#addRecordValue(boolean)}\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + (allowDuplicateHeaderNames ? 1231 : 1237);\n        result = prime * result + (trim ? 1231 : 1237);\n        result = prime * result + (autoFlush ? 1231 : 1237);\n        result = prime * result + (trailingDelimiter ? 1231 : 1237);\n        result = prime * result + (allowMissingColumnNames ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        result = prime * result + Arrays.hashCode(headerComments);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     * Trims the value if {@link #getTrim()} is true\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quotedNullString;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        } else {\n            if (value instanceof CharSequence) {\n                charSequence = (CharSequence) value;\n            } else if (value instanceof Reader) {\n                print((Reader) value, out, newRecord);\n                return;\n            } else {\n                charSequence = value.toString();\n            }\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        print(value, charSequence, out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord)\n            throws IOException {\n        final int offset = 0;\n        final int len = value.length();\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printWithQuotes(object, value, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(value, out);\n        } else {\n            out.append(value, offset, len);\n        }\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n        // Reader is never null\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (isQuoteCharacterSet()) {\n            printWithQuotes(reader, out);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(reader, out);\n        } else if (out instanceof Writer) {\n            IOUtils.copyLarge(reader, (Writer) out);\n        } else {\n            IOUtils.copy(reader, out);\n        }\n\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printWithEscapes(final CharSequence value, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    private void printWithEscapes(final Reader reader, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(builder.substring(start, pos));\n                    builder.setLength(0);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append((char) c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(builder.substring(start, pos));\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printWithQuotes(final Object object, final CharSequence value, final Appendable out,\n            final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        // If escape char not specified, default to the quote char\n        // This avoids having to keep checking whether there is an escape character\n        // at the cost of checking against quote twice\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(value, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar || c == escapeChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar || c == escapeChar) {\n                // write out the chunk up until this point\n                out.append(value, start, pos);\n                out.append(escapeChar); // now output the escape\n                start = pos; // and restart with the matched char\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\n     *\n     * @throws IOException\n     */\n    private void printWithQuotes(final Reader reader, final Appendable out) throws IOException {\n\n        if (getQuoteMode() == QuoteMode.NONE) {\n            printWithEscapes(reader, out);\n            return;\n        }\n\n        int pos = 0;\n\n        final char quote = getQuoteCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        out.append(quote);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == quote) {\n                // write out segment up until this char\n                if (pos > 0) {\n                    out.append(builder.substring(0, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n\n                out.append(quote);\n                out.append((char) c);\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > 0) {\n            out.append(builder.substring(0, pos));\n        }\n\n        out.append(quote);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (quoteMode != null) {\n            sb.append(' ');\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null && !allowDuplicateHeaderNames) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} that allows duplicate header names.\n     *\n     * @return a new {@code CSVFormat} that allows duplicate header names\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames() {\n        return withAllowDuplicateHeaderNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     *\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces,\n     *        {@code false} to leave the spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line\n     * separator string, typically CR+LF on Windows and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     */\n    public CSVFormat withSystemRecordSeparator() {\n        return withRecordSeparator(System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex a75b86334..6e9f4fb5a 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1408,6 +1408,7 @@ private void printWithEscapes(final Reader reader, final Appendable out) throws\n                 if (pos > start) {\n                     out.append(builder.substring(start, pos));\n                     builder.setLength(0);\n+                    pos = -1;\n                 }\n                 if (c == LF) {\n                     c = 'n';\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/resources/CSV-259/sample.txt",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 60,
    "title": "Fix CSV-149 and CSV-195",
    "state": "closed",
    "created_at": "2020-02-24T08:10:36Z",
    "merge_commit_sha": "ad11cd14d0e407e351d7de71018cbc25ccb4352f",
    "base_sha": "c958d96f34a88bd70c5e79fddf7522f604e882c9",
    "head_sha": "5a621a5870a43bf399d38e8553b680a140ac880a",
    "user_login": "dota17",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport java.io.StringReader;\nimport org.junit.jupiter.api.Test;\n\npublic class ExtendedBufferedReaderTest2 {\n\n    @Test\n    public void testEndOfStreamIncrementsEolCounter() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"a\")) {\n            assertEquals('a', br.read());\n            assertEquals(0, br.getCurrentLineNumber());\n            assertEquals(END_OF_STREAM, br.read());\n            assertEquals(1, br.getCurrentLineNumber());\n        }\n    }\n\n    @Test\n    public void testEndOfStreamDoesNotIncrementEolCounterAfterCR() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"\\r\")) {\n            assertEquals('\\r', br.read());\n            assertEquals(1, br.getCurrentLineNumber());\n            assertEquals(END_OF_STREAM, br.read());\n            assertEquals(1, br.getCurrentLineNumber());\n        }\n    }\n\n    @Test\n    public void testEndOfStreamDoesNotIncrementEolCounterAfterLF() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"\\n\")) {\n            assertEquals('\\n', br.read());\n            assertEquals(1, br.getCurrentLineNumber());\n            assertEquals(END_OF_STREAM, br.read());\n            assertEquals(1, br.getCurrentLineNumber());\n        }\n    }\n\n    @Test\n    public void testEndOfStreamDoesNotIncrementEolCounterAfterCRLF() throws Exception {\n        try (final ExtendedBufferedReader br = createBufferedReader(\"\\r\\n\")) {\n            assertEquals('\\r', br.read());\n            assertEquals(1, br.getCurrentLineNumber());\n            assertEquals('\\n', br.read());\n            assertEquals(1, br.getCurrentLineNumber());\n            assertEquals(END_OF_STREAM, br.read());\n            assertEquals(1, br.getCurrentLineNumber());\n        }\n    }\n\n    private ExtendedBufferedReader createBufferedReader(final String s) {\n        return new ExtendedBufferedReader(new StringReader(s));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * A special buffered reader which supports sophisticated read access.\n * <p>\n * In particular the reader supports a look-ahead option, which allows you to see the next char returned by\n * {@link #read()}. This reader also tracks how many characters have been read with {@link #getPosition()}.\n * </p>\n */\nfinal class ExtendedBufferedReader extends BufferedReader {\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The count of EOLs (CR/LF/CRLF) seen so far */\n    private long eolCounter;\n\n    /** The position, which is number of characters read so far */\n    private long position;\n\n    private boolean closed;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(final Reader reader) {\n        super(reader);\n    }\n\n    /**\n     * Closes the stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        // Set ivars before calling super close() in case close() throws an IOException.\n        closed = true;\n        lastChar = END_OF_STREAM;\n        super.close();\n    }\n\n    /**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getCurrentLineNumber() {\n        // Check if we are at EOL or EOF or just starting\n        if (lastChar == CR || lastChar == LF || lastChar == UNDEFINED || lastChar == END_OF_STREAM) {\n            return eolCounter; // counter is accurate\n        }\n        return eolCounter + 1; // Allow for counter being incremented only at EOL\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n     * any of the read methods. This will not include a character read using the {@link #lookAhead()} method. If no\n     * character has been read then this will return {@link Constants#UNDEFINED}. If the end of the stream was reached\n     * on the last read then this will return {@link Constants#END_OF_STREAM}.\n     *\n     * @return the last character that was read\n     */\n    int getLastChar() {\n        return lastChar;\n    }\n\n    /**\n     * Gets the character position in the reader.\n     *\n     * @return the current position in the reader (counting characters, not bytes since this is a Reader)\n     */\n    long getPosition() {\n        return this.position;\n    }\n\n    public boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Returns the next character in the current reader without consuming it. So the next call to {@link #read()} will\n     * still return this value. Does not affect line number or last character.\n     *\n     * @return the next character\n     *\n     * @throws IOException\n     *             if there is an error in reading\n     */\n    int lookAhead() throws IOException {\n        super.mark(1);\n        final int c = super.read();\n        super.reset();\n\n        return c;\n    }\n\n    @Override\n    public int read() throws IOException {\n        final int current = super.read();\n        if (current == CR || current == LF && lastChar != CR) {\n            eolCounter++;\n        }\n        lastChar = current;\n        this.position++;\n        return lastChar;\n    }\n\n    @Override\n    public int read(final char[] buf, final int offset, final int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n\n        final int len = super.read(buf, offset, length);\n\n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n                final char ch = buf[i];\n                if (ch == LF) {\n                    if (CR != (i > 0 ? buf[i - 1] : lastChar)) {\n                        eolCounter++;\n                    }\n                } else if (ch == CR) {\n                    eolCounter++;\n                }\n            }\n\n            lastChar = buf[offset + len - 1];\n\n        } else if (len == -1) {\n            lastChar = END_OF_STREAM;\n        }\n\n        position += len;\n        return len;\n    }\n\n    /**\n     * Calls {@link BufferedReader#readLine()} which drops the line terminator(s). This method should only be called\n     * when processing a comment, otherwise information can be lost.\n     * <p>\n     * Increments {@link #eolCounter}\n     * <p>\n     * Sets {@link #lastChar} to {@link Constants#END_OF_STREAM} at EOF, otherwise to LF\n     *\n     * @return the line that was read, or null if reached EOF.\n     */\n    @Override\n    public String readLine() throws IOException {\n        final String line = super.readLine();\n\n        if (line != null) {\n            lastChar = LF; // needed for detecting start of line\n            eolCounter++;\n        } else {\n            lastChar = END_OF_STREAM;\n        }\n\n        return line;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\nindex b9ca79df9..9731f8186 100644\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n@@ -125,7 +125,8 @@ int lookAhead() throws IOException {\n     @Override\n     public int read() throws IOException {\n         final int current = super.read();\n-        if (current == CR || current == LF && lastChar != CR) {\n+        if ((current == CR || current == LF && lastChar != CR)\n+            || (current == END_OF_STREAM && lastChar != CR && lastChar != LF && lastChar != END_OF_STREAM)) {\n             eolCounter++;\n         }\n         lastChar = current;\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/issues/JiraCsv149Test.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 57,
    "title": "Javadoc typo in CSVFormat let's -> lets",
    "state": "closed",
    "created_at": "2020-02-10T07:09:49Z",
    "merge_commit_sha": "db130e71784f18624debe3f8f763523ff1dd53c4",
    "base_sha": "e60777139fa7e93cf8fac5511c54334f9f36c775",
    "head_sha": "e754863d1304e213e5611a402782134e4456d8e1",
    "user_login": "dota17",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.apache.commons.csv.CSVFormat.RFC4180;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testWithHeaderStringArray() {\n        // Test withHeader method with a String array\n        final String[] header = {\"col1\", \"col2\", \"col3\"};\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader(header);\n        assertEquals(header.length, format.getHeader().length);\n        assertEquals(\"col1\", format.getHeader()[0]);\n        assertEquals(\"col2\", format.getHeader()[1]);\n        assertEquals(\"col3\", format.getHeader()[2]);\n    }\n\n    @Test\n    public void testWithHeaderStringArrayNull() {\n        // Test withHeader method with a null String array\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader((String[]) null);\n        assertEquals(null, format.getHeader());\n    }\n\n    @Test\n    public void testWithHeaderStringArrayEmpty() {\n        // Test withHeader method with an empty String array\n        final String[] header = {};\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader(header);\n        assertEquals(header.length, format.getHeader().length);\n    }\n\n    @Test\n    public void testWithHeaderStringArrayDuplicate() {\n        // Test withHeader method with duplicate header names\n        final String[] header = {\"col1\", \"col1\"};\n        assertThrows(IllegalArgumentException.class, () -> CSVFormat.DEFAULT.withHeader(header));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #INFORMIX_UNLOAD}</li>\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #ORACLE}</li>\n * <li>{@link #POSTGRESQL_CSV}</li>\n * <li>{@link #POSTGRESQL_TEXT}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_CSV\n         * @since 1.7\n         */\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_TSV\n         * @since 1.7\n         */\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#ORACLE\n         */\n        Oracle(CSVFormat.ORACLE),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(true)}</li>\n     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false, true);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code {@link #withDelimiter(char) withDelimiter(',')}}</li>\n     * <li>{@code {@link #withQuote(char) withQuote('\"')}}</li>\n     * <li>{@code {@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}}</li>\n     * <li>{@code {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}}</li>\n     * <li>{@code {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}}</li>\n     * <li>{@code {@link #withAllowDuplicateHeaderNames(boolean) withAllowDuplicateHeaderNames(true)}}</li>\n     * </ul>\n     * <p>\n     * Note: This is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)} and {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with\n     * {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *      documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a tab-delimited format. Values are double quoted only if needed and special\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *          documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_TSV = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote(null)}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default Oracle format used by the SQL*Loader utility.\n     *\n     * <p>\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\n     * {@code \"\"}. Values are trimmed.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withTrim()}</li>\n     * <li>{@code withSystemRecordSeparator()}</li>\n     * <li>{@code withQuoteMode(QuoteMode.MINIMAL)}</li>\n     * </ul>\n     *\n     * @see Predefined#Oracle\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\n     * @since 1.6\n     */\n    // @formatter:off\n    public static final CSVFormat ORACLE = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withNullString(\"\\\\N\")\n            .withTrim()\n            .withSystemRecordSeparator()\n            .withQuoteMode(QuoteMode.MINIMAL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreSurroundingSpaces(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if {@code c} is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if {@code c} is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false, false, true);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowDuplicateHeaderNames;\n\n    private final boolean allowMissingColumnNames;\n\n    private final boolean autoFlush;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final String quotedNullString;\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter, final boolean autoFlush, final boolean allowDuplicateHeaderNames) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n        this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (trailingDelimiter != other.trailingDelimiter) {\n            return false;\n        }\n        if (autoFlush != other.autoFlush) {\n            return false;\n        }\n        if (trim != other.trim) {\n            return false;\n        }\n        if (allowMissingColumnNames != other.allowMissingColumnNames) {\n            return false;\n        }\n        if (allowDuplicateHeaderNames != other.allowDuplicateHeaderNames) {\n            return false;\n        }\n        if (ignoreHeaderCase != other.ignoreHeaderCase) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        if (!Arrays.equals(headerComments, other.headerComments)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns true if and only if duplicate names are allowed in the headers.\n     *\n     * @return whether duplicate header names are allowed\n     * @since 1.7\n     */\n    public boolean getAllowDuplicateHeaderNames() {\n        return allowDuplicateHeaderNames;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     * This is used by {@link #print(Object, Appendable, boolean)}\n     * Also by {@link CSVParser#addRecordValue(boolean)}\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + (allowDuplicateHeaderNames ? 1231 : 1237);\n        result = prime * result + (trim ? 1231 : 1237);\n        result = prime * result + (autoFlush ? 1231 : 1237);\n        result = prime * result + (trailingDelimiter ? 1231 : 1237);\n        result = prime * result + (allowMissingColumnNames ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        result = prime * result + Arrays.hashCode(headerComments);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     * Trims the value if {@link #getTrim()} is true\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quotedNullString;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        } else {\n            if (value instanceof CharSequence) {\n                charSequence = (CharSequence) value;\n            } else if (value instanceof Reader) {\n                print((Reader) value, out, newRecord);\n                return;\n            } else {\n                charSequence = value.toString();\n            }\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        print(value, charSequence, out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord)\n            throws IOException {\n        final int offset = 0;\n        final int len = value.length();\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printWithQuotes(object, value, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(value, out);\n        } else {\n            out.append(value, offset, len);\n        }\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n        // Reader is never null\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (isQuoteCharacterSet()) {\n            printWithQuotes(reader, out);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(reader, out);\n        } else if (out instanceof Writer) {\n            IOUtils.copyLarge(reader, (Writer) out);\n        } else {\n            IOUtils.copy(reader, out);\n        }\n\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printWithEscapes(final CharSequence value, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    private void printWithEscapes(final Reader reader, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(builder.substring(start, pos));\n                    builder.setLength(0);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append((char) c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(builder.substring(start, pos));\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printWithQuotes(final Object object, final CharSequence value, final Appendable out,\n            final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        // If escape char not specified, default to the quote char\n        // This avoids having to keep checking whether there is an escape character\n        // at the cost of checking against quote twice\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeCharacter().charValue() : quoteChar;\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(value, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar || c == escapeChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar || c == escapeChar) {\n                // write out the chunk up until this point\n                out.append(value, start, pos);\n                out.append(escapeChar); // now output the escape\n                start = pos; // and restart with the matched char\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\n     *\n     * @throws IOException\n     */\n    private void printWithQuotes(final Reader reader, final Appendable out) throws IOException {\n\n        if (getQuoteMode() == QuoteMode.NONE) {\n            printWithEscapes(reader, out);\n            return;\n        }\n\n        int pos = 0;\n\n        final char quote = getQuoteCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        out.append(quote);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == quote) {\n                // write out segment up until this char\n                if (pos > 0) {\n                    out.append(builder.substring(0, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n\n                out.append(quote);\n                out.append((char) c);\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > 0) {\n            out.append(builder.substring(0, pos));\n        }\n\n        out.append(quote);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (quoteMode != null) {\n            sb.append(' ');\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null && !allowDuplicateHeaderNames) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} that allows duplicate header names.\n     *\n     * @return a new {@code CSVFormat} that allows duplicate header names\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames() {\n        return withAllowDuplicateHeaderNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     *\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces,\n     *        {@code false} to leave the spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line\n     * separator string, typically CR+LF on Windows and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     */\n    public CSVFormat withSystemRecordSeparator() {\n        return withRecordSeparator(System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     * See {@link #getTrim()} for details of where this is used.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex e304bccb5..a75b86334 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -106,7 +106,7 @@\n  * </pre>\n  *\n  * <p>\n- * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n+ * Calling {@link #withHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and\n  * assumes that your CSV source does not contain a first record that also defines column names.\n  *\n  * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n"
      }
    ]
  },
  {
    "pr_number": 52,
    "title": "Add CSVRecord.isSet(int) method",
    "state": "closed",
    "created_at": "2019-12-25T20:49:43Z",
    "merge_commit_sha": "4033a0199e2d0086afeeb07870a687e3b0caf4bf",
    "base_sha": "129641ead46c8faefdb18903e283f7c4f55a000d",
    "head_sha": "827565a715def081359f6d01c782437bdf92b8ff",
    "user_login": "0x100",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVRecordTest2 {\n\n    private String[] values;\n    private CSVRecord record;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        values = new String[] { \"A\", \"B\", \"C\" };\n        final String rowData = String.join(\",\", values);\n        try (final CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(rowData))) {\n            record = parser.iterator().next();\n        }\n    }\n\n    @Test\n    public void testIsSetInt() {\n        // Test with valid indices\n        assertTrue(record.isSet(0));\n        assertTrue(record.isSet(1));\n        assertTrue(record.isSet(2));\n\n        // Test with invalid indices\n        assertFalse(record.isSet(-1));\n        assertFalse(record.isSet(3));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * A CSV record parsed from a CSV file.\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final long serialVersionUID = 1L;\n\n    private final long characterPosition;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    /** The parser that originates this record. */\n    private final CSVParser parser;\n\n    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber,\n            final long characterPosition) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.parser = parser;\n        this.comment = comment;\n        this.characterPosition = characterPosition;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e.toString());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        if (headerMap == null) {\n            throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = headerMap.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                headerMap.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream.\n     */\n    public long getCharacterPosition() {\n        return characterPosition;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    private Map<String, Integer> getHeaderMapRaw() {\n        return parser.getHeaderMapRaw();\n    }\n\n    /**\n     * Returns the parser.\n     *\n     * @return the parser.\n     * @since 1.7\n     */\n    public CSVParser getParser() {\n        return parser;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3\n     */\n    public boolean hasComment() {\n        return comment != null;\n    }\n\n    /**\n     * Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap == null || headerMap.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap != null && headerMap.containsKey(name);\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    @Override\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map\n     *            The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        if (getHeaderMapRaw() == null) {\n            return map;\n        }\n        for (final Entry<String, Integer> entry : getHeaderMapRaw().entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Converts the values to a List.\n     *\n     * TODO: Maybe make this public?\n     *\n     * @return a new List\n     */\n    private List<String> toList() {\n        return Arrays.asList(values);\n    }\n\n    /**\n     * Copies this record into a new Map of header name to record value.\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new LinkedHashMap<String, String>(values.length));\n    }\n\n    /**\n     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.\n     */\n    @Override\n    public String toString() {\n        return \"CSVRecord [comment='\" + comment + \"', recordNumber=\" + recordNumber + \", values=\" +\n            Arrays.toString(values) + \"]\";\n    }\n\n    String[] values() {\n        return values;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex b1b3f9954..e063edc31 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -214,6 +214,17 @@ public boolean isSet(final String name) {\n         return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n     }\n \n+    /**\n+     * Checks whether a column with given index has a value.\n+     *\n+     * @param i\n+     *         a column index (0-based)\n+     * @return whether a column with given index has a value\n+     */\n+    public boolean isSet(final int i) {\n+        return 0 <= i && i < values.length;\n+    }\n+\n     /**\n      * Returns an iterator over the values of this record.\n      *\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVRecordTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 47,
    "title": "CSV-247: CSVParser to check an empty header before checking duplicates.",
    "state": "closed",
    "created_at": "2019-07-03T08:49:48Z",
    "merge_commit_sha": "059649167c5045dfd40ebf0f97def33a9235c3d1",
    "base_sha": "dcc44cdcd1419c65cc0b51a7368f3a63a06e9872",
    "head_sha": "c4633eada5bc97cd8e4245954891738364428da3",
    "user_login": "aherbert",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport java.io.StringReader;\nimport org.junit.jupiter.api.Test;\n\npublic class CSVParserTest2 {\n\n    @Test\n    public void testEmptyHeaderNotAllowed() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            CSVParser.parse(\"a,,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames(false));\n        });\n    }\n\n    @Test\n    public void testDuplicateHeaderNotAllowedWithEmptyHeader() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            CSVParser.parse(\"a,,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader().withAllowDuplicateHeaderNames(false).withAllowMissingColumnNames(true));\n        });\n    }\n\n    @Test\n    public void testDuplicateHeaderAllowedWithEmptyHeader() throws Exception {\n        try (CSVParser parser = CSVParser.parse(\"a,,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader().withAllowDuplicateHeaderNames(true).withAllowMissingColumnNames(true))) {\n            // Ensure the parser does not throw an exception\n            parser.getRecords();\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n\n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n\n            return this.current != null;\n        }\n\n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n\n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n\n            return next;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newInputStream(path), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    /** The column order to avoid re-computing it. */\n    private final List<String> headerNames;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n        throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        final Headers headers = createHeaders();\n        this.headerMap = headers.headerMap;\n        this.headerNames = headers.headerNames;\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    private Map<String, Integer> createEmptyHeaderMap() {\n        return this.format.getIgnoreHeaderCase() ?\n                new TreeMap<>(String.CASE_INSENSITIVE_ORDER) :\n                new LinkedHashMap<>();\n    }\n\n    /**\n     * Header information based on name and position.\n     */\n    private static final class Headers {\n        /**\n         * Header column positions (0-based)\n         */\n        final Map<String, Integer> headerMap;\n\n        /**\n         * Header names in column order\n         */\n        final List<String> headerNames;\n\n        Headers(final Map<String, Integer> headerMap, final List<String> headerNames) {\n            this.headerMap = headerMap;\n            this.headerNames = headerNames;\n        }\n    }\n\n    /**\n     * Creates the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Headers createHeaders() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        List<String> headerNames = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = createEmptyHeaderMap();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = header != null && hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader) {\n                        if (!emptyHeader && !this.format.getAllowDuplicateHeaderNames()) {\n                            throw new IllegalArgumentException(\n                                String.format(\n                                    \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.withAllowDuplicateHeaderNames().\",\n                                    header, Arrays.toString(headerRecord)));\n                        }\n                        if (emptyHeader && !this.format.getAllowMissingColumnNames()) {\n                            throw new IllegalArgumentException(\n                                    \"A header name is missing in \" + Arrays.toString(headerRecord));\n                        }\n                    }\n                    if (header != null) {\n                        hdrMap.put(header, Integer.valueOf(i));\n                        if (headerNames == null) {\n                            headerNames = new ArrayList<>(headerRecord.length);\n                        }\n                        headerNames.add(header);\n                    }\n                }\n            }\n        }\n        if (headerNames == null) {\n            headerNames = Collections.emptyList(); //immutable\n        } else {\n            headerNames = Collections.unmodifiableList(headerNames);\n        }\n        return new Headers(hdrMap, headerNames);\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        if (this.headerMap == null) {\n            return null;\n        }\n        final Map<String, Integer> map = createEmptyHeaderMap();\n        map.putAll(this.headerMap);\n        return map;\n    }\n\n    /**\n     * Returns the header map.\n     *\n     * @return the header map.\n     */\n    Map<String, Integer> getHeaderMapRaw() {\n        return this.headerMap;\n    }\n\n    /**\n     * Returns a read-only list of header names that iterates in column order.\n     *\n     * @return read-only list of header names that iterates in column order.\n     * @since 1.7\n     */\n    public List<String> getHeaderNames() {\n        return headerNames;\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this, this.recordList.toArray(new String[this.recordList.size()]),\n                comment, this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 3b3b3e7cb..3803d9676 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -495,19 +495,18 @@ private Headers createHeaders() throws IOException {\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n-                    final boolean containsHeader = header != null && hdrMap.containsKey(header);\n                     final boolean emptyHeader = header == null || header.trim().isEmpty();\n-                    if (containsHeader) {\n-                        if (!emptyHeader && !this.format.getAllowDuplicateHeaderNames()) {\n-                            throw new IllegalArgumentException(\n-                                String.format(\n-                                    \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.withAllowDuplicateHeaderNames().\",\n-                                    header, Arrays.toString(headerRecord)));\n-                        }\n-                        if (emptyHeader && !this.format.getAllowMissingColumnNames()) {\n-                            throw new IllegalArgumentException(\n-                                    \"A header name is missing in \" + Arrays.toString(headerRecord));\n-                        }\n+                    if (emptyHeader && !this.format.getAllowMissingColumnNames()) {\n+                        throw new IllegalArgumentException(\n+                            \"A header name is missing in \" + Arrays.toString(headerRecord));\n+                    }\n+                    // Note: This will always allow a duplicate header if the header is empty\n+                    final boolean containsHeader = header != null && hdrMap.containsKey(header);\n+                    if (containsHeader && !emptyHeader && !this.format.getAllowDuplicateHeaderNames()) {\n+                        throw new IllegalArgumentException(\n+                            String.format(\n+                                \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.withAllowDuplicateHeaderNames().\",\n+                                header, Arrays.toString(headerRecord)));\n                     }\n                     if (header != null) {\n                         hdrMap.put(header, Integer.valueOf(i));\n"
      },
      {
        "filename": "src/main/resources/checkstyle/checkstyle-suppressions.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/issues/JiraCsv247Test.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 44,
    "title": "Post release fixes",
    "state": "closed",
    "created_at": "2019-06-13T21:21:32Z",
    "merge_commit_sha": "03550ab565e55f509def8995c3c852b8686e80b2",
    "base_sha": "42b9fdb099a438886842795d8b0b325952d9f3e9",
    "head_sha": "e9e98f0050bd99fef8a9700bedf82828364760c4",
    "user_login": "aherbert",
    "changed_files": [
      {
        "filename": "pom.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\nimport java.io.StringWriter;\nimport java.io.IOException;\n\nimport org.junit.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testFormatWithTryWithoutFinal() {\n        CSVFormat format = CSVFormat.DEFAULT;\n        StringWriter out = new StringWriter();\n        try (CSVPrinter csvPrinter = new CSVPrinter(out, format)) {\n            csvPrinter.printRecord(\"a\", \"b\", \"c\");\n            assertEquals(\"a,b,c\", out.toString().trim());\n        } catch (IOException e) {\n            fail(\"IOException should not have been thrown\");\n        }\n    }\n\n    @Test\n    public void testWithAllowDuplicateHeaderNamesIndentation() {\n        CSVFormat format = CSVFormat.DEFAULT.withAllowDuplicateHeaderNames();\n        assertEquals(true, format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testWithAllowDuplicateHeaderNamesBooleanIndentation() {\n        CSVFormat format = CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(false);\n        assertEquals(false, format.getAllowDuplicateHeaderNames());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #INFORMIX_UNLOAD}</li>\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #ORACLE}</li>\n * <li>{@link #POSTGRESQL_CSV}</li>\n * <li>{@link #POSTGRESQL_TEXT}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_CSV\n         * @since 1.7\n         */\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_TSV\n         * @since 1.7\n         */\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#ORACLE\n         */\n        Oracle(CSVFormat.ORACLE),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(true)}</li>\n     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false, true);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code {@link #withDelimiter(char) withDelimiter(',')}}</li>\n     * <li>{@code {@link #withQuote(char) withQuote('\"')}}</li>\n     * <li>{@code {@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}}</li>\n     * <li>{@code {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}}</li>\n     * <li>{@code {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}}</li>\n     * <li>{@code {@link #withAllowDuplicateHeaderNames(boolean) withAllowDuplicateHeaderNames(true)}}</li>\n     * </ul>\n     * <p>\n     * Note: This is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)} and {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with\n     * {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *      documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a tab-delimited format. Values are double quoted only if needed and special\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *          documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_TSV = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote(null)}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default Oracle format used by the SQL*Loader utility.\n     *\n     * <p>\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\n     * {@code \"\"}. Values are trimmed.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withTrim()}</li>\n     * <li>{@code withSystemRecordSeparator()}</li>\n     * <li>{@code withQuoteMode(QuoteMode.MINIMAL)}</li>\n     * </ul>\n     *\n     * @see Predefined#Oracle\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\n     * @since 1.6\n     */\n    // @formatter:off\n    public static final CSVFormat ORACLE = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withNullString(\"\\\\N\")\n            .withTrim()\n            .withSystemRecordSeparator()\n            .withQuoteMode(QuoteMode.MINIMAL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreSurroundingSpaces(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false, false, true);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowDuplicateHeaderNames;\n\n    private final boolean allowMissingColumnNames;\n\n    private final boolean autoFlush;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final String quotedNullString;\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter, final boolean autoFlush, final boolean allowDuplicateHeaderNames) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n        this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (trailingDelimiter != other.trailingDelimiter) {\n            return false;\n        }\n        if (autoFlush != other.autoFlush) {\n            return false;\n        }\n        if (trim != other.trim) {\n            return false;\n        }\n        if (allowMissingColumnNames != other.allowMissingColumnNames) {\n            return false;\n        }\n        if (allowDuplicateHeaderNames != other.allowDuplicateHeaderNames) {\n            return false;\n        }\n        if (ignoreHeaderCase != other.ignoreHeaderCase) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        if (!Arrays.equals(headerComments, other.headerComments)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns true if and only if duplicate names are allowed in the headers.\n     *\n     * @return whether duplicate header names are allowed\n     * @since 1.7\n     */\n    public boolean getAllowDuplicateHeaderNames() {\n        return allowDuplicateHeaderNames;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + (allowDuplicateHeaderNames ? 1231 : 1237);\n        result = prime * result + (trim ? 1231 : 1237);\n        result = prime * result + (autoFlush ? 1231 : 1237);\n        result = prime * result + (trailingDelimiter ? 1231 : 1237);\n        result = prime * result + (allowMissingColumnNames ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        result = prime * result + Arrays.hashCode(headerComments);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quotedNullString;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        } else {\n            if (value instanceof CharSequence) {\n                charSequence = (CharSequence) value;\n            } else if (value instanceof Reader) {\n                print((Reader) value, out, newRecord);\n                return;\n            } else {\n                charSequence = value.toString();\n            }\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        print(value, charSequence, out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord)\n            throws IOException {\n        final int offset = 0;\n        final int len = value.length();\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printWithQuotes(object, value, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(value, out);\n        } else {\n            out.append(value, offset, len);\n        }\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n        // Reader is never null\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (isQuoteCharacterSet()) {\n            printWithQuotes(reader, out);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(reader, out);\n        } else if (out instanceof Writer) {\n            IOUtils.copyLarge(reader, (Writer) out);\n        } else {\n            IOUtils.copy(reader, out);\n        }\n\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printWithEscapes(final CharSequence value, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    private void printWithEscapes(final Reader reader, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(builder.substring(start, pos));\n                    builder.setLength(0);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append((char) c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(builder.substring(start, pos));\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printWithQuotes(final Object object, final CharSequence value, final Appendable out,\n            final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(value, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\n     *\n     * @throws IOException\n     */\n    private void printWithQuotes(final Reader reader, final Appendable out) throws IOException {\n\n        if (getQuoteMode() == QuoteMode.NONE) {\n            printWithEscapes(reader, out);\n            return;\n        }\n\n        int pos = 0;\n\n        final char quote = getQuoteCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        out.append(quote);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == quote) {\n                // write out segment up until this char\n                if (pos > 0) {\n                    out.append(builder.substring(0, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n\n                out.append(quote);\n                out.append((char) c);\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > 0) {\n            out.append(builder.substring(0, pos));\n        }\n\n        out.append(quote);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null && !allowDuplicateHeaderNames) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} that allows duplicate header names.\n     *\n     * @return a new {@code CSVFormat} that allows duplicate header names\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames() {\n    \treturn withAllowDuplicateHeaderNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     *\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     * @since 1.7\n     */\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n    \treturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line\n     * separator string, typically CR+LF on Windows and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     */\n    public CSVFormat withSystemRecordSeparator() {\n        return withRecordSeparator(System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks when printing.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks when printing.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks when printing.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 1111762a9..263943f29 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -892,7 +892,7 @@ public boolean equals(final Object obj) {\n      */\n     public String format(final Object... values) {\n         final StringWriter out = new StringWriter();\n-        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n+        try (CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n             csvPrinter.printRecord(values);\n             return out.toString().trim();\n         } catch (final IOException e) {\n@@ -1713,7 +1713,7 @@ private void validate() throws IllegalArgumentException {\n      * @since 1.7\n      */\n     public CSVFormat withAllowDuplicateHeaderNames() {\n-    \treturn withAllowDuplicateHeaderNames(true);\n+        return withAllowDuplicateHeaderNames(true);\n     }\n \n     /**\n@@ -1724,7 +1724,7 @@ public CSVFormat withAllowDuplicateHeaderNames() {\n      * @since 1.7\n      */\n     public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n-    \treturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                 skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                 allowDuplicateHeaderNames);\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.Test;\n\npublic class CSVParserTest2 {\n\n    @Test\n    public void testCreateHeadersWithDuplicateHeaderNamesAllowed() throws IOException {\n        final String input = \"a,b,a\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader().withAllowDuplicateHeaderNames(true);\n        try (final CSVParser parser = CSVParser.parse(input, format)) {\n            final List<String> headerNames = parser.getHeaderNames();\n            assertEquals(Arrays.asList(\"a\", \"b\", \"a\"), headerNames);\n        }\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCreateHeadersWithDuplicateHeaderNamesNotAllowed() throws IOException {\n        final String input = \"a,b,a\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader().withAllowDuplicateHeaderNames(false);\n        try (final CSVParser parser = CSVParser.parse(input, format)) {\n            fail(\"Expected IllegalArgumentException due to duplicate header names\");\n        }\n    }\n\n    @Test\n    public void testCreateHeadersWithEmptyHeaderNamesAllowed() throws IOException {\n        final String input = \"a,,c\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames(true);\n        try (final CSVParser parser = CSVParser.parse(input, format)) {\n            final List<String> headerNames = parser.getHeaderNames();\n            assertEquals(Arrays.asList(\"a\", \"\", \"c\"), headerNames);\n        }\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCreateHeadersWithEmptyHeaderNamesNotAllowed() throws IOException {\n        final String input = \"a,,c\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames(false);\n        try (final CSVParser parser = CSVParser.parse(input, format)) {\n            fail(\"Expected IllegalArgumentException due to missing header names\");\n        }\n    }\n\n    @Test\n    public void testCreateHeadersWithIgnoreHeaderCase() throws IOException {\n        final String input = \"A,b,C\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader().withIgnoreHeaderCase(true);\n        try (final CSVParser parser = CSVParser.parse(input, format)) {\n            final List<String> headerNames = parser.getHeaderNames();\n            assertTrue(headerNames.contains(\"a\"));\n            assertTrue(headerNames.contains(\"b\"));\n            assertTrue(headerNames.contains(\"c\"));\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n\n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n\n            return this.current != null;\n        }\n\n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n\n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n\n            return next;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newInputStream(path), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    /** The column order to avoid re-computing it. */\n    private final List<String> headerNames;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n        throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        final Headers headers = createHeaders();\n        this.headerMap = headers.headerMap;\n        this.headerNames = headers.headerNames;\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    private Map<String, Integer> createEmptyHeaderMap() {\n        return this.format.getIgnoreHeaderCase() ?\n                new TreeMap<>(String.CASE_INSENSITIVE_ORDER) :\n                new LinkedHashMap<>();\n    }\n\n    /**\n     * Header information based on name and position.\n     */\n    private static final class Headers {\n        /**\n         * Header column positions (0-based)\n         */\n        final Map<String, Integer> headerMap;\n\n        /**\n         * Header names in column order\n         */\n        final List<String> headerNames;\n\n        Headers(final Map<String, Integer> headerMap, final List<String> headerNames) {\n            this.headerMap = headerMap;\n            this.headerNames = headerNames;\n        }\n    }\n\n    /**\n     * Creates the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Headers createHeaders() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        List<String> headerNames = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = createEmptyHeaderMap();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = header == null ? false : hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader) {\n                        if (!emptyHeader && !this.format.getAllowDuplicateHeaderNames()) {\n                            throw new IllegalArgumentException(\n                                String.format(\n                                    \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.withAllowDuplicateHeaderNames().\",\n                                    header, Arrays.toString(headerRecord)));\n                        }\n                        if (emptyHeader && !this.format.getAllowMissingColumnNames()) {\n                            throw new IllegalArgumentException(\n                                    \"A header name is missing in \" + Arrays.toString(headerRecord));\n                        }\n                    }\n                    if (header != null) {\n                        hdrMap.put(header, Integer.valueOf(i));\n                        if (headerNames == null) {\n                            headerNames = new ArrayList<>(headerRecord.length);\n                        }\n                        headerNames.add(header);\n                    }\n                }\n            }\n        }\n        if (headerNames == null) {\n        \theaderNames = Collections.emptyList(); //immutable\n        } else {\n        \theaderNames = Collections.unmodifiableList(headerNames);\n        }\n        return new Headers(hdrMap, headerNames);\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        if (this.headerMap == null) {\n            return null;\n        }\n        final Map<String, Integer> map = createEmptyHeaderMap();\n        map.putAll(this.headerMap);\n        return map;\n    }\n\n    /**\n     * Returns the header map.\n     *\n     * @return the header map.\n     */\n    Map<String, Integer> getHeaderMapRaw() {\n        return this.headerMap;\n    }\n\n    /**\n     * Returns a read-only list of header names that iterates in column order.\n     *\n     * @return read-only list of header names that iterates in column order.\n     * @since 1.7\n     */\n    public List<String> getHeaderNames() {\n        return headerNames;\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this, this.recordList.toArray(new String[this.recordList.size()]),\n                comment, this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex a8b16c2c2..3b3b3e7cb 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -495,7 +495,7 @@ private Headers createHeaders() throws IOException {\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n-                    final boolean containsHeader = header == null ? false : hdrMap.containsKey(header);\n+                    final boolean containsHeader = header != null && hdrMap.containsKey(header);\n                     final boolean emptyHeader = header == null || header.trim().isEmpty();\n                     if (containsHeader) {\n                         if (!emptyHeader && !this.format.getAllowDuplicateHeaderNames()) {\n@@ -520,9 +520,9 @@ private Headers createHeaders() throws IOException {\n             }\n         }\n         if (headerNames == null) {\n-        \theaderNames = Collections.emptyList(); //immutable\n+            headerNames = Collections.emptyList(); //immutable\n         } else {\n-        \theaderNames = Collections.unmodifiableList(headerNames);\n+            headerNames = Collections.unmodifiableList(headerNames);\n         }\n         return new Headers(hdrMap, headerNames);\n     }\n"
      },
      {
        "filename": "src/main/resources/checkstyle/checkstyle-suppressions.xml",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/resources/findbugs/findbugs-exclude-filter.xml",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/resources/pmd/pmd-ruleset.xml",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVPrinterTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 42,
    "title": "[CSV-239] Add javadoc to CSVFormat",
    "state": "closed",
    "created_at": "2019-05-27T21:45:55Z",
    "merge_commit_sha": "474b7f4d00387aefa7abc559034ab58ee92e62b6",
    "base_sha": "dca99998f17a9755dfb40ed30bc1734e54ba0b04",
    "head_sha": "e177f5dc37e737b0fcc1649ab08ac3096a610e0d",
    "user_login": "davidmoten",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport org.junit.Test;\n\npublic class CSVFormatTest2 {\n\n    /**\n     * Test for the getAllowDuplicateHeaderNames method.\n     */\n    @Test\n    public void testGetAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(true);\n        assertTrue(format.getAllowDuplicateHeaderNames());\n\n        format = CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(false);\n        assertFalse(format.getAllowDuplicateHeaderNames());\n    }\n\n    /**\n     * Test for the withAllowDuplicateHeaderNames method.\n     */\n    @Test\n    public void testWithAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.DEFAULT.withAllowDuplicateHeaderNames();\n        assertTrue(format.getAllowDuplicateHeaderNames());\n\n        format = CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(false);\n        CSVFormat newFormat = format.withAllowDuplicateHeaderNames();\n        assertTrue(newFormat.getAllowDuplicateHeaderNames());\n    }\n\n    /**\n     * Test for the withAllowDuplicateHeaderNames method with a parameter.\n     */\n    @Test\n    public void testWithAllowDuplicateHeaderNamesWithParameter() {\n        CSVFormat format = CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(false);\n        CSVFormat newFormat = format.withAllowDuplicateHeaderNames(true);\n        assertTrue(newFormat.getAllowDuplicateHeaderNames());\n\n        newFormat = format.withAllowDuplicateHeaderNames(false);\n        assertFalse(newFormat.getAllowDuplicateHeaderNames());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #INFORMIX_UNLOAD}</li>\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #ORACLE}</li>\n * <li>{@link #POSTGRESQL_CSV}</li>\n * <li>{@link #POSTGRESQL_TEXT}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_CSV\n         * @since 1.7\n         */\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_TSV\n         * @since 1.7\n         */\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#ORACLE\n         */\n        Oracle(CSVFormat.ORACLE),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(true)}</li>\n     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false, true);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code {@link #withDelimiter(char) withDelimiter(',')}}</li>\n     * <li>{@code {@link #withQuote(char) withQuote('\"')}}</li>\n     * <li>{@code {@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}}</li>\n     * <li>{@code {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}}</li>\n     * <li>{@code {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}}</li>\n     * <li>{@code {@link #withAllowDuplicateHeaderNames(boolean) withAllowDuplicateHeaderNames(true)}}</li>\n     * </ul>\n     * <p>\n     * Note: This is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)} and {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with\n     * {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *      documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a tab-delimited format. Values are double quoted only if needed and special\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *          documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_TSV = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote(null)}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default Oracle format used by the SQL*Loader utility.\n     *\n     * <p>\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\n     * {@code \"\"}. Values are trimmed.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withTrim()}</li>\n     * <li>{@code withSystemRecordSeparator()}</li>\n     * <li>{@code withQuoteMode(QuoteMode.MINIMAL)}</li>\n     * </ul>\n     *\n     * @see Predefined#Oracle\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\n     * @since 1.6\n     */\n    // @formatter:off\n    public static final CSVFormat ORACLE = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withNullString(\"\\\\N\")\n            .withTrim()\n            .withSystemRecordSeparator()\n            .withQuoteMode(QuoteMode.MINIMAL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreSurroundingSpaces(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false, false, true);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowDuplicateHeaderNames;\n\n    private final boolean allowMissingColumnNames;\n\n    private final boolean autoFlush;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final String quotedNullString;\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter, final boolean autoFlush, final boolean allowDuplicateHeaderNames) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n        this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public boolean getAllowDuplicateHeaderNames() {\n\t\treturn allowDuplicateHeaderNames;\n\t}\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quotedNullString;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        } else {\n            if (value instanceof CharSequence) {\n                charSequence = (CharSequence) value;\n            } else if (value instanceof Reader) {\n                print((Reader) value, out, newRecord);\n                return;\n            } else {\n                charSequence = value.toString();\n            }\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        print(value, charSequence, out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord)\n            throws IOException {\n        final int offset = 0;\n        final int len = value.length();\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printWithQuotes(object, value, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(value, out);\n        } else {\n            out.append(value, offset, len);\n        }\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n        // Reader is never null\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (isQuoteCharacterSet()) {\n            printWithQuotes(reader, out);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(reader, out);\n        } else if (out instanceof Writer) {\n            IOUtils.copyLarge(reader, (Writer) out);\n        } else {\n            IOUtils.copy(reader, out);\n        }\n\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printWithEscapes(final CharSequence value, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    private void printWithEscapes(final Reader reader, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(builder.substring(start, pos));\n                    builder.setLength(0);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append((char) c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(builder.substring(start, pos));\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printWithQuotes(final Object object, final CharSequence value, final Appendable out,\n            final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(value, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\n     *\n     * @throws IOException\n     */\n    private void printWithQuotes(final Reader reader, final Appendable out) throws IOException {\n\n        if (getQuoteMode() == QuoteMode.NONE) {\n            printWithEscapes(reader, out);\n            return;\n        }\n\n        int pos = 0;\n\n        final char quote = getQuoteCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        out.append(quote);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == quote) {\n                // write out segment up until this char\n                if (pos > 0) {\n                    out.append(builder.substring(0, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n\n                out.append(quote);\n                out.append((char) c);\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > 0) {\n            out.append(builder.substring(0, pos));\n        }\n\n        out.append(quote);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    public CSVFormat withAllowDuplicateHeaderNames() {\n    \treturn withAllowDuplicateHeaderNames(true);\n    }\n\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n    \treturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line\n     * separator string, typically CR+LF on Windows and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     */\n    public CSVFormat withSystemRecordSeparator() {\n        return withRecordSeparator(System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n                allowDuplicateHeaderNames);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex f6d162304..1c0e2d4db 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -880,6 +880,11 @@ public String format(final Object... values) {\n         }\n     }\n \n+    /**\n+     * Returns true if and only if duplicate names are allowed in the headers.\n+     * \n+     * @return whether duplicate header names are allowed\n+     */\n     public boolean getAllowDuplicateHeaderNames() {\n \t\treturn allowDuplicateHeaderNames;\n \t}\n@@ -1673,10 +1678,20 @@ private void validate() throws IllegalArgumentException {\n         }\n     }\n \n+    /**\n+     * Returns a new {@code CSVFormat} that allows duplicate header names.\n+     * \n+     * @return a new {@code CSVFormat} that allows duplicate header names\n+     */\n     public CSVFormat withAllowDuplicateHeaderNames() {\n     \treturn withAllowDuplicateHeaderNames(true);\n     }\n \n+    /**\n+     * Returns a new {@code CSVFormat} with duplicate header names behaviour set to the given value.\n+     * \n+     * @return a new {@code CSVFormat} with duplicate header names behaviour set to the given value\n+     */\n     public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n     \treturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n"
      }
    ]
  },
  {
    "pr_number": 41,
    "title": "[CSV-239] Add CSVRecord.getHeaderNames and allow duplicate headers",
    "state": "closed",
    "created_at": "2019-05-22T02:20:47Z",
    "merge_commit_sha": "030fb8e37c4024b24fac2b5404300449a6741699",
    "base_sha": "4d2616b7a550c2ce855b612829eb34dea9ce09dc",
    "head_sha": "2a5ddb72aeec50180de878386b4be04a6f41c49c",
    "user_login": "davidmoten",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\n\nimport org.junit.Test;\n\npublic class CSVFormatTest2 {\n\n    @Test\n    public void testWithAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.DEFAULT.withAllowDuplicateHeaderNames();\n        assertTrue(format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testWithAllowDuplicateHeaderNamesFalse() {\n        CSVFormat format = CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(false);\n        assertFalse(format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testDefaultAllowDuplicateHeaderNames() {\n        assertTrue(CSVFormat.DEFAULT.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testEqualsAllowDuplicateHeaderNames() {\n        CSVFormat right = CSVFormat.DEFAULT.withAllowDuplicateHeaderNames(true);\n        CSVFormat left = right.withAllowDuplicateHeaderNames(false);\n        assertNotEquals(right, left);\n    }\n\n    @Test\n    public void testNewFormatAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.newFormat(';');\n        assertTrue(format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testWithHeaderAllowDuplicateHeaderNames() {\n        String[] header = new String[]{\"one\", \"two\", \"three\"};\n        CSVFormat format = CSVFormat.DEFAULT.withHeader(header).withAllowDuplicateHeaderNames();\n        assertTrue(format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testWithHeaderCommentsAllowDuplicateHeaderNames() {\n        Object[] headerComments = new Object[]{\"comment1\", \"comment2\"};\n        CSVFormat format = CSVFormat.DEFAULT.withHeaderComments(headerComments).withAllowDuplicateHeaderNames();\n        assertTrue(format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testWithNullStringAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.DEFAULT.withNullString(\"null\").withAllowDuplicateHeaderNames();\n        assertTrue(format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testWithQuoteAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.DEFAULT.withQuote('\"').withAllowDuplicateHeaderNames();\n        assertTrue(format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testWithRecordSeparatorAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withAllowDuplicateHeaderNames();\n        assertTrue(format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testWithSkipHeaderRecordAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.DEFAULT.withSkipHeaderRecord().withAllowDuplicateHeaderNames();\n        assertTrue(format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testWithTrailingDelimiterAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.DEFAULT.withTrailingDelimiter().withAllowDuplicateHeaderNames();\n        assertTrue(format.getAllowDuplicateHeaderNames());\n    }\n\n    @Test\n    public void testWithTrimAllowDuplicateHeaderNames() {\n        CSVFormat format = CSVFormat.DEFAULT.withTrim().withAllowDuplicateHeaderNames();\n        assertTrue(format.getAllowDuplicateHeaderNames());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #INFORMIX_UNLOAD}</li>\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #ORACLE}</li>\n * <li>{@link #POSTGRESQL_CSV}</li>\n * <li>{@link #POSTGRESQL_TEXT}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_CSV\n         * @since 1.7\n         */\n        MongoDBCsv(CSVFormat.MONGODB_CSV),\n\n        /**\n         * @see CSVFormat#MONGODB_TSV\n         * @since 1.7\n         */\n        MongoDBTsv(CSVFormat.MONGODB_TSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#ORACLE\n         */\n        Oracle(CSVFormat.ORACLE),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard Comma Separated Value format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code {@link #withDelimiter(char) withDelimiter(',')}}</li>\n     * <li>{@code {@link #withQuote(char) withQuote('\"')}}</li>\n     * <li>{@code {@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}}</li>\n     * <li>{@code {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}}</li>\n     * <li>{@code {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}}</li>\n     * </ul>\n     * <p>\n     * Note: This is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)} and {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote(\"\\\"\")}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MongoDB CSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a comma-delimited format. Values are double quoted only if needed and special characters are escaped with\n     * {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *      documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MongoDB TSV format used by the {@code mongoexport} operation.\n     * <p>\n     * <b>Parsing is not supported yet.</b>\n     * </p>\n     *\n     * <p>\n     * This is a tab-delimited format. Values are double quoted only if needed and special\n     * characters are escaped with {@code '\"'}. A header line with field names is expected.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * <li>{@code withSkipHeaderRecord(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#MongoDBCsv\n     * @see <a href=\"https://docs.mongodb.com/manual/reference/program/mongoexport/\">MongoDB mongoexport command\n     *          documentation</a>\n     * @since 1.7\n     */\n    // @formatter:off\n    public static final CSVFormat MONGODB_TSV = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withQuoteMode(QuoteMode.MINIMAL)\n            .withSkipHeaderRecord(false);\n    // @formatter:off\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote(null)}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default Oracle format used by the SQL*Loader utility.\n     *\n     * <p>\n     * This is a comma-delimited format with the system line separator character as the record separator.Values are\n     * double quoted when needed and special characters are escaped with {@code '\"'}. The default NULL string is\n     * {@code \"\"}. Values are trimmed.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',') // default is {@code FIELDS TERMINATED BY ','}}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')  // default is {@code OPTIONALLY ENCLOSED BY '\"'}}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withTrim()}</li>\n     * <li>{@code withSystemRecordSeparator()}</li>\n     * <li>{@code withQuoteMode(QuoteMode.MINIMAL)}</li>\n     * </ul>\n     *\n     * @see Predefined#Oracle\n     * @see <a href=\"https://s.apache.org/CGXG\">Oracle CSV Format Specification</a>\n     * @since 1.6\n     */\n    // @formatter:off\n    public static final CSVFormat ORACLE = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withNullString(\"\\\\N\")\n            .withTrim()\n            .withSystemRecordSeparator()\n            .withQuoteMode(QuoteMode.MINIMAL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withEscape('\"')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withEscape('\\\\')}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator('\\n')}</li>\n     * <li>{@code withNullString(\"\\\\N\")}</li>\n     * <li>{@code withQuoteMode(QuoteMode.ALL_NON_NULL)}</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"https://www.postgresql.org/docs/current/static/sql-copy.html\">PostgreSQL COPY command\n     *          documentation</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter(',')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreEmptyLines(false)}</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@code withDelimiter('\\t')}</li>\n     * <li>{@code withQuote('\"')}</li>\n     * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@code withIgnoreSurroundingSpaces(true)}</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false, false);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowMissingColumnNames;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final String quotedNullString;\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    private final boolean autoFlush;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter, final boolean autoFlush) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quotedNullString;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        } else {\n            if (value instanceof CharSequence) {\n                charSequence = (CharSequence) value;\n            } else if (value instanceof Reader) {\n                print((Reader) value, out, newRecord);\n                return;\n            } else {\n                charSequence = value.toString();\n            }\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        print(value, charSequence, out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord)\n            throws IOException {\n        final int offset = 0;\n        final int len = value.length();\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printWithQuotes(object, value, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(value, out);\n        } else {\n            out.append(value, offset, len);\n        }\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n        // Reader is never null\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (isQuoteCharacterSet()) {\n            printWithQuotes(reader, out);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(reader, out);\n        } else if (out instanceof Writer) {\n            IOUtils.copyLarge(reader, (Writer) out);\n        } else {\n            IOUtils.copy(reader, out);\n        }\n\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printWithEscapes(final CharSequence value, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    private void printWithEscapes(final Reader reader, final Appendable out) throws IOException {\n        int start = 0;\n        int pos = 0;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(builder.substring(start, pos));\n                    builder.setLength(0);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append((char) c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(builder.substring(start, pos));\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printWithQuotes(final Object object, final CharSequence value, final Appendable out,\n            final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = 0;\n        int pos = 0;\n        final int len = value.length();\n        final int end = len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(value, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\n     *\n     * @throws IOException\n     */\n    private void printWithQuotes(final Reader reader, final Appendable out) throws IOException {\n\n        if (getQuoteMode() == QuoteMode.NONE) {\n            printWithEscapes(reader, out);\n            return;\n        }\n\n        int pos = 0;\n\n        final char quote = getQuoteCharacter().charValue();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n\n        out.append(quote);\n\n        int c;\n        while (-1 != (c = reader.read())) {\n            builder.append((char) c);\n            if (c == quote) {\n                // write out segment up until this char\n                if (pos > 0) {\n                    out.append(builder.substring(0, pos));\n                    builder.setLength(0);\n                    pos = -1;\n                }\n\n                out.append(quote);\n                out.append((char) c);\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > 0) {\n            out.append(builder.substring(0, pos));\n        }\n\n        out.append(quote);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the operating system's line\n     * separator string, typically CR+LF on Windows and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     */\n    public CSVFormat withSystemRecordSeparator() {\n        return withRecordSeparator(System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 6f77bef53..33130b0b5 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -260,12 +260,13 @@ public CSVFormat getFormat() {\n      * <li>{@code withQuote('\"')}</li>\n      * <li>{@code withRecordSeparator(\"\\r\\n\")}</li>\n      * <li>{@code withIgnoreEmptyLines(true)}</li>\n+     * <li>{@code withAllowDuplicateHeaderNames(true)}</li>\n      * </ul>\n      *\n      * @see Predefined#Default\n      */\n     public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n-            null, null, null, false, false, false, false, false, false);\n+            null, null, null, false, false, false, false, false, false, true);\n \n     /**\n      * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n@@ -288,6 +289,7 @@ public CSVFormat getFormat() {\n      * <li>{@code {@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}}</li>\n      * <li>{@code {@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}}</li>\n      * <li>{@code {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}}</li>\n+     * <li>{@code {@link #withAllowDuplicateHeaderNames(boolean) withAllowDuplicateHeaderNames(true)}}</li>\n      * </ul>\n      * <p>\n      * Note: This is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n@@ -671,7 +673,7 @@ private static boolean isLineBreak(final Character c) {\n      */\n     public static CSVFormat newFormat(final char delimiter) {\n         return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n-                false, false, false, false);\n+                false, false, false, false, true);\n     }\n \n     /**\n@@ -721,6 +723,8 @@ public static CSVFormat valueOf(final String format) {\n     private final boolean trim;\n \n     private final boolean autoFlush;\n+    \n+    private final boolean allowDuplicateHeaderNames;\n \n     /**\n      * Creates a customized CSV format.\n@@ -766,7 +770,7 @@ private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMo\n             final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n             final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n             final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n-            final boolean trailingDelimiter, final boolean autoFlush) {\n+            final boolean trailingDelimiter, final boolean autoFlush, final boolean allowDuplicateHeaderNames) {\n         this.delimiter = delimiter;\n         this.quoteCharacter = quoteChar;\n         this.quoteMode = quoteMode;\n@@ -785,6 +789,7 @@ private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMo\n         this.trim = trim;\n         this.autoFlush = autoFlush;\n         this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n+        this.allowDuplicateHeaderNames = allowDuplicateHeaderNames;\n         validate();\n     }\n \n@@ -1686,7 +1691,8 @@ public CSVFormat withAllowMissingColumnNames() {\n     public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush, \n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -1701,7 +1707,8 @@ public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNam\n     public CSVFormat withAutoFlush(final boolean autoFlush) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -1736,7 +1743,8 @@ public CSVFormat withCommentMarker(final Character commentMarker) {\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -1754,7 +1762,8 @@ public CSVFormat withDelimiter(final char delimiter) {\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -1785,7 +1794,8 @@ public CSVFormat withEscape(final Character escape) {\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                 ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n-                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -1941,7 +1951,8 @@ public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLExceptio\n     public CSVFormat withHeader(final String... header) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -1962,7 +1973,8 @@ public CSVFormat withHeader(final String... header) {\n     public CSVFormat withHeaderComments(final Object... headerComments) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -1987,7 +1999,8 @@ public CSVFormat withIgnoreEmptyLines() {\n     public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -2013,7 +2026,8 @@ public CSVFormat withIgnoreHeaderCase() {\n     public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -2038,7 +2052,8 @@ public CSVFormat withIgnoreSurroundingSpaces() {\n     public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -2057,7 +2072,8 @@ public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpac\n     public CSVFormat withNullString(final String nullString) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -2088,7 +2104,8 @@ public CSVFormat withQuote(final Character quoteChar) {\n         }\n         return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                 ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n-                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -2102,7 +2119,8 @@ public CSVFormat withQuote(final Character quoteChar) {\n     public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -2140,7 +2158,8 @@ public CSVFormat withRecordSeparator(final char recordSeparator) {\n     public CSVFormat withRecordSeparator(final String recordSeparator) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -2167,7 +2186,8 @@ public CSVFormat withSkipHeaderRecord() {\n     public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -2208,7 +2228,8 @@ public CSVFormat withTrailingDelimiter() {\n     public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n \n     /**\n@@ -2233,6 +2254,22 @@ public CSVFormat withTrim() {\n     public CSVFormat withTrim(final boolean trim) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n     }\n+    \n+    public CSVFormat withAllowDuplicateHeaderNames(boolean allowDuplicateHeaderNames) {\n+    \treturn new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush,\n+                allowDuplicateHeaderNames);\n+    }\n+\n+    public CSVFormat withAllowDuplicateHeaderNames() {\n+    \treturn withAllowDuplicateHeaderNames(true);\n+    }\n+    \n+    public boolean getAllowDuplicateHeaderNames() {\n+\t\treturn allowDuplicateHeaderNames;\n+\t}\n }\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.List;\n\nimport org.junit.Test;\n\npublic class CSVParserTest2 {\n\n    @Test\n    public void testAllowDuplicateHeaderNames() throws IOException {\n        final String csvData = \"a,a,a\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader().withAllowDuplicateHeaderNames();\n        try (final CSVParser parser = CSVParser.parse(csvData, format)) {\n            final List<CSVRecord> records = parser.getRecords();\n            assertEquals(2, records.size());\n            assertEquals(\"1\", records.get(0).get(0));\n            assertEquals(\"2\", records.get(0).get(1));\n            assertEquals(\"3\", records.get(0).get(2));\n            assertEquals(\"x\", records.get(1).get(0));\n            assertEquals(\"y\", records.get(1).get(1));\n            assertEquals(\"z\", records.get(1).get(2));\n        }\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testDisallowDuplicateHeaderNames() throws IOException {\n        final String csvData = \"a,a,a\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader();\n        try (final CSVParser parser = CSVParser.parse(csvData, format)) {\n            fail(\"Expected IllegalArgumentException due to duplicate header names\");\n        }\n    }\n\n    @Test\n    public void testAllowMissingColumnNames() throws IOException {\n        final String csvData = \"a,,c\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames();\n        try (final CSVParser parser = CSVParser.parse(csvData, format)) {\n            final List<CSVRecord> records = parser.getRecords();\n            assertEquals(2, records.size());\n            assertEquals(\"1\", records.get(0).get(0));\n            assertEquals(\"2\", records.get(0).get(1));\n            assertEquals(\"3\", records.get(0).get(2));\n            assertEquals(\"x\", records.get(1).get(0));\n            assertEquals(\"y\", records.get(1).get(1));\n            assertEquals(\"z\", records.get(1).get(2));\n        }\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testDisallowMissingColumnNames() throws IOException {\n        final String csvData = \"a,,c\\n1,2,3\\nx,y,z\";\n        final CSVFormat format = CSVFormat.DEFAULT.withHeader();\n        try (final CSVParser parser = CSVParser.parse(csvData, format)) {\n            fail(\"Expected IllegalArgumentException due to missing column names\");\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n\n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n\n            return this.current != null;\n        }\n\n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n\n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n\n            return next;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newInputStream(path), charset, format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    /** The column order to avoid re-computing it. */\n    private final List<String> headerNames;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n        throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = createHeaderMap(); // 1st\n        this.headerNames = createHeaderNames(this.headerMap); // 2nd\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    private Map<String, Integer> createEmptyHeaderMap() {\n        return this.format.getIgnoreHeaderCase() ?\n                new TreeMap<>(String.CASE_INSENSITIVE_ORDER) :\n                new LinkedHashMap<>();\n    }\n\n    /**\n     * Creates the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> createHeaderMap() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = createEmptyHeaderMap();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = header == null ? false : hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header\n                                + \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    if (header != null) {\n                        hdrMap.put(header, Integer.valueOf(i));\n                    }\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    private List<String> createHeaderNames(final Map<String, Integer> headerMap) {\n        // @formatter:off\n        return headerMap == null ? null\n            : headerMap.entrySet().stream()\n                .sorted(Map.Entry.comparingByValue())\n                .map(Map.Entry::getKey)\n                .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));\n        // @formatter:on\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        if (this.headerMap == null) {\n            return null;\n        }\n        final Map<String, Integer> map = createEmptyHeaderMap();\n        map.putAll(this.headerMap);\n        return map;\n    }\n\n    /**\n     * Returns the header map.\n     *\n     * @return the header map.\n     */\n    Map<String, Integer> getHeaderMapRaw() {\n        return this.headerMap;\n    }\n\n    /**\n     * Returns a read-only list of header names that iterates in column order.\n     *\n     * @return read-only list of header names that iterates in column order.\n     * @since 1.7\n     */\n    public List<String> getHeaderNames() {\n        return headerNames;\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this, this.recordList.toArray(new String[this.recordList.size()]),\n                comment, this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 15357c05f..eff740225 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -410,8 +410,9 @@ public CSVParser(final Reader reader, final CSVFormat format, final long charact\n         this.format = format;\n         this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n         this.csvRecordIterator = new CSVRecordIterator();\n-        this.headerMap = createHeaderMap(); // 1st\n-        this.headerNames = createHeaderNames(this.headerMap); // 2nd\n+        Headers headers = createHeaders();\n+        this.headerMap = headers.headerMap;\n+        this.headerNames = headers.headerNames;\n         this.characterOffset = characterOffset;\n         this.recordNumber = recordNumber - 1;\n     }\n@@ -445,14 +446,35 @@ private Map<String, Integer> createEmptyHeaderMap() {\n                 new LinkedHashMap<>();\n     }\n \n+    /**\n+     * Header information based on name and position.\n+     */\n+    private static final class Headers {\n+        /**\n+         * Header column positions (0-based)\n+         */\n+        final Map<String, Integer> headerMap;\n+        \n+        /**\n+         * Header names in column order\n+         */\n+        final List<String> headerNames;\n+\n+        Headers(Map<String, Integer> headerMap, List<String> headerNames) {\n+            this.headerMap = headerMap;\n+            this.headerNames = headerNames;\n+        }\n+    }\n+    \n     /**\n      * Creates the name to index mapping if the format defines a header.\n      *\n      * @return null if the format has no header.\n      * @throws IOException if there is a problem reading the header or skipping the first record\n      */\n-    private Map<String, Integer> createHeaderMap() throws IOException {\n+    private Headers createHeaders() throws IOException {\n         Map<String, Integer> hdrMap = null;\n+        List<String> headerNames = null;\n         final String[] formatHeader = this.format.getHeader();\n         if (formatHeader != null) {\n             hdrMap = createEmptyHeaderMap();\n@@ -476,27 +498,34 @@ private Map<String, Integer> createHeaderMap() throws IOException {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = header == null ? false : hdrMap.containsKey(header);\n                     final boolean emptyHeader = header == null || header.trim().isEmpty();\n-                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n-                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header\n-                                + \"\\\" in \" + Arrays.toString(headerRecord));\n+                    if (containsHeader) {\n+                        if (!emptyHeader && !this.format.getAllowDuplicateHeaderNames()) {\n+                            throw new IllegalArgumentException(\n+                                    String.format(\"The header contains a duplicate name: \\\"%s\\\" in %s.\"\n+                                        + \" If this is valid then use CSVFormat.withAllowDuplicateHeaderNames().\", \n+                                        header, Arrays.toString(headerRecord)));\n+                        }\n+                        if (emptyHeader && !this.format.getAllowMissingColumnNames()) {\n+                            throw new IllegalArgumentException(\n+                                    \"A header name is missing in \" + Arrays.toString(headerRecord));\n+                        }\n                     }\n                     if (header != null) {\n                         hdrMap.put(header, Integer.valueOf(i));\n+                        if (headerNames == null) {\n+                        \theaderNames = new ArrayList<>(headerRecord.length);\n+                        }\n+                        headerNames.add(header);\n                     }\n                 }\n             }\n+        } \n+        if (headerNames == null) {\n+        \theaderNames = Collections.emptyList(); //immutable\n+        } else {\n+        \theaderNames = Collections.unmodifiableList(headerNames);\n         }\n-        return hdrMap;\n-    }\n-\n-    private List<String> createHeaderNames(final Map<String, Integer> headerMap) {\n-        // @formatter:off\n-        return headerMap == null ? null\n-            : headerMap.entrySet().stream()\n-                .sorted(Map.Entry.comparingByValue())\n-                .map(Map.Entry::getKey)\n-                .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));\n-        // @formatter:on\n+        return new Headers(hdrMap, headerNames);\n     }\n \n     /**\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.csv;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class CSVRecordTest2 {\n\n    private String[] values;\n    private CSVRecord recordWithHeader;\n\n    @Before\n    public void setUp() throws Exception {\n        values = new String[] { \"A\", \"B\", \"C\" };\n        final String rowData = StringUtils.join(values, ',');\n        final String[] headers = { \"first\", \"second\", \"third\" };\n        try (final CSVParser parser = CSVFormat.DEFAULT.withHeader(headers).parse(new StringReader(rowData))) {\n            recordWithHeader = parser.iterator().next();\n        }\n    }\n\n    /**\n     * Test to ensure that the toMap method correctly copies the record into a new Map.\n     */\n    @Test\n    public void testToMap() {\n        final Map<String, String> map = this.recordWithHeader.toMap();\n        validateMap(map);\n    }\n\n    /**\n     * Helper method to validate the contents of the map.\n     */\n    private void validateMap(final Map<String, String> map) {\n        assertTrue(map.containsKey(\"first\"));\n        assertTrue(map.containsKey(\"second\"));\n        assertTrue(map.containsKey(\"third\"));\n        assertEquals(\"A\", map.get(\"first\"));\n        assertEquals(\"B\", map.get(\"second\"));\n        assertEquals(\"C\", map.get(\"third\"));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * A CSV record parsed from a CSV file.\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final long serialVersionUID = 1L;\n\n    private final long characterPosition;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    /** The parser that originates this record. */\n    private final CSVParser parser;\n\n    CSVRecord(final CSVParser parser, final String[] values, final String comment, final long recordNumber,\n            final long characterPosition) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.parser = parser;\n        this.comment = comment;\n        this.characterPosition = characterPosition;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e.toString());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        if (headerMap == null) {\n            throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = headerMap.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                headerMap.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream.\n     */\n    public long getCharacterPosition() {\n        return characterPosition;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    private Map<String, Integer> getHeaderMapRaw() {\n        return parser.getHeaderMapRaw();\n    }\n\n    /**\n     * Returns the parser.\n     *\n     * @return the parser.\n     * @since 1.7\n     */\n    public CSVParser getParser() {\n        return parser;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3\n     */\n    public boolean hasComment() {\n        return comment != null;\n    }\n\n    /**\n     * Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap == null || headerMap.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap != null && headerMap.containsKey(name);\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && getHeaderMapRaw().get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    @Override\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map\n     *            The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        if (getHeaderMapRaw() == null) {\n            return map;\n        }\n        for (final Entry<String, Integer> entry : getHeaderMapRaw().entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Converts the values to a List.\n     *\n     * TODO: Maybe make this public?\n     *\n     * @return a new List\n     */\n    private List<String> toList() {\n        return Arrays.asList(values);\n    }\n\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new LinkedHashMap<String, String>(values.length));\n    }\n\n    /**\n     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.\n     */\n    @Override\n    public String toString() {\n        return \"CSVRecord [comment='\" + comment + \"', recordNumber=\" + recordNumber + \", values=\"\n            + Arrays.toString(values) + \"]\";\n    }\n\n    String[] values() {\n        return values;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex acc4c8df4..99dce26a9 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -265,7 +265,7 @@ private List<String> toList() {\n     }\n \n     /**\n-     * Copies this record into a new Map. The new map is not connect\n+     * Copies this record into a new Map of header name to record value.\n      *\n      * @return A new Map. The map is empty if the record has no headers.\n      */\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/csv/CSVParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  }
]