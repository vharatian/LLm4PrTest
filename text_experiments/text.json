[
  {
    "pr_number": 467,
    "title": "Update DoubleFormat to state it is based on Double.toString.",
    "state": "closed",
    "created_at": "2023-10-20T08:07:51Z",
    "merge_commit_sha": "4331f2ef85801e4aba4a3999bc39ba33d6b68b0c",
    "base_sha": "fb476ec5f1d64575f09b3187aeee02681e726a3e",
    "head_sha": "22c0bb12ff2ce18e1c2c7bc146231bffa670d269",
    "user_login": "aherbert",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/numbers/DoubleFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.numbers;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DoubleFormatTest2 {\n\n    /**\n     * Test to ensure that the formatted output string created by DoubleFormat\n     * matches the precision required to exactly represent the input double.\n     */\n    @Test\n    void testFormattedOutputPrecision() {\n        DoubleFunction<String> fmt = DoubleFormat.PLAIN.builder().build();\n        double value = 12345.6789;\n        String formatted = fmt.apply(value);\n        double parsed = Double.parseDouble(formatted);\n        Assertions.assertEquals(value, parsed, \"Formatted double string did not match input value\");\n    }\n\n    /**\n     * Test to ensure that the formatted output string created by DoubleFormat\n     * cannot extend beyond the precision provided by Double.toString().\n     */\n    @Test\n    void testFormattedOutputPrecisionLimit() {\n        DoubleFunction<String> fmt = DoubleFormat.PLAIN.builder().build();\n        double value = 1.2345678901234567e+30;\n        String formatted = fmt.apply(value);\n        double parsed = Double.parseDouble(formatted);\n        Assertions.assertEquals(value, parsed, \"Formatted double string did not match input value\");\n    }\n\n    /**\n     * Test to ensure that the formatted output string created by DoubleFormat\n     * matches the precision required to exactly represent the input double for negative values.\n     */\n    @Test\n    void testFormattedOutputPrecisionNegative() {\n        DoubleFunction<String> fmt = DoubleFormat.PLAIN.builder().build();\n        double value = -12345.6789;\n        String formatted = fmt.apply(value);\n        double parsed = Double.parseDouble(formatted);\n        Assertions.assertEquals(value, parsed, \"Formatted double string did not match input value\");\n    }\n\n    /**\n     * Test to ensure that the formatted output string created by DoubleFormat\n     * matches the precision required to exactly represent the input double for very small values.\n     */\n    @Test\n    void testFormattedOutputPrecisionSmallValue() {\n        DoubleFunction<String> fmt = DoubleFormat.PLAIN.builder().build();\n        double value = 1.2345678901234567e-30;\n        String formatted = fmt.apply(value);\n        double parsed = Double.parseDouble(formatted);\n        Assertions.assertEquals(value, parsed, \"Formatted double string did not match input value\");\n    }\n\n    /**\n     * Test to ensure that the formatted output string created by DoubleFormat\n     * matches the precision required to exactly represent the input double for very large values.\n     */\n    @Test\n    void testFormattedOutputPrecisionLargeValue() {\n        DoubleFunction<String> fmt = DoubleFormat.PLAIN.builder().build();\n        double value = 1.2345678901234567e+308;\n        String formatted = fmt.apply(value);\n        double parsed = Double.parseDouble(formatted);\n        Assertions.assertEquals(value, parsed, \"Formatted double string did not match input value\");\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.numbers;\n\nimport java.text.DecimalFormatSymbols;\nimport java.util.Objects;\nimport java.util.function.DoubleFunction;\nimport java.util.function.Function;\n\n/**\n * Enum containing standard double format types with methods to produce\n * configured formatter instances. This type is intended to provide a\n * quick and convenient way to create lightweight, thread-safe double format functions\n * for common format types using a builder pattern. Output can be localized by\n * passing a {@link DecimalFormatSymbols} instance to the\n * {@link Builder#formatSymbols(DecimalFormatSymbols) formatSymbols} method or by\n * directly calling the various other builder configuration methods, such as\n * {@link Builder#digits(String) digits}.\n *\n * <p><strong>Comparison with DecimalFormat</strong></p>\n * <p>\n * This type provides some of the same functionality as Java's own\n * {@link java.text.DecimalFormat}. However, unlike {@code DecimalFormat}, the format\n * functions produced by this type are lightweight and thread-safe, making them\n * much easier to work with in multi-threaded environments. They also provide performance\n * comparable to, and in many cases faster than, {@code DecimalFormat}.\n * </p>\n * <p><strong>Examples</strong></p>\n * <pre>\n * // construct a formatter equivalent to Double.toString()\n * DoubleFunction&lt;String&gt; fmt = DoubleFormat.MIXED.builder().build();\n *\n * // construct a formatter equivalent to Double.toString() but using\n * // format symbols for a specific locale\n * DoubleFunction&lt;String&gt; fmt = DoubleFormat.MIXED.builder()\n *      .formatSymbols(DecimalFormatSymbols.getInstance(locale))\n *      .build();\n *\n * // construct a formatter equivalent to the DecimalFormat pattern \"0.0##\"\n * DoubleFunction&lt;String&gt; fmt = DoubleFormat.PLAIN.builder()\n *      .minDecimalExponent(-3)\n *      .build();\n *\n * // construct a formatter equivalent to the DecimalFormat pattern \"#,##0.0##\",\n * // where whole number groups of thousands are separated\n * DoubleFunction&lt;String&gt; fmt = DoubleFormat.PLAIN.builder()\n *      .minDecimalExponent(-3)\n *      .groupThousands(true)\n *      .build();\n *\n * // construct a formatter equivalent to the DecimalFormat pattern \"0.0##E0\"\n * DoubleFunction&lt;String&gt; fmt = DoubleFormat.SCIENTIFIC.builder()\n *      .maxPrecision(4)\n *      .alwaysIncludeExponent(true)\n *      .build()\n *\n * // construct a formatter equivalent to the DecimalFormat pattern \"##0.0##E0\",\n * // i.e. \"engineering format\"\n * DoubleFunction&lt;String&gt; fmt = DoubleFormat.ENGINEERING.builder()\n *      .maxPrecision(6)\n *      .alwaysIncludeExponent(true)\n *      .build()\n * </pre>\n *\n * <p><strong>Implementation Notes</strong></p>\n * <p>\n * {@link java.math.RoundingMode#HALF_EVEN Half-even} rounding is used in cases where the\n * decimal value must be rounded in order to meet the configuration requirements of the formatter\n * instance.\n * </p>\n *\n * @since 1.10.0\n */\npublic enum DoubleFormat {\n\n    /**\n     * Number format without exponents.\n     * <p>\n     * For example:\n     * </p>\n     *\n     * <pre>\n     * 0.0\n     * 12.401\n     * 100000.0\n     * 1450000000.0\n     * 0.0000000000123\n     * </pre>\n     */\n    PLAIN(PlainDoubleFormat::new),\n\n    /**\n     * Number format that uses exponents and contains a single digit to the left of the decimal point.\n     * <p>\n     * For example:\n     * </p>\n     *\n     * <pre>\n     * 0.0\n     * 1.2401E1\n     * 1.0E5\n     * 1.45E9\n     * 1.23E-11\n     * </pre>\n     */\n    SCIENTIFIC(ScientificDoubleFormat::new),\n\n    /**\n     * Number format similar to {@link #SCIENTIFIC scientific format} but adjusted so that the exponent value is always a multiple of 3, allowing easier\n     * alignment with SI prefixes.\n     * <p>\n     * For example:\n     * </p>\n     *\n     * <pre>\n     * 0.0\n     * 12.401\n     * 100.0E3\n     * 1.45E9\n     * 12.3E-12\n     * </pre>\n     */\n    ENGINEERING(EngineeringDoubleFormat::new),\n\n    /**\n     * Number format that uses {@link #PLAIN plain format} for small numbers and {@link #SCIENTIFIC scientific format} for large numbers. The number thresholds\n     * can be configured through the {@link Builder#plainFormatMinDecimalExponent(int) plainFormatMinDecimalExponent} and\n     * {@link Builder#plainFormatMaxDecimalExponent(int) plainFormatMaxDecimalExponent} properties.\n     * <p>\n     * For example:\n     * </p>\n     *\n     * <pre>\n     * 0.0\n     * 12.401\n     * 100000.0\n     * 1.45E9\n     * 1.23E-11\n     * </pre>\n     */\n    MIXED(MixedDoubleFormat::new);\n\n    /**\n     * Base class for standard double formatting classes.\n     */\n    private abstract static class AbstractDoubleFormat implements DoubleFunction<String>, ParsedDecimal.FormatOptions {\n\n        /** Maximum precision; 0 indicates no limit. */\n        private final int maxPrecision;\n\n        /** Minimum decimal exponent. */\n        private final int minDecimalExponent;\n\n        /** String representing positive infinity. */\n        private final String positiveInfinity;\n\n        /** String representing negative infinity. */\n        private final String negativeInfinity;\n\n        /** String representing NaN. */\n        private final String nan;\n\n        /** Flag determining if fraction placeholders should be used. */\n        private final boolean fractionPlaceholder;\n\n        /** Flag determining if signed zero strings are allowed. */\n        private final boolean signedZero;\n\n        /** String containing the digits 0-9. */\n        private final char[] digits;\n\n        /** Decimal separator character. */\n        private final char decimalSeparator;\n\n        /** Thousands grouping separator. */\n        private final char groupingSeparator;\n\n        /** Flag indicating if thousands should be grouped. */\n        private final boolean groupThousands;\n\n        /** Minus sign character. */\n        private final char minusSign;\n\n        /** Exponent separator character. */\n        private final char[] exponentSeparatorChars;\n\n        /** Flag indicating if exponent values should always be included, even if zero. */\n        private final boolean alwaysIncludeExponent;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param builder builder instance containing configuration values\n         */\n        AbstractDoubleFormat(final Builder builder) {\n            this.maxPrecision = builder.maxPrecision;\n            this.minDecimalExponent = builder.minDecimalExponent;\n\n            this.positiveInfinity = builder.infinity;\n            this.negativeInfinity = builder.minusSign + builder.infinity;\n            this.nan = builder.nan;\n\n            this.fractionPlaceholder = builder.fractionPlaceholder;\n            this.signedZero = builder.signedZero;\n            this.digits = builder.digits.toCharArray();\n            this.decimalSeparator = builder.decimalSeparator;\n            this.groupingSeparator = builder.groupingSeparator;\n            this.groupThousands = builder.groupThousands;\n            this.minusSign = builder.minusSign;\n            this.exponentSeparatorChars = builder.exponentSeparator.toCharArray();\n            this.alwaysIncludeExponent = builder.alwaysIncludeExponent;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public String apply(final double d) {\n            if (Double.isFinite(d)) {\n                return applyFinite(d);\n            }\n            if (Double.isInfinite(d)) {\n                return d > 0.0 ? positiveInfinity : negativeInfinity;\n            }\n            return nan;\n        }\n\n        /**\n         * Returns a formatted string representation of the given finite value.\n         *\n         * @param d double value\n         */\n        private String applyFinite(final double d) {\n            final ParsedDecimal n = ParsedDecimal.from(d);\n\n            int roundExponent = Math.max(n.getExponent(), minDecimalExponent);\n            if (maxPrecision > 0) {\n                roundExponent = Math.max(n.getScientificExponent() - maxPrecision + 1, roundExponent);\n            }\n            n.round(roundExponent);\n\n            return applyFiniteInternal(n);\n        }\n\n        /**\n         * Returns a formatted representation of the given rounded decimal value to {@code dst}.\n         *\n         * @param val value to format\n         * @return a formatted representation of the given rounded decimal value to {@code dst}.\n         */\n        protected abstract String applyFiniteInternal(ParsedDecimal val);\n\n        /** {@inheritDoc} */\n        @Override\n        public char getDecimalSeparator() {\n            return decimalSeparator;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public char[] getDigits() {\n            return digits;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public char[] getExponentSeparatorChars() {\n            return exponentSeparatorChars;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public char getGroupingSeparator() {\n            return groupingSeparator;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public char getMinusSign() {\n            return minusSign;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean isAlwaysIncludeExponent() {\n            return alwaysIncludeExponent;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean isGroupThousands() {\n            return groupThousands;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean isIncludeFractionPlaceholder() {\n            return fractionPlaceholder;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean isSignedZero() {\n            return signedZero;\n        }\n    }\n\n    /**\n     * Builds configured format functions for standard double format types.\n     */\n    public static final class Builder {\n\n        /** Default value for the plain format max decimal exponent. */\n        private static final int DEFAULT_PLAIN_FORMAT_MAX_DECIMAL_EXPONENT = 6;\n\n        /** Default value for the plain format min decimal exponent. */\n        private static final int DEFAULT_PLAIN_FORMAT_MIN_DECIMAL_EXPONENT = -3;\n\n        /** Default decimal digit characters. */\n        private static final String DEFAULT_DECIMAL_DIGITS = \"0123456789\";\n\n        /** Function used to construct format instances. */\n        private final Function<Builder, DoubleFunction<String>> factory;\n\n        /** Maximum number of significant decimal digits in formatted strings. */\n        private int maxPrecision = 0;\n\n        /** Minimum decimal exponent. */\n        private int minDecimalExponent = Integer.MIN_VALUE;\n\n        /** Max decimal exponent to use with plain formatting with the mixed format type. */\n        private int plainFormatMaxDecimalExponent = DEFAULT_PLAIN_FORMAT_MAX_DECIMAL_EXPONENT;\n\n        /** Min decimal exponent to use with plain formatting with the mixed format type. */\n        private int plainFormatMinDecimalExponent = DEFAULT_PLAIN_FORMAT_MIN_DECIMAL_EXPONENT;\n\n        /** String representing infinity. */\n        private String infinity = \"Infinity\";\n\n        /** String representing NaN. */\n        private String nan = \"NaN\";\n\n        /** Flag determining if fraction placeholders should be used. */\n        private boolean fractionPlaceholder = true;\n\n        /** Flag determining if signed zero strings are allowed. */\n        private boolean signedZero = true;\n\n        /** String of digit characters 0-9. */\n        private String digits = DEFAULT_DECIMAL_DIGITS;\n\n        /** Decimal separator character. */\n        private char decimalSeparator = '.';\n\n        /** Character used to separate groups of thousands. */\n        private char groupingSeparator = ',';\n\n        /** If {@code true}, thousands groups will be separated by the grouping separator. */\n        private boolean groupThousands = false;\n\n        /** Minus sign character. */\n        private char minusSign = '-';\n\n        /** Exponent separator character. */\n        private String exponentSeparator = \"E\";\n\n        /** Flag indicating if the exponent value should always be included, even if zero. */\n        private boolean alwaysIncludeExponent = false;\n\n        /**\n         * Builds a new instance that delegates double function construction to the given factory object.\n         *\n         * @param factory factory function\n         */\n        private Builder(final Function<Builder, DoubleFunction<String>> factory) {\n            this.factory = factory;\n        }\n\n        /**\n         * Sets the flag determining whether or not the zero string may be returned with the minus sign or if it will always be returned in the positive form.\n         * For example, if set to {@code true}, the string {@code \"-0.0\"} may be returned for some input numbers. If {@code false}, only {@code \"0.0\"} will be\n         * returned, regardless of the sign of the input number. The default value is {@code true}.\n         *\n         * @param signedZero if {@code true}, the zero string may be returned with a preceding minus sign; if {@code false}, the zero string will only be\n         *                   returned in its positive form\n         * @return this instance\n         */\n        public Builder allowSignedZero(final boolean signedZero) {\n            this.signedZero = signedZero;\n            return this;\n        }\n\n        /**\n         * Sets the flag indicating if an exponent value should always be included in the formatted value, even if the exponent value is zero. This property\n         * only applies to formats that use scientific notation, namely {@link DoubleFormat#SCIENTIFIC SCIENTIFIC}, {@link DoubleFormat#ENGINEERING\n         * ENGINEERING}, and {@link DoubleFormat#MIXED MIXED}. The default value is {@code false}.\n         *\n         * @param alwaysIncludeExponent if {@code true}, exponents will always be included in formatted output even if the exponent value is zero\n         * @return this instance\n         */\n        public Builder alwaysIncludeExponent(final boolean alwaysIncludeExponent) {\n            this.alwaysIncludeExponent = alwaysIncludeExponent;\n            return this;\n        }\n\n        /**\n         * Builds a new double format function.\n         *\n         * @return format function\n         */\n        public DoubleFunction<String> build() {\n            return factory.apply(this);\n        }\n\n        /**\n         * Sets the decimal separator character, i.e., the character placed between the whole number and fractional portions of the formatted strings. The\n         * default value is {@code '.'}.\n         *\n         * @param decimalSeparator decimal separator character\n         * @return this instance\n         */\n        public Builder decimalSeparator(final char decimalSeparator) {\n            this.decimalSeparator = decimalSeparator;\n            return this;\n        }\n\n        /**\n         * Sets the string containing the digit characters 0-9, in that order. The default value is the string {@code \"0123456789\"}.\n         *\n         * @param digits string containing the digit characters 0-9\n         * @return this instance\n         * @throws NullPointerException     if the argument is {@code null}\n         * @throws IllegalArgumentException if the argument does not have a length of exactly 10\n         */\n        public Builder digits(final String digits) {\n            Objects.requireNonNull(digits, \"Digits string cannot be null\");\n            if (digits.length() != DEFAULT_DECIMAL_DIGITS.length()) {\n                throw new IllegalArgumentException(\"Digits string must contain exactly \" + DEFAULT_DECIMAL_DIGITS.length() + \" characters.\");\n            }\n\n            this.digits = digits;\n            return this;\n        }\n\n        /**\n         * Sets the exponent separator character, i.e., the string placed between the mantissa and the exponent. The default value is {@code \"E\"}, as in\n         * {@code \"1.2E6\"}.\n         *\n         * @param exponentSeparator exponent separator string\n         * @return this instance\n         * @throws NullPointerException if the argument is {@code null}\n         */\n        public Builder exponentSeparator(final String exponentSeparator) {\n            this.exponentSeparator = Objects.requireNonNull(exponentSeparator, \"Exponent separator cannot be null\");\n            return this;\n        }\n\n        /**\n         * Configures this instance with the given format symbols. The following values are set:\n         * <ul>\n         * <li>{@link #digits(String) digit characters}</li>\n         * <li>{@link #decimalSeparator(char) decimal separator}</li>\n         * <li>{@link #groupingSeparator(char) thousands grouping separator}</li>\n         * <li>{@link #minusSign(char) minus sign}</li>\n         * <li>{@link #exponentSeparator(String) exponent separator}</li>\n         * <li>{@link #infinity(String) infinity}</li>\n         * <li>{@link #nan(String) NaN}</li>\n         * </ul>\n         * The digit character string is constructed by starting at the configured {@link DecimalFormatSymbols#getZeroDigit() zero digit} and adding the next 9\n         * consecutive characters.\n         *\n         * @param symbols format symbols\n         * @return this instance\n         * @throws NullPointerException if the argument is {@code null}\n         */\n        public Builder formatSymbols(final DecimalFormatSymbols symbols) {\n            Objects.requireNonNull(symbols, \"Decimal format symbols cannot be null\");\n\n            return digits(getDigitString(symbols)).decimalSeparator(symbols.getDecimalSeparator()).groupingSeparator(symbols.getGroupingSeparator())\n                    .minusSign(symbols.getMinusSign()).exponentSeparator(symbols.getExponentSeparator()).infinity(symbols.getInfinity()).nan(symbols.getNaN());\n        }\n\n        /**\n         * Gets a string containing the localized digits 0-9 for the given symbols object. The string is constructed by starting at the\n         * {@link DecimalFormatSymbols#getZeroDigit() zero digit} and adding the next 9 consecutive characters.\n         *\n         * @param symbols symbols object\n         * @return string containing the localized digits 0-9\n         */\n        private static String getDigitString(final DecimalFormatSymbols symbols) {\n            final int zeroDelta = symbols.getZeroDigit() - DEFAULT_DECIMAL_DIGITS.charAt(0);\n\n            final char[] digitChars = new char[DEFAULT_DECIMAL_DIGITS.length()];\n            for (int i = 0; i < DEFAULT_DECIMAL_DIGITS.length(); ++i) {\n                digitChars[i] = (char) (DEFAULT_DECIMAL_DIGITS.charAt(i) + zeroDelta);\n            }\n\n            return String.valueOf(digitChars);\n        }\n\n        /**\n         * Sets the character used to separate groups of thousands. Default value is {@code ','}.\n         *\n         * @param groupingSeparator character used to separate groups of thousands\n         * @return this instance\n         * @see #groupThousands(boolean)\n         */\n        public Builder groupingSeparator(final char groupingSeparator) {\n            this.groupingSeparator = groupingSeparator;\n            return this;\n        }\n\n        /**\n         * If set to {@code true}, thousands will be grouped with the {@link #groupingSeparator(char) grouping separator}. For example, if set to {@code true},\n         * the number {@code 1000} could be formatted as {@code \"1,000\"}. This property only applies to the {@link DoubleFormat#PLAIN PLAIN} format. Default\n         * value is {@code false}.\n         *\n         * @param groupThousands if {@code true}, thousands will be grouped\n         * @return this instance\n         * @see #groupingSeparator(char)\n         */\n        public Builder groupThousands(final boolean groupThousands) {\n            this.groupThousands = groupThousands;\n            return this;\n        }\n\n        /**\n         * Sets the flag determining whether or not a zero character is added in the fraction position when no fractional value is present. For example, if set\n         * to {@code true}, the number {@code 1} would be formatted as {@code \"1.0\"}. If {@code false}, it would be formatted as {@code \"1\"}. The default value\n         * is {@code true}.\n         *\n         * @param fractionPlaceholder if {@code true}, a zero character is placed in the fraction position when no fractional value is present; if\n         *                            {@code false}, fractional digits are only included when needed\n         * @return this instance\n         */\n        public Builder includeFractionPlaceholder(final boolean fractionPlaceholder) {\n            this.fractionPlaceholder = fractionPlaceholder;\n            return this;\n        }\n\n        /**\n         * Sets the string used to represent infinity. For negative infinity, this string is prefixed with the {@link #minusSign(char) minus sign}.\n         *\n         * @param infinity string used to represent infinity\n         * @return this instance\n         * @throws NullPointerException if the argument is {@code null}\n         */\n        public Builder infinity(final String infinity) {\n            this.infinity = Objects.requireNonNull(infinity, \"Infinity string cannot be null\");\n            return this;\n        }\n\n        /**\n         * Sets the maximum number of significant decimal digits used in format results. A value of {@code 0} indicates no limit. The default value is\n         * {@code 0}.\n         *\n         * @param maxPrecision maximum precision\n         * @return this instance\n         */\n        public Builder maxPrecision(final int maxPrecision) {\n            this.maxPrecision = maxPrecision;\n            return this;\n        }\n\n        /**\n         * Sets the minimum decimal exponent for formatted strings. No digits with an absolute value of less than <code>10<sup>minDecimalExponent</sup></code>\n         * will be included in format results. If the number being formatted does not contain any such digits, then zero is returned. For example, if\n         * {@code minDecimalExponent} is set to {@code -2} and the number {@code 3.14159} is formatted, the plain format result will be {@code \"3.14\"}. If\n         * {@code 0.001} is formatted, then the result is the zero string.\n         *\n         * @param minDecimalExponent minimum decimal exponent\n         * @return this instance\n         */\n        public Builder minDecimalExponent(final int minDecimalExponent) {\n            this.minDecimalExponent = minDecimalExponent;\n            return this;\n        }\n\n        /**\n         * Sets the character used as the minus sign.\n         *\n         * @param minusSign character to use as the minus sign\n         * @return this instance\n         */\n        public Builder minusSign(final char minusSign) {\n            this.minusSign = minusSign;\n            return this;\n        }\n\n        /**\n         * Sets the string used to represent {@link Double#NaN}.\n         *\n         * @param nan string used to represent {@link Double#NaN}\n         * @return this instance\n         * @throws NullPointerException if the argument is {@code null}\n         */\n        public Builder nan(final String nan) {\n            this.nan = Objects.requireNonNull(nan, \"NaN string cannot be null\");\n            return this;\n        }\n\n        /**\n         * Sets the maximum decimal exponent for numbers formatted as plain decimal strings when using the {@link DoubleFormat#MIXED MIXED} format type. If the\n         * number being formatted has an absolute value less than <code>10<sup>plainFormatMaxDecimalExponent + 1</sup></code> and greater than or equal to\n         * <code>10<sup>plainFormatMinDecimalExponent</sup></code> after any necessary rounding, then the formatted result will use the\n         * {@link DoubleFormat#PLAIN PLAIN} format type. Otherwise, {@link DoubleFormat#SCIENTIFIC SCIENTIFIC} format will be used. For example, if this value\n         * is set to {@code 2}, the number {@code 999} will be formatted as {@code \"999.0\"} while {@code 1000} will be formatted as {@code \"1.0E3\"}.\n         *\n         * <p>\n         * The default value is {@code 6}.\n         *\n         * <p>\n         * This value is ignored for formats other than {@link DoubleFormat#MIXED}.\n         *\n         * @param plainFormatMaxDecimalExponent maximum decimal exponent for values formatted as plain strings when using the {@link DoubleFormat#MIXED MIXED}\n         *                                      format type.\n         * @return this instance\n         * @see #plainFormatMinDecimalExponent(int)\n         */\n        public Builder plainFormatMaxDecimalExponent(final int plainFormatMaxDecimalExponent) {\n            this.plainFormatMaxDecimalExponent = plainFormatMaxDecimalExponent;\n            return this;\n        }\n\n        /**\n         * Sets the minimum decimal exponent for numbers formatted as plain decimal strings when using the {@link DoubleFormat#MIXED MIXED} format type. If the\n         * number being formatted has an absolute value less than <code>10<sup>plainFormatMaxDecimalExponent + 1</sup></code> and greater than or equal to\n         * <code>10<sup>plainFormatMinDecimalExponent</sup></code> after any necessary rounding, then the formatted result will use the\n         * {@link DoubleFormat#PLAIN PLAIN} format type. Otherwise, {@link DoubleFormat#SCIENTIFIC SCIENTIFIC} format will be used. For example, if this value\n         * is set to {@code -2}, the number {@code 0.01} will be formatted as {@code \"0.01\"} while {@code 0.0099} will be formatted as {@code \"9.9E-3\"}.\n         *\n         * <p>\n         * The default value is {@code -3}.\n         *\n         * <p>\n         * This value is ignored for formats other than {@link DoubleFormat#MIXED}.\n         *\n         * @param plainFormatMinDecimalExponent maximum decimal exponent for values formatted as plain strings when using the {@link DoubleFormat#MIXED MIXED}\n         *                                      format type.\n         * @return this instance\n         * @see #plainFormatMinDecimalExponent(int)\n         */\n        public Builder plainFormatMinDecimalExponent(final int plainFormatMinDecimalExponent) {\n            this.plainFormatMinDecimalExponent = plainFormatMinDecimalExponent;\n            return this;\n        }\n    }\n\n    /**\n     * Format class that uses engineering notation for all values.\n     */\n    private static final class EngineeringDoubleFormat extends AbstractDoubleFormat {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param builder builder instance containing configuration values\n         */\n        EngineeringDoubleFormat(final Builder builder) {\n            super(builder);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public String applyFiniteInternal(final ParsedDecimal val) {\n            return val.toEngineeringString(this);\n        }\n    }\n\n    /**\n     * Format class producing results similar to {@link Double#toString()}, with plain decimal notation for small numbers relatively close to zero and\n     * scientific notation otherwise.\n     */\n    private static final class MixedDoubleFormat extends AbstractDoubleFormat {\n\n        /** Max decimal exponent for plain format. */\n        private final int plainMaxExponent;\n\n        /** Min decimal exponent for plain format. */\n        private final int plainMinExponent;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param builder builder instance containing configuration values\n         */\n        MixedDoubleFormat(final Builder builder) {\n            super(builder);\n\n            this.plainMaxExponent = builder.plainFormatMaxDecimalExponent;\n            this.plainMinExponent = builder.plainFormatMinDecimalExponent;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        protected String applyFiniteInternal(final ParsedDecimal val) {\n            final int sciExp = val.getScientificExponent();\n            if (sciExp <= plainMaxExponent && sciExp >= plainMinExponent) {\n                return val.toPlainString(this);\n            }\n            return val.toScientificString(this);\n        }\n    }\n\n    /**\n     * Format class that produces plain decimal strings that do not use scientific notation.\n     */\n    private static final class PlainDoubleFormat extends AbstractDoubleFormat {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param builder builder instance containing configuration values\n         */\n        PlainDoubleFormat(final Builder builder) {\n            super(builder);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected String applyFiniteInternal(final ParsedDecimal val) {\n            return val.toPlainString(this);\n        }\n    }\n\n    /**\n     * Format class that uses scientific notation for all values.\n     */\n    private static final class ScientificDoubleFormat extends AbstractDoubleFormat {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param builder builder instance containing configuration values\n         */\n        ScientificDoubleFormat(final Builder builder) {\n            super(builder);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public String applyFiniteInternal(final ParsedDecimal val) {\n            return val.toScientificString(this);\n        }\n    }\n\n    /** Function used to construct instances for this format type. */\n    private final Function<Builder, DoubleFunction<String>> factory;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param factory function used to construct format instances\n     */\n    DoubleFormat(final Function<Builder, DoubleFunction<String>> factory) {\n        this.factory = factory;\n    }\n\n    /**\n     * Creates a {@link Builder} for building formatter functions for this format type.\n     *\n     * @return builder instance\n     */\n    public Builder builder() {\n        return new Builder(factory);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/numbers/DoubleFormat.java b/src/main/java/org/apache/commons/text/numbers/DoubleFormat.java\nindex 05cae505d3..cd42017bb1 100644\n--- a/src/main/java/org/apache/commons/text/numbers/DoubleFormat.java\n+++ b/src/main/java/org/apache/commons/text/numbers/DoubleFormat.java\n@@ -39,6 +39,16 @@\n  * much easier to work with in multi-threaded environments. They also provide performance\n  * comparable to, and in many cases faster than, {@code DecimalFormat}.\n  * </p>\n+ * <p>\n+ * It should be noted that the output {@code String} is created by formatting the output of\n+ * {@link Double#toString()}. This limits the output precision to the precision required\n+ * to exactly represent the input {@code double} and is dependent on the JDK implementation\n+ * of {@link Double#toString()}. A number formatted with the maximum\n+ * precision should be parsed to the same input {@code double}. This implementation\n+ * cannot extend the {@code String} to the required length to represent the exact decimal\n+ * value of the {@code double} as per\n+ * {@link java.math.BigDecimal#toString() BigDecimal#toString()}.\n+ * </p>\n  * <p><strong>Examples</strong></p>\n  * <pre>\n  * // construct a formatter equivalent to Double.toString()\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/numbers/DoubleFormatTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 452,
    "title": "TEXT-228: Fix TextStringBuilder to over-allocate when ensuring capacity",
    "state": "closed",
    "created_at": "2023-08-21T13:17:46Z",
    "merge_commit_sha": "92cd8ae9f3ad2a586c23b599d339907af20caa5b",
    "base_sha": "efa7475c3da2153a0d3a769dac8f5fe606c2b9fb",
    "head_sha": "58d3a8fed616e75e13f54c22175b25f5a0f67ec1",
    "user_login": "aherbert",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/TextStringBuilder.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.Locale;\n\nimport org.apache.commons.io.output.NullAppendable;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\nimport org.junit.jupiter.api.Test;\n\npublic class TextStringBuilderTest2 {\n\n    @Test\n    public void testEnsureCapacityInternal() {\n        TextStringBuilder sb = new TextStringBuilder();\n        sb.ensureCapacity(2);\n        assertTrue(sb.capacity() >= 2);\n\n        sb.ensureCapacityInternal(2);\n        assertTrue(sb.capacity() >= 2);\n\n        sb.ensureCapacityInternal(-1);\n        assertTrue(sb.capacity() >= 0);\n\n        sb.append(\"HelloWorld\");\n        sb.ensureCapacityInternal(40);\n        assertTrue(sb.capacity() >= 40);\n    }\n\n    @Test\n    public void testResizeBuffer() {\n        TextStringBuilder sb = new TextStringBuilder();\n        sb.ensureCapacityInternal(2);\n        assertTrue(sb.capacity() >= 2);\n\n        sb.ensureCapacityInternal(100);\n        assertTrue(sb.capacity() >= 100);\n\n        sb.ensureCapacityInternal(Integer.MAX_VALUE - 8);\n        assertTrue(sb.capacity() >= Integer.MAX_VALUE - 8);\n    }\n\n    @Test\n    public void testCreatePositiveCapacity() {\n        assertThrows(OutOfMemoryError.class, () -> TextStringBuilder.createPositiveCapacity(-1));\n\n        int capacity = TextStringBuilder.createPositiveCapacity(10);\n        assertEquals(10, capacity);\n\n        capacity = TextStringBuilder.createPositiveCapacity(Integer.MAX_VALUE - 8);\n        assertEquals(Integer.MAX_VALUE - 8, capacity);\n    }\n\n    @Test\n    public void testAppendWithEnsureCapacityInternal() {\n        TextStringBuilder sb = new TextStringBuilder();\n        sb.append(true);\n        assertEquals(\"true\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.append(false);\n        assertEquals(\"false\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.append('a');\n        assertEquals(\"a\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.append(new char[]{'a', 'b', 'c'});\n        assertEquals(\"abc\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.append(new char[]{'a', 'b', 'c'}, 1, 2);\n        assertEquals(\"bc\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.append(CharBuffer.wrap(\"abc\"));\n        assertEquals(\"abc\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.append(CharBuffer.wrap(\"abc\"), 1, 2);\n        assertEquals(\"bc\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.append(\"abc\", 1, 2);\n        assertEquals(\"bc\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.append(new StringBuffer(\"abc\"), 1, 2);\n        assertEquals(\"bc\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.append(new StringBuilder(\"abc\"), 1, 2);\n        assertEquals(\"bc\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.append(new TextStringBuilder(\"abc\"), 1, 2);\n        assertEquals(\"bc\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.appendFixedWidthPadLeft(123, 5, '0');\n        assertEquals(\"00123\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.appendFixedWidthPadRight(123, 5, '0');\n        assertEquals(\"12300\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.appendPadding(5, '0');\n        assertEquals(\"00000\", sb.toString());\n    }\n\n    @Test\n    public void testInsertWithEnsureCapacityInternal() {\n        TextStringBuilder sb = new TextStringBuilder(\"abc\");\n        sb.insert(1, true);\n        assertEquals(\"atruebc\", sb.toString());\n\n        sb = new TextStringBuilder(\"abc\");\n        sb.insert(1, false);\n        assertEquals(\"afalsebc\", sb.toString());\n\n        sb = new TextStringBuilder(\"abc\");\n        sb.insert(1, 'd');\n        assertEquals(\"adbc\", sb.toString());\n\n        sb = new TextStringBuilder(\"abc\");\n        sb.insert(1, new char[]{'d', 'e', 'f'});\n        assertEquals(\"adefbc\", sb.toString());\n\n        sb = new TextStringBuilder(\"abc\");\n        sb.insert(1, new char[]{'d', 'e', 'f'}, 1, 2);\n        assertEquals(\"aefbc\", sb.toString());\n\n        sb = new TextStringBuilder(\"abc\");\n        sb.insert(1, 1.23);\n        assertEquals(\"a1.23bc\", sb.toString());\n\n        sb = new TextStringBuilder(\"abc\");\n        sb.insert(1, 1.23f);\n        assertEquals(\"a1.23bc\", sb.toString());\n\n        sb = new TextStringBuilder(\"abc\");\n        sb.insert(1, 123);\n        assertEquals(\"a123bc\", sb.toString());\n\n        sb = new TextStringBuilder(\"abc\");\n        sb.insert(1, 123L);\n        assertEquals(\"a123bc\", sb.toString());\n\n        sb = new TextStringBuilder(\"abc\");\n        sb.insert(1, \"def\");\n        assertEquals(\"adefbc\", sb.toString());\n    }\n\n    @Test\n    public void testReadFromWithEnsureCapacityInternal() throws IOException {\n        TextStringBuilder sb = new TextStringBuilder();\n        sb.readFrom(new StringReader(\"abc\"));\n        assertEquals(\"abc\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.readFrom(new StringReader(\"abc\"), 2);\n        assertEquals(\"ab\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.readFrom(CharBuffer.wrap(\"abc\"));\n        assertEquals(\"abc\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.readFrom(CharBuffer.wrap(\"abc\"), 2);\n        assertEquals(\"ab\", sb.toString());\n\n        sb = new TextStringBuilder();\n        sb.readFrom(new MockReadable(\"abc\"));\n        assertEquals(\"abc\", sb.toString());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.Writer;\nimport java.nio.CharBuffer;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.matcher.StringMatcher;\n\n/**\n * Builds a string from constituent parts providing a more flexible and powerful API than {@link StringBuffer} and\n * {@link StringBuilder}.\n * <p>\n * The main differences from StringBuffer/StringBuilder are:\n * </p>\n * <ul>\n * <li>Not synchronized</li>\n * <li>Not final</li>\n * <li>Subclasses have direct access to character array</li>\n * <li>Additional methods\n * <ul>\n * <li>appendWithSeparators - adds an array of values, with a separator</li>\n * <li>appendPadding - adds a length padding characters</li>\n * <li>appendFixedLength - adds a fixed width field to the builder</li>\n * <li>toCharArray/getChars - simpler ways to get a range of the character array</li>\n * <li>delete - delete char or string</li>\n * <li>replace - search and replace for a char or string</li>\n * <li>leftString/rightString/midString - substring without exceptions</li>\n * <li>contains - whether the builder contains a char or string</li>\n * <li>size/clear/isEmpty - collections style API methods</li>\n * </ul>\n * </li>\n * <li>Views\n * <ul>\n * <li>asTokenizer - uses the internal buffer as the source of a StrTokenizer</li>\n * <li>asReader - uses the internal buffer as the source of a Reader</li>\n * <li>asWriter - allows a Writer to write directly to the internal buffer</li>\n * </ul>\n * </li>\n * </ul>\n * <p>\n * The aim has been to provide an API that mimics very closely what StringBuffer provides, but with additional methods.\n * It should be noted that some edge cases, with invalid indices or null input, have been altered - see individual\n * methods. The biggest of these changes is that by default, null will not output the text 'null'. This can be\n * controlled by a property, {@link #setNullText(String)}.\n * </p>\n * <p>\n * This class is called {@code TextStringBuilder} instead of {@code StringBuilder} to avoid clashing with\n * {@link StringBuilder}.\n * </p>\n *\n * @since 1.3\n */\npublic class TextStringBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Inner class to allow StrBuilder to operate as a reader.\n     */\n    class TextStringBuilderReader extends Reader {\n\n        /** The last mark position. */\n        private int mark;\n\n        /** The current stream position. */\n        private int pos;\n\n        /**\n         * Default constructor.\n         */\n        TextStringBuilderReader() {\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void mark(final int readAheadLimit) {\n            mark = pos;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean markSupported() {\n            return true;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int read() {\n            if (!ready()) {\n                return -1;\n            }\n            return TextStringBuilder.this.charAt(pos++);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int read(final char[] b, final int off, int len) {\n            if (off < 0 || len < 0 || off > b.length || off + len > b.length || off + len < 0) {\n                throw new IndexOutOfBoundsException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            if (pos >= TextStringBuilder.this.size()) {\n                return -1;\n            }\n            if (pos + len > size()) {\n                len = TextStringBuilder.this.size() - pos;\n            }\n            TextStringBuilder.this.getChars(pos, pos + len, b, off);\n            pos += len;\n            return len;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean ready() {\n            return pos < TextStringBuilder.this.size();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void reset() {\n            pos = mark;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public long skip(long n) {\n            if (pos + n > TextStringBuilder.this.size()) {\n                n = TextStringBuilder.this.size() - pos;\n            }\n            if (n < 0) {\n                return 0;\n            }\n            pos = Math.addExact(pos, Math.toIntExact(n));\n            return n;\n        }\n    }\n\n    /**\n     * Inner class to allow StrBuilder to operate as a tokenizer.\n     */\n    class TextStringBuilderTokenizer extends StringTokenizer {\n\n        /**\n         * Default constructor.\n         */\n        TextStringBuilderTokenizer() {\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public String getContent() {\n            final String str = super.getContent();\n            if (str == null) {\n                return TextStringBuilder.this.toString();\n            }\n            return str;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n            if (chars == null) {\n                return super.tokenize(TextStringBuilder.this.getBuffer(), 0, TextStringBuilder.this.size());\n            }\n            return super.tokenize(chars, offset, count);\n        }\n    }\n\n    /**\n     * Inner class to allow StrBuilder to operate as a writer.\n     */\n    class TextStringBuilderWriter extends Writer {\n\n        /**\n         * Default constructor.\n         */\n        TextStringBuilderWriter() {\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void flush() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final char[] cbuf) {\n            TextStringBuilder.this.append(cbuf);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final char[] cbuf, final int off, final int len) {\n            TextStringBuilder.this.append(cbuf, off, len);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final int c) {\n            TextStringBuilder.this.append((char) c);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final String str) {\n            TextStringBuilder.this.append(str);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final String str, final int off, final int len) {\n            TextStringBuilder.this.append(str, off, len);\n        }\n    }\n\n    /** The space character. */\n    private static final char SPACE = ' ';\n\n    /**\n     * The extra capacity for new builders.\n     */\n    static final int CAPACITY = 32;\n\n    /**\n     * End-Of-Stream.\n     */\n    private static final int EOS = -1;\n\n    /**\n     * The size of the string {@code \"false\"}.\n     */\n    private static final int FALSE_STRING_SIZE = Boolean.FALSE.toString().length();\n\n    /**\n     * Required for serialization support.\n     *\n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * The size of the string {@code \"true\"}.\n     */\n    private static final int TRUE_STRING_SIZE = Boolean.TRUE.toString().length();\n\n    /**\n     * Constructs an instance from a reference to a character array. Changes to the input chars are reflected in this\n     * instance until the internal buffer needs to be reallocated. Using a reference to an array allows the instance to\n     * be initialized without copying the input array.\n     *\n     * @param initialBuffer The initial array that will back the new builder.\n     * @return A new instance.\n     * @since 1.9\n     */\n    public static TextStringBuilder wrap(final char[] initialBuffer) {\n        Objects.requireNonNull(initialBuffer, \"initialBuffer\");\n        return new TextStringBuilder(initialBuffer, initialBuffer.length);\n    }\n\n    /**\n     * Constructs an instance from a reference to a character array. Changes to the input chars are reflected in this\n     * instance until the internal buffer needs to be reallocated. Using a reference to an array allows the instance to\n     * be initialized without copying the input array.\n     *\n     * @param initialBuffer The initial array that will back the new builder.\n     * @param length The length of the subarray to be used; must be non-negative and no larger than\n     *        {@code initialBuffer.length}. The new builder's size will be set to {@code length}.\n     * @return A new instance.\n     * @since 1.9\n     */\n    public static TextStringBuilder wrap(final char[] initialBuffer, final int length) {\n        return new TextStringBuilder(initialBuffer, length);\n    }\n\n    /** Internal data storage. */\n    private char[] buffer;\n\n    /** The new line. */\n    private String newLine;\n\n    /** The null text. */\n    private String nullText;\n\n    /** Incremented when the buffer is reallocated. */\n    private int reallocations;\n\n    /** Current size of the buffer. */\n    private int size;\n\n    /**\n     * Constructs an empty builder with an initial capacity of 32 characters.\n     */\n    public TextStringBuilder() {\n        this(CAPACITY);\n    }\n\n    /**\n     * Constructs an instance from a reference to a character array.\n     *\n     * @param initialBuffer a reference to a character array, must not be null.\n     * @param length The length of the subarray to be used; must be non-negative and no larger than\n     *        {@code initialBuffer.length}. The new builder's size will be set to {@code length}.\n     * @throws NullPointerException If {@code initialBuffer} is null.\n     * @throws IllegalArgumentException if {@code length} is bad.\n     */\n    private TextStringBuilder(final char[] initialBuffer, final int length) {\n        this.buffer = Objects.requireNonNull(initialBuffer, \"initialBuffer\");\n        if (length < 0 || length > initialBuffer.length) {\n            throw new IllegalArgumentException(\"initialBuffer.length=\" + initialBuffer.length + \", length=\" + length);\n        }\n        this.size = length;\n    }\n\n    /**\n     * Constructs an instance from a character sequence, allocating 32 extra characters for growth.\n     *\n     * @param seq the string to copy, null treated as blank string\n     * @since 1.9\n     */\n    public TextStringBuilder(final CharSequence seq) {\n        this(StringUtils.length(seq) + CAPACITY);\n        if (seq != null) {\n            append(seq);\n        }\n    }\n\n    /**\n     * Constructs an instance with the specified initial capacity.\n     *\n     * @param initialCapacity the initial capacity, zero or less will be converted to 32\n     */\n    public TextStringBuilder(final int initialCapacity) {\n        buffer = new char[initialCapacity <= 0 ? CAPACITY : initialCapacity];\n    }\n\n    /**\n     * Constructs an instance from a string, allocating 32 extra characters for growth.\n     *\n     * @param str the string to copy, null treated as blank string\n     */\n    public TextStringBuilder(final String str) {\n        this(StringUtils.length(str) + CAPACITY);\n        if (str != null) {\n            append(str);\n        }\n    }\n\n    /**\n     * Appends a boolean value to the string builder.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final boolean value) {\n        if (value) {\n            ensureCapacity(size + TRUE_STRING_SIZE);\n            appendTrue(size);\n        } else {\n            ensureCapacity(size + FALSE_STRING_SIZE);\n            appendFalse(size);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char value to the string builder.\n     *\n     * @param ch the value to append\n     * @return this, to enable chaining\n     */\n    @Override\n    public TextStringBuilder append(final char ch) {\n        final int len = length();\n        ensureCapacity(len + 1);\n        buffer[size++] = ch;\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final char[] chars) {\n        if (chars == null) {\n            return appendNull();\n        }\n        final int strLen = chars.length;\n        if (strLen > 0) {\n            final int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(chars, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     * @throws StringIndexOutOfBoundsException if {@code startIndex} is not in the\n     *  range {@code 0 <= startIndex <= chars.length}\n     * @throws StringIndexOutOfBoundsException if {@code length < 0}\n     * @throws StringIndexOutOfBoundsException if {@code startIndex + length > chars.length}\n     */\n    public TextStringBuilder append(final char[] chars, final int startIndex, final int length) {\n        if (chars == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n        }\n        if (length < 0 || startIndex + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(chars, startIndex, buffer, len, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends the contents of a char buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the char buffer to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final CharBuffer str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends the contents of a char buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param buf the char buffer to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final CharBuffer buf, final int startIndex, final int length) {\n        if (buf == null) {\n            return appendNull();\n        }\n        if (buf.hasArray()) {\n            final int totalLength = buf.remaining();\n            if (startIndex < 0 || startIndex > totalLength) {\n                throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n            }\n            if (length < 0 || startIndex + length > totalLength) {\n                throw new StringIndexOutOfBoundsException(\"length must be valid\");\n            }\n            final int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(buf.array(), buf.arrayOffset() + buf.position() + startIndex, buffer, len, length);\n            size += length;\n        } else {\n            append(buf.toString(), startIndex, length);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a CharSequence to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param seq the CharSequence to append\n     * @return this, to enable chaining\n     */\n    @Override\n    public TextStringBuilder append(final CharSequence seq) {\n        if (seq == null) {\n            return appendNull();\n        }\n        if (seq instanceof TextStringBuilder) {\n            return append((TextStringBuilder) seq);\n        }\n        if (seq instanceof StringBuilder) {\n            return append((StringBuilder) seq);\n        }\n        if (seq instanceof StringBuffer) {\n            return append((StringBuffer) seq);\n        }\n        if (seq instanceof CharBuffer) {\n            return append((CharBuffer) seq);\n        }\n        return append(seq.toString());\n    }\n\n    /**\n     * Appends part of a CharSequence to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param seq the CharSequence to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid\n     * @return this, to enable chaining\n     */\n    @Override\n    public TextStringBuilder append(final CharSequence seq, final int startIndex, final int endIndex) {\n        if (seq == null) {\n            return appendNull();\n        }\n        if (endIndex <= 0) {\n            throw new StringIndexOutOfBoundsException(\"endIndex must be valid\");\n        }\n        if (startIndex >= endIndex) {\n            throw new StringIndexOutOfBoundsException(\"endIndex must be greater than startIndex\");\n        }\n        return append(seq.toString(), startIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Appends a double value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final double value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a float value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final float value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends an int value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final int value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a long value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final long value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends an object to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param obj the object to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final Object obj) {\n        if (obj == null) {\n            return appendNull();\n        }\n        if (obj instanceof CharSequence) {\n            return append((CharSequence) obj);\n        }\n        return append(obj.toString());\n    }\n\n    /**\n     * Appends a string to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final String str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a string to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     * @throws StringIndexOutOfBoundsException if {@code startIndex} is not in the\n     *  range {@code 0 <= startIndex <= str.length()}\n     * @throws StringIndexOutOfBoundsException if {@code length < 0}\n     * @throws StringIndexOutOfBoundsException if {@code startIndex + length > str.length()}\n     */\n    public TextStringBuilder append(final String str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Calls {@link String#format(String, Object...)} and appends the result.\n     *\n     * @param format the format string\n     * @param objs the objects to use in the format string\n     * @return {@code this} to enable chaining\n     * @see String#format(String, Object...)\n     */\n    public TextStringBuilder append(final String format, final Object... objs) {\n        return append(String.format(format, objs));\n    }\n\n    /**\n     * Appends a string buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string buffer to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuffer str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a string buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuffer str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a StringBuilder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the StringBuilder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuilder str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a StringBuilder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the StringBuilder to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuilder str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends another string builder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final TextStringBuilder str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a string builder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final TextStringBuilder str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an iterable to the builder without any separators. Appending a null iterable will have no\n     * effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param iterable the iterable to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendAll(final Iterable<?> iterable) {\n        if (iterable != null) {\n            iterable.forEach(this::append);\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an iterator to the builder without any separators. Appending a null iterator will have no\n     * effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param it the iterator to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendAll(final Iterator<?> it) {\n        if (it != null) {\n            it.forEachRemaining(this::append);\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an array to the builder without any separators. Appending a null array will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param <T> the element type\n     * @param array the array to append\n     * @return this, to enable chaining\n     */\n    public <T> TextStringBuilder appendAll(@SuppressWarnings(\"unchecked\") final T... array) {\n        /*\n         * @SuppressWarnings used to hide warning about vararg usage. We cannot use @SafeVarargs, since this method is\n         * not final. Using @SuppressWarnings is fine, because it isn't inherited by subclasses, so each subclass must\n         * vouch for itself whether its use of 'array' is safe.\n         */\n        if (array != null && array.length > 0) {\n            for (final Object element : array) {\n                append(element);\n            }\n        }\n        return this;\n    }\n\n    /** Appends {@code \"false\"}. */\n    private void appendFalse(int index) {\n        buffer[index++] = 'f';\n        buffer[index++] = 'a';\n        buffer[index++] = 'l';\n        buffer[index++] = 's';\n        buffer[index] = 'e';\n        size += FALSE_STRING_SIZE;\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width. The {@code String.valueOf} of the\n     * {@code int} value is used. If the formatted value is larger than the length, the left hand side is lost.\n     *\n     * @param value the value to append\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {\n        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width. The {@code toString} of the object is\n     * used. If the object is larger than the length, the left hand side is lost. If the object is null, the null text\n     * value is used.\n     *\n     * @param obj the object to append, null uses null text\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = obj == null ? getNullText() : obj.toString();\n            if (str == null) {\n                str = StringUtils.EMPTY;\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length. The {@code String.valueOf} of the\n     * {@code int} value is used. If the object is larger than the length, the right hand side is lost.\n     *\n     * @param value the value to append\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {\n        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length. The {@code toString} of the object is\n     * used. If the object is larger than the length, the right hand side is lost. If the object is null, null text\n     * value is used.\n     *\n     * @param obj the object to append, null uses null text\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = obj == null ? getNullText() : obj.toString();\n            if (str == null) {\n                str = StringUtils.EMPTY;\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a boolean value followed by a new line to the string builder.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final boolean value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a char value followed by a new line to the string builder.\n     *\n     * @param ch the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final char ch) {\n        return append(ch).appendNewLine();\n    }\n\n    /**\n     * Appends a char array followed by a new line to the string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final char[] chars) {\n        return append(chars).appendNewLine();\n    }\n\n    /**\n     * Appends a char array followed by a new line to the string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final char[] chars, final int startIndex, final int length) {\n        return append(chars, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends a double value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final double value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a float value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final float value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends an int value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final int value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a long value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final long value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends an object followed by a new line to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param obj the object to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final Object obj) {\n        return append(obj).appendNewLine();\n    }\n\n    /**\n     * Appends a string followed by a new line to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final String str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final String str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Calls {@link String#format(String, Object...)} and appends the result.\n     *\n     * @param format the format string\n     * @param objs the objects to use in the format string\n     * @return {@code this} to enable chaining\n     * @see String#format(String, Object...)\n     */\n    public TextStringBuilder appendln(final String format, final Object... objs) {\n        return append(format, objs).appendNewLine();\n    }\n\n    /**\n     * Appends a string buffer followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string buffer to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuffer str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string buffer followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuffer str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends a string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuilder str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuilder str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends another string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final TextStringBuilder str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final TextStringBuilder str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends the new line string to this string builder.\n     * <p>\n     * The new line string can be altered using {@link #setNewLineText(String)}. This might be used to force the output\n     * to always use Unix line endings even when on Windows.\n     * </p>\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendNewLine() {\n        if (newLine == null) {\n            append(System.lineSeparator());\n            return this;\n        }\n        return append(newLine);\n    }\n\n    /**\n     * Appends the text representing {@code null} to this string builder.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendNull() {\n        if (nullText == null) {\n            return this;\n        }\n        return append(nullText);\n    }\n\n    /**\n     * Appends the pad character to the builder the specified number of times.\n     *\n     * @param length the length to append, negative means no append\n     * @param padChar the character to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendPadding(final int length, final char padChar) {\n        if (length >= 0) {\n            ensureCapacity(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator if the builder is currently non-empty. The separator is appended using {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (Iterator it = list.iterator(); it.hasNext();) {\n     *     appendSeparator(',');\n     *     append(it.next());\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final char separator) {\n        if (isNotEmpty()) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends one of both separators to the builder If the builder is currently empty it will append the\n     * defaultIfEmpty-separator Otherwise it will append the standard-separator\n     *\n     * The separator is appended using {@link #append(char)}.\n     *\n     * @param standard the separator if builder is not empty\n     * @param defaultIfEmpty the separator if builder is empty\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final char standard, final char defaultIfEmpty) {\n        if (isEmpty()) {\n            append(defaultIfEmpty);\n        } else {\n            append(standard);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero. The separator is appended using\n     * {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (int i = 0; i &lt; list.size(); i++) {\n     *     appendSeparator(\",\", i);\n     *     append(list.get(i));\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use\n     * @param loopIndex the loop index\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final char separator, final int loopIndex) {\n        if (loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator if the builder is currently non-empty. Appending a null separator will have no effect. The\n     * separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (Iterator it = list.iterator(); it.hasNext();) {\n     *     appendSeparator(\",\");\n     *     append(it.next());\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final String separator) {\n        return appendSeparator(separator, null);\n    }\n\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero. Appending a null separator will have\n     * no effect. The separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (int i = 0; i &lt; list.size(); i++) {\n     *     appendSeparator(\",\", i);\n     *     append(list.get(i));\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use, null means no separator\n     * @param loopIndex the loop index\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final String separator, final int loopIndex) {\n        if (separator != null && loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends one of both separators to the StrBuilder. If the builder is currently empty it will append the\n     * defaultIfEmpty-separator Otherwise it will append the standard-separator\n     *\n     * Appending a null separator will have no effect. The separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is for example useful for constructing queries\n     * </p>\n     *\n     * <pre>\n     * StrBuilder whereClause = new StrBuilder();\n     * if(searchCommand.getPriority() != null) {\n     *  whereClause.appendSeparator(\" and\", \" where\");\n     *  whereClause.append(\" priority = ?\")\n     * }\n     * if(searchCommand.getComponent() != null) {\n     *  whereClause.appendSeparator(\" and\", \" where\");\n     *  whereClause.append(\" component = ?\")\n     * }\n     * selectClause.append(whereClause)\n     * </pre>\n     *\n     * @param standard the separator if builder is not empty, null means no separator\n     * @param defaultIfEmpty the separator if builder is empty, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final String standard, final String defaultIfEmpty) {\n        final String str = isEmpty() ? defaultIfEmpty : standard;\n        if (str != null) {\n            append(str);\n        }\n        return this;\n    }\n\n    /**\n     * Appends current contents of this {@code StrBuilder} to the provided {@link Appendable}.\n     * <p>\n     * This method tries to avoid doing any extra copies of contents.\n     * </p>\n     *\n     * @param appendable the appendable to append data to\n     * @throws IOException if an I/O error occurs.\n     *\n     * @see #readFrom(Readable)\n     */\n    public void appendTo(final Appendable appendable) throws IOException {\n        if (appendable instanceof Writer) {\n            ((Writer) appendable).write(buffer, 0, size);\n        } else if (appendable instanceof StringBuilder) {\n            ((StringBuilder) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof StringBuffer) {\n            ((StringBuffer) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof CharBuffer) {\n            ((CharBuffer) appendable).put(buffer, 0, size);\n        } else {\n            appendable.append(this);\n        }\n    }\n\n    /** Appends {@code \"true\"}. */\n    private void appendTrue(int index) {\n        buffer[index++] = 't';\n        buffer[index++] = 'r';\n        buffer[index++] = 'u';\n        buffer[index] = 'e';\n        size += TRUE_STRING_SIZE;\n    }\n\n    /**\n     * Appends an iterable placing separators between each value, but not before the first or after the last. Appending\n     * a null iterable will have no effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param iterable the iterable to append\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendWithSeparators(final Iterable<?> iterable, final String separator) {\n        if (iterable != null) {\n            appendWithSeparators(iterable.iterator(), separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends an iterator placing separators between each value, but not before the first or after the last. Appending\n     * a null iterator will have no effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param it the iterator to append\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendWithSeparators(final Iterator<?> it, final String separator) {\n        if (it != null) {\n            final String sep = Objects.toString(separator, StringUtils.EMPTY);\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(sep);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends an array placing separators between each value, but not before the first or after the last. Appending a\n     * null array will have no effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param array the array to append\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendWithSeparators(final Object[] array, final String separator) {\n        if (array != null && array.length > 0) {\n            final String sep = Objects.toString(separator, StringUtils.EMPTY);\n            append(array[0]);\n            for (int i = 1; i < array.length; i++) {\n                append(sep);\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Gets the contents of this builder as a Reader.\n     * <p>\n     * This method allows the contents of the builder to be read using any standard method that expects a Reader.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder}, populate it with data, call {@code asReader}, and then read away.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the reader. This allows you to append to the\n     * builder after creating the reader, and the changes will be picked up. Note however, that no synchronization\n     * occurs, so you must perform all operations with the builder and the reader in one thread.\n     * </p>\n     * <p>\n     * The returned reader supports marking, and ignores the flush method.\n     * </p>\n     *\n     * @return a reader that reads from this builder\n     */\n    public Reader asReader() {\n        return new TextStringBuilderReader();\n    }\n\n    /**\n     * Creates a tokenizer that can tokenize the contents of this builder.\n     * <p>\n     * This method allows the contents of this builder to be tokenized. The tokenizer will be setup by default to\n     * tokenize on space, tab, newline and form feed (as per StringTokenizer). These values can be changed on the\n     * tokenizer class, before retrieving the tokens.\n     * </p>\n     * <p>\n     * The returned tokenizer is linked to this builder. You may intermix calls to the builder and tokenizer within\n     * certain limits, however there is no synchronization. Once the tokenizer has been used once, it must be\n     * {@link StringTokenizer#reset() reset} to pickup the latest changes in the builder. For example:\n     * </p>\n     *\n     * <pre>\n     * StrBuilder b = new StrBuilder();\n     * b.append(\"a b \");\n     * StrTokenizer t = b.asTokenizer();\n     * String[] tokens1 = t.getTokenArray(); // returns a,b\n     * b.append(\"c d \");\n     * String[] tokens2 = t.getTokenArray(); // returns a,b (c and d ignored)\n     * t.reset(); // reset causes builder changes to be picked up\n     * String[] tokens3 = t.getTokenArray(); // returns a,b,c,d\n     * </pre>\n     *\n     * <p>\n     * In addition to simply intermixing appends and tokenization, you can also call the set methods on the tokenizer to\n     * alter how it tokenizes. Just remember to call reset when you want to pickup builder changes.\n     * </p>\n     * <p>\n     * Calling {@link StringTokenizer#reset(String)} or {@link StringTokenizer#reset(char[])} with a non-null value will\n     * break the link with the builder.\n     * </p>\n     *\n     * @return a tokenizer that is linked to this builder\n     */\n    public StringTokenizer asTokenizer() {\n        return new TextStringBuilderTokenizer();\n    }\n\n    /**\n     * Gets this builder as a Writer that can be written to.\n     * <p>\n     * This method allows you to populate the contents of the builder using any standard method that takes a Writer.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder}, call {@code asWriter}, and populate away. The data is available at\n     * any time using the methods of the {@code StrBuilder}.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the writer. This allows you to intermix calls that\n     * append to the builder and write using the writer and the changes will be occur correctly. Note however, that no\n     * synchronization occurs, so you must perform all operations with the builder and the writer in one thread.\n     * </p>\n     * <p>\n     * The returned writer ignores the close and flush methods.\n     * </p>\n     *\n     * @return a writer that populates this builder\n     */\n    public Writer asWriter() {\n        return new TextStringBuilderWriter();\n    }\n\n    /**\n     * Implement the {@link Builder} interface.\n     *\n     * @return The builder as a String\n     * @see #toString()\n     */\n    @Override\n    public String build() {\n        return toString();\n    }\n\n    /**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return The capacity\n     */\n    public int capacity() {\n        return buffer.length;\n    }\n\n    /**\n     * Gets the character at the specified index.\n     *\n     * @see #setCharAt(int, char)\n     * @see #deleteCharAt(int)\n     * @param index the index to retrieve, must be valid\n     * @return The character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    @Override\n    public char charAt(final int index) {\n        validateIndex(index);\n        return buffer[index];\n    }\n\n    /**\n     * Clears the string builder (convenience Collections API style method).\n     * <p>\n     * This method does not reduce the size of the internal character buffer. To do that, call {@code clear()} followed\n     * by {@link #minimizeCapacity()}.\n     * </p>\n     * <p>\n     * This method is the same as {@link #setLength(int)} called with zero and is provided to match the API of\n     * Collections.\n     * </p>\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder clear() {\n        size = 0;\n        return this;\n    }\n\n    /**\n     * Tests if the string builder contains the specified char.\n     *\n     * @param ch the character to find\n     * @return true if the builder contains the character\n     */\n    public boolean contains(final char ch) {\n        final char[] thisBuf = buffer;\n        for (int i = 0; i < this.size; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Tests if the string builder contains the specified string.\n     *\n     * @param str the string to find\n     * @return true if the builder contains the string\n     */\n    public boolean contains(final String str) {\n        return indexOf(str, 0) >= 0;\n    }\n\n    /**\n     * Tests if the string builder contains a string matched using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to search for\n     * the character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @return true if the matcher finds a match in the builder\n     */\n    public boolean contains(final StringMatcher matcher) {\n        return indexOf(matcher, 0) >= 0;\n    }\n\n    /**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder delete(final int startIndex, final int endIndex) {\n        final int actualEndIndex = validateRange(startIndex, endIndex);\n        final int len = actualEndIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, actualEndIndex, len);\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch the character to delete\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteAll(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                final int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                final int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteAll(final String str) {\n        final int len = str == null ? 0 : str.length();\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            while (index >= 0) {\n                deleteImpl(index, index + len, len);\n                index = indexOf(str, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes all parts of the builder that the matcher matches.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteAll(final StringMatcher matcher) {\n        return replace(matcher, null, 0, size, -1);\n    }\n\n    /**\n     * Deletes the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #setCharAt(int, char)\n     * @param index the index to delete\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder deleteCharAt(final int index) {\n        validateIndex(index);\n        deleteImpl(index, index + 1, 1);\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch the character to delete\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteFirst(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteFirst(final String str) {\n        final int len = str == null ? 0 : str.length();\n        if (len > 0) {\n            final int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the first match within the builder using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior. For example you could write a matcher to delete where\n     * the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteFirst(final StringMatcher matcher) {\n        return replace(matcher, null, 0, size, 1);\n    }\n\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex the start index, must be valid\n     * @param endIndex the end index (exclusive), must be valid\n     * @param len the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void deleteImpl(final int startIndex, final int endIndex, final int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    /**\n     * Gets the character at the specified index before deleting it.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index the index to retrieve, must be valid\n     * @return The character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 1.9\n     */\n    public char drainChar(final int index) {\n        validateIndex(index);\n        final char c = buffer[index];\n        deleteCharAt(index);\n        return c;\n    }\n\n    /**\n     * Drains (copies, then deletes) this character sequence into the specified array. This is equivalent to copying the\n     * characters from this sequence into the target and then deleting those character from this sequence.\n     *\n     * @param startIndex first index to copy, inclusive.\n     * @param endIndex last index to copy, exclusive.\n     * @param target the target array, must not be {@code null}.\n     * @param targetIndex the index to start copying in the target.\n     * @return How many characters where copied (then deleted). If this builder is empty, return {@code 0}.\n     * @since 1.9\n     */\n    public int drainChars(final int startIndex, final int endIndex, final char[] target, final int targetIndex) {\n        final int length = endIndex - startIndex;\n        if (isEmpty() || length == 0 || target.length == 0) {\n            return 0;\n        }\n        final int actualLen = Math.min(Math.min(size, length), target.length - targetIndex);\n        getChars(startIndex, actualLen, target, targetIndex);\n        delete(startIndex, actualLen);\n        return actualLen;\n    }\n\n    /**\n     * Checks whether this builder ends with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str the string to search for, null returns false\n     * @return true if the builder ends with the string\n     */\n    public boolean endsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        int pos = size - len;\n        for (int i = 0; i < len; i++, pos++) {\n            if (buffer[pos] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests the capacity and ensures that it is at least the size specified.\n     *\n     * @param capacity the capacity to ensure\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder ensureCapacity(final int capacity) {\n        // checks for overflow\n        if (capacity > 0 && capacity - buffer.length > 0) {\n            reallocate(capacity);\n        }\n        return this;\n    }\n\n    /**\n     * Tests the contents of this builder against another to see if they contain the same character content.\n     *\n     * @param obj the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        return obj instanceof TextStringBuilder && equals((TextStringBuilder) obj);\n    }\n\n    /**\n     * Tests the contents of this builder against another to see if they contain the same character content.\n     *\n     * @param other the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equals(final TextStringBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (other == null) {\n            return false;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        // Be aware not to use Arrays.equals(buffer, other.buffer) for equals() method\n        // as length of the buffers may be different (TEXT-211)\n        final char[] thisBuf = this.buffer;\n        final char[] otherBuf = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            if (thisBuf[i] != otherBuf[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests the contents of this builder against another to see if they contain the same character content ignoring\n     * case.\n     *\n     * @param other the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equalsIgnoreCase(final TextStringBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        final char[] thisBuf = this.buffer;\n        final char[] otherBuf = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            final char c1 = thisBuf[i];\n            final char c2 = otherBuf[i];\n            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /** Gets a direct reference to internal storage, not for public consumption. */\n    char[] getBuffer() {\n        return buffer;\n    }\n\n    /**\n     * Copies this character array into the specified array.\n     *\n     * @param target the target array, null will cause an array to be created\n     * @return The input array, unless that was null or too small\n     */\n    public char[] getChars(char[] target) {\n        final int len = length();\n        if (target == null || target.length < len) {\n            target = new char[len];\n        }\n        System.arraycopy(buffer, 0, target, 0, len);\n        return target;\n    }\n\n    /**\n     * Copies this character array into the specified array.\n     *\n     * @param startIndex first index to copy, inclusive, must be valid.\n     * @param endIndex last index to copy, exclusive, must be valid.\n     * @param target the target array, must not be null or too small.\n     * @param targetIndex the index to start copying in target.\n     * @throws NullPointerException if the array is null.\n     * @throws IndexOutOfBoundsException if any index is invalid.\n     */\n    public void getChars(final int startIndex, final int endIndex, final char[] target, final int targetIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex < 0 || endIndex > length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        System.arraycopy(buffer, startIndex, target, targetIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Gets the text to be appended when a new line is added.\n     *\n     * @return The new line text, null means use system default\n     */\n    public String getNewLineText() {\n        return newLine;\n    }\n\n    /**\n     * Gets the text to be appended when null is added.\n     *\n     * @return The null text, null means no append\n     */\n    public String getNullText() {\n        return nullText;\n    }\n\n    /**\n     * Gets a suitable hash code for this builder.\n     *\n     * @return a hash code\n     */\n    @Override\n    public int hashCode() {\n        // no allocation\n        final char[] buf = buffer;\n        int result = 0;\n        for (int i = 0; i < size; i++) {\n            result = 31 * result + buf[i];\n        }\n        return result;\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     *\n     * @param ch the character to find\n     * @return The first index of the character, or -1 if not found\n     */\n    public int indexOf(final char ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     *\n     * @param ch the character to find\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The first index of the character, or -1 if not found\n     */\n    public int indexOf(final char ch, int startIndex) {\n        startIndex = Math.max(0, startIndex);\n        if (startIndex >= size) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str the string to find, null returns -1\n     * @return The first index of the string, or -1 if not found\n     */\n    public int indexOf(final String str) {\n        return indexOf(str, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified string starting searching from the given\n     * index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str the string to find, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The first index of the string, or -1 if not found\n     */\n    public int indexOf(final String str, int startIndex) {\n        startIndex = Math.max(0, startIndex);\n        if (str == null || startIndex >= size) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final char[] thisBuf = buffer;\n        final int len = size - strLen + 1;\n        outer: for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @return The first index matched, or -1 if not found\n     */\n    public int indexOf(final StringMatcher matcher) {\n        return indexOf(matcher, 0);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The first index matched, or -1 if not found\n     */\n    public int indexOf(final StringMatcher matcher, int startIndex) {\n        startIndex = Math.max(0, startIndex);\n        if (matcher == null || startIndex >= size) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final int len = size;\n        final char[] buf = buffer;\n        for (int i = startIndex; i < len; i++) {\n            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + TRUE_STRING_SIZE);\n            System.arraycopy(buffer, index, buffer, index + TRUE_STRING_SIZE, size - index);\n            appendTrue(index);\n        } else {\n            ensureCapacity(size + FALSE_STRING_SIZE);\n            System.arraycopy(buffer, index, buffer, index + FALSE_STRING_SIZE, size - index);\n            appendFalse(index);\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Inserts the character array into this builder. Inserting null will use the stored null text value.\n     *\n     * @param index the index to add at, must be valid\n     * @param chars the char array to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final char[] chars) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        final int len = chars.length;\n        if (len > 0) {\n            ensureCapacity(size + len);\n            System.arraycopy(buffer, index, buffer, index + len, size - index);\n            System.arraycopy(chars, 0, buffer, index, len);\n            size += len;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts part of the character array into this builder. Inserting null will use the stored null text value.\n     *\n     * @param index the index to add at, must be valid\n     * @param chars the char array to insert\n     * @param offset the offset into the character array to start at, must be valid\n     * @param length the length of the character array part to copy, must be positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    public TextStringBuilder insert(final int index, final char[] chars, final int offset, final int length) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        if (offset < 0 || offset > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n        }\n        if (length < 0 || offset + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            ensureCapacity(size + length);\n            System.arraycopy(buffer, index, buffer, index + length, size - index);\n            System.arraycopy(chars, offset, buffer, index, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the string representation of an object into this builder. Inserting null will use the stored null text\n     * value.\n     *\n     * @param index the index to add at, must be valid\n     * @param obj the object to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final Object obj) {\n        if (obj == null) {\n            return insert(index, nullText);\n        }\n        return insert(index, obj.toString());\n    }\n\n    /**\n     * Inserts the string into this builder. Inserting null will use the stored null text value.\n     *\n     * @param index the index to add at, must be valid\n     * @param str the string to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, String str) {\n        validateIndex(index);\n        if (str == null) {\n            str = nullText;\n        }\n        if (str != null) {\n            final int strLen = str.length();\n            if (strLen > 0) {\n                final int newSize = size + strLen;\n                ensureCapacity(newSize);\n                System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n                size = newSize;\n                str.getChars(0, strLen, buffer, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Checks is the string builder is empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return {@code true} if the size is {@code 0}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Checks is the string builder is not empty.\n     * <p>\n     * This method is the same as checking {@link #length()}.\n     * </p>\n     *\n     * @return {@code true} if the size is not {@code 0}.\n     * @since 1.9\n     */\n    public boolean isNotEmpty() {\n        return size != 0;\n    }\n\n    /**\n     * Gets whether the internal buffer has been reallocated.\n     *\n     * @return Whether the internal buffer has been reallocated.\n     * @since 1.9\n     */\n    public boolean isReallocated() {\n        return reallocations > 0;\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     *\n     * @param ch the character to find\n     * @return The last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(final char ch) {\n        return lastIndexOf(ch, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     *\n     * @param ch the character to find\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(final char ch, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (startIndex < 0) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (buffer[i] == ch) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str the string to find, null returns -1\n     * @return The last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(final String str) {\n        return lastIndexOf(str, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified string starting searching from the given\n     * index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str the string to find, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(final String str, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (str == null || startIndex < 0) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final int strLen = str.length();\n        if (strLen > 0 && strLen <= size) {\n            if (strLen == 1) {\n                return lastIndexOf(str.charAt(0), startIndex);\n            }\n\n            outer: for (int i = startIndex - strLen + 1; i >= 0; i--) {\n                for (int j = 0; j < strLen; j++) {\n                    if (str.charAt(j) != buffer[i + j]) {\n                        continue outer;\n                    }\n                }\n                return i;\n            }\n\n        } else if (strLen == 0) {\n            return startIndex;\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last match.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @return The last index matched, or -1 if not found\n     */\n    public int lastIndexOf(final StringMatcher matcher) {\n        return lastIndexOf(matcher, size);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The last index matched, or -1 if not found\n     */\n    public int lastIndexOf(final StringMatcher matcher, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (matcher == null || startIndex < 0) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final char[] buf = buffer;\n        final int endIndex = startIndex + 1;\n        for (int i = startIndex; i >= 0; i--) {\n            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Extracts the leftmost characters from the string builder without throwing an exception.\n     * <p>\n     * This method extracts the left {@code length} characters from the builder. If this many characters are not\n     * available, the whole builder is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String leftString(final int length) {\n        if (length <= 0) {\n            return StringUtils.EMPTY;\n        }\n        if (length >= size) {\n            return new String(buffer, 0, size);\n        }\n        return new String(buffer, 0, length);\n    }\n\n    /**\n     * Gets the length of the string builder.\n     *\n     * @return The length\n     */\n    @Override\n    public int length() {\n        return size;\n    }\n\n    /**\n     * Extracts some characters from the middle of the string builder without throwing an exception.\n     * <p>\n     * This method extracts {@code length} characters from the builder at the specified index. If the index is negative\n     * it is treated as zero. If the index is greater than the builder size, it is treated as the builder size. If the\n     * length is negative, the empty string is returned. If insufficient characters are available in the builder, as\n     * much as possible is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param index the index to start at, negative means zero\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String midString(int index, final int length) {\n        if (index < 0) {\n            index = 0;\n        }\n        if (length <= 0 || index >= size) {\n            return StringUtils.EMPTY;\n        }\n        if (size <= index + length) {\n            return new String(buffer, index, size - index);\n        }\n        return new String(buffer, index, length);\n    }\n\n    /**\n     * Minimizes the capacity to the actual length of the string.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder minimizeCapacity() {\n        if (buffer.length > size) {\n            reallocate(size);\n        }\n        return this;\n    }\n\n    /**\n     * If possible, reads chars from the provided {@link CharBuffer} directly into underlying character buffer without\n     * making extra copies.\n     *\n     * @param charBuffer CharBuffer to read.\n     * @return The number of characters read.\n     *\n     * @see #appendTo(Appendable)\n     * @since 1.9\n     */\n    public int readFrom(final CharBuffer charBuffer) {\n        final int oldSize = size;\n        final int remaining = charBuffer.remaining();\n        ensureCapacity(size + remaining);\n        charBuffer.get(buffer, size, remaining);\n        size += remaining;\n        return size - oldSize;\n    }\n\n    /**\n     * If possible, reads all chars from the provided {@link Readable} directly into underlying character buffer without\n     * making extra copies.\n     *\n     * @param readable object to read from\n     * @return The number of characters read\n     * @throws IOException if an I/O error occurs.\n     *\n     * @see #appendTo(Appendable)\n     */\n    public int readFrom(final Readable readable) throws IOException {\n        if (readable instanceof Reader) {\n            return readFrom((Reader) readable);\n        }\n        if (readable instanceof CharBuffer) {\n            return readFrom((CharBuffer) readable);\n        }\n        final int oldSize = size;\n        while (true) {\n            ensureCapacity(size + 1);\n            final CharBuffer buf = CharBuffer.wrap(buffer, size, buffer.length - size);\n            final int read = readable.read(buf);\n            if (read == EOS) {\n                break;\n            }\n            size += read;\n        }\n        return size - oldSize;\n    }\n\n    /**\n     * If possible, reads all chars from the provided {@link Reader} directly into underlying character buffer without\n     * making extra copies.\n     *\n     * @param reader Reader to read.\n     * @return The number of characters read or -1 if we reached the end of stream.\n     * @throws IOException if an I/O error occurs.\n     *\n     * @see #appendTo(Appendable)\n     * @since 1.9\n     */\n    public int readFrom(final Reader reader) throws IOException {\n        final int oldSize = size;\n        ensureCapacity(size + 1);\n        int readCount = reader.read(buffer, size, buffer.length - size);\n        if (readCount == EOS) {\n            return EOS;\n        }\n        do {\n            size += readCount;\n            ensureCapacity(size + 1);\n            readCount = reader.read(buffer, size, buffer.length - size);\n        } while (readCount != EOS);\n        return size - oldSize;\n    }\n\n    /**\n     * If possible, reads {@code count} chars from the provided {@link Reader} directly into underlying character buffer\n     * without making extra copies.\n     *\n     * @param reader Reader to read.\n     * @param count The maximum characters to read, a value &lt;= 0 returns 0.\n     * @return The number of characters read. If less than {@code count}, then we've reached the end-of-stream, or -1 if\n     *         we reached the end of stream.\n     * @throws IOException if an I/O error occurs.\n     * @see #appendTo(Appendable)\n     * @since 1.9\n     */\n    public int readFrom(final Reader reader, final int count) throws IOException {\n        if (count <= 0) {\n            return 0;\n        }\n        final int oldSize = size;\n        ensureCapacity(size + count);\n        int target = count;\n        int readCount = reader.read(buffer, size, target);\n        if (readCount == EOS) {\n            return EOS;\n        }\n        do {\n            target -= readCount;\n            size += readCount;\n            readCount = reader.read(buffer, size, target);\n        } while (target > 0 && readCount != EOS);\n        return size - oldSize;\n    }\n\n    /**\n     * Reallocates the buffer to the new length.\n     *\n     * @param newLength the length of the copy to be returned\n     */\n    private void reallocate(final int newLength) {\n        this.buffer = Arrays.copyOf(buffer, newLength);\n        this.reallocations++;\n    }\n\n    /**\n     * Replaces a portion of the string builder with another string. The length of the inserted string does not have to\n     * match the removed length.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @param replaceStr the string to replace with, null means delete range\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder replace(final int startIndex, int endIndex, final String replaceStr) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int insertLen = replaceStr == null ? 0 : replaceStr.length();\n        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n        return this;\n    }\n\n    /**\n     * Advanced search and replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the string to replace the match with, null is a delete\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @param replaceCount the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if start index is invalid\n     */\n    public TextStringBuilder replace(final StringMatcher matcher, final String replaceStr, final int startIndex,\n        int endIndex, final int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }\n\n    /**\n     * Replaces the search character with the replace character throughout the builder.\n     *\n     * @param search the search character\n     * @param replace the replace character\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceAll(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the search string with the replace string throughout the builder.\n     *\n     * @param searchStr the search string, null causes no action to occur\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceAll(final String searchStr, final String replaceStr) {\n        final int searchLen = searchStr == null ? 0 : searchStr.length();\n        if (searchLen > 0) {\n            final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n            int index = indexOf(searchStr, 0);\n            while (index >= 0) {\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n                index = indexOf(searchStr, index + replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces all matches within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior. For example you could write a matcher to replace all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceAll(final StringMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }\n\n    /**\n     * Replaces the first instance of the search character with the replace character in the builder.\n     *\n     * @param search the search character\n     * @param replace the replace character\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceFirst(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search string with the replace string.\n     *\n     * @param searchStr the search string, null causes no action to occur\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceFirst(final String searchStr, final String replaceStr) {\n        final int searchLen = searchStr == null ? 0 : searchStr.length();\n        if (searchLen > 0) {\n            final int index = indexOf(searchStr, 0);\n            if (index >= 0) {\n                final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first match within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior. For example you could write a matcher to replace where\n     * the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceFirst(final StringMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }\n\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex the start index, must be valid\n     * @param endIndex the end index (exclusive), must be valid\n     * @param removeLen the length to remove (endIndex - startIndex), must be valid\n     * @param insertStr the string to replace with, null means delete range\n     * @param insertLen the length of the insert string, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr,\n        final int insertLen) {\n        final int newSize = size - removeLen + insertLen;\n        if (insertLen != removeLen) {\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n            size = newSize;\n        }\n        if (insertLen > 0) {\n            insertStr.getChars(0, insertLen, buffer, startIndex);\n        }\n    }\n\n    /**\n     * Replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the string to replace the match with, null is a delete\n     * @param from the start index, must be valid\n     * @param to the end index (exclusive), must be valid\n     * @param replaceCount the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private TextStringBuilder replaceImpl(final StringMatcher matcher, final String replaceStr, final int from, int to,\n        int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            final char[] buf = buffer;\n            final int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Reverses the string builder placing each character in the opposite index.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder reverse() {\n        if (size == 0) {\n            return this;\n        }\n\n        final int half = size / 2;\n        final char[] buf = buffer;\n        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {\n            final char swap = buf[leftIdx];\n            buf[leftIdx] = buf[rightIdx];\n            buf[rightIdx] = swap;\n        }\n        return this;\n    }\n\n    /**\n     * Extracts the rightmost characters from the string builder without throwing an exception.\n     * <p>\n     * This method extracts the right {@code length} characters from the builder. If this many characters are not\n     * available, the whole builder is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String rightString(final int length) {\n        if (length <= 0) {\n            return StringUtils.EMPTY;\n        }\n        if (length >= size) {\n            return new String(buffer, 0, size);\n        }\n        return new String(buffer, size - length, length);\n    }\n\n    /**\n     * Clears and sets this builder to the given value.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param str the new value.\n     * @return this, to enable chaining\n     * @since 1.9\n     */\n    public TextStringBuilder set(final CharSequence str) {\n        clear();\n        append(str);\n        return this;\n    }\n\n    /**\n     * Sets the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index the index to set\n     * @param ch the new character\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder setCharAt(final int index, final char ch) {\n        validateIndex(index);\n        buffer[index] = ch;\n        return this;\n    }\n\n    /**\n     * Updates the length of the builder by either dropping the last characters or adding filler of Unicode zero.\n     *\n     * @param length the length to set to, must be zero or positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the length is negative\n     */\n    public TextStringBuilder setLength(final int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacity(length);\n            final int oldEnd = size;\n            size = length;\n            Arrays.fill(buffer, oldEnd, length, '\\0');\n        }\n        return this;\n    }\n\n    /**\n     * Sets the text to be appended when a new line is added.\n     *\n     * @param newLine the new line text, null means use system default\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder setNewLineText(final String newLine) {\n        this.newLine = newLine;\n        return this;\n    }\n\n    /**\n     * Sets the text to be appended when null is added.\n     *\n     * @param nullText the null text, null means no append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.isEmpty()) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }\n\n    /**\n     * Gets the length of the string builder.\n     * <p>\n     * This method is the same as {@link #length()} and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return The length\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Checks whether this builder starts with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str the string to search for, null returns false\n     * @return true if the builder starts with the string\n     */\n    public boolean startsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        for (int i = 0; i < len; i++) {\n            if (buffer[i] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public CharSequence subSequence(final int startIndex, final int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(endIndex - startIndex);\n        }\n        return substring(startIndex, endIndex);\n    }\n\n    /**\n     * Extracts a portion of this string builder as a string.\n     *\n     * @param start the start index, inclusive, must be valid\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(final int start) {\n        return substring(start, size);\n    }\n\n    /**\n     * Extracts a portion of this string builder as a string.\n     * <p>\n     * Note: This method treats an endIndex greater than the length of the builder as equal to the length of the\n     * builder, and continues without error, unlike StringBuffer or String.\n     * </p>\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        return new String(buffer, startIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Copies the builder's character array into a new character array.\n     *\n     * @return a new array that represents the contents of the builder\n     */\n    public char[] toCharArray() {\n        return size == 0 ? ArrayUtils.EMPTY_CHAR_ARRAY : Arrays.copyOf(buffer, size);\n    }\n\n    /**\n     * Copies part of the builder's character array into a new character array.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return a new array that holds part of the contents of the builder\n     * @throws IndexOutOfBoundsException if startIndex is invalid, or if endIndex is invalid (but endIndex greater than\n     *         size is valid)\n     */\n    public char[] toCharArray(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        return len == 0 ? ArrayUtils.EMPTY_CHAR_ARRAY : Arrays.copyOfRange(buffer, startIndex, endIndex);\n    }\n\n    /**\n     * Gets a String version of the string builder, creating a new instance each time the method is called.\n     * <p>\n     * Note that unlike StringBuffer, the string version returned is independent of the string builder.\n     * </p>\n     *\n     * @return The builder as a String\n     */\n    @Override\n    public String toString() {\n        return new String(buffer, 0, size);\n    }\n\n    /**\n     * Gets a StringBuffer version of the string builder, creating a new instance each time the method is called.\n     *\n     * @return The builder as a StringBuffer\n     */\n    public StringBuffer toStringBuffer() {\n        return new StringBuffer(size).append(buffer, 0, size);\n    }\n\n    /**\n     * Gets a StringBuilder version of the string builder, creating a new instance each time the method is called.\n     *\n     * @return The builder as a StringBuilder\n     */\n    public StringBuilder toStringBuilder() {\n        return new StringBuilder(size).append(buffer, 0, size);\n    }\n\n    /**\n     * Trims the builder by removing characters less than or equal to a space from the beginning and end.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder trim() {\n        if (size == 0) {\n            return this;\n        }\n        int len = size;\n        final char[] buf = buffer;\n        int pos = 0;\n        while (pos < len && buf[pos] <= SPACE) {\n            pos++;\n        }\n        while (pos < len && buf[len - 1] <= SPACE) {\n            len--;\n        }\n        if (len < size) {\n            delete(len, size);\n        }\n        if (pos > 0) {\n            delete(0, pos);\n        }\n        return this;\n    }\n\n    /**\n     * Validates that an index is in the range {@code 0 <= index <= size}.\n     *\n     * @param index the index to test.\n     * @throws IndexOutOfBoundsException Thrown when the index is not the range {@code 0 <= index <= size}.\n     */\n    protected void validateIndex(final int index) {\n        if (index < 0 || index >= size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n    }\n\n    /**\n     * Validates parameters defining a range of the builder.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return A valid end index.\n     * @throws StringIndexOutOfBoundsException if the index is invalid\n     */\n    protected int validateRange(final int startIndex, int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            endIndex = size;\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        return endIndex;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/TextStringBuilder.java b/src/main/java/org/apache/commons/text/TextStringBuilder.java\nindex d391fc118d..50aa3c7fa5 100644\n--- a/src/main/java/org/apache/commons/text/TextStringBuilder.java\n+++ b/src/main/java/org/apache/commons/text/TextStringBuilder.java\n@@ -281,6 +281,18 @@ public void write(final String str, final int off, final int len) {\n      */\n     private static final int TRUE_STRING_SIZE = Boolean.TRUE.toString().length();\n \n+    /**\n+     * The maximum size buffer to allocate.\n+     *\n+     * <p>This is set to the same size used in the JDK {@code java.util.ArrayList}:</p>\n+     * <blockquote>\n+     * Some VMs reserve some header words in an array.\n+     * Attempts to allocate larger arrays may result in\n+     * OutOfMemoryError: Requested array size exceeds VM limit.\n+     * </blockquote>\n+     */\n+    private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n+\n     /**\n      * Constructs an instance from a reference to a character array. Changes to the input chars are reflected in this\n      * instance until the internal buffer needs to be reallocated. Using a reference to an array allows the instance to\n@@ -391,10 +403,10 @@ public TextStringBuilder(final String str) {\n      */\n     public TextStringBuilder append(final boolean value) {\n         if (value) {\n-            ensureCapacity(size + TRUE_STRING_SIZE);\n+            ensureCapacityInternal(size + TRUE_STRING_SIZE);\n             appendTrue(size);\n         } else {\n-            ensureCapacity(size + FALSE_STRING_SIZE);\n+            ensureCapacityInternal(size + FALSE_STRING_SIZE);\n             appendFalse(size);\n         }\n         return this;\n@@ -409,7 +421,7 @@ public TextStringBuilder append(final boolean value) {\n     @Override\n     public TextStringBuilder append(final char ch) {\n         final int len = length();\n-        ensureCapacity(len + 1);\n+        ensureCapacityInternal(len + 1);\n         buffer[size++] = ch;\n         return this;\n     }\n@@ -427,7 +439,7 @@ public TextStringBuilder append(final char[] chars) {\n         final int strLen = chars.length;\n         if (strLen > 0) {\n             final int len = length();\n-            ensureCapacity(len + strLen);\n+            ensureCapacityInternal(len + strLen);\n             System.arraycopy(chars, 0, buffer, len, strLen);\n             size += strLen;\n         }\n@@ -458,7 +470,7 @@ public TextStringBuilder append(final char[] chars, final int startIndex, final\n         }\n         if (length > 0) {\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             System.arraycopy(chars, startIndex, buffer, len, length);\n             size += length;\n         }\n@@ -496,7 +508,7 @@ public TextStringBuilder append(final CharBuffer buf, final int startIndex, fina\n                 throw new StringIndexOutOfBoundsException(\"length must be valid\");\n             }\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             System.arraycopy(buf.array(), buf.arrayOffset() + buf.position() + startIndex, buffer, len, length);\n             size += length;\n         } else {\n@@ -643,7 +655,7 @@ public TextStringBuilder append(final String str, final int startIndex, final in\n         }\n         if (length > 0) {\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         }\n@@ -692,7 +704,7 @@ public TextStringBuilder append(final StringBuffer str, final int startIndex, fi\n         }\n         if (length > 0) {\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         }\n@@ -729,7 +741,7 @@ public TextStringBuilder append(final StringBuilder str, final int startIndex, f\n         }\n         if (length > 0) {\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         }\n@@ -766,7 +778,7 @@ public TextStringBuilder append(final TextStringBuilder str, final int startInde\n         }\n         if (length > 0) {\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         }\n@@ -858,7 +870,7 @@ public TextStringBuilder appendFixedWidthPadLeft(final int value, final int widt\n      */\n     public TextStringBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacityInternal(size + width);\n             String str = obj == null ? getNullText() : obj.toString();\n             if (str == null) {\n                 str = StringUtils.EMPTY;\n@@ -903,7 +915,7 @@ public TextStringBuilder appendFixedWidthPadRight(final int value, final int wid\n      */\n     public TextStringBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacityInternal(size + width);\n             String str = obj == null ? getNullText() : obj.toString();\n             if (str == null) {\n                 str = StringUtils.EMPTY;\n@@ -1162,7 +1174,7 @@ public TextStringBuilder appendNull() {\n      */\n     public TextStringBuilder appendPadding(final int length, final char padChar) {\n         if (length >= 0) {\n-            ensureCapacity(size + length);\n+            ensureCapacityInternal(size + length);\n             for (int i = 0; i < length; i++) {\n                 buffer[size++] = padChar;\n             }\n@@ -1820,17 +1832,84 @@ public boolean endsWith(final String str) {\n     /**\n      * Tests the capacity and ensures that it is at least the size specified.\n      *\n+     * <p>Note: This method can be used to minimise memory reallocations during\n+     * repeated addition of values by pre-allocating the character buffer.\n+     * The method ignores a negative {@code capacity} argument.\n+     *\n      * @param capacity the capacity to ensure\n      * @return this, to enable chaining\n+     * @throws OutOfMemoryError if the capacity cannot be allocated\n      */\n     public TextStringBuilder ensureCapacity(final int capacity) {\n-        // checks for overflow\n-        if (capacity > 0 && capacity - buffer.length > 0) {\n-            reallocate(capacity);\n+        if (capacity > 0) {\n+            ensureCapacityInternal(capacity);\n         }\n         return this;\n     }\n \n+    /**\n+     * Ensure that the buffer is at least the size specified. The {@code capacity} argument\n+     * is treated as an unsigned integer.\n+     *\n+     * <p>This method will raise an {@link OutOfMemoryError} if the capacity is too large\n+     * for an array, or cannot be allocated.\n+     *\n+     * @param capacity the capacity to ensure\n+     * @throws OutOfMemoryError if the capacity cannot be allocated\n+     */\n+    private void ensureCapacityInternal(final int capacity) {\n+        // Check for overflow of the current buffer.\n+        // Assumes capacity is an unsigned integer up to Integer.MAX_VALUE * 2\n+        // (the largest possible addition of two maximum length arrays).\n+        if (capacity - buffer.length > 0) {\n+            resizeBuffer(capacity);\n+        }\n+    }\n+\n+    /**\n+     * Resizes the buffer to at least the size specified.\n+     *\n+     * @param minCapacity the minimum required capacity\n+     * @throws OutOfMemoryError if the {@code minCapacity} is negative\n+     */\n+    private void resizeBuffer(final int minCapacity) {\n+        // Overflow-conscious code treats the min and new capacity as unsigned.\n+        final int oldCapacity = buffer.length;\n+        int newCapacity = oldCapacity * 2;\n+        if (Integer.compareUnsigned(newCapacity, minCapacity) < 0) {\n+            newCapacity = minCapacity;\n+        }\n+        if (Integer.compareUnsigned(newCapacity, MAX_BUFFER_SIZE) > 0) {\n+            newCapacity = createPositiveCapacity(minCapacity);\n+        }\n+        reallocate(newCapacity);\n+    }\n+\n+    /**\n+     * Create a positive capacity at least as large the minimum required capacity.\n+     * If the minimum capacity is negative then this throws an OutOfMemoryError as no array\n+     * can be allocated.\n+     *\n+     * @param minCapacity the minimum capacity\n+     * @return the capacity\n+     * @throws OutOfMemoryError if the {@code minCapacity} is negative\n+     */\n+    private static int createPositiveCapacity(final int minCapacity) {\n+        if (minCapacity < 0) {\n+            // overflow\n+            throw new OutOfMemoryError(\"Unable to allocate array size: \" + Integer.toUnsignedString(minCapacity));\n+        }\n+        // This is called when we require buffer expansion to a very big array.\n+        // Use the conservative maximum buffer size if possible, otherwise the biggest required.\n+        //\n+        // Note: In this situation JDK 1.8 java.util.ArrayList returns Integer.MAX_VALUE.\n+        // This excludes some VMs that can exceed MAX_BUFFER_SIZE but not allocate a full\n+        // Integer.MAX_VALUE length array.\n+        // The result is that we may have to allocate an array of this size more than once if\n+        // the capacity must be expanded again.\n+        return Math.max(minCapacity, MAX_BUFFER_SIZE);\n+    }\n+\n     /**\n      * Tests the contents of this builder against another to see if they contain the same character content.\n      *\n@@ -2107,11 +2186,11 @@ public int indexOf(final StringMatcher matcher, int startIndex) {\n     public TextStringBuilder insert(final int index, final boolean value) {\n         validateIndex(index);\n         if (value) {\n-            ensureCapacity(size + TRUE_STRING_SIZE);\n+            ensureCapacityInternal(size + TRUE_STRING_SIZE);\n             System.arraycopy(buffer, index, buffer, index + TRUE_STRING_SIZE, size - index);\n             appendTrue(index);\n         } else {\n-            ensureCapacity(size + FALSE_STRING_SIZE);\n+            ensureCapacityInternal(size + FALSE_STRING_SIZE);\n             System.arraycopy(buffer, index, buffer, index + FALSE_STRING_SIZE, size - index);\n             appendFalse(index);\n         }\n@@ -2128,7 +2207,7 @@ public TextStringBuilder insert(final int index, final boolean value) {\n      */\n     public TextStringBuilder insert(final int index, final char value) {\n         validateIndex(index);\n-        ensureCapacity(size + 1);\n+        ensureCapacityInternal(size + 1);\n         System.arraycopy(buffer, index, buffer, index + 1, size - index);\n         buffer[index] = value;\n         size++;\n@@ -2150,7 +2229,7 @@ public TextStringBuilder insert(final int index, final char[] chars) {\n         }\n         final int len = chars.length;\n         if (len > 0) {\n-            ensureCapacity(size + len);\n+            ensureCapacityInternal(size + len);\n             System.arraycopy(buffer, index, buffer, index + len, size - index);\n             System.arraycopy(chars, 0, buffer, index, len);\n             size += len;\n@@ -2180,7 +2259,7 @@ public TextStringBuilder insert(final int index, final char[] chars, final int o\n             throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n         }\n         if (length > 0) {\n-            ensureCapacity(size + length);\n+            ensureCapacityInternal(size + length);\n             System.arraycopy(buffer, index, buffer, index + length, size - index);\n             System.arraycopy(chars, offset, buffer, index, length);\n             size += length;\n@@ -2269,7 +2348,7 @@ public TextStringBuilder insert(final int index, String str) {\n             final int strLen = str.length();\n             if (strLen > 0) {\n                 final int newSize = size + strLen;\n-                ensureCapacity(newSize);\n+                ensureCapacityInternal(newSize);\n                 System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n                 size = newSize;\n                 str.getChars(0, strLen, buffer, index);\n@@ -2514,7 +2593,7 @@ public TextStringBuilder minimizeCapacity() {\n     public int readFrom(final CharBuffer charBuffer) {\n         final int oldSize = size;\n         final int remaining = charBuffer.remaining();\n-        ensureCapacity(size + remaining);\n+        ensureCapacityInternal(size + remaining);\n         charBuffer.get(buffer, size, remaining);\n         size += remaining;\n         return size - oldSize;\n@@ -2539,7 +2618,7 @@ public int readFrom(final Readable readable) throws IOException {\n         }\n         final int oldSize = size;\n         while (true) {\n-            ensureCapacity(size + 1);\n+            ensureCapacityInternal(size + 1);\n             final CharBuffer buf = CharBuffer.wrap(buffer, size, buffer.length - size);\n             final int read = readable.read(buf);\n             if (read == EOS) {\n@@ -2563,14 +2642,14 @@ public int readFrom(final Readable readable) throws IOException {\n      */\n     public int readFrom(final Reader reader) throws IOException {\n         final int oldSize = size;\n-        ensureCapacity(size + 1);\n+        ensureCapacityInternal(size + 1);\n         int readCount = reader.read(buffer, size, buffer.length - size);\n         if (readCount == EOS) {\n             return EOS;\n         }\n         do {\n             size += readCount;\n-            ensureCapacity(size + 1);\n+            ensureCapacityInternal(size + 1);\n             readCount = reader.read(buffer, size, buffer.length - size);\n         } while (readCount != EOS);\n         return size - oldSize;\n@@ -2593,7 +2672,7 @@ public int readFrom(final Reader reader, final int count) throws IOException {\n             return 0;\n         }\n         final int oldSize = size;\n-        ensureCapacity(size + count);\n+        ensureCapacityInternal(size + count);\n         int target = count;\n         int readCount = reader.read(buffer, size, target);\n         if (readCount == EOS) {\n@@ -2775,7 +2854,7 @@ private void replaceImpl(final int startIndex, final int endIndex, final int rem\n         final int insertLen) {\n         final int newSize = size - removeLen + insertLen;\n         if (insertLen != removeLen) {\n-            ensureCapacity(newSize);\n+            ensureCapacityInternal(newSize);\n             System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n             size = newSize;\n         }\n@@ -2905,7 +2984,7 @@ public TextStringBuilder setLength(final int length) {\n         if (length < size) {\n             size = length;\n         } else if (length > size) {\n-            ensureCapacity(length);\n+            ensureCapacityInternal(length);\n             final int oldEnd = size;\n             size = length;\n             Arrays.fill(buffer, oldEnd, length, '\\0');\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/TextStringBuilderTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 449,
    "title": "[TEXT-229] Add XmlEncoderStringLookup/XmlDecoderStringLookup",
    "state": "closed",
    "created_at": "2023-08-15T13:17:14Z",
    "merge_commit_sha": "c4e9af6e278b348f1c4a02a4a15b574a8a19a186",
    "base_sha": "28b6e1d38a47cab1b6beaadd8585780b49a178ef",
    "head_sha": "a53726384e1bdcd6a57e45170bb938da5758bc4a",
    "user_login": "michael-o",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/StringSubstitutor.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.text.lookup.StringLookupFactory;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class StringSubstitutorTest2 {\n\n    private Map<String, String> values;\n\n    @BeforeEach\n    public void setUp() {\n        values = new HashMap<>();\n        values.put(\"animal\", \"quick brown fox\");\n        values.put(\"target\", \"lazy dog\");\n    }\n\n    @Test\n    public void testXmlDecoderStringLookup() {\n        StringSubstitutor sub = new StringSubstitutor(StringLookupFactory.INSTANCE.xmlDecoderStringLookup());\n        String template = \"The &lt;animal&gt; jumps over the &lt;target&gt;.\";\n        String expected = \"The <animal> jumps over the <target>.\";\n        assertEquals(expected, sub.replace(template));\n    }\n\n    @Test\n    public void testXmlEncoderStringLookup() {\n        StringSubstitutor sub = new StringSubstitutor(StringLookupFactory.INSTANCE.xmlEncoderStringLookup());\n        String template = \"The <animal> jumps over the <target>.\";\n        String expected = \"The &lt;animal&gt; jumps over the &lt;target&gt;.\";\n        assertEquals(expected, sub.replace(template));\n    }\n\n    @Test\n    public void testCreateInterpolatorWithXmlDecoder() {\n        StringSubstitutor sub = StringSubstitutor.createInterpolator();\n        sub.setVariableResolver(StringLookupFactory.INSTANCE.xmlDecoderStringLookup());\n        String template = \"The &lt;animal&gt; jumps over the &lt;target&gt;.\";\n        String expected = \"The <animal> jumps over the <target>.\";\n        assertEquals(expected, sub.replace(template));\n    }\n\n    @Test\n    public void testCreateInterpolatorWithXmlEncoder() {\n        StringSubstitutor sub = StringSubstitutor.createInterpolator();\n        sub.setVariableResolver(StringLookupFactory.INSTANCE.xmlEncoderStringLookup());\n        String template = \"The <animal> jumps over the <target>.\";\n        String expected = \"The &lt;animal&gt; jumps over the &lt;target&gt;.\";\n        assertEquals(expected, sub.replace(template));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.text.lookup.StringLookup;\nimport org.apache.commons.text.lookup.StringLookupFactory;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\n\n/**\n * Substitutes variables within a string by values.\n * <p>\n * This class takes a piece of text and substitutes all the variables within it. The default definition of a variable is\n * {@code ${variableName}}. The prefix and suffix can be changed via constructors and set methods.\n * </p>\n * <p>\n * Variable values are typically resolved from a map, but could also be resolved from system properties, or by supplying\n * a custom variable resolver.\n * </p>\n * <h2>Using System Properties</h2>\n * <p>\n * The simplest example is to use this class to replace Java System properties. For example:\n * </p>\n *\n * <pre>\n * StringSubstitutor\n *     .replaceSystemProperties(\"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n * </pre>\n *\n * <h2>Using a Custom Map</h2>\n * <p>\n * Typical usage of this class follows the following pattern:\n * </p>\n * <ul>\n * <li>Create and initialize a StringSubstitutor with the map that contains the values for the variables you want to\n * make available.</li>\n * <li>Optionally set attributes like variable prefix, variable suffix, default value delimiter, and so on.</li>\n * <li>Call the {@code replace()} method with in the source text for interpolation.</li>\n * <li>The returned text contains all variable references (as long as their values are known) as resolved.</li>\n * </ul>\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * // Build map\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n *\n * // Build StringSubstitutor\n * StringSubstitutor sub = new StringSubstitutor(valuesMap);\n *\n * // Replace\n * String resolvedString = sub.replace(templateString);\n * </pre>\n *\n * <p>\n * yielding:\n * </p>\n *\n * <pre>\n * \"The quick brown fox jumped over the lazy dog.\"\n * </pre>\n *\n * <h2>Providing Default Values</h2>\n * <p>\n * You can set a default value for unresolved variables. The default value for a variable can be appended to the\n * variable name after the variable default value delimiter. The default value of the variable default value delimiter\n * is \":-\", as in bash and other *nix shells.\n * </p>\n * <p>\n * You can set the variable value delimiter with {@link #setValueDelimiterMatcher(StringMatcher)},\n * {@link #setValueDelimiter(char)} or {@link #setValueDelimiter(String)}.\n * </p>\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * // Build map\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target} ${undefined.number:-1234567890} times.&quot;;\n *\n * // Build StringSubstitutor\n * StringSubstitutor sub = new StringSubstitutor(valuesMap);\n *\n * // Replace\n * String resolvedString = sub.replace(templateString);\n * </pre>\n *\n * <p>\n * yielding:\n * </p>\n *\n * <pre>\n * \"The quick brown fox jumped over the lazy dog 1234567890 times.\"\n * </pre>\n *\n * <p>\n * {@code StringSubstitutor} supports throwing exceptions for unresolved variables, you enable this by setting calling\n * {@link #setEnableUndefinedVariableException(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Reusing Instances</h2>\n * <p>\n * Static shortcut methods cover the most common use cases. If multiple replace operations are to be performed, creating\n * and reusing an instance of this class will be more efficient.\n * </p>\n *\n * <h2>Using Interpolation</h2>\n * <p>\n * The default interpolator lets you use string lookups like:\n * </p>\n *\n * <pre>\n * final StringSubstitutor interpolator = StringSubstitutor.createInterpolator();\n * final String text = interpolator.replace(\n *       \"Base64 Decoder:        ${base64Decoder:SGVsbG9Xb3JsZCE=}\\n\"\n *     + \"Base64 Encoder:        ${base64Encoder:HelloWorld!}\\n\"\n *     + \"Java Constant:         ${const:java.awt.event.KeyEvent.VK_ESCAPE}\\n\"\n *     + \"Date:                  ${date:yyyy-MM-dd}\\n\"\n *     + \"Environment Variable:  ${env:USERNAME}\\n\"\n *     + \"File Content:          ${file:UTF-8:src/test/resources/document.properties}\\n\"\n *     + \"Java:                  ${java:version}\\n\"\n *     + \"Localhost:             ${localhost:canonical-name}\\n\"\n *     + \"Properties File:       ${properties:src/test/resources/document.properties::mykey}\\n\"\n *     + \"Resource Bundle:       ${resourceBundle:org.apache.commons.text.example.testResourceBundleLookup:mykey}\\n\"\n *     + \"System Property:       ${sys:user.dir}\\n\"\n *     + \"URL Decoder:           ${urlDecoder:Hello%20World%21}\\n\"\n *     + \"URL Encoder:           ${urlEncoder:Hello World!}\\n\"\n *     + \"XML XPath:             ${xml:src/test/resources/document.xml:/root/path/to/node}\\n\");\n * </pre>\n * <p>\n * For documentation and a full list of available lookups, see {@link StringLookupFactory}.\n * </p>\n * <p><strong>NOTE:</strong> The list of lookups available by default in {@link #createInterpolator()} changed\n * in version {@code 1.10.0}. See the {@link StringLookupFactory} documentation for details and an explanation\n * on how to reproduce the previous functionality.\n * </p>\n *\n * <h2>Using Recursive Variable Replacement</h2>\n * <p>\n * Variable replacement can work recursively by calling {@link #setEnableSubstitutionInVariables(boolean)} with\n * {@code true}. If a variable value contains a variable then that variable will also be replaced. Cyclic replacements\n * are detected and will throw an exception.\n * </p>\n * <p>\n * You can get the replace result to contain a variable prefix. For example:\n * </p>\n *\n * <pre>\n * \"The variable ${${name}} must be used.\"\n * </pre>\n *\n * <p>\n * If the value of the \"name\" variable is \"x\", then only the variable \"name\" is replaced resulting in:\n * </p>\n *\n * <pre>\n * \"The variable ${x} must be used.\"\n * </pre>\n *\n * <p>\n * To achieve this effect there are two possibilities: Either set a different prefix and suffix for variables which do\n * not conflict with the result text you want to produce. The other possibility is to use the escape character, by\n * default '$'. If this character is placed before a variable reference, this reference is ignored and won't be\n * replaced. For example:\n * </p>\n *\n * <pre>\n * \"The variable $${${name}} must be used.\"\n * </pre>\n * <p>\n * In some complex scenarios you might even want to perform substitution in the names of variables, for instance\n * </p>\n *\n * <pre>\n * ${jre-${java.specification.version}}\n * </pre>\n *\n * <p>\n * {@code StringSubstitutor} supports this recursive substitution in variable names, but it has to be enabled explicitly\n * by calling {@link #setEnableSubstitutionInVariables(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Thread Safety</h2>\n * <p>\n * This class is <b>not</b> thread safe.\n * </p>\n *\n * @since 1.3\n */\npublic class StringSubstitutor {\n\n    /**\n     * The low-level result of a substitution.\n     *\n     * @since 1.9\n     */\n    private static final class Result {\n\n        /** Whether the buffer is altered. */\n        public final boolean altered;\n\n        /** The length of change. */\n        public final int lengthChange;\n\n        private Result(final boolean altered, final int lengthChange) {\n            this.altered = altered;\n            this.lengthChange = lengthChange;\n        }\n\n        @Override\n        public String toString() {\n            return \"Result [altered=\" + altered + \", lengthChange=\" + lengthChange + \"]\";\n        }\n    }\n\n    /**\n     * Constant for the default escape character.\n     */\n    public static final char DEFAULT_ESCAPE = '$';\n\n    /**\n     * The default variable default separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_DEFAULT = \":-\";\n\n    /**\n     * The default variable end separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_END = \"}\";\n\n    /**\n     * The default variable start separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_START = \"${\";\n\n    /**\n     * Constant for the default variable prefix.\n     */\n    public static final StringMatcher DEFAULT_PREFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_START);\n\n    /**\n     * Constant for the default variable suffix.\n     */\n    public static final StringMatcher DEFAULT_SUFFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_END);\n\n    /**\n     * Constant for the default value delimiter of a variable.\n     */\n    public static final StringMatcher DEFAULT_VALUE_DELIMITER = StringMatcherFactory.INSTANCE\n        .stringMatcher(DEFAULT_VAR_DEFAULT);\n\n    /**\n     * Creates a new instance using the interpolator string lookup\n     * {@link StringLookupFactory#interpolatorStringLookup()}.\n     * <p>\n     * This StringSubstitutor lets you perform substitutions like:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\n     *   \"OS name: ${sys:os.name}, user: ${env:USER}\");\n     * </pre>\n     *\n     * <p>The table below lists the lookups available by default in the returned instance. These\n     * may be modified through the use of the\n     * {@value org.apache.commons.text.lookup.StringLookupFactory#DEFAULT_STRING_LOOKUPS_PROPERTY}\n     * system property, as described in the {@link StringLookupFactory} documentation.</p>\n     *\n     * <p><strong>NOTE:</strong> The list of lookups available by default changed in version {@code 1.10.0}.\n     * Configuration via system property (as mentioned above) may be necessary to reproduce previous functionality.\n     * </p>\n     *\n     * <table>\n     * <caption>Default Lookups</caption>\n     * <tr>\n     * <th>Key</th>\n     * <th>Lookup</th>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_BASE64_DECODER}</td>\n     * <td>{@link StringLookupFactory#base64DecoderStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_BASE64_ENCODER}</td>\n     * <td>{@link StringLookupFactory#base64EncoderStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_CONST}</td>\n     * <td>{@link StringLookupFactory#constantStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_DATE}</td>\n     * <td>{@link StringLookupFactory#dateStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_ENV}</td>\n     * <td>{@link StringLookupFactory#environmentVariableStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_FILE}</td>\n     * <td>{@link StringLookupFactory#fileStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_JAVA}</td>\n     * <td>{@link StringLookupFactory#javaPlatformStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_LOCALHOST}</td>\n     * <td>{@link StringLookupFactory#localHostStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_PROPERTIES}</td>\n     * <td>{@link StringLookupFactory#propertiesStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_RESOURCE_BUNDLE}</td>\n     * <td>{@link StringLookupFactory#resourceBundleStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_SYS}</td>\n     * <td>{@link StringLookupFactory#systemPropertyStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_URL_DECODER}</td>\n     * <td>{@link StringLookupFactory#urlDecoderStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_URL_ENCODER}</td>\n     * <td>{@link StringLookupFactory#urlEncoderStringLookup()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_XML}</td>\n     * <td>{@link StringLookupFactory#xmlStringLookup()}</td>\n     * </tr>\n     * </table>\n     *\n     * @return a new instance using the interpolator string lookup.\n     * @see StringLookupFactory#interpolatorStringLookup()\n     * @since 1.8\n     */\n    public static StringSubstitutor createInterpolator() {\n        return new StringSubstitutor(StringLookupFactory.INSTANCE.interpolatorStringLookup());\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the map.\n     *\n     * @param <V> the type of the values in the map\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueMap the map with the values, may be null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static <V> String replace(final Object source, final Map<String, V> valueMap) {\n        return new StringSubstitutor(valueMap).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the map.\n     * This method allows to specify a custom variable prefix and suffix\n     *\n     * @param <V> the type of the values in the map\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueMap the map with the values, may be null\n     * @param prefix the prefix of variables, not null\n     * @param suffix the suffix of variables, not null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static <V> String replace(final Object source, final Map<String, V> valueMap, final String prefix,\n        final String suffix) {\n        return new StringSubstitutor(valueMap, prefix, suffix).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the\n     * properties.\n     *\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueProperties the properties with values, may be null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static String replace(final Object source, final Properties valueProperties) {\n        if (valueProperties == null) {\n            return source.toString();\n        }\n        return StringSubstitutor.replace(source,\n                valueProperties.stringPropertyNames().stream().collect(Collectors.toMap(Function.identity(), valueProperties::getProperty)));\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the system\n     * properties.\n     *\n     * @param source the source text containing the variables to substitute, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static String replaceSystemProperties(final Object source) {\n        return new StringSubstitutor(StringLookupFactory.INSTANCE.systemPropertyStringLookup()).replace(source);\n    }\n\n    /**\n     * The flag whether substitution in variable values is disabled.\n     */\n    private boolean disableSubstitutionInValues;\n\n    /**\n     * The flag whether substitution in variable names is enabled.\n     */\n    private boolean enableSubstitutionInVariables;\n\n    /**\n     * The flag whether exception should be thrown on undefined variable.\n     */\n    private boolean enableUndefinedVariableException;\n\n    /**\n     * Stores the escape character.\n     */\n    private char escapeChar;\n\n    /**\n     * Stores the variable prefix.\n     */\n    private StringMatcher prefixMatcher;\n\n    /**\n     * Whether escapes should be preserved. Default is false;\n     */\n    private boolean preserveEscapes;\n\n    /**\n     * Stores the variable suffix.\n     */\n    private StringMatcher suffixMatcher;\n\n    /**\n     * Stores the default variable value delimiter.\n     */\n    private StringMatcher valueDelimiterMatcher;\n\n    /**\n     * Variable resolution is delegated to an implementor of {@link StringLookup}.\n     */\n    private StringLookup variableResolver;\n\n    /**\n     * Creates a new instance with defaults for variable prefix and suffix and the escaping character.\n     */\n    public StringSubstitutor() {\n        this((StringLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses defaults for variable prefix and suffix and the escaping\n     * character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses a default escaping character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n        final char escape) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiter the variable default value delimiter, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n        final char escape, final String valueDelimiter) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape, valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     */\n    public StringSubstitutor(final StringLookup variableResolver) {\n        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,\n        final char escape) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiter the variable default value delimiter string, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,\n        final char escape, final String valueDelimiter) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiter(valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefixMatcher the prefix for variables, not null\n     * @param suffixMatcher the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,\n        final StringMatcher suffixMatcher, final char escape) {\n        this(variableResolver, prefixMatcher, suffixMatcher, escape, DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefixMatcher the prefix for variables, not null\n     * @param suffixMatcher the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiterMatcher the variable default value delimiter matcher, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,\n        final StringMatcher suffixMatcher, final char escape, final StringMatcher valueDelimiterMatcher) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefixMatcher(prefixMatcher);\n        this.setVariableSuffixMatcher(suffixMatcher);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(valueDelimiterMatcher);\n    }\n\n    /**\n     * Creates a new instance based on the given StringSubstitutor.\n     *\n     * @param other The StringSubstitutor used as the source.\n     * @since 1.9\n     */\n    public StringSubstitutor(final StringSubstitutor other) {\n        disableSubstitutionInValues = other.isDisableSubstitutionInValues();\n        enableSubstitutionInVariables = other.isEnableSubstitutionInVariables();\n        enableUndefinedVariableException = other.isEnableUndefinedVariableException();\n        escapeChar = other.getEscapeChar();\n        prefixMatcher = other.getVariablePrefixMatcher();\n        preserveEscapes = other.isPreserveEscapes();\n        suffixMatcher = other.getVariableSuffixMatcher();\n        valueDelimiterMatcher = other.getValueDelimiterMatcher();\n        variableResolver = other.getStringLookup();\n    }\n\n    /**\n     * Checks if the specified variable is already in the stack (list) of variables.\n     *\n     * @param varName the variable name to check\n     * @param priorVariables the list of prior variables\n     */\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\n        if (!priorVariables.contains(varName)) {\n            return;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(256);\n        buf.append(\"Infinite loop in property interpolation of \");\n        buf.append(priorVariables.remove(0));\n        buf.append(\": \");\n        buf.appendWithSeparators(priorVariables, \"->\");\n        throw new IllegalStateException(buf.toString());\n    }\n\n    // Escape\n    /**\n     * Returns the escape character.\n     *\n     * @return The character used for escaping variable references\n     */\n    public char getEscapeChar() {\n        return this.escapeChar;\n    }\n\n    /**\n     * Gets the StringLookup that is used to lookup variables.\n     *\n     * @return The StringLookup\n     */\n    public StringLookup getStringLookup() {\n        return this.variableResolver;\n    }\n\n    /**\n     * Gets the variable default value delimiter matcher currently in use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\n     * value delimiter matches.\n     * </p>\n     * <p>\n     * If it returns null, then the variable default value resolution is disabled.\n     *\n     * @return The variable default value delimiter matcher in use, may be null\n     */\n    public StringMatcher getValueDelimiterMatcher() {\n        return valueDelimiterMatcher;\n    }\n\n    /**\n     * Gets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This prefix is\n     * expressed in terms of a matcher allowing advanced prefix matches.\n     * </p>\n     *\n     * @return The prefix matcher in use\n     */\n    public StringMatcher getVariablePrefixMatcher() {\n        return prefixMatcher;\n    }\n\n    /**\n     * Gets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed\n     * in terms of a matcher allowing advanced suffix matches.\n     * </p>\n     *\n     * @return The suffix matcher in use\n     */\n    public StringMatcher getVariableSuffixMatcher() {\n        return suffixMatcher;\n    }\n\n    /**\n     * Returns a flag whether substitution is disabled in variable values.If set to <b>true</b>, the values of variables\n     * can contain other variables will not be processed and substituted original variable is evaluated, e.g.\n     *\n     * <pre>\n     * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n     * valuesMap.put(&quot;name&quot;, &quot;Douglas ${surname}&quot;);\n     * valuesMap.put(&quot;surname&quot;, &quot;Crockford&quot;);\n     * String templateString = &quot;Hi ${name}&quot;;\n     * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n     * String resolvedString = sub.replace(templateString);\n     * </pre>\n     *\n     * yielding:\n     *\n     * <pre>\n     *      Hi Douglas ${surname}\n     * </pre>\n     *\n     * @return The substitution in variable values flag\n     */\n    public boolean isDisableSubstitutionInValues() {\n        return disableSubstitutionInValues;\n    }\n\n    /**\n     * Returns a flag whether substitution is done in variable names.\n     *\n     * @return The substitution in variable names flag\n     */\n    public boolean isEnableSubstitutionInVariables() {\n        return enableSubstitutionInVariables;\n    }\n\n    /**\n     * Returns a flag whether exception can be thrown upon undefined variable.\n     *\n     * @return The fail on undefined variable flag\n     */\n    public boolean isEnableUndefinedVariableException() {\n        return enableUndefinedVariableException;\n    }\n\n    /**\n     * Returns the flag controlling whether escapes are preserved during substitution.\n     *\n     * @return The preserve escape flag\n     */\n    public boolean isPreserveEscapes() {\n        return preserveEscapes;\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * array as a template. The array is not altered by this method.\n     *\n     * @param source the character array to replace in, not altered, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final char[] source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source.length).append(source);\n        substitute(buf, 0, source.length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * array as a template. The array is not altered by this method.\n     * <p>\n     * Only the specified portion of the array will be processed. The rest of the array is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the character array to replace in, not altered, null returns null\n     * @param offset the start offset within the array, must be valid\n     * @param length the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     * @throws StringIndexOutOfBoundsException if {@code offset} is not in the\n     *  range {@code 0 <= offset <= chars.length}\n     * @throws StringIndexOutOfBoundsException if {@code length < 0}\n     * @throws StringIndexOutOfBoundsException if {@code offset + length > chars.length}\n     */\n    public String replace(final char[] source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as\n     * a template. The source is not altered by this method.\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final CharSequence source) {\n        if (source == null) {\n            return null;\n        }\n        return replace(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as\n     * a template. The source is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @param offset the start offset within the array, must be valid\n     * @param length the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final CharSequence source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source.toString(), offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the\n     * resolver. The input source object is converted to a string using {@code toString} and is not altered.\n     *\n     * @param source the source to replace in, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public String replace(final Object source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder().append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * string as a template.\n     *\n     * @param source the string to replace in, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final String source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source);\n        if (!substitute(buf, 0, source.length())) {\n            return source;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * string as a template.\n     * <p>\n     * Only the specified portion of the string will be processed. The rest of the string is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the string to replace in, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     * @throws StringIndexOutOfBoundsException if {@code offset} is not in the\n     *  range {@code 0 <= offset <= source.length()}\n     * @throws StringIndexOutOfBoundsException if {@code length < 0}\n     * @throws StringIndexOutOfBoundsException if {@code offset + length > source.length()}\n     */\n    public String replace(final String source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return source.substring(offset, offset + length);\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * buffer as a template. The buffer is not altered by this method.\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final StringBuffer source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source.length()).append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * buffer as a template. The buffer is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * builder as a template. The builder is not altered by this method.\n     *\n     * @param source the builder to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final TextStringBuilder source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder builder = new TextStringBuilder(source.length()).append(source);\n        substitute(builder, 0, builder.length());\n        return builder.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * builder as a template. The builder is not altered by this method.\n     * <p>\n     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the builder to use as a template, not changed, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final TextStringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuffer source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver. The builder is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final StringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver.\n     *\n     * @param source the builder to replace in, updated, null returns zero\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final TextStringBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver.\n     * <p>\n     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the builder to replace in, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final TextStringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, offset, length);\n    }\n\n    /**\n     * Internal method that resolves the value of a variable.\n     * <p>\n     * Most users of this class do not need to call this method. This method is called automatically by the substitution\n     * process.\n     * </p>\n     * <p>\n     * Writers of subclasses can override this method if they need to alter how each substitution occurs. The method is\n     * passed the variable's name and must return the corresponding value. This implementation uses the\n     * {@link #getStringLookup()} with the variable's name as the key.\n     * </p>\n     *\n     * @param variableName the name of the variable, not null\n     * @param buf the buffer where the substitution is occurring, not null\n     * @param startPos the start position of the variable including the prefix, valid\n     * @param endPos the end position of the variable including the suffix, valid\n     * @return The variable's value or <b>null</b> if the variable is unknown\n     */\n    protected String resolveVariable(final String variableName, final TextStringBuilder buf, final int startPos,\n        final int endPos) {\n        final StringLookup resolver = getStringLookup();\n        if (resolver == null) {\n            return null;\n        }\n        return resolver.lookup(variableName);\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable values (recursive).\n     *\n     * @param disableSubstitutionInValues true if substitution in variable value are disabled\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setDisableSubstitutionInValues(final boolean disableSubstitutionInValues) {\n        this.disableSubstitutionInValues = disableSubstitutionInValues;\n        return this;\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable names. If set to <b>true</b>, the names of variables can\n     * contain other variables which are processed first before the original variable is evaluated, e.g.\n     * {@code ${jre-${java.version}}}. The default value is <b>false</b>.\n     *\n     * @param enableSubstitutionInVariables the new value of the flag\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {\n        this.enableSubstitutionInVariables = enableSubstitutionInVariables;\n        return this;\n    }\n\n    /**\n     * Sets a flag whether exception should be thrown if any variable is undefined.\n     *\n     * @param failOnUndefinedVariable true if exception should be thrown on undefined variable\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEnableUndefinedVariableException(final boolean failOnUndefinedVariable) {\n        this.enableUndefinedVariableException = failOnUndefinedVariable;\n        return this;\n    }\n\n    /**\n     * Sets the escape character. If this character is placed before a variable reference in the source text, this\n     * variable will be ignored.\n     *\n     * @param escapeCharacter the escape character (0 for disabling escaping)\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEscapeChar(final char escapeCharacter) {\n        this.escapeChar = escapeCharacter;\n        return this;\n    }\n\n    /**\n     * Sets a flag controlling whether escapes are preserved during substitution. If set to <b>true</b>, the escape\n     * character is retained during substitution (e.g. {@code $${this-is-escaped}} remains {@code $${this-is-escaped}}).\n     * If set to <b>false</b>, the escape character is removed during substitution (e.g. {@code $${this-is-escaped}}\n     * becomes {@code ${this-is-escaped}}). The default value is <b>false</b>\n     *\n     * @param preserveEscapes true if escapes are to be preserved\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setPreserveEscapes(final boolean preserveEscapes) {\n        this.preserveEscapes = preserveEscapes;\n        return this;\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This method allows a single character variable default value delimiter to be easily set.\n     * </p>\n     *\n     * @param valueDelimiter the variable default value delimiter character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiter(final char valueDelimiter) {\n        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.charMatcher(valueDelimiter));\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This method allows a string variable default value delimiter to be easily set.\n     * </p>\n     * <p>\n     * If the {@code valueDelimiter} is null or empty string, then the variable default value resolution becomes\n     * disabled.\n     * </p>\n     *\n     * @param valueDelimiter the variable default value delimiter string to use, may be null or empty\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiter(final String valueDelimiter) {\n        if (valueDelimiter == null || valueDelimiter.isEmpty()) {\n            setValueDelimiterMatcher(null);\n            return this;\n        }\n        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.stringMatcher(valueDelimiter));\n    }\n\n    /**\n     * Sets the variable default value delimiter matcher to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\n     * value delimiter matches.\n     * </p>\n     * <p>\n     * If the {@code valueDelimiterMatcher} is null, then the variable default value resolution becomes disabled.\n     * </p>\n     *\n     * @param valueDelimiterMatcher variable default value delimiter matcher to use, may be null\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiterMatcher(final StringMatcher valueDelimiterMatcher) {\n        this.valueDelimiterMatcher = valueDelimiterMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This method allows a\n     * single character prefix to be easily set.\n     * </p>\n     *\n     * @param prefix the prefix character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariablePrefix(final char prefix) {\n        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.charMatcher(prefix));\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This method allows a\n     * string prefix to be easily set.\n     * </p>\n     *\n     * @param prefix the prefix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix is null\n     */\n    public StringSubstitutor setVariablePrefix(final String prefix) {\n        Validate.isTrue(prefix != null, \"Variable prefix must not be null!\");\n        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(prefix));\n    }\n\n    /**\n     * Sets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This prefix is\n     * expressed in terms of a matcher allowing advanced prefix matches.\n     * </p>\n     *\n     * @param prefixMatcher the prefix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix matcher is null\n     */\n    public StringSubstitutor setVariablePrefixMatcher(final StringMatcher prefixMatcher) {\n        Validate.isTrue(prefixMatcher != null, \"Variable prefix matcher must not be null!\");\n        this.prefixMatcher = prefixMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the VariableResolver that is used to lookup variables.\n     *\n     * @param variableResolver the VariableResolver\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariableResolver(final StringLookup variableResolver) {\n        this.variableResolver = variableResolver;\n        return this;\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This method allows a\n     * single character suffix to be easily set.\n     * </p>\n     *\n     * @param suffix the suffix character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariableSuffix(final char suffix) {\n        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.charMatcher(suffix));\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This method allows a\n     * string suffix to be easily set.\n     * </p>\n     *\n     * @param suffix the suffix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix is null\n     */\n    public StringSubstitutor setVariableSuffix(final String suffix) {\n        Validate.isTrue(suffix != null, \"Variable suffix must not be null!\");\n        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(suffix));\n    }\n\n    /**\n     * Sets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed\n     * in terms of a matcher allowing advanced suffix matches.\n     * </p>\n     *\n     * @param suffixMatcher the suffix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix matcher is null\n     */\n    public StringSubstitutor setVariableSuffixMatcher(final StringMatcher suffixMatcher) {\n        Validate.isTrue(suffixMatcher != null, \"Variable suffix matcher must not be null!\");\n        this.suffixMatcher = suffixMatcher;\n        return this;\n    }\n\n    /**\n     * Internal method that substitutes the variables.\n     * <p>\n     * Most users of this class do not need to call this method. This method will be called automatically by another\n     * (public) method.\n     * </p>\n     * <p>\n     * Writers of subclasses can override this method if they need access to the substitution process at the start or\n     * end.\n     * </p>\n     *\n     * @param builder the string builder to substitute into, not null\n     * @param offset the start offset within the builder, must be valid\n     * @param length the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    protected boolean substitute(final TextStringBuilder builder, final int offset, final int length) {\n        return substitute(builder, offset, length, null).altered;\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation. This is the main interpolation method, which resolves the\n     * values of all variable references contained in the passed in text.\n     *\n     * @param builder the string builder to substitute into, not null\n     * @param offset the start offset within the builder, must be valid\n     * @param length the length within the builder to be processed, must be valid\n     * @param priorVariables the stack keeping track of the replaced variables, may be null\n     * @return The result.\n     * @throws IllegalArgumentException if variable is not found and <pre>isEnableUndefinedVariableException()==true</pre>\n     * @since 1.9\n     */\n    private Result substitute(final TextStringBuilder builder, final int offset, final int length,\n        List<String> priorVariables) {\n        Objects.requireNonNull(builder, \"builder\");\n        final StringMatcher prefixMatcher = getVariablePrefixMatcher();\n        final StringMatcher suffixMatcher = getVariableSuffixMatcher();\n        final char escapeCh = getEscapeChar();\n        final StringMatcher valueDelimMatcher = getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n        final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues();\n        final boolean undefinedVariableException = isEnableUndefinedVariableException();\n        final boolean preserveEscapes = isPreserveEscapes();\n\n        boolean altered = false;\n        int lengthChange = 0;\n        int bufEnd = offset + length;\n        int pos = offset;\n        int escPos = -1;\n        outer: while (pos < bufEnd) {\n            final int startMatchLen = prefixMatcher.isMatch(builder, pos, offset, bufEnd);\n            if (startMatchLen == 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos > offset && builder.charAt(pos - 1) == escapeCh) {\n                    // escape detected\n                    if (preserveEscapes) {\n                        // keep escape\n                        pos++;\n                        continue;\n                    }\n                    // mark esc ch for deletion if we find a complete variable\n                    escPos = pos - 1;\n                }\n                // find suffix\n                int startPos = pos;\n                pos += startMatchLen;\n                int endMatchLen = 0;\n                int nestedVarCount = 0;\n                while (pos < bufEnd) {\n                    if (substitutionInVariablesEnabled && prefixMatcher.isMatch(builder, pos, offset, bufEnd) != 0) {\n                        // found a nested variable start\n                        endMatchLen = prefixMatcher.isMatch(builder, pos, offset, bufEnd);\n                        nestedVarCount++;\n                        pos += endMatchLen;\n                        continue;\n                    }\n\n                    endMatchLen = suffixMatcher.isMatch(builder, pos, offset, bufEnd);\n                    if (endMatchLen == 0) {\n                        pos++;\n                    } else {\n                        // found variable end marker\n                        if (nestedVarCount == 0) {\n                            if (escPos >= 0) {\n                                // delete escape\n                                builder.deleteCharAt(escPos);\n                                escPos = -1;\n                                lengthChange--;\n                                altered = true;\n                                bufEnd--;\n                                pos = startPos + 1;\n                                startPos--;\n                                continue outer;\n                            }\n                            // get var name\n                            String varNameExpr = builder.midString(startPos + startMatchLen,\n                                pos - startPos - startMatchLen);\n                            if (substitutionInVariablesEnabled) {\n                                final TextStringBuilder bufName = new TextStringBuilder(varNameExpr);\n                                substitute(bufName, 0, bufName.length());\n                                varNameExpr = bufName.toString();\n                            }\n                            pos += endMatchLen;\n                            final int endPos = pos;\n\n                            String varName = varNameExpr;\n                            String varDefaultValue = null;\n\n                            if (valueDelimMatcher != null) {\n                                final char[] varNameExprChars = varNameExpr.toCharArray();\n                                int valueDelimiterMatchLen = 0;\n                                for (int i = 0; i < varNameExprChars.length; i++) {\n                                    // if there's any nested variable when nested variable substitution disabled,\n                                    // then stop resolving name and default value.\n                                    if (!substitutionInVariablesEnabled && prefixMatcher.isMatch(varNameExprChars, i, i,\n                                        varNameExprChars.length) != 0) {\n                                        break;\n                                    }\n                                    if (valueDelimMatcher.isMatch(varNameExprChars, i, 0,\n                                        varNameExprChars.length) != 0) {\n                                        valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i, 0,\n                                            varNameExprChars.length);\n                                        varName = varNameExpr.substring(0, i);\n                                        varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                        break;\n                                    }\n                                }\n                            }\n\n                            // on the first call initialize priorVariables\n                            if (priorVariables == null) {\n                                priorVariables = new ArrayList<>();\n                                priorVariables.add(builder.midString(offset, length));\n                            }\n\n                            // handle cyclic substitution\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n\n                            // resolve the variable\n                            String varValue = resolveVariable(varName, builder, startPos, endPos);\n                            if (varValue == null) {\n                                varValue = varDefaultValue;\n                            }\n                            if (varValue != null) {\n                                final int varLen = varValue.length();\n                                builder.replace(startPos, endPos, varValue);\n                                altered = true;\n                                int change = 0;\n                                if (!substitutionInValuesDisabled) { // recursive replace\n                                    change = substitute(builder, startPos, varLen, priorVariables).lengthChange;\n                                }\n                                change = change + varLen - (endPos - startPos);\n                                pos += change;\n                                bufEnd += change;\n                                lengthChange += change;\n                            } else if (undefinedVariableException) {\n                                throw new IllegalArgumentException(\n                                    String.format(\"Cannot resolve variable '%s' (enableSubstitutionInVariables=%s).\",\n                                        varName, substitutionInVariablesEnabled));\n                            }\n\n                            // remove variable from the cyclic stack\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                        nestedVarCount--;\n                        pos += endMatchLen;\n                    }\n                }\n            }\n        }\n        return new Result(altered, lengthChange);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/StringSubstitutor.java b/src/main/java/org/apache/commons/text/StringSubstitutor.java\nindex af49341dac..b9960d9907 100644\n--- a/src/main/java/org/apache/commons/text/StringSubstitutor.java\n+++ b/src/main/java/org/apache/commons/text/StringSubstitutor.java\n@@ -368,6 +368,14 @@ public String toString() {\n      * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_XML}</td>\n      * <td>{@link StringLookupFactory#xmlStringLookup()}</td>\n      * </tr>\n+     * <tr>\n+     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_XML_DECODER}</td>\n+     * <td>{@link StringLookupFactory#xmlDecoderStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_XML_ENCODER}</td>\n+     * <td>{@link StringLookupFactory#xmlEncoderStringLookup()}</td>\n+     * </tr>\n      * </table>\n      *\n      * @return a new instance using the interpolator string lookup.\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport org.junit.jupiter.api.Test;\n\npublic class DefaultStringLookupTest2 {\n\n    @Test\n    public void testNewEnums() {\n        // Test for XML_DECODER\n        assertSame(DefaultStringLookup.XML_DECODER.getStringLookup(),\n            StringLookupFactory.INSTANCE.xmlDecoderStringLookup());\n\n        // Test for XML_ENCODER\n        assertSame(DefaultStringLookup.XML_ENCODER.getStringLookup(),\n            StringLookupFactory.INSTANCE.xmlEncoderStringLookup());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.lookup;\n\n/**\n * An enumeration defining {@link StringLookup} objects available through {@link StringLookupFactory}.\n * <p>\n * This enum was adapted and expanded from Apache Commons Configuration 2.4.\n * </p>\n * <p><strong>NOTE:</strong> Starting in version 1.10.0, not all lookups defined in this class are\n * included by default in the\n * {@link StringLookupFactory#addDefaultStringLookups(java.util.Map) StringLookupFactory.addDefaultStringLookups}\n * method. See the {@link StringLookupFactory} class documentation for details.\n * </p>\n *\n * @see StringLookupFactory\n * @see StringLookup\n * @since 1.7\n */\npublic enum DefaultStringLookup {\n\n    /**\n     * The lookup for Base64 decoding using the key {@code \"base64Decoder\"}.\n     * @see StringLookupFactory#KEY_BASE64_DECODER\n     * @see StringLookupFactory#base64DecoderStringLookup()\n     */\n    BASE64_DECODER(StringLookupFactory.KEY_BASE64_DECODER, StringLookupFactory.INSTANCE.base64DecoderStringLookup()),\n\n    /**\n     * The lookup for Base64 decoding using the key {@code \"base64Encoder\"}.\n     * @see StringLookupFactory#KEY_BASE64_ENCODER\n     * @see StringLookupFactory#base64EncoderStringLookup()\n     */\n    BASE64_ENCODER(StringLookupFactory.KEY_BASE64_ENCODER, StringLookupFactory.INSTANCE.base64EncoderStringLookup()),\n\n    /**\n     * The lookup for Java static class member constants using the key {@code \"const\"}.\n     * @see StringLookupFactory#KEY_CONST\n     * @see StringLookupFactory#constantStringLookup()\n     */\n    CONST(StringLookupFactory.KEY_CONST, StringLookupFactory.INSTANCE.constantStringLookup()),\n\n    /**\n     * The lookup for formatting the current date using the key {@code \"date\"}.\n     * @see StringLookupFactory#KEY_DATE\n     * @see StringLookupFactory#dateStringLookup()\n     */\n    DATE(StringLookupFactory.KEY_DATE, StringLookupFactory.INSTANCE.dateStringLookup()),\n\n    /**\n     * The lookup for DNS using the key {@code \"dns\"}.\n     * @see StringLookupFactory#KEY_DNS\n     * @see StringLookupFactory#dnsStringLookup()\n     * @since 1.8\n     */\n    DNS(StringLookupFactory.KEY_DNS, StringLookupFactory.INSTANCE.dnsStringLookup()),\n\n    /**\n     * The lookup for environment properties using the key {@code \"env\"}.\n     * @see StringLookupFactory#KEY_ENV\n     * @see StringLookupFactory#environmentVariableStringLookup()\n     */\n    ENVIRONMENT(StringLookupFactory.KEY_ENV, StringLookupFactory.INSTANCE.environmentVariableStringLookup()),\n\n    /**\n     * The lookup for files using the key {@code \"file\"}.\n     * @see StringLookupFactory#KEY_FILE\n     * @see StringLookupFactory#fileStringLookup()\n     */\n    FILE(StringLookupFactory.KEY_FILE, StringLookupFactory.INSTANCE.fileStringLookup()),\n\n    /**\n     * The lookup for Java platform information using the key {@code \"java\"}.\n     * @see StringLookupFactory#KEY_JAVA\n     * @see StringLookupFactory#javaPlatformStringLookup()\n     */\n    JAVA(StringLookupFactory.KEY_JAVA, StringLookupFactory.INSTANCE.javaPlatformStringLookup()),\n\n    /**\n     * The lookup for localhost information using the key {@code \"localhost\"}.\n     * @see StringLookupFactory#KEY_LOCALHOST\n     * @see StringLookupFactory#localHostStringLookup()\n     */\n    LOCAL_HOST(StringLookupFactory.KEY_LOCALHOST, StringLookupFactory.INSTANCE.localHostStringLookup()),\n\n    /**\n     * The lookup for properties using the key {@code \"properties\"}.\n     * @see StringLookupFactory#KEY_PROPERTIES\n     * @see StringLookupFactory#propertiesStringLookup()\n     */\n    PROPERTIES(StringLookupFactory.KEY_PROPERTIES, StringLookupFactory.INSTANCE.propertiesStringLookup()),\n\n    /**\n     * The lookup for resource bundles using the key {@code \"resourceBundle\"}.\n     * @see StringLookupFactory#KEY_RESOURCE_BUNDLE\n     * @see StringLookupFactory#resourceBundleStringLookup()\n     */\n    RESOURCE_BUNDLE(StringLookupFactory.KEY_RESOURCE_BUNDLE, StringLookupFactory.INSTANCE.resourceBundleStringLookup()),\n\n    /**\n     * The lookup for scripts using the key {@code \"script\"}.\n     * @see StringLookupFactory#KEY_SCRIPT\n     * @see StringLookupFactory#scriptStringLookup()\n     */\n    SCRIPT(StringLookupFactory.KEY_SCRIPT, StringLookupFactory.INSTANCE.scriptStringLookup()),\n\n    /**\n     * The lookup for system properties using the key {@code \"sys\"}.\n     * @see StringLookupFactory#KEY_SYS\n     * @see StringLookupFactory#systemPropertyStringLookup()\n     */\n    SYSTEM_PROPERTIES(StringLookupFactory.KEY_SYS, StringLookupFactory.INSTANCE.systemPropertyStringLookup()),\n\n    /**\n     * The lookup for URLs using the key {@code \"url\"}.\n     * @see StringLookupFactory#KEY_URL\n     * @see StringLookupFactory#urlStringLookup()\n     */\n    URL(StringLookupFactory.KEY_URL, StringLookupFactory.INSTANCE.urlStringLookup()),\n\n    /**\n     * The lookup for URL decoding using the key {@code \"urlDecoder\"}.\n     * @see StringLookupFactory#KEY_URL_DECODER\n     * @see StringLookupFactory#urlDecoderStringLookup()\n     */\n    URL_DECODER(StringLookupFactory.KEY_URL_DECODER, StringLookupFactory.INSTANCE.urlDecoderStringLookup()),\n\n    /**\n     * The lookup for URL decoding using the key {@code \"urlEncoder\"}.\n     * @see StringLookupFactory#KEY_URL_ENCODER\n     * @see StringLookupFactory#urlEncoderStringLookup()\n     */\n    URL_ENCODER(StringLookupFactory.KEY_URL_ENCODER, StringLookupFactory.INSTANCE.urlEncoderStringLookup()),\n\n    /**\n     * The lookup for URL decoding using the key {@code \"xml\"}.\n     * @see StringLookupFactory#KEY_XML\n     * @see StringLookupFactory#xmlStringLookup()\n     */\n    XML(StringLookupFactory.KEY_XML, StringLookupFactory.INSTANCE.xmlStringLookup());\n\n    /** The prefix under which the associated lookup object is registered. */\n    private final String key;\n\n    /** The associated lookup instance. */\n    private final StringLookup lookup;\n\n    /**\n     * Creates a new instance of {@link DefaultStringLookup} and sets the key and the associated lookup instance.\n     *\n     * @param prefix the prefix\n     * @param lookup the {@link StringLookup} instance\n     */\n    DefaultStringLookup(final String prefix, final StringLookup lookup) {\n        this.key = prefix;\n        this.lookup = lookup;\n    }\n\n    /**\n     * Returns the standard prefix for the lookup object of this kind.\n     *\n     * @return the prefix\n     */\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     * Returns the standard {@link StringLookup} instance of this kind.\n     *\n     * @return the associated {@link StringLookup} object\n     */\n    public StringLookup getStringLookup() {\n        return lookup;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java b/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\nindex c23d97dd4e..baf1351bb2 100644\n--- a/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\n@@ -151,7 +151,23 @@ public enum DefaultStringLookup {\n      * @see StringLookupFactory#KEY_XML\n      * @see StringLookupFactory#xmlStringLookup()\n      */\n-    XML(StringLookupFactory.KEY_XML, StringLookupFactory.INSTANCE.xmlStringLookup());\n+    XML(StringLookupFactory.KEY_XML, StringLookupFactory.INSTANCE.xmlStringLookup()),\n+\n+    /**\n+     * The lookup for XML decoding using the key {@code \"xmlDecoder\"}.\n+     * @see StringLookupFactory#KEY_XML_DECODER\n+     * @see StringLookupFactory#xmlDecoderStringLookup()\n+     * @since 1.11.0\n+     */\n+    XML_DECODER(StringLookupFactory.KEY_XML_DECODER, StringLookupFactory.INSTANCE.xmlDecoderStringLookup()),\n+\n+    /**\n+     * The lookup for XML encoding using the key {@code \"xmlEncoder\"}.\n+     * @see StringLookupFactory#KEY_XML_ENCODER\n+     * @see StringLookupFactory#xmlEncoderStringLookup()\n+     * @since 1.11.0\n+     */\n+    XML_ENCODER(StringLookupFactory.KEY_XML_ENCODER, StringLookupFactory.INSTANCE.xmlEncoderStringLookup());\n \n     /** The prefix under which the associated lookup object is registered. */\n     private final String key;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport javax.xml.XMLConstants;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class StringLookupFactoryTest2 {\n\n    @Test\n    public void testAddDefaultStringLookupsMap() {\n        final Map<String, StringLookup> stringLookupMap = new HashMap<>();\n        StringLookupFactory.INSTANCE.addDefaultStringLookups(stringLookupMap);\n        assertDefaultKeys(stringLookupMap);\n    }\n\n    @Test\n    public void testAddDefaultStringLookupsNull() {\n        StringLookupFactory.INSTANCE.addDefaultStringLookups(null);\n    }\n\n    @Test\n    public void testDefaultStringLookupsHolder_allLookups() {\n        final Properties props = new Properties();\n        props.setProperty(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY,\n                \"BASE64_DECODER BASE64_ENCODER const, date, dns, environment \"\n                        + \"file ,java, local_host properties, resource_bundle,script,system_properties \"\n                        + \"url url_decoder , url_encoder, xml, xml_decoder, xml_encoder\");\n        checkDefaultStringLookupsHolder(props,\n                \"base64\",\n                StringLookupFactory.KEY_BASE64_DECODER,\n                StringLookupFactory.KEY_BASE64_ENCODER,\n                StringLookupFactory.KEY_CONST,\n                StringLookupFactory.KEY_DATE,\n                StringLookupFactory.KEY_ENV,\n                StringLookupFactory.KEY_FILE,\n                StringLookupFactory.KEY_JAVA,\n                StringLookupFactory.KEY_LOCALHOST,\n                StringLookupFactory.KEY_PROPERTIES,\n                StringLookupFactory.KEY_RESOURCE_BUNDLE,\n                StringLookupFactory.KEY_SYS,\n                StringLookupFactory.KEY_URL_DECODER,\n                StringLookupFactory.KEY_URL_ENCODER,\n                StringLookupFactory.KEY_XML,\n                StringLookupFactory.KEY_XML_DECODER,\n                StringLookupFactory.KEY_XML_ENCODER,\n                StringLookupFactory.KEY_DNS,\n                StringLookupFactory.KEY_URL,\n                StringLookupFactory.KEY_SCRIPT);\n    }\n\n    @Test\n    public void testSingletons() {\n        final StringLookupFactory stringLookupFactory = StringLookupFactory.INSTANCE;\n        Assertions.assertSame(XmlDecoderStringLookup.INSTANCE, stringLookupFactory.xmlDecoderStringLookup());\n        Assertions.assertSame(XmlEncoderStringLookup.INSTANCE, stringLookupFactory.xmlEncoderStringLookup());\n    }\n\n    @Test\n    public void testXmlDecoderStringLookup() {\n        final StringLookupFactory stringLookupFactory = StringLookupFactory.INSTANCE;\n        Assertions.assertEquals(\"<element>\", stringLookupFactory.xmlDecoderStringLookup().lookup(\"&lt;element&gt;\"));\n    }\n\n    @Test\n    public void testXmlEncoderStringLookup() {\n        final StringLookupFactory stringLookupFactory = StringLookupFactory.INSTANCE;\n        Assertions.assertEquals(\"&lt;element&gt;\", stringLookupFactory.xmlEncoderStringLookup().lookup(\"<element>\"));\n    }\n\n    private static void assertDefaultKeys(final Map<String, StringLookup> stringLookupMap) {\n        assertMappedLookups(stringLookupMap,\n                \"base64\",\n                StringLookupFactory.KEY_BASE64_DECODER,\n                StringLookupFactory.KEY_BASE64_ENCODER,\n                StringLookupFactory.KEY_CONST,\n                StringLookupFactory.KEY_DATE,\n                StringLookupFactory.KEY_ENV,\n                StringLookupFactory.KEY_FILE,\n                StringLookupFactory.KEY_JAVA,\n                StringLookupFactory.KEY_LOCALHOST,\n                StringLookupFactory.KEY_PROPERTIES,\n                StringLookupFactory.KEY_RESOURCE_BUNDLE,\n                StringLookupFactory.KEY_SYS,\n                StringLookupFactory.KEY_URL_DECODER,\n                StringLookupFactory.KEY_URL_ENCODER,\n                StringLookupFactory.KEY_XML,\n                StringLookupFactory.KEY_XML_DECODER,\n                StringLookupFactory.KEY_XML_ENCODER);\n    }\n\n    private static void assertMappedLookups(final Map<String, StringLookup> lookupMap, final String... keys) {\n        final Set<String> remainingKeys = new HashSet<>(lookupMap.keySet());\n        for (final String key : keys) {\n            final String normalizedKey = StringLookupFactory.toKey(key);\n            Assertions.assertNotNull(normalizedKey, () -> \"Expected map to contain string lookup for key \" + key);\n            remainingKeys.remove(normalizedKey);\n        }\n        Assertions.assertTrue(remainingKeys.isEmpty(), () -> \"Unexpected keys in lookup map: \" + remainingKeys);\n    }\n\n    private static void checkDefaultStringLookupsHolder(final Properties props, final String... keys) {\n        final StringLookupFactory.DefaultStringLookupsHolder holder =\n                new StringLookupFactory.DefaultStringLookupsHolder(props);\n        final Map<String, StringLookup> lookupMap = holder.getDefaultStringLookups();\n        assertMappedLookups(lookupMap, keys);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\n\npackage org.apache.commons.text.lookup;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport javax.xml.xpath.XPathFactory;\n\nimport org.apache.commons.text.StringSubstitutor;\n\n/**\n * Create instances of string lookups or access singleton string lookups implemented in this package.\n * <p>\n * The \"classic\" look up is {@link #mapStringLookup(Map)}.\n * </p>\n * <p>\n * The methods for variable interpolation (A.K.A. variable substitution) are:\n * </p>\n * <ul>\n * <li>{@link #interpolatorStringLookup()}.</li>\n * <li>{@link #interpolatorStringLookup(Map)}.</li>\n * <li>{@link #interpolatorStringLookup(StringLookup)}.</li>\n * <li>{@link #interpolatorStringLookup(Map, StringLookup, boolean)}.</li>\n * </ul>\n * <p>\n * Unless explicitly requested otherwise, a set of default lookups are included for convenience with these\n * variable interpolation methods. These defaults are listed in the table below. However, the exact lookups\n * included can be configured through the use of the {@value #DEFAULT_STRING_LOOKUPS_PROPERTY} system property.\n * If present, this system property will be parsed as a comma-separated list of lookup names, with the names\n * being those defined by the {@link DefaultStringLookup} enum. For example, setting this system property to\n * {@code \"BASE64_ENCODER,ENVIRONMENT\"} will only include the\n * {@link DefaultStringLookup#BASE64_ENCODER BASE64_ENCODER} and {@link DefaultStringLookup#ENVIRONMENT ENVIRONMENT}\n * lookups. Setting the property to the empty string will cause no defaults to be configured.\n * Note that not all lookups defined here and in {@link DefaultStringLookup} are included by default.\n * Specifically, lookups that can execute code (e.g., {@link DefaultStringLookup#SCRIPT SCRIPT}) and those\n * that can result in contact with remote servers (e.g., {@link DefaultStringLookup#URL URL} and\n * {@link DefaultStringLookup#DNS DNS}) are not included by default. The current set of default lookups can\n * be accessed directly with {@link #addDefaultStringLookups(Map)}.\n * </p>\n * <table>\n * <caption>Default String Lookups</caption>\n * <tr>\n * <th>Key</th>\n * <th>Interface</th>\n * <th>Factory Method</th>\n * <th>Since</th>\n * </tr>\n * <tr>\n * <td>{@value #KEY_BASE64_DECODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #base64DecoderStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_BASE64_ENCODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #base64EncoderStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_CONST}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #constantStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_DATE}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #dateStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_ENV}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #environmentVariableStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_FILE}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #fileStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_JAVA}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #javaPlatformStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_LOCALHOST}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #localHostStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_PROPERTIES}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #propertiesStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_RESOURCE_BUNDLE}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #resourceBundleStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_SYS}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #systemPropertyStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL_DECODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #urlDecoderStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL_ENCODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #urlEncoderStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_XML}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #xmlStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * </table>\n *\n * <table>\n * <caption>Additional String Lookups (not included by default)</caption>\n * <tr>\n * <th>Key</th>\n * <th>Interface</th>\n * <th>Factory Method</th>\n * <th>Since</th>\n * </tr>\n * <tr>\n * <td>{@value #KEY_DNS}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #dnsStringLookup()}</td>\n * <td>1.8</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #urlStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_SCRIPT}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #scriptStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * </table>\n *\n * <p>\n * This class also provides functional lookups used as building blocks for other lookups.\n * <table>\n * <caption>Functional String Lookups</caption>\n * <tr>\n * <th>Interface</th>\n * <th>Factory Method</th>\n * <th>Since</th>\n * </tr>\n * <tr>\n * <td>{@link BiStringLookup}</td>\n * <td>{@link #biFunctionStringLookup(BiFunction)}</td>\n * <td>1.9</td>\n * </tr>\n * <tr>\n * <td>{@link StringLookup}</td>\n * <td>{@link #functionStringLookup(Function)}</td>\n * <td>1.9</td>\n * </tr>\n * </table>\n *\n * @since 1.3\n */\npublic final class StringLookupFactory {\n\n    /**\n     * Internal class used to construct the default {@link StringLookup} map used by\n     * {@link StringLookupFactory#addDefaultStringLookups(Map)}.\n     */\n    static final class DefaultStringLookupsHolder {\n\n        /** Singleton instance, initialized with the system properties. */\n        static final DefaultStringLookupsHolder INSTANCE = new DefaultStringLookupsHolder(System.getProperties());\n\n        /**\n         * Add the key and string lookup from {@code lookup} to {@code map}, also adding any additional\n         * key aliases if needed. Keys are normalized using the {@link #toKey(String)} method.\n         * @param lookup lookup to add\n         * @param map map to add to\n         */\n        private static void addLookup(final DefaultStringLookup lookup, final Map<String, StringLookup> map) {\n            map.put(toKey(lookup.getKey()), lookup.getStringLookup());\n\n            if (DefaultStringLookup.BASE64_DECODER.equals(lookup)) {\n                // \"base64\" is deprecated in favor of KEY_BASE64_DECODER.\n                map.put(toKey(\"base64\"), lookup.getStringLookup());\n            }\n        }\n\n        /**\n         * Create the lookup map used when the user has requested no customization.\n         * @return default lookup map\n         */\n        private static Map<String, StringLookup> createDefaultStringLookups() {\n            final Map<String, StringLookup> lookupMap = new HashMap<>();\n\n            addLookup(DefaultStringLookup.BASE64_DECODER, lookupMap);\n            addLookup(DefaultStringLookup.BASE64_ENCODER, lookupMap);\n            addLookup(DefaultStringLookup.CONST, lookupMap);\n            addLookup(DefaultStringLookup.DATE, lookupMap);\n            addLookup(DefaultStringLookup.ENVIRONMENT, lookupMap);\n            addLookup(DefaultStringLookup.FILE, lookupMap);\n            addLookup(DefaultStringLookup.JAVA, lookupMap);\n            addLookup(DefaultStringLookup.LOCAL_HOST, lookupMap);\n            addLookup(DefaultStringLookup.PROPERTIES, lookupMap);\n            addLookup(DefaultStringLookup.RESOURCE_BUNDLE, lookupMap);\n            addLookup(DefaultStringLookup.SYSTEM_PROPERTIES, lookupMap);\n            addLookup(DefaultStringLookup.URL_DECODER, lookupMap);\n            addLookup(DefaultStringLookup.URL_ENCODER, lookupMap);\n            addLookup(DefaultStringLookup.XML, lookupMap);\n\n            return lookupMap;\n        }\n\n        /**\n         * Construct a lookup map by parsing the given string. The string is expected to contain\n         * comma or space-separated names of values from the {@link DefaultStringLookup} enum. If\n         * the given string is null or empty, an empty map is returned.\n         * @param str string to parse; may be null or empty\n         * @return lookup map parsed from the given string\n         */\n        private static Map<String, StringLookup> parseStringLookups(final String str) {\n            final Map<String, StringLookup> lookupMap = new HashMap<>();\n\n            try {\n                for (final String lookupName : str.split(\"[\\\\s,]+\")) {\n                    if (!lookupName.isEmpty()) {\n                        addLookup(DefaultStringLookup.valueOf(lookupName.toUpperCase()), lookupMap);\n                    }\n                }\n            } catch (IllegalArgumentException exc) {\n                throw new IllegalArgumentException(\"Invalid default string lookups definition: \" + str, exc);\n            }\n\n            return lookupMap;\n        }\n\n        /** Default string lookup map. */\n        private final Map<String, StringLookup> defaultStringLookups;\n\n        /**\n         * Construct a new instance initialized with the given properties.\n         * @param props initialization properties\n         */\n        DefaultStringLookupsHolder(final Properties props) {\n            final Map<String, StringLookup> lookups =\n                    props.containsKey(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY)\n                        ? parseStringLookups(props.getProperty(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY))\n                        : createDefaultStringLookups();\n\n            defaultStringLookups = Collections.unmodifiableMap(lookups);\n        }\n\n        /**\n         * Get the default string lookups map.\n         * @return default string lookups map\n         */\n        Map<String, StringLookup> getDefaultStringLookups() {\n            return defaultStringLookups;\n        }\n    }\n\n    /**\n     * Defines the singleton for this class.\n     */\n    public static final StringLookupFactory INSTANCE = new StringLookupFactory();\n\n    /**\n     * Decodes Base64 Strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64DecoderStringLookup().lookup(\"SGVsbG9Xb3JsZCE=\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Decoder:SGVsbG9Xb3JsZCE=} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"SGVsbG9Xb3JsZCE=\"} to {@code \"HelloWorld!\"}.\n     * </p>\n     */\n    static final FunctionStringLookup<String> INSTANCE_BASE64_DECODER = FunctionStringLookup\n        .on(key -> new String(Base64.getDecoder().decode(key), StandardCharsets.ISO_8859_1));\n\n    /**\n     * Encodes Base64 Strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64EncoderStringLookup().lookup(\"HelloWorld!\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Encoder:HelloWorld!} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"HelloWorld!\"} to {@code \"SGVsbG9Xb3JsZCE=\"}.\n     * </p>\n     * Defines the singleton for this class.\n     */\n    static final FunctionStringLookup<String> INSTANCE_BASE64_ENCODER = FunctionStringLookup\n        .on(key -> Base64.getEncoder().encodeToString(key.getBytes(StandardCharsets.ISO_8859_1)));\n\n    /**\n     * Looks up keys from environment variables.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.environmentVariableStringLookup().lookup(\"USER\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${env:USER} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert (on Linux) {@code \"USER\"} to the current user name. On Windows 10, you would use\n     * {@code \"USERNAME\"} to the same effect.\n     * </p>\n     */\n    static final FunctionStringLookup<String> INSTANCE_ENVIRONMENT_VARIABLES = FunctionStringLookup.on(System::getenv);\n\n    /**\n     * Defines the FunctionStringLookup singleton that always returns null.\n     */\n    static final FunctionStringLookup<String> INSTANCE_NULL = FunctionStringLookup.on(key -> null);\n\n    /**\n     * Defines the FunctionStringLookup singleton for looking up system properties.\n     */\n    static final FunctionStringLookup<String> INSTANCE_SYSTEM_PROPERTIES = FunctionStringLookup.on(System::getProperty);\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_BASE64_DECODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_BASE64_DECODER = \"base64Decoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_BASE64_ENCODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_BASE64_ENCODER = \"base64Encoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_CONST}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_CONST = \"const\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_DATE}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_DATE = \"date\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_DNS}.\n     *\n     * @since 1.8\n     */\n    public static final String KEY_DNS = \"dns\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_ENV}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_ENV = \"env\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_FILE}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_FILE = \"file\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_JAVA}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_JAVA = \"java\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_LOCALHOST}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_LOCALHOST = \"localhost\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_PROPERTIES}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_PROPERTIES = \"properties\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_RESOURCE_BUNDLE}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_RESOURCE_BUNDLE = \"resourceBundle\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_SCRIPT}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_SCRIPT = \"script\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_SYS}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_SYS = \"sys\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_URL}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL = \"url\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_URL_DECODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL_DECODER = \"urlDecoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_URL_ENCODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL_ENCODER = \"urlEncoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_XML}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_XML = \"xml\";\n\n    /**\n     * Name of the system property used to determine the string lookups added by the\n     * {@link #addDefaultStringLookups(Map)} method. Use of this property is only required\n     * in cases where the set of default lookups must be modified. (See the class documentation\n     * for details.)\n     *\n     * @since 1.10.0\n     */\n    public static final String DEFAULT_STRING_LOOKUPS_PROPERTY = \"org.apache.commons.text.lookup.StringLookupFactory.defaultStringLookups\";\n\n    /**\n     * Clears any static resources.\n     *\n     * @since 1.5\n     */\n    public static void clear() {\n        ConstantStringLookup.clear();\n    }\n\n    /**\n     * Get a string suitable for use as a key in the string lookup map.\n     * @param key string to convert to a string lookup map key\n     * @return string lookup map key\n     */\n    static String toKey(final String key) {\n        return key.toLowerCase(Locale.ROOT);\n    }\n\n    /**\n     * Returns the given map if the input is non-null or an empty immutable map if the input is null.\n     *\n     * @param <K> the class of the map keys\n     * @param <V> the class of the map values\n     * @param map The map to test\n     * @return the given map if the input is non-null or an empty immutable map if the input is null.\n     */\n    static <K, V> Map<K, V> toMap(final Map<K, V> map) {\n        return map == null ? Collections.emptyMap() : map;\n    }\n\n    /**\n     * No need to build instances for now.\n     */\n    private StringLookupFactory() {\n        // empty\n    }\n\n    /**\n     * Adds the default string lookups for this class to {@code stringLookupMap}. The default string\n     * lookups are a set of built-in lookups added for convenience during string interpolation. The\n     * defaults may be configured using the {@value #DEFAULT_STRING_LOOKUPS_PROPERTY} system property.\n     * See the class documentation for details and a list of lookups.\n     *\n     * @param stringLookupMap the map of string lookups to edit.\n     * @since 1.5\n     */\n    public void addDefaultStringLookups(final Map<String, StringLookup> stringLookupMap) {\n        if (stringLookupMap != null) {\n            stringLookupMap.putAll(DefaultStringLookupsHolder.INSTANCE.getDefaultStringLookups());\n        }\n    }\n\n    /**\n     * Returns the Base64DecoderStringLookup singleton instance to decode Base64 strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64DecoderStringLookup().lookup(\"SGVsbG9Xb3JsZCE=\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Decoder:SGVsbG9Xb3JsZCE=} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"SGVsbG9Xb3JsZCE=\"} to {@code \"HelloWorld!\"}.\n     * </p>\n     *\n     * @return The Base64DecoderStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup base64DecoderStringLookup() {\n        return StringLookupFactory.INSTANCE_BASE64_DECODER;\n    }\n\n    /**\n     * Returns the Base64EncoderStringLookup singleton instance to encode strings to Base64.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64EncoderStringLookup().lookup(\"HelloWorld!\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Encoder:HelloWorld!} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code } to {@code \"SGVsbG9Xb3JsZCE=\"}.\n     * </p>\n     *\n     * @return The Base64EncoderStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup base64EncoderStringLookup() {\n        return StringLookupFactory.INSTANCE_BASE64_ENCODER;\n    }\n\n    /**\n     * Returns the Base64DecoderStringLookup singleton instance to decode Base64 strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64DecoderStringLookup().lookup(\"SGVsbG9Xb3JsZCE=\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Decoder:SGVsbG9Xb3JsZCE=} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"SGVsbG9Xb3JsZCE=\"} to {@code \"HelloWorld!\"}.\n     * </p>\n     *\n     * @return The Base64DecoderStringLookup singleton instance.\n     * @since 1.5\n     * @deprecated Use {@link #base64DecoderStringLookup()}.\n     */\n    @Deprecated\n    public StringLookup base64StringLookup() {\n        return StringLookupFactory.INSTANCE_BASE64_DECODER;\n    }\n\n    /**\n     * Returns a new function-based lookup where the request for a lookup is answered by applying the function with a\n     * lookup key.\n     *\n     * @param <R> the function return type.\n     * @param <U> the function's second parameter type.\n     * @param biFunction the function.\n     * @return a new MapStringLookup.\n     * @since 1.9\n     */\n    public <R, U> BiStringLookup<U> biFunctionStringLookup(final BiFunction<String, U, R> biFunction) {\n        return BiFunctionStringLookup.on(biFunction);\n    }\n\n    /**\n     * Returns the ConstantStringLookup singleton instance to look up the value of a fully-qualified static final value.\n     * <p>\n     * Sometimes it is necessary in a configuration file to refer to a constant defined in a class. This can be done\n     * with this lookup implementation. Variable names must be in the format {@code apackage.AClass.AFIELD}. The\n     * {@code lookup(String)} method will split the passed in string at the last dot, separating the fully qualified\n     * class name and the name of the constant (i.e. <b>static final</b>) member field. Then the class is loaded and the\n     * field's value is obtained using reflection.\n     * </p>\n     * <p>\n     * Once retrieved values are cached for fast access. This class is thread-safe. It can be used as a standard (i.e.\n     * global) lookup object and serve multiple clients concurrently.\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.constantStringLookup().lookup(\"java.awt.event.KeyEvent.VK_ESCAPE\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${const:java.awt.event.KeyEvent.VK_ESCAPE} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code java.awt.event.KeyEvent.VK_ESCAPE} to {@code \"27\"}.\n     * </p>\n     *\n     * @return The ConstantStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup constantStringLookup() {\n        return ConstantStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the DateStringLookup singleton instance to format the current date with the format given in the key in a\n     * format compatible with {@link java.text.SimpleDateFormat}.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.dateStringLookup().lookup(\"yyyy-MM-dd\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${date:yyyy-MM-dd} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"yyyy-MM-dd\"} to todays's date, for example, {@code \"2019-08-04\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     */\n    public StringLookup dateStringLookup() {\n        return DateStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the DnsStringLookup singleton instance where the lookup key is one of:\n     * <ul>\n     * <li><b>name</b>: for the local host name, for example {@code EXAMPLE} but also {@code EXAMPLE.apache.org}.</li>\n     * <li><b>canonical-name</b>: for the local canonical host name, for example {@code EXAMPLE.apache.org}.</li>\n     * <li><b>address</b>: for the local host address, for example {@code 192.168.56.1}.</li>\n     * </ul>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.dnsStringLookup().lookup(\"address|apache.org\");\n     * </pre>\n     * <p>\n     * When used through a {@link StringSubstitutor}, this lookup must either be added programmatically\n     * (as below) or enabled as a default lookup using the {@value #DEFAULT_STRING_LOOKUPS_PROPERTY} system property\n     * (see class documentation).\n     * </p>\n     *\n     * <pre>\n     * Map&lt;String, StringLookup&gt; lookupMap = new HashMap&lt;&gt;();\n     * lookupMap.put(\"dns\", StringLookupFactory.INSTANCE.dnsStringLookup());\n     *\n     * StringLookup variableResolver = StringLookupFactory.INSTANCE.interpolatorStringLookup(lookupMap, null, false);\n     *\n     * new StringSubstitutor(variableResolver).replace(\"... ${dns:address|apache.org} ...\");\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"address|apache.org\"} to the IP address of {@code apache.org}.\n     * </p>\n     *\n     * @return the DnsStringLookup singleton instance.\n     * @since 1.8\n     */\n    public StringLookup dnsStringLookup() {\n        return DnsStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the EnvironmentVariableStringLookup singleton instance where the lookup key is an environment variable\n     * name.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.environmentVariableStringLookup().lookup(\"USER\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${env:USER} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert (on Linux) {@code \"USER\"} to the current user name. On Windows 10, you would use\n     * {@code \"USERNAME\"} to the same effect.\n     * </p>\n     *\n     * @return The EnvironmentVariableStringLookup singleton instance.\n     */\n    public StringLookup environmentVariableStringLookup() {\n        return StringLookupFactory.INSTANCE_ENVIRONMENT_VARIABLES;\n    }\n\n    /**\n     * Returns the FileStringLookup singleton instance.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.fileStringLookup().lookup(\"UTF-8:com/domain/document.properties\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${file:UTF-8:com/domain/document.properties} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"UTF-8:com/domain/document.properties\"} to the contents of the file.\n     * </p>\n     *\n     * @return The FileStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup fileStringLookup() {\n        return FileStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new function-based lookup where the request for a lookup is answered by applying the function with a\n     * lookup key.\n     *\n     * @param <R> the function return type.\n     * @param function the function.\n     * @return a new MapStringLookup.\n     * @since 1.9\n     */\n    public <R> StringLookup functionStringLookup(final Function<String, R> function) {\n        return FunctionStringLookup.on(function);\n    }\n\n    /**\n     * Returns a {@link InterpolatorStringLookup} containing the configured\n     * {@link #addDefaultStringLookups(Map) default lookups}. See the class documentation for\n     * details on how these defaults are configured.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.interpolatorStringLookup().lookup(\"${sys:os.name}, ${env:USER}\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${sys:os.name}, ${env:USER} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"${sys:os.name}, ${env:USER}\"} to the OS name and Linux user name.\n     * </p>\n     *\n     * @return the default {@link InterpolatorStringLookup}.\n     */\n    public StringLookup interpolatorStringLookup() {\n        return InterpolatorStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup. If {@code addDefaultLookups} is {@code true}, the configured\n     * {@link #addDefaultStringLookups(Map) default lookups} are included in addition to the ones\n     * provided in {@code stringLookupMap}. (See the class documentation for details on how default lookups\n     * are configured.)\n     *\n     * @param stringLookupMap the map of string lookups.\n     * @param defaultStringLookup the default string lookup; this lookup is used when a variable cannot be\n     *      resolved using the lookups in {@code stringLookupMap} or the configured default lookups (if enabled)\n     * @param addDefaultLookups whether to use default lookups as described above.\n     * @return a new InterpolatorStringLookup.\n     * @since 1.4\n     */\n    public StringLookup interpolatorStringLookup(final Map<String, StringLookup> stringLookupMap,\n        final StringLookup defaultStringLookup, final boolean addDefaultLookups) {\n        return new InterpolatorStringLookup(stringLookupMap, defaultStringLookup, addDefaultLookups);\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the given key-value pairs and the configured\n     * {@link #addDefaultStringLookups(Map) default lookups} to resolve variables. (See the class\n     * documentation for details on how default lookups are configured.)\n     *\n     * @param <V> the value type the default string lookup's map.\n     * @param map the default map for string lookups.\n     * @return a new InterpolatorStringLookup.\n     */\n    public <V> StringLookup interpolatorStringLookup(final Map<String, V> map) {\n        return new InterpolatorStringLookup(map);\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the given lookup and the configured\n     * {@link #addDefaultStringLookups(Map) default lookups} to resolve variables. (See the class\n     * documentation for details on how default lookups are configured.)\n     *\n     * @param defaultStringLookup the default string lookup.\n     * @return a new InterpolatorStringLookup.\n     */\n    public StringLookup interpolatorStringLookup(final StringLookup defaultStringLookup) {\n        return new InterpolatorStringLookup(defaultStringLookup);\n    }\n\n    /**\n     * Returns the JavaPlatformStringLookup singleton instance. Looks up keys related to Java: Java version, JRE\n     * version, VM version, and so on.\n     * <p>\n     * The lookup keys with examples are:\n     * </p>\n     * <ul>\n     * <li><b>version</b>: \"Java version 1.8.0_181\"</li>\n     * <li><b>runtime</b>: \"Java(TM) SE Runtime Environment (build 1.8.0_181-b13) from Oracle Corporation\"</li>\n     * <li><b>vm</b>: \"Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)\"</li>\n     * <li><b>os</b>: \"Windows 10 10.0, architecture: amd64-64\"</li>\n     * <li><b>hardware</b>: \"processors: 4, architecture: amd64-64, instruction sets: amd64\"</li>\n     * <li><b>locale</b>: \"default locale: en_US, platform encoding: iso-8859-1\"</li>\n     * </ul>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.javaPlatformStringLookup().lookup(\"version\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${java:version} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"version\"} to the current VM version, for example,\n     * {@code \"Java version 1.8.0_181\"}.\n     * </p>\n     *\n     * @return The JavaPlatformStringLookup singleton instance.\n     */\n    public StringLookup javaPlatformStringLookup() {\n        return JavaPlatformStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the LocalHostStringLookup singleton instance where the lookup key is one of:\n     * <ul>\n     * <li><b>name</b>: for the local host name, for example {@code EXAMPLE}.</li>\n     * <li><b>canonical-name</b>: for the local canonical host name, for example {@code EXAMPLE.apache.org}.</li>\n     * <li><b>address</b>: for the local host address, for example {@code 192.168.56.1}.</li>\n     * </ul>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.localHostStringLookup().lookup(\"canonical-name\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${localhost:canonical-name} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"canonical-name\"} to the current host name, for example,\n     * {@code \"EXAMPLE.apache.org\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     */\n    public StringLookup localHostStringLookup() {\n        return LocalHostStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new map-based lookup where the request for a lookup is answered with the value for that key.\n     *\n     * @param <V> the map value type.\n     * @param map the map.\n     * @return a new MapStringLookup.\n     */\n    public <V> StringLookup mapStringLookup(final Map<String, V> map) {\n        return FunctionStringLookup.on(map);\n    }\n\n    /**\n     * Returns the NullStringLookup singleton instance which always returns null.\n     *\n     * @return The NullStringLookup singleton instance.\n     */\n    public StringLookup nullStringLookup() {\n        return StringLookupFactory.INSTANCE_NULL;\n    }\n\n    /**\n     * Returns the PropertiesStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"DocumentPath::MyKey\".\n     * </p>\n     * <p>\n     * Note the use of \"::\" instead of \":\" to allow for \"C:\" drive letters in paths.\n     * </p>\n     * <p>\n     * For example: \"com/domain/document.properties::MyKey\".\n     * </p>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.propertiesStringLookup().lookup(\"com/domain/document.properties::MyKey\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${properties:com/domain/document.properties::MyKey} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"com/domain/document.properties::MyKey\"} to the key value in the properties\n     * file at the path \"com/domain/document.properties\".\n     * </p>\n     *\n     * @return The PropertiesStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup propertiesStringLookup() {\n        return PropertiesStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the ResourceBundleStringLookup singleton instance.\n     * <p>\n     * Looks up the value for a given key in the format \"BundleName:BundleKey\".\n     * </p>\n     * <p>\n     * For example: \"com.domain.messages:MyKey\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.resourceBundleStringLookup().lookup(\"com.domain.messages:MyKey\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${resourceBundle:com.domain.messages:MyKey} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"com.domain.messages:MyKey\"} to the key value in the resource bundle at\n     * {@code \"com.domain.messages\"}.\n     * </p>\n     *\n     * @return The ResourceBundleStringLookup singleton instance.\n     */\n    public StringLookup resourceBundleStringLookup() {\n        return ResourceBundleStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a ResourceBundleStringLookup instance for the given bundle name.\n     * <p>\n     * Looks up the value for a given key in the format \"MyKey\".\n     * </p>\n     * <p>\n     * For example: \"MyKey\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.resourceBundleStringLookup(\"com.domain.messages\").lookup(\"MyKey\");\n     * </pre>\n     * <p>\n     * The above example converts {@code \"MyKey\"} to the key value in the resource bundle at\n     * {@code \"com.domain.messages\"}.\n     * </p>\n     *\n     * @param bundleName Only lookup in this bundle.\n     * @return a ResourceBundleStringLookup instance for the given bundle name.\n     * @since 1.5\n     */\n    public StringLookup resourceBundleStringLookup(final String bundleName) {\n        return new ResourceBundleStringLookup(bundleName);\n    }\n\n    /**\n     * Returns the ScriptStringLookup singleton instance. NOTE: This lookup is not included\n     * as a {@link #addDefaultStringLookups(Map) default lookup} unless explicitly enabled. See\n     * the class level documentation for details.\n     * <p>\n     * Looks up the value for the key in the format \"ScriptEngineName:Script\".\n     * </p>\n     * <p>\n     * For example: \"javascript:3 + 4\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.scriptStringLookup().lookup(\"javascript:3 + 4\");\n     * </pre>\n     * <p>\n     * When used through a {@link StringSubstitutor}, this lookup must either be added programmatically\n     * (as below) or enabled as a default lookup using the {@value #DEFAULT_STRING_LOOKUPS_PROPERTY} system property\n     * (see class documentation).\n     * </p>\n     *\n     * <pre>\n     * Map&lt;String, StringLookup&gt; lookupMap = new HashMap&lt;&gt;();\n     * lookupMap.put(\"script\", StringLookupFactory.INSTANCE.scriptStringLookup());\n     *\n     * StringLookup variableResolver = StringLookupFactory.INSTANCE.interpolatorStringLookup(lookupMap, null, false);\n     *\n     * String value = new StringSubstitutor(variableResolver).replace(\"${script:javascript:3 + 4}\");\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"javascript:3 + 4\"} to {@code \"7\"}.\n     * </p>\n     *\n     * @return The ScriptStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup scriptStringLookup() {\n        return ScriptStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the SystemPropertyStringLookup singleton instance where the lookup key is a system property name.\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.systemPropertyStringLookup().lookup(\"os.name\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${sys:os.name} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"os.name\"} to the operating system name.\n     * </p>\n     *\n     * @return The SystemPropertyStringLookup singleton instance.\n     */\n    public StringLookup systemPropertyStringLookup() {\n        return StringLookupFactory.INSTANCE_SYSTEM_PROPERTIES;\n    }\n\n    /**\n     * Returns the UrlDecoderStringLookup singleton instance.\n     * <p>\n     * Decodes URL Strings using the UTF-8 encoding.\n     * </p>\n     * <p>\n     * For example: \"Hello%20World%21\" becomes \"Hello World!\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.urlDecoderStringLookup().lookup(\"Hello%20World%21\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${urlDecoder:Hello%20World%21} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"Hello%20World%21\"} to {@code \"Hello World!\"}.\n     * </p>\n     *\n     * @return The UrlStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup urlDecoderStringLookup() {\n        return UrlDecoderStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the UrlDecoderStringLookup singleton instance.\n     * <p>\n     * Decodes URL Strings using the UTF-8 encoding.\n     * </p>\n     * <p>\n     * For example: \"Hello World!\" becomes \"Hello+World%21\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.urlEncoderStringLookup().lookup(\"Hello World!\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${urlEncoder:Hello World!} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"Hello World!\"} to {@code \"Hello%20World%21\"}.\n     * </p>\n     *\n     * @return The UrlStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup urlEncoderStringLookup() {\n        return UrlEncoderStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the UrlStringLookup singleton instance. This lookup is not included\n     * as a {@link #addDefaultStringLookups(Map) default lookup} unless explicitly enabled. See\n     * the class level documentation for details.\n     * <p>\n     * Looks up the value for the key in the format \"CharsetName:URL\".\n     * </p>\n     * <p>\n     * For example, using the HTTP scheme: \"UTF-8:http://www.google.com\"\n     * </p>\n     * <p>\n     * For example, using the file scheme:\n     * \"UTF-8:file:///C:/somehome/commons/commons-text/src/test/resources/document.properties\"\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.urlStringLookup().lookup(\"UTF-8:https://www.apache.org\");\n     * </pre>\n     * <p>\n     * When used through a {@link StringSubstitutor}, this lookup must either be added programmatically\n     * (as below) or enabled as a default lookup using the {@value #DEFAULT_STRING_LOOKUPS_PROPERTY} system property\n     * (see class documentation).\n     * </p>\n     *\n     * <pre>\n     * Map&lt;String, StringLookup&gt; lookupMap = new HashMap&lt;&gt;();\n     * lookupMap.put(\"url\", StringLookupFactory.INSTANCE.urlStringLookup());\n     *\n     * StringLookup variableResolver = StringLookupFactory.INSTANCE.interpolatorStringLookup(lookupMap, null, false);\n     *\n     * String value = new StringSubstitutor(variableResolver).replace(\"${url:UTF-8:https://www.apache.org}\");\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"UTF-8:https://www.apache.org\"} to the contents of that page.\n     * </p>\n     *\n     * @return The UrlStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup urlStringLookup() {\n        return UrlStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the XmlStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"DocumentPath:XPath\".\n     * </p>\n     * <p>\n     * For example: \"com/domain/document.xml:/path/to/node\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.xmlStringLookup().lookup(\"com/domain/document.xml:/path/to/node\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${xml:com/domain/document.xml:/path/to/node} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"com/domain/document.xml:/path/to/node\"} to the value of the XPath in the XML\n     * document.\n     * </p>\n     *\n     * @return The XmlStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup xmlStringLookup() {\n        return XmlStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the XmlStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"DocumentPath:XPath\".\n     * </p>\n     * <p>\n     * For example: \"com/domain/document.xml:/path/to/node\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.xmlStringLookup().lookup(\"com/domain/document.xml:/path/to/node\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${xml:com/domain/document.xml:/path/to/node} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"com/domain/document.xml:/path/to/node\"} to the value of the XPath in the XML\n     * document.\n     * </p>\n     *\n     * @param xPathFactoryFeatures XPathFactory features to set.\n     * @return The XmlStringLookup singleton instance.\n     * @see XPathFactory#setFeature(String, boolean)\n     * @since 1.11.0\n     */\n    public StringLookup xmlStringLookup(final Map<String, Boolean> xPathFactoryFeatures) {\n        return new XmlStringLookup(xPathFactoryFeatures);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\nindex be952db1eb..bea9143bd2 100644\n--- a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n+++ b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n@@ -152,6 +152,18 @@\n  * <td>{@link #xmlStringLookup()}</td>\n  * <td>1.5</td>\n  * </tr>\n+ * <tr>\n+ * <td>{@value #KEY_XML_DECODER}</td>\n+ * <td>{@link StringLookup}</td>\n+ * <td>{@link #xmlDecoderStringLookup()}</td>\n+ * <td>1.11.0</td>\n+ * </tr>\n+ * <tr>\n+ * <td>{@value #KEY_XML_ENCODER}</td>\n+ * <td>{@link StringLookup}</td>\n+ * <td>{@link #xmlEncoderStringLookup()}</td>\n+ * <td>1.11.0</td>\n+ * </tr>\n  * </table>\n  *\n  * <table>\n@@ -252,6 +264,8 @@ private static Map<String, StringLookup> createDefaultStringLookups() {\n             addLookup(DefaultStringLookup.URL_DECODER, lookupMap);\n             addLookup(DefaultStringLookup.URL_ENCODER, lookupMap);\n             addLookup(DefaultStringLookup.XML, lookupMap);\n+            addLookup(DefaultStringLookup.XML_DECODER, lookupMap);\n+            addLookup(DefaultStringLookup.XML_ENCODER, lookupMap);\n \n             return lookupMap;\n         }\n@@ -508,6 +522,20 @@ Map<String, StringLookup> getDefaultStringLookups() {\n      */\n     public static final String KEY_XML = \"xml\";\n \n+    /**\n+     * Default lookup key for interpolation {@value #KEY_XML_DECODER}.\n+     *\n+     * @since 1.11.0\n+     */\n+    public static final String KEY_XML_DECODER = \"xmlDecoder\";\n+\n+    /**\n+     * Default lookup key for interpolation {@value #KEY_XML_ENCODER}.\n+     *\n+     * @since 1.11.0\n+     */\n+    public static final String KEY_XML_ENCODER = \"xmlEncoder\";\n+\n     /**\n      * Name of the system property used to determine the string lookups added by the\n      * {@link #addDefaultStringLookups(Map)} method. Use of this property is only required\n@@ -1353,4 +1381,70 @@ public StringLookup xmlStringLookup() {\n     public StringLookup xmlStringLookup(final Map<String, Boolean> xPathFactoryFeatures) {\n         return new XmlStringLookup(xPathFactoryFeatures);\n     }\n+\n+    /**\n+     * Returns the XmlDecoderStringLookup singleton instance.\n+     * <p>\n+     * Decodes strings according to the XML 1.0 specification.\n+     * </p>\n+     * <p>\n+     * For example: \"&amp;lt;element&amp;gt;\" becomes \"&lt;element&gt;\".\n+     * </p>\n+     * <p>\n+     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n+     * </p>\n+     *\n+     * <pre>\n+     * StringLookupFactory.INSTANCE.xmlDecoderStringLookup().lookup(\"&amp;lt;element&amp;gt;\");\n+     * </pre>\n+     * <p>\n+     * Using a {@link StringSubstitutor}:\n+     * </p>\n+     *\n+     * <pre>\n+     * StringSubstitutor.createInterpolator().replace(\"... ${xmlDecoder:&amp;lt;element&amp;gt;} ...\"));\n+     * </pre>\n+     * <p>\n+     * The above examples convert {@code \"&lt;element&gt;\"} to {@code \"<element>\"}.\n+     * </p>\n+     *\n+     * @return The XmlDecoderStringLookup singleton instance.\n+     * @since 1.11.0\n+     */\n+    public StringLookup xmlDecoderStringLookup() {\n+        return XmlDecoderStringLookup.INSTANCE;\n+    }\n+\n+    /**\n+     * Returns the XmlEncoderStringLookup singleton instance.\n+     * <p>\n+     * Encodes strings according to the XML 1.0 specification.\n+     * </p>\n+     * <p>\n+     * For example: \"&lt;element&gt;\" becomes \"&amp;lt;element&amp;gt;\".\n+     * </p>\n+     * <p>\n+     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n+     * </p>\n+     *\n+     * <pre>\n+     * StringLookupFactory.INSTANCE.xmlEncoderStringLookup().lookup(\"&lt;element&gt;\");\n+     * </pre>\n+     * <p>\n+     * Using a {@link StringSubstitutor}:\n+     * </p>\n+     *\n+     * <pre>\n+     * StringSubstitutor.createInterpolator().replace(\"... ${xmlEncoder:&lt;element&gt;} ...\"));\n+     * </pre>\n+     * <p>\n+     * The above examples convert {@code \"<element>\"} to {@code \"&lt;element&gt;\"}.\n+     * </p>\n+     *\n+     * @return The XmlEncoderStringLookup singleton instance.\n+     * @since 1.11.0\n+     */\n+    public StringLookup xmlEncoderStringLookup() {\n+        return XmlEncoderStringLookup.INSTANCE;\n+    }\n }\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/XmlDecoderStringLookup.java",
        "status": "added",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport org.apache.commons.text.StringEscapeUtils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class XmlDecoderStringLookupTest {\n\n    @Test\n    public void testLookup() {\n        XmlDecoderStringLookup lookup = XmlDecoderStringLookup.INSTANCE;\n        assertEquals(\"Hello & World\", lookup.lookup(\"Hello &amp; World\"));\n        assertEquals(\"<tag>\", lookup.lookup(\"&lt;tag&gt;\"));\n        assertEquals(\"\\\"quote\\\"\", lookup.lookup(\"&quot;quote&quot;\"));\n        assertEquals(\"Apostrophe's\", lookup.lookup(\"Apostrophe&apos;s\"));\n        assertEquals(\"10 > 5\", lookup.lookup(\"10 &gt; 5\"));\n        assertEquals(\"5 < 10\", lookup.lookup(\"5 &lt; 10\"));\n    }\n\n    @Test\n    public void testLookupWithNoEscapeSequences() {\n        XmlDecoderStringLookup lookup = XmlDecoderStringLookup.INSTANCE;\n        assertEquals(\"plain text\", lookup.lookup(\"plain text\"));\n    }\n\n    @Test\n    public void testLookupWithEmptyString() {\n        XmlDecoderStringLookup lookup = XmlDecoderStringLookup.INSTANCE;\n        assertEquals(\"\", lookup.lookup(\"\"));\n    }\n\n    @Test\n    public void testLookupWithNull() {\n        XmlDecoderStringLookup lookup = XmlDecoderStringLookup.INSTANCE;\n        assertEquals(null, lookup.lookup(null));\n    }\n}",
        "file_content": null,
        "diff": " a/src/main/java/org/apache/commons/text/lookup/XmlDecoderStringLookup.java b/src/main/java/org/apache/commons/text/lookup/XmlDecoderStringLookup.java\nnew file mode 100644\nindex 0000000000..9fd878f081\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/lookup/XmlDecoderStringLookup.java\n@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache license, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the license for the specific language governing permissions and\n+ * limitations under the license.\n+ */\n+\n+package org.apache.commons.text.lookup;\n+\n+import org.apache.commons.text.StringEscapeUtils;\n+\n+/**\n+ * Decodes strings according to the XML 1.0 specification.\n+ *\n+ * @see StringEscapeUtils#unescapeXml(String)\n+ */\n+final class XmlDecoderStringLookup extends AbstractStringLookup {\n+\n+    /**\n+     * Defines the singleton for this class.\n+     */\n+    static final XmlDecoderStringLookup INSTANCE = new XmlDecoderStringLookup();\n+\n+    private XmlDecoderStringLookup() {\n+        // empty\n+    }\n+\n+    @Override\n+    public String lookup(String key) {\n+        return StringEscapeUtils.unescapeXml(key);\n+    }\n+\n+}\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/XmlEncoderStringLookup.java",
        "status": "added",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport org.apache.commons.text.StringEscapeUtils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass XmlEncoderStringLookupTest {\n\n    @Test\n    void testLookupWithSpecialCharacters() {\n        XmlEncoderStringLookup lookup = XmlEncoderStringLookup.INSTANCE;\n        String input = \"<tag>value</tag>\";\n        String expected = \"&lt;tag&gt;value&lt;/tag&gt;\";\n        assertEquals(expected, lookup.lookup(input));\n    }\n\n    @Test\n    void testLookupWithNull() {\n        XmlEncoderStringLookup lookup = XmlEncoderStringLookup.INSTANCE;\n        assertNull(lookup.lookup(null));\n    }\n\n    @Test\n    void testLookupWithEmptyString() {\n        XmlEncoderStringLookup lookup = XmlEncoderStringLookup.INSTANCE;\n        String input = \"\";\n        String expected = \"\";\n        assertEquals(expected, lookup.lookup(input));\n    }\n\n    @Test\n    void testLookupWithNoSpecialCharacters() {\n        XmlEncoderStringLookup lookup = XmlEncoderStringLookup.INSTANCE;\n        String input = \"plainText\";\n        String expected = \"plainText\";\n        assertEquals(expected, lookup.lookup(input));\n    }\n\n    @Test\n    void testLookupWithAmpersand() {\n        XmlEncoderStringLookup lookup = XmlEncoderStringLookup.INSTANCE;\n        String input = \"Fish & Chips\";\n        String expected = \"Fish &amp; Chips\";\n        assertEquals(expected, lookup.lookup(input));\n    }\n}",
        "file_content": null,
        "diff": " a/src/main/java/org/apache/commons/text/lookup/XmlEncoderStringLookup.java b/src/main/java/org/apache/commons/text/lookup/XmlEncoderStringLookup.java\nnew file mode 100644\nindex 0000000000..77bd5aa13d\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/lookup/XmlEncoderStringLookup.java\n@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache license, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the license for the specific language governing permissions and\n+ * limitations under the license.\n+ */\n+\n+package org.apache.commons.text.lookup;\n+\n+import org.apache.commons.text.StringEscapeUtils;\n+\n+/**\n+ * Encodes strings according to the XML 1.0 specification.\n+ *\n+ * @see StringEscapeUtils#escapeXml10(String)\n+ * @since 1.11.0\n+ */\n+final class XmlEncoderStringLookup extends AbstractStringLookup {\n+\n+    /**\n+     * Defines the singleton for this class.\n+     */\n+    static final XmlEncoderStringLookup INSTANCE = new XmlEncoderStringLookup();\n+\n+    XmlEncoderStringLookup() {\n+        // empty\n+    }\n+\n+    @Override\n+    public String lookup(String key) {\n+        return StringEscapeUtils.escapeXml10(key);\n+    }\n+\n+}\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/lookup/XmlDecoderStringLookupTest.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/lookup/XmlEncoderStringLookupTest.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 438,
    "title": "Fix exception message in IntersectionResult to make set-theoretic sense",
    "state": "closed",
    "created_at": "2023-06-27T10:03:08Z",
    "merge_commit_sha": "c379d452d3e2e13cdf414e8a08bc47fa278b7a47",
    "base_sha": "a020a66964fbd82dba96cad4725db8dd5df85457",
    "head_sha": "54de6cf0f4b08aa5a883fb19660bf069a093fd47",
    "user_login": "orionlibs",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/IntersectionResult.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class IntersectionResultTest2 {\n\n    @Test\n    public void testNewIntersectionResult_WithInvalidIntersectionMessage() {\n        final int sizeA = 5;\n        final int sizeB = 5;\n        final int intersection = 6;\n        IllegalArgumentException exception = Assertions.assertThrows(IllegalArgumentException.class, () -> new IntersectionResult(sizeA, sizeB, intersection));\n        Assertions.assertEquals(\"Invalid intersection of A and B: \" + intersection, exception.getMessage());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.Objects;\n\n/**\n * Represents the intersection result between two sets.\n *\n * <p>Stores the size of set A, set B and the intersection of A and B\n * ({@code |A &#8745; B|}).</p>\n *\n * <p>This class is immutable.</p>\n *\n * @since 1.7\n * @see <a href=\"https://en.wikipedia.org/wiki/Intersection_(set_theory)\">Intersection</a>\n */\npublic class IntersectionResult {\n\n    /**\n     * The size of set A.\n     */\n    private final int sizeA;\n\n    /**\n     * The size of set B.\n     */\n    private final int sizeB;\n\n    /**\n     * The size of the intersection between set A and B.\n     */\n    private final int intersection;\n\n    /**\n     * Constructs the results for an intersection between two sets.\n     *\n     * @param sizeA the size of set A ({@code |A|})\n     * @param sizeB the size of set B ({@code |B|})\n     * @param intersection the size of the intersection of A and B ({@code |A &#8745; B|})\n     * @throws IllegalArgumentException if the sizes are negative or the intersection is greater\n     * than the minimum of the two set sizes\n     */\n    public IntersectionResult(final int sizeA, final int sizeB, final int intersection) {\n        if (sizeA < 0) {\n            throw new IllegalArgumentException(\"Set size |A| is not positive: \" + sizeA);\n        }\n        if (sizeB < 0) {\n            throw new IllegalArgumentException(\"Set size |B| is not positive: \" + sizeB);\n        }\n        if (intersection < 0 || intersection > Math.min(sizeA, sizeB)) {\n            throw new IllegalArgumentException(\"Invalid intersection of |A| and |B|: \" + intersection);\n        }\n        this.sizeA = sizeA;\n        this.sizeB = sizeB;\n        this.intersection = intersection;\n    }\n\n    @Override\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        final IntersectionResult result = (IntersectionResult) o;\n        return sizeA == result.sizeA && sizeB == result.sizeB && intersection == result.intersection;\n    }\n\n    /**\n     * Gets the size of the intersection between set A and B.\n     *\n     * @return {@code |A &#8745; B|}\n     */\n    public int getIntersection() {\n        return intersection;\n    }\n\n    /**\n     * Gets the size of set A.\n     *\n     * @return |A|\n     */\n    public int getSizeA() {\n        return sizeA;\n    }\n\n    /**\n     * Gets the size of set B.\n     *\n     * @return |B|\n     */\n    public int getSizeB() {\n        return sizeB;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(sizeA, sizeB, intersection);\n    }\n\n    @Override\n    public String toString() {\n        return \"Size A: \" + sizeA + \", Size B: \" + sizeB + \", Intersection: \" + intersection;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/IntersectionResult.java b/src/main/java/org/apache/commons/text/similarity/IntersectionResult.java\nindex 711af57ab7..ebdade170e 100644\n--- a/src/main/java/org/apache/commons/text/similarity/IntersectionResult.java\n+++ b/src/main/java/org/apache/commons/text/similarity/IntersectionResult.java\n@@ -63,7 +63,7 @@ public IntersectionResult(final int sizeA, final int sizeB, final int intersecti\n             throw new IllegalArgumentException(\"Set size |B| is not positive: \" + sizeB);\n         }\n         if (intersection < 0 || intersection > Math.min(sizeA, sizeB)) {\n-            throw new IllegalArgumentException(\"Invalid intersection of |A| and |B|: \" + intersection);\n+            throw new IllegalArgumentException(\"Invalid intersection of A and B: \" + intersection);\n         }\n         this.sizeA = sizeA;\n         this.sizeB = sizeB;\n"
      }
    ]
  },
  {
    "pr_number": 434,
    "title": "Add null-check in RandomStringGenerator#selectFrom() to avoid NullPointerException",
    "state": "closed",
    "created_at": "2023-06-26T17:49:43Z",
    "merge_commit_sha": "ce20118e7c2690306ecaadd2a130657299eee16c",
    "base_sha": "a020a66964fbd82dba96cad4725db8dd5df85457",
    "head_sha": "5b32e42447364e291f7876ba2940023bc54fde9e",
    "user_login": "orionlibs",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/RandomStringGenerator.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatNullPointerException;\nimport static org.assertj.core.api.Assertions.fail;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\npublic class RandomStringGeneratorTest2 {\n\n    /**\n     * Test to ensure that selectFrom method handles null input gracefully.\n     */\n    @Test\n    public void testSelectFromNullCharArray() {\n        final RandomStringGenerator generator = new RandomStringGenerator.Builder().selectFrom((char[]) null).build();\n        final String randomText = generator.generate(5);\n        for (final char c : randomText.toCharArray()) {\n            assertTrue(c >= Character.MIN_CODE_POINT && c <= Character.MAX_CODE_POINT);\n        }\n    }\n\n    /**\n     * Test to ensure that selectFrom method handles empty input array.\n     */\n    @Test\n    public void testSelectFromEmptyCharArray() {\n        final RandomStringGenerator generator = new RandomStringGenerator.Builder().selectFrom(new char[0]).build();\n        final String randomText = generator.generate(5);\n        for (final char c : randomText.toCharArray()) {\n            assertTrue(c >= Character.MIN_CODE_POINT && c <= Character.MAX_CODE_POINT);\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\n\n/**\n * Generates random Unicode strings containing the specified number of code points.\n * Instances are created using a builder class, which allows the\n * callers to define the properties of the generator. See the documentation for the\n * {@link Builder} class to see available properties.\n *\n * <pre>\n * // Generates a 20 code point string, using only the letters a-z\n * RandomStringGenerator generator = new RandomStringGenerator.Builder()\n *     .withinRange('a', 'z').build();\n * String randomLetters = generator.generate(20);\n * </pre>\n * <pre>\n * // Using Apache Commons RNG for randomness\n * UniformRandomProvider rng = RandomSource.create(...);\n * // Generates a 20 code point string, using only the letters a-z\n * RandomStringGenerator generator = new RandomStringGenerator.Builder()\n *     .withinRange('a', 'z')\n *     .usingRandom(rng::nextInt) // uses Java 8 syntax\n *     .build();\n * String randomLetters = generator.generate(20);\n * </pre>\n * <p>\n * {@code RandomStringGenerator} instances are thread-safe when using the\n * default random number generator (RNG). If a custom RNG is set by calling the method\n * {@link Builder#usingRandom(TextRandomProvider) Builder.usingRandom(TextRandomProvider)}, thread-safety\n * must be ensured externally.\n * </p>\n * @since 1.1\n */\npublic final class RandomStringGenerator {\n\n    /**\n     * A builder for generating {@code RandomStringGenerator} instances.\n     *\n     * <p>The behavior of a generator is controlled by properties set by this\n     * builder. Each property has a default value, which can be overridden by\n     * calling the methods defined in this class, prior to calling {@link #build()}.</p>\n     *\n     * <p>All the property setting methods return the {@code Builder} instance to allow for method chaining.</p>\n     *\n     * <p>The minimum and maximum code point values are defined using {@link #withinRange(int, int)}. The\n     * default values are {@code 0} and {@link Character#MAX_CODE_POINT} respectively.</p>\n     *\n     * <p>The source of randomness can be set using {@link #usingRandom(TextRandomProvider)},\n     * otherwise {@link ThreadLocalRandom} is used.</p>\n     *\n     * <p>The type of code points returned can be filtered using {@link #filteredBy(CharacterPredicate...)},\n     * which defines a collection of tests that are applied to the randomly generated code points.\n     * The code points will only be included in the result if they pass at least one of the tests.\n     * Some commonly used predicates are provided by the {@link CharacterPredicates} enum.</p>\n     *\n     * <p>This class is not thread safe.</p>\n     * @since 1.1\n     */\n    public static class Builder implements org.apache.commons.text.Builder<RandomStringGenerator> {\n\n        /**\n         * The default maximum code point allowed: {@link Character#MAX_CODE_POINT}\n         * ({@value}).\n         */\n        public static final int DEFAULT_MAXIMUM_CODE_POINT = Character.MAX_CODE_POINT;\n\n        /**\n         * The default string length produced by this builder: {@value}.\n         */\n        public static final int DEFAULT_LENGTH = 0;\n\n        /**\n         * The default minimum code point allowed: {@value}.\n         */\n        public static final int DEFAULT_MINIMUM_CODE_POINT = 0;\n\n        /**\n         * The minimum code point allowed.\n         */\n        private int minimumCodePoint = DEFAULT_MINIMUM_CODE_POINT;\n\n        /**\n         * The maximum code point allowed.\n         */\n        private int maximumCodePoint = DEFAULT_MAXIMUM_CODE_POINT;\n\n        /**\n         * Filters for code points.\n         */\n        private Set<CharacterPredicate> inclusivePredicates;\n\n        /**\n         * The source of randomness.\n         */\n        private TextRandomProvider random;\n\n        /**\n         * The source of provided characters.\n         */\n        private List<Character> characterList;\n\n        /**\n         * Builds the {@code RandomStringGenerator} using the properties specified.\n         *\n         * @return The configured {@code RandomStringGenerator}\n         */\n        @Override\n        public RandomStringGenerator build() {\n            return new RandomStringGenerator(minimumCodePoint, maximumCodePoint, inclusivePredicates,\n                    random, characterList);\n        }\n\n        /**\n         * Limits the characters in the generated string to those that match at\n         * least one of the predicates supplied.\n         *\n         * <p>\n         * Passing {@code null} or an empty array to this method will revert to the\n         * default behavior of allowing any character. Multiple calls to this\n         * method will replace the previously stored predicates.\n         * </p>\n         *\n         * @param predicates\n         *            the predicates, may be {@code null} or empty\n         * @return {@code this}, to allow method chaining\n         */\n        public Builder filteredBy(final CharacterPredicate... predicates) {\n            if (ArrayUtils.isEmpty(predicates)) {\n                inclusivePredicates = null;\n                return this;\n            }\n\n            if (inclusivePredicates == null) {\n                inclusivePredicates = new HashSet<>();\n            } else {\n                inclusivePredicates.clear();\n            }\n\n            Collections.addAll(inclusivePredicates, predicates);\n\n            return this;\n        }\n\n        /**\n         * Limits the characters in the generated string to those who match at\n         * supplied list of Character.\n         *\n         * <p>\n         * Passing {@code null} or an empty array to this method will revert to the\n         * default behavior of allowing any character. Multiple calls to this\n         * method will replace the previously stored Character.\n         * </p>\n         *\n         * @param chars set of predefined Characters for random string generation\n         *            the Character can be, may be {@code null} or empty\n         * @return {@code this}, to allow method chaining\n         * @since 1.2\n         */\n        public Builder selectFrom(final char... chars) {\n            characterList = new ArrayList<>();\n            for (final char c : chars) {\n                characterList.add(c);\n            }\n            return this;\n        }\n\n        /**\n         * Overrides the default source of randomness.  It is highly\n         * recommended that a random number generator library like\n         * <a href=\"https://commons.apache.org/proper/commons-rng/\">Apache Commons RNG</a>\n         * be used to provide the random number generation.\n         *\n         * <p>\n         * When using Java 8 or later, {@link TextRandomProvider} is a\n         * functional interface and need not be explicitly implemented:\n         * </p>\n         * <pre>\n         * {@code\n         *     UniformRandomProvider rng = RandomSource.create(...);\n         *     RandomStringGenerator gen = new RandomStringGenerator.Builder()\n         *         .usingRandom(rng::nextInt)\n         *         // additional builder calls as needed\n         *         .build();\n         * }\n         * </pre>\n         *\n         * <p>\n         * Passing {@code null} to this method will revert to the default source of\n         * randomness.\n         * </p>\n         *\n         * @param random\n         *            the source of randomness, may be {@code null}\n         * @return {@code this}, to allow method chaining\n         */\n        public Builder usingRandom(final TextRandomProvider random) {\n            this.random = random;\n            return this;\n        }\n\n        /**\n         * Sets the array of minimum and maximum char allowed in the\n         * generated string.\n         *\n         * For example:\n         * <pre>\n         * {@code\n         *     char [][] pairs = {{'0','9'}};\n         *     char [][] pairs = {{'a','z'}};\n         *     char [][] pairs = {{'a','z'},{'0','9'}};\n         * }\n         * </pre>\n         *\n         * @param pairs array of characters array, expected is to pass min, max pairs through this arg.\n         * @return {@code this}, to allow method chaining.\n         */\n        public Builder withinRange(final char[]... pairs) {\n            characterList = new ArrayList<>();\n            for (final char[] pair :  pairs) {\n                Validate.isTrue(pair.length == 2,\n                      \"Each pair must contain minimum and maximum code point\");\n                final int minimumCodePoint = pair[0];\n                final int maximumCodePoint = pair[1];\n                Validate.isTrue(minimumCodePoint <= maximumCodePoint,\n                    \"Minimum code point %d is larger than maximum code point %d\", minimumCodePoint, maximumCodePoint);\n\n                for (int index = minimumCodePoint; index <= maximumCodePoint; index++) {\n                    characterList.add((char) index);\n                }\n            }\n            return this;\n\n        }\n\n        /**\n         * Sets the minimum and maximum code points allowed in the\n         * generated string.\n         *\n         * @param minimumCodePoint\n         *            the smallest code point allowed (inclusive)\n         * @param maximumCodePoint\n         *            the largest code point allowed (inclusive)\n         * @return {@code this}, to allow method chaining\n         * @throws IllegalArgumentException\n         *             if {@code maximumCodePoint >}\n         *             {@link Character#MAX_CODE_POINT}\n         * @throws IllegalArgumentException\n         *             if {@code minimumCodePoint < 0}\n         * @throws IllegalArgumentException\n         *             if {@code minimumCodePoint > maximumCodePoint}\n         */\n        public Builder withinRange(final int minimumCodePoint, final int maximumCodePoint) {\n            Validate.isTrue(minimumCodePoint <= maximumCodePoint,\n                    \"Minimum code point %d is larger than maximum code point %d\", minimumCodePoint, maximumCodePoint);\n            Validate.isTrue(minimumCodePoint >= 0, \"Minimum code point %d is negative\", minimumCodePoint);\n            Validate.isTrue(maximumCodePoint <= Character.MAX_CODE_POINT,\n                    \"Value %d is larger than Character.MAX_CODE_POINT.\", maximumCodePoint);\n\n            this.minimumCodePoint = minimumCodePoint;\n            this.maximumCodePoint = maximumCodePoint;\n            return this;\n        }\n    }\n\n    /**\n     * The smallest allowed code point (inclusive).\n     */\n    private final int minimumCodePoint;\n\n    /**\n     * The largest allowed code point (inclusive).\n     */\n    private final int maximumCodePoint;\n\n    /**\n     * Filters for code points.\n     */\n    private final Set<CharacterPredicate> inclusivePredicates;\n\n    /**\n     * The source of randomness for this generator.\n     */\n    private final TextRandomProvider random;\n\n    /**\n     * The source of provided characters.\n     */\n    private final List<Character> characterList;\n\n    /**\n     * Constructs the generator.\n     *\n     * @param minimumCodePoint\n     *            smallest allowed code point (inclusive)\n     * @param maximumCodePoint\n     *            largest allowed code point (inclusive)\n     * @param inclusivePredicates\n     *            filters for code points\n     * @param random\n     *            source of randomness\n     * @param characterList list of predefined set of characters.\n     */\n    private RandomStringGenerator(final int minimumCodePoint, final int maximumCodePoint,\n                                  final Set<CharacterPredicate> inclusivePredicates, final TextRandomProvider random,\n                                  final List<Character> characterList) {\n        this.minimumCodePoint = minimumCodePoint;\n        this.maximumCodePoint = maximumCodePoint;\n        this.inclusivePredicates = inclusivePredicates;\n        this.random = random;\n        this.characterList = characterList;\n    }\n\n    /**\n     * Generates a random string, containing the specified number of code points.\n     *\n     * <p>\n     * Code points are randomly selected between the minimum and maximum values defined\n     * in the generator.\n     * Surrogate and private use characters are not returned, although the\n     * resulting string may contain pairs of surrogates that together encode a\n     * supplementary character.\n     * </p>\n     * <p>\n     * Note: the number of {@code char} code units generated will exceed\n     * {@code length} if the string contains supplementary characters. See the\n     * {@link Character} documentation to understand how Java stores Unicode\n     * values.\n     * </p>\n     *\n     * @param length\n     *            the number of code points to generate\n     * @return The generated string\n     * @throws IllegalArgumentException\n     *             if {@code length < 0}\n     */\n    public String generate(final int length) {\n        if (length == 0) {\n            return StringUtils.EMPTY;\n        }\n        Validate.isTrue(length > 0, \"Length %d is smaller than zero.\", length);\n\n        final StringBuilder builder = new StringBuilder(length);\n        long remaining = length;\n\n        do {\n            final int codePoint;\n            if (characterList != null && !characterList.isEmpty()) {\n                codePoint = generateRandomNumber(characterList);\n            } else {\n                codePoint = generateRandomNumber(minimumCodePoint, maximumCodePoint);\n            }\n            switch (Character.getType(codePoint)) {\n            case Character.UNASSIGNED:\n            case Character.PRIVATE_USE:\n            case Character.SURROGATE:\n                continue;\n            default:\n            }\n\n            if (inclusivePredicates != null) {\n                boolean matchedFilter = false;\n                for (final CharacterPredicate predicate : inclusivePredicates) {\n                    if (predicate.test(codePoint)) {\n                        matchedFilter = true;\n                        break;\n                    }\n                }\n                if (!matchedFilter) {\n                    continue;\n                }\n            }\n\n            builder.appendCodePoint(codePoint);\n            remaining--;\n\n        } while (remaining != 0);\n\n        return builder.toString();\n    }\n\n    /**\n     * Generates a random string, containing between the minimum (inclusive) and the maximum (inclusive)\n     * number of code points.\n     *\n     * @param minLengthInclusive\n     *            the minimum (inclusive) number of code points to generate\n     * @param maxLengthInclusive\n     *            the maximum (inclusive) number of code points to generate\n     * @return The generated string\n     * @throws IllegalArgumentException\n     *             if {@code minLengthInclusive < 0}, or {@code maxLengthInclusive < minLengthInclusive}\n     * @see RandomStringGenerator#generate(int)\n     * @since 1.2\n     */\n    public String generate(final int minLengthInclusive, final int maxLengthInclusive) {\n        Validate.isTrue(minLengthInclusive >= 0, \"Minimum length %d is smaller than zero.\", minLengthInclusive);\n        Validate.isTrue(minLengthInclusive <= maxLengthInclusive,\n                \"Maximum length %d is smaller than minimum length %d.\", maxLengthInclusive, minLengthInclusive);\n        return generate(generateRandomNumber(minLengthInclusive, maxLengthInclusive));\n    }\n\n    /**\n     * Generates a random number within a range, using a {@link ThreadLocalRandom} instance\n     * or the user-supplied source of randomness.\n     *\n     * @param minInclusive\n     *            the minimum value allowed\n     * @param maxInclusive\n     *            the maximum value allowed\n     * @return The random number.\n     */\n    private int generateRandomNumber(final int minInclusive, final int maxInclusive) {\n        if (random != null) {\n            return random.nextInt(maxInclusive - minInclusive + 1) + minInclusive;\n        }\n        return ThreadLocalRandom.current().nextInt(minInclusive, maxInclusive + 1);\n    }\n\n    /**\n     * Generates a random number within a range, using a {@link ThreadLocalRandom} instance\n     * or the user-supplied source of randomness.\n     *\n     * @param characterList predefined char list.\n     * @return The random number.\n     */\n    private int generateRandomNumber(final List<Character> characterList) {\n        final int listSize = characterList.size();\n        if (random != null) {\n            return String.valueOf(characterList.get(random.nextInt(listSize))).codePointAt(0);\n        }\n        return String.valueOf(characterList.get(ThreadLocalRandom.current().nextInt(0, listSize))).codePointAt(0);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/RandomStringGenerator.java b/src/main/java/org/apache/commons/text/RandomStringGenerator.java\nindex ead0148f37..8ae6d002a2 100644\n--- a/src/main/java/org/apache/commons/text/RandomStringGenerator.java\n+++ b/src/main/java/org/apache/commons/text/RandomStringGenerator.java\n@@ -184,8 +184,10 @@ public Builder filteredBy(final CharacterPredicate... predicates) {\n          */\n         public Builder selectFrom(final char... chars) {\n             characterList = new ArrayList<>();\n-            for (final char c : chars) {\n-                characterList.add(c);\n+            if (chars != null) {\n+                for (final char c : chars) {\n+                    characterList.add(c);\n+                }\n             }\n             return this;\n         }\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/RandomStringGeneratorTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 429,
    "title": "Improve AlphabetConverter Javadoc",
    "state": "closed",
    "created_at": "2023-06-26T13:57:47Z",
    "merge_commit_sha": "9b312a12eda60e80ffa31cea8de2f02d221b3ac6",
    "base_sha": "7f3f9f5c7d0cd693e201a8e9f265b380694806e9",
    "head_sha": "815315fff2bbcb427b91e0e737b803a9cd4d565b",
    "user_login": "orionlibs",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/AlphabetConverter.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class AlphabetConverterTest2 {\n\n    private static final Character[] LOWER_CASE_ENGLISH = {' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\n            't', 'u', 'v', 'w', 'x', 'y', 'z'};\n    private static final Character[] ENGLISH_AND_NUMBERS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n            'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n            'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' '};\n    private static final Character[] LOWER_CASE_ENGLISH_AND_NUMBERS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\n            'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', ' '};\n    private static final Character[] NUMBERS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n    private static final Character[] BINARY = {'0', '1'};\n    private static final Character[] HEBREW = {'_', ' ', '\\u05e7', '\\u05e8', '\\u05d0', '\\u05d8', '\\u05d5', '\\u05df', '\\u05dd', '\\u05e4', '\\u05e9', '\\u05d3',\n            '\\u05d2', '\\u05db', '\\u05e2', '\\u05d9', '\\u05d7', '\\u05dc', '\\u05da', '\\u05e3', '\\u05d6', '\\u05e1', '\\u05d1', '\\u05d4', '\\u05e0', '\\u05de', '\\u05e6',\n            '\\u05ea', '\\u05e5'};\n    private static final Integer[] UNICODE = {32, 35395, 35397, 36302, 36291, 35203, 35201, 35215, 35219, 35268, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,\n            107, 108, 109, 110, 1001, 1002, 1003, 1004, 1005};\n    private static final Integer[] LOWER_CASE_ENGLISH_CODEPOINTS = {32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,\n            115, 116, 117, 118, 119, 120, 121, 122};\n    private static final Integer[] DO_NOT_ENCODE_CODEPOINTS = {32, 97, 98, 99};\n\n    @Test\n    public void testCreateConverterWithUnicodeBMP() {\n        final Character[] original = {'a', 'b', 'c', 'd'};\n        final Character[] encoding = {'0', '1', 'd'};\n        final Character[] doNotEncode = {'d'};\n        AlphabetConverter ac = AlphabetConverter.createConverterFromChars(original, encoding, doNotEncode);\n        assertThat(ac).isNotNull();\n    }\n\n    @Test\n    public void testCreateConverterWithUnicodeBMPFailure() {\n        final Character[] original = {'a', 'b', 'c', 'd'};\n        final Character[] encoding = {'0', '1'};\n        final Character[] doNotEncode = {'d'};\n        assertThatThrownBy(() -> AlphabetConverter.createConverterFromChars(original, encoding, doNotEncode))\n                .isInstanceOf(IllegalArgumentException.class)\n                .hasMessage(\"Can not use 'do not encode' list because encoding alphabet does not contain 'd'\");\n    }\n\n    @Test\n    public void testCreateConverterWithUnicodeBMPOriginalFailure() {\n        final Character[] original = {'a', 'b'};\n        final Character[] encoding = {'0', '1', 'd'};\n        final Character[] doNotEncode = {'c'};\n        assertThatThrownBy(() -> AlphabetConverter.createConverterFromChars(original, encoding, doNotEncode))\n                .isInstanceOf(IllegalArgumentException.class)\n                .hasMessage(\"Can not use 'do not encode' list because original alphabet does not contain 'c'\");\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * <p>\n * Convert from one alphabet to another, with the possibility of leaving certain\n * characters unencoded.\n * </p>\n *\n * <p>\n * The target and do not encode languages must be in the Unicode BMP, but the\n * source language does not.\n * </p>\n *\n * <p>\n * The encoding will all be of a fixed length, except for the 'do not encode'\n * chars, which will be of length 1\n * </p>\n *\n * <h2>Sample usage</h2>\n *\n * <pre>\n * Character[] originals;   // a, b, c, d\n * Character[] encoding;    // 0, 1, d\n * Character[] doNotEncode; // d\n *\n * AlphabetConverter ac = AlphabetConverter.createConverterFromChars(originals,\n * encoding, doNotEncode);\n *\n * ac.encode(\"a\");    // 00\n * ac.encode(\"b\");    // 01\n * ac.encode(\"c\");    // 0d\n * ac.encode(\"d\");    // d\n * ac.encode(\"abcd\"); // 00010dd\n * </pre>\n *\n * <p>\n * #ThreadSafe# AlphabetConverter class methods are thread-safe as they do not\n * change internal state.\n * </p>\n *\n * @since 1.0\n */\npublic final class AlphabetConverter {\n\n    /**\n     * Arrow constant, used for converting the object into a string.\n     */\n    private static final String ARROW = \" -> \";\n\n    /**\n     * Creates new String that contains just the given code point.\n     *\n     * @param i code point\n     * @return a new string with the new code point\n     * @see \"http://www.oracle.com/us/technologies/java/supplementary-142654.html\"\n     */\n    private static String codePointToString(final int i) {\n        if (Character.charCount(i) == 1) {\n            return String.valueOf((char) i);\n        }\n        return new String(Character.toChars(i));\n    }\n\n    /**\n     * Converts characters to integers.\n     *\n     * @param chars array of characters\n     * @return an equivalent array of integers\n     */\n    private static Integer[] convertCharsToIntegers(final Character[] chars) {\n        if (ArrayUtils.isEmpty(chars)) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] integers = new Integer[chars.length];\n        Arrays.setAll(integers, i -> (int) chars[i]);\n        return integers;\n    }\n\n    /**\n     * Creates an alphabet converter, for converting from the original alphabet,\n     * to the encoded alphabet, while leaving\n     * the characters in <em>doNotEncode</em> as they are (if possible).\n     *\n     * <p>Duplicate letters in either original or encoding will be ignored.</p>\n     *\n     * @param original an array of ints representing the original alphabet in\n     *                 code points\n     * @param encoding an array of ints representing the alphabet to be used for\n     *                 encoding, in code points\n     * @param doNotEncode an array of ints representing the chars to be encoded\n     *                    using the original alphabet - every char\n     *                    here must appear in both the previous params\n     * @return The AlphabetConverter\n     * @throws IllegalArgumentException if an AlphabetConverter cannot be\n     *                                   constructed\n     */\n    public static AlphabetConverter createConverter(\n            final Integer[] original,\n            final Integer[] encoding,\n            final Integer[] doNotEncode) {\n        final Set<Integer> originalCopy = new LinkedHashSet<>(Arrays.asList(original));\n        final Set<Integer> encodingCopy = new LinkedHashSet<>(Arrays.asList(encoding));\n        final Set<Integer> doNotEncodeCopy = new LinkedHashSet<>(Arrays.asList(doNotEncode));\n\n        final Map<Integer, String> originalToEncoded = new LinkedHashMap<>();\n        final Map<String, String> encodedToOriginal = new LinkedHashMap<>();\n        final Map<Integer, String> doNotEncodeMap = new HashMap<>();\n\n        final int encodedLetterLength;\n\n        for (final int i : doNotEncodeCopy) {\n            if (!originalCopy.contains(i)) {\n                throw new IllegalArgumentException(\n                        \"Can not use 'do not encode' list because original \"\n                                + \"alphabet does not contain '\"\n                                + codePointToString(i) + \"'\");\n            }\n\n            if (!encodingCopy.contains(i)) {\n                throw new IllegalArgumentException(\n                        \"Can not use 'do not encode' list because encoding alphabet does not contain '\"\n                                + codePointToString(i) + \"'\");\n            }\n\n            doNotEncodeMap.put(i, codePointToString(i));\n        }\n\n        if (encodingCopy.size() >= originalCopy.size()) {\n            encodedLetterLength = 1;\n\n            final Iterator<Integer> it = encodingCopy.iterator();\n\n            for (final int originalLetter : originalCopy) {\n                final String originalLetterAsString =\n                        codePointToString(originalLetter);\n\n                if (doNotEncodeMap.containsKey(originalLetter)) {\n                    originalToEncoded.put(originalLetter,\n                            originalLetterAsString);\n                    encodedToOriginal.put(originalLetterAsString,\n                            originalLetterAsString);\n                } else {\n                    Integer next = it.next();\n\n                    while (doNotEncodeCopy.contains(next)) {\n                        next = it.next();\n                    }\n\n                    final String encodedLetter = codePointToString(next);\n\n                    originalToEncoded.put(originalLetter, encodedLetter);\n                    encodedToOriginal.put(encodedLetter,\n                            originalLetterAsString);\n                }\n            }\n\n            return new AlphabetConverter(originalToEncoded,\n                    encodedToOriginal,\n                    encodedLetterLength);\n\n        }\n        if (encodingCopy.size() - doNotEncodeCopy.size() < 2) {\n            throw new IllegalArgumentException(\n                    \"Must have at least two encoding characters (excluding \"\n                            + \"those in the 'do not encode' list), but has \"\n                            + (encodingCopy.size() - doNotEncodeCopy.size()));\n        }\n        // we start with one which is our minimum, and because we do the\n        // first division outside the loop\n        int lettersSoFar = 1;\n\n        // the first division takes into account that the doNotEncode\n        // letters can't be in the leftmost place\n        int lettersLeft = (originalCopy.size() - doNotEncodeCopy.size())\n                / (encodingCopy.size() - doNotEncodeCopy.size());\n\n        while (lettersLeft / encodingCopy.size() >= 1) {\n            lettersLeft = lettersLeft / encodingCopy.size();\n            lettersSoFar++;\n        }\n\n        encodedLetterLength = lettersSoFar + 1;\n\n        final AlphabetConverter ac =\n                new AlphabetConverter(originalToEncoded,\n                        encodedToOriginal,\n                        encodedLetterLength);\n\n        ac.addSingleEncoding(encodedLetterLength,\n                StringUtils.EMPTY,\n                encodingCopy,\n                originalCopy.iterator(),\n                doNotEncodeMap);\n\n        return ac;\n    }\n\n    /**\n     * Creates an alphabet converter, for converting from the original alphabet,\n     * to the encoded alphabet, while leaving the characters in\n     * <em>doNotEncode</em> as they are (if possible).\n     *\n     * <p>Duplicate letters in either original or encoding will be ignored.</p>\n     *\n     * @param original an array of chars representing the original alphabet\n     * @param encoding an array of chars representing the alphabet to be used\n     *                 for encoding\n     * @param doNotEncode an array of chars to be encoded using the original\n     *                    alphabet - every char here must appear in\n     *                    both the previous params\n     * @return The AlphabetConverter\n     * @throws IllegalArgumentException if an AlphabetConverter cannot be\n     *                                  constructed\n     */\n    public static AlphabetConverter createConverterFromChars(\n            final Character[] original,\n            final Character[] encoding,\n            final Character[] doNotEncode) {\n        return AlphabetConverter.createConverter(\n                convertCharsToIntegers(original),\n                convertCharsToIntegers(encoding),\n                convertCharsToIntegers(doNotEncode));\n    }\n\n    /**\n     * Creates a new converter from a map.\n     *\n     * @param originalToEncoded a map returned from getOriginalToEncoded()\n     * @return The reconstructed AlphabetConverter\n     * @see AlphabetConverter#getOriginalToEncoded()\n     */\n    public static AlphabetConverter createConverterFromMap(final Map<Integer, String> originalToEncoded) {\n        final Map<Integer, String> unmodifiableOriginalToEncoded = Collections.unmodifiableMap(originalToEncoded);\n        final Map<String, String> encodedToOriginal = new LinkedHashMap<>();\n\n        int encodedLetterLength = 1;\n\n        for (final Entry<Integer, String> e : unmodifiableOriginalToEncoded.entrySet()) {\n            final String originalAsString = codePointToString(e.getKey());\n            encodedToOriginal.put(e.getValue(), originalAsString);\n\n            if (e.getValue().length() > encodedLetterLength) {\n                encodedLetterLength = e.getValue().length();\n            }\n        }\n\n        return new AlphabetConverter(unmodifiableOriginalToEncoded, encodedToOriginal, encodedLetterLength);\n    }\n\n    /**\n     * Original string to be encoded.\n     */\n    private final Map<Integer, String> originalToEncoded;\n\n    /**\n     * Encoding alphabet.\n     */\n    private final Map<String, String> encodedToOriginal;\n\n    /**\n     * Length of the encoded letter.\n     */\n    private final int encodedLetterLength;\n\n    /**\n     * Hidden constructor for alphabet converter. Used by static helper methods.\n     *\n     * @param originalToEncoded original string to be encoded\n     * @param encodedToOriginal encoding alphabet\n     * @param encodedLetterLength length of the encoded letter\n     */\n    private AlphabetConverter(final Map<Integer, String> originalToEncoded,\n                              final Map<String, String> encodedToOriginal,\n                              final int encodedLetterLength) {\n\n        this.originalToEncoded = originalToEncoded;\n        this.encodedToOriginal = encodedToOriginal;\n        this.encodedLetterLength = encodedLetterLength;\n    }\n\n    /**\n     * Recursive method used when creating encoder/decoder.\n     *\n     * @param level at which point it should add a single encoding\n     * @param currentEncoding current encoding\n     * @param encoding letters encoding\n     * @param originals original values\n     * @param doNotEncodeMap map of values that should not be encoded\n     */\n    private void addSingleEncoding(final int level,\n                                   final String currentEncoding,\n                                   final Collection<Integer> encoding,\n                                   final Iterator<Integer> originals,\n                                   final Map<Integer, String> doNotEncodeMap) {\n\n        if (level > 0) {\n            for (final int encodingLetter : encoding) {\n                if (!originals.hasNext()) {\n                    return; // done encoding all the original alphabet\n                }\n                // this skips the doNotEncode chars if they are in the\n                // leftmost place\n                if (level != encodedLetterLength\n                        || !doNotEncodeMap.containsKey(encodingLetter)) {\n                    addSingleEncoding(level - 1,\n                            currentEncoding\n                                    + codePointToString(encodingLetter),\n                            encoding,\n                            originals,\n                            doNotEncodeMap\n                    );\n                }\n            }\n        } else {\n            Integer next = originals.next();\n\n            while (doNotEncodeMap.containsKey(next)) {\n                final String originalLetterAsString = codePointToString(next);\n\n                originalToEncoded.put(next, originalLetterAsString);\n                encodedToOriginal.put(originalLetterAsString,\n                        originalLetterAsString);\n\n                if (!originals.hasNext()) {\n                    return;\n                }\n\n                next = originals.next();\n            }\n\n            final String originalLetterAsString = codePointToString(next);\n\n            originalToEncoded.put(next, currentEncoding);\n            encodedToOriginal.put(currentEncoding, originalLetterAsString);\n        }\n    }\n\n    /**\n     * Decodes a given string.\n     *\n     * @param encoded a string that has been encoded using this\n     *                AlphabetConverter\n     * @return The decoded string, {@code null} if the given string is null\n     * @throws UnsupportedEncodingException if unexpected characters that\n     *                                      cannot be handled are encountered\n     */\n    public String decode(final String encoded)\n            throws UnsupportedEncodingException {\n        if (encoded == null) {\n            return null;\n        }\n\n        final StringBuilder result = new StringBuilder();\n\n        for (int j = 0; j < encoded.length();) {\n            final int i = encoded.codePointAt(j);\n            final String s = codePointToString(i);\n\n            if (s.equals(originalToEncoded.get(i))) {\n                result.append(s);\n                j++; // because we do not encode in Unicode extended the\n                     // length of each encoded char is 1\n            } else {\n                if (j + encodedLetterLength > encoded.length()) {\n                    throw new UnsupportedEncodingException(\"Unexpected end \"\n                            + \"of string while decoding \" + encoded);\n                }\n                final String nextGroup = encoded.substring(j,\n                        j + encodedLetterLength);\n                final String next = encodedToOriginal.get(nextGroup);\n                if (next == null) {\n                    throw new UnsupportedEncodingException(\n                            \"Unexpected string without decoding (\"\n                                    + nextGroup + \") in \" + encoded);\n                }\n                result.append(next);\n                j += encodedLetterLength;\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Encodes a given string.\n     *\n     * @param original the string to be encoded\n     * @return The encoded string, {@code null} if the given string is null\n     * @throws UnsupportedEncodingException if chars that are not supported are\n     *                                      encountered\n     */\n    public String encode(final String original)\n            throws UnsupportedEncodingException {\n        if (original == null) {\n            return null;\n        }\n\n        final StringBuilder sb = new StringBuilder();\n\n        for (int i = 0; i < original.length();) {\n            final int codePoint = original.codePointAt(i);\n\n            final String nextLetter = originalToEncoded.get(codePoint);\n\n            if (nextLetter == null) {\n                throw new UnsupportedEncodingException(\n                        \"Couldn't find encoding for '\"\n                                + codePointToString(codePoint)\n                                + \"' in \"\n                                + original\n                );\n            }\n\n            sb.append(nextLetter);\n\n            i += Character.charCount(codePoint);\n        }\n\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof AlphabetConverter)) {\n            return false;\n        }\n        final AlphabetConverter other = (AlphabetConverter) obj;\n        return originalToEncoded.equals(other.originalToEncoded)\n                && encodedToOriginal.equals(other.encodedToOriginal)\n                && encodedLetterLength == other.encodedLetterLength;\n    }\n\n    /**\n     * Gets the length of characters in the encoded alphabet that are necessary\n     * for each character in the original\n     * alphabet.\n     *\n     * @return The length of the encoded char\n     */\n    public int getEncodedCharLength() {\n        return encodedLetterLength;\n    }\n\n    /**\n     * Gets the mapping from integer code point of source language to encoded\n     * string. Use to reconstruct converter from\n     * serialized map.\n     *\n     * @return The original map\n     */\n    public Map<Integer, String> getOriginalToEncoded() {\n        return Collections.unmodifiableMap(originalToEncoded);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(originalToEncoded,\n                encodedToOriginal,\n                encodedLetterLength);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        // @formatter:off\n        originalToEncoded.forEach((k, v) ->\n            sb.append(codePointToString(k))\n              .append(ARROW)\n              .append(k)\n              .append(System.lineSeparator()));\n        // @formatter:on\n        return sb.toString();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/AlphabetConverter.java b/src/main/java/org/apache/commons/text/AlphabetConverter.java\nindex 033ede17c6..59dcaaf236 100644\n--- a/src/main/java/org/apache/commons/text/AlphabetConverter.java\n+++ b/src/main/java/org/apache/commons/text/AlphabetConverter.java\n@@ -39,7 +39,7 @@\n  * </p>\n  *\n  * <p>\n- * The target and do not encode languages must be in the Unicode BMP, but the\n+ * The target and 'do not encode' languages must be in the Unicode BMP, but the\n  * source language does not.\n  * </p>\n  *\n"
      }
    ]
  },
  {
    "pr_number": 382,
    "title": "Fix javadoc for escapeHtml4",
    "state": "closed",
    "created_at": "2022-11-04T10:33:14Z",
    "merge_commit_sha": "8d8185bc3267fb0b9058a79157c902aa1240e9e6",
    "base_sha": "a4a325177487a34cc1290fb2dad79d4fda4f660d",
    "head_sha": "4d7e453bdfde355d97e3ca2143536b450cf240e1",
    "user_login": "jtnord",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/StringEscapeUtils.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.apache.commons.text.StringEscapeUtils.escapeHtml3;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\n\nimport org.junit.jupiter.api.Test;\n\npublic class StringEscapeUtilsTest2 {\n\n    @Test\n    public void testEscapeHtml3Updated() {\n        // Test case to verify the updated HTML escape functionality\n        final String input = \"\\\"bread\\\" & \\\"butter\\\"\";\n        final String expected = \"&quot;bread&quot; &amp; &quot;butter&quot;\";\n        assertEquals(expected, escapeHtml3(input));\n\n        final StringWriter sw = new StringWriter();\n        try {\n            StringEscapeUtils.ESCAPE_HTML3.translate(input, sw);\n        } catch (final IOException e) {\n            // Handle exception\n        }\n        final String actual = sw.toString();\n        assertEquals(expected, actual);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.translate.AggregateTranslator;\nimport org.apache.commons.text.translate.CharSequenceTranslator;\nimport org.apache.commons.text.translate.CsvTranslators;\nimport org.apache.commons.text.translate.EntityArrays;\nimport org.apache.commons.text.translate.JavaUnicodeEscaper;\nimport org.apache.commons.text.translate.LookupTranslator;\nimport org.apache.commons.text.translate.NumericEntityEscaper;\nimport org.apache.commons.text.translate.NumericEntityUnescaper;\nimport org.apache.commons.text.translate.OctalUnescaper;\nimport org.apache.commons.text.translate.UnicodeUnescaper;\nimport org.apache.commons.text.translate.UnicodeUnpairedSurrogateRemover;\n\n/**\n * <p>\n * Escapes and unescapes {@code String}s for Java, Java Script, HTML and XML.\n * </p>\n *\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * <p>\n * This code has been adapted from Apache Commons Lang 3.5.\n * </p>\n *\n * @since 1.0\n */\npublic class StringEscapeUtils {\n\n    /* ESCAPE TRANSLATORS */\n\n    /**\n     * Convenience wrapper for {@link java.lang.StringBuilder} providing escape methods.\n     *\n     * <p>Example:</p>\n     * <pre>\n     * new Builder(ESCAPE_HTML4)\n     *      .append(\"&lt;p&gt;\")\n     *      .escape(\"This is paragraph 1 and special chars like &amp; get escaped.\")\n     *      .append(\"&lt;/p&gt;&lt;p&gt;\")\n     *      .escape(\"This is paragraph 2 &amp; more...\")\n     *      .append(\"&lt;/p&gt;\")\n     *      .toString()\n     * </pre>\n     *\n     */\n    public static final class Builder {\n\n        /**\n         * StringBuilder to be used in the Builder class.\n         */\n        private final StringBuilder sb;\n\n        /**\n         * CharSequenceTranslator to be used in the Builder class.\n         */\n        private final CharSequenceTranslator translator;\n\n        /**\n         * Builder constructor.\n         *\n         * @param translator a CharSequenceTranslator.\n         */\n        private Builder(final CharSequenceTranslator translator) {\n            this.sb = new StringBuilder();\n            this.translator = translator;\n        }\n\n        /**\n         * Literal append, no escaping being done.\n         *\n         * @param input the String to append\n         * @return {@code this}, to enable chaining\n         */\n        public Builder append(final String input) {\n            sb.append(input);\n            return this;\n        }\n\n        /**\n         * Escape {@code input} according to the given {@link CharSequenceTranslator}.\n         *\n         * @param input the String to escape\n         * @return {@code this}, to enable chaining\n         */\n        public Builder escape(final String input) {\n            sb.append(translator.translate(input));\n            return this;\n        }\n\n        /**\n         * Return the escaped string.\n         *\n         * @return The escaped string\n         */\n        @Override\n        public String toString() {\n            return sb.toString();\n        }\n    }\n    /**\n     * Translator object for unescaping backslash escaped entries.\n     */\n    static class XsiUnescaper extends CharSequenceTranslator {\n\n        /**\n         * Escaped backslash constant.\n         */\n        private static final char BACKSLASH = '\\\\';\n\n        @Override\n        public int translate(final CharSequence input, final int index, final Writer writer) throws IOException {\n\n            if (index != 0) {\n                throw new IllegalStateException(\"XsiUnescaper should never reach the [1] index\");\n            }\n\n            final String s = input.toString();\n\n            int segmentStart = 0;\n            int searchOffset = 0;\n            while (true) {\n                final int pos = s.indexOf(BACKSLASH, searchOffset);\n                if (pos == -1) {\n                    if (segmentStart < s.length()) {\n                        writer.write(s.substring(segmentStart));\n                    }\n                    break;\n                }\n                if (pos > segmentStart) {\n                    writer.write(s.substring(segmentStart, pos));\n                }\n                segmentStart = pos + 1;\n                searchOffset = pos + 2;\n            }\n\n            return Character.codePointCount(input, 0, input.length());\n        }\n    }\n\n    /**\n     * Translator object for escaping Java.\n     *\n     * While {@link #escapeJava(String)} is the expected method of use, this\n     * object allows the Java escaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator ESCAPE_JAVA;\n    static {\n        final Map<CharSequence, CharSequence> escapeJavaMap = new HashMap<>();\n        escapeJavaMap.put(\"\\\"\", \"\\\\\\\"\");\n        escapeJavaMap.put(\"\\\\\", \"\\\\\\\\\");\n        ESCAPE_JAVA = new AggregateTranslator(\n                new LookupTranslator(Collections.unmodifiableMap(escapeJavaMap)),\n                new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE),\n                JavaUnicodeEscaper.outsideOf(32, 0x7f)\n        );\n    }\n\n    /**\n     * Translator object for escaping EcmaScript/JavaScript.\n     *\n     * While {@link #escapeEcmaScript(String)} is the expected method of use, this\n     * object allows the EcmaScript escaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator ESCAPE_ECMASCRIPT;\n    static {\n        final Map<CharSequence, CharSequence> escapeEcmaScriptMap = new HashMap<>();\n        escapeEcmaScriptMap.put(\"'\", \"\\\\'\");\n        escapeEcmaScriptMap.put(\"\\\"\", \"\\\\\\\"\");\n        escapeEcmaScriptMap.put(\"\\\\\", \"\\\\\\\\\");\n        escapeEcmaScriptMap.put(\"/\", \"\\\\/\");\n        ESCAPE_ECMASCRIPT = new AggregateTranslator(\n                new LookupTranslator(Collections.unmodifiableMap(escapeEcmaScriptMap)),\n                new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE),\n                JavaUnicodeEscaper.outsideOf(32, 0x7f)\n        );\n    }\n\n    /**\n     * Translator object for escaping Json.\n     *\n     * While {@link #escapeJson(String)} is the expected method of use, this\n     * object allows the Json escaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator ESCAPE_JSON;\n    static {\n        final Map<CharSequence, CharSequence> escapeJsonMap = new HashMap<>();\n        escapeJsonMap.put(\"\\\"\", \"\\\\\\\"\");\n        escapeJsonMap.put(\"\\\\\", \"\\\\\\\\\");\n        escapeJsonMap.put(\"/\", \"\\\\/\");\n        ESCAPE_JSON = new AggregateTranslator(\n                new LookupTranslator(Collections.unmodifiableMap(escapeJsonMap)),\n                new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE),\n                JavaUnicodeEscaper.outsideOf(32, 0x7e)\n        );\n    }\n\n    /**\n     * Translator object for escaping XML 1.0.\n     *\n     * While {@link #escapeXml10(String)} is the expected method of use, this\n     * object allows the XML escaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator ESCAPE_XML10;\n    static {\n        final Map<CharSequence, CharSequence> escapeXml10Map = new HashMap<>();\n        escapeXml10Map.put(\"\\u0000\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0001\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0002\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0003\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0004\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0005\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0006\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0007\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0008\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000b\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000c\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000e\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000f\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0010\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0011\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0012\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0013\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0014\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0015\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0016\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0017\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0018\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0019\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001a\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001b\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001c\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001d\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001e\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001f\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\ufffe\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\uffff\", StringUtils.EMPTY);\n        ESCAPE_XML10 = new AggregateTranslator(\n                new LookupTranslator(EntityArrays.BASIC_ESCAPE),\n                new LookupTranslator(EntityArrays.APOS_ESCAPE),\n                new LookupTranslator(Collections.unmodifiableMap(escapeXml10Map)),\n                NumericEntityEscaper.between(0x7f, 0x84),\n                NumericEntityEscaper.between(0x86, 0x9f),\n                new UnicodeUnpairedSurrogateRemover()\n        );\n    }\n\n    /**\n     * Translator object for escaping XML 1.1.\n     *\n     * While {@link #escapeXml11(String)} is the expected method of use, this\n     * object allows the XML escaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator ESCAPE_XML11;\n\n    static {\n        final Map<CharSequence, CharSequence> escapeXml11Map = new HashMap<>();\n        escapeXml11Map.put(\"\\u0000\", StringUtils.EMPTY);\n        escapeXml11Map.put(\"\\u000b\", \"&#11;\");\n        escapeXml11Map.put(\"\\u000c\", \"&#12;\");\n        escapeXml11Map.put(\"\\ufffe\", StringUtils.EMPTY);\n        escapeXml11Map.put(\"\\uffff\", StringUtils.EMPTY);\n        ESCAPE_XML11 = new AggregateTranslator(\n                new LookupTranslator(EntityArrays.BASIC_ESCAPE),\n                new LookupTranslator(EntityArrays.APOS_ESCAPE),\n                new LookupTranslator(Collections.unmodifiableMap(escapeXml11Map)),\n                NumericEntityEscaper.between(0x1, 0x8),\n                NumericEntityEscaper.between(0xe, 0x1f),\n                NumericEntityEscaper.between(0x7f, 0x84),\n                NumericEntityEscaper.between(0x86, 0x9f),\n                new UnicodeUnpairedSurrogateRemover()\n        );\n    }\n\n    /**\n     * Translator object for escaping HTML version 3.0.\n     *\n     * While {@link #escapeHtml3(String)} is the expected method of use, this\n     * object allows the HTML escaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator ESCAPE_HTML3 =\n            new AggregateTranslator(\n                    new LookupTranslator(EntityArrays.BASIC_ESCAPE),\n                    new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE)\n            );\n\n    /**\n     * Translator object for escaping HTML version 4.0.\n     *\n     * While {@link #escapeHtml4(String)} is the expected method of use, this\n     * object allows the HTML escaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator ESCAPE_HTML4 =\n            new AggregateTranslator(\n                    new LookupTranslator(EntityArrays.BASIC_ESCAPE),\n                    new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE),\n                    new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE)\n            );\n    /**\n     * Translator object for escaping individual Comma Separated Values.\n     *\n     * While {@link #escapeCsv(String)} is the expected method of use, this\n     * object allows the CSV escaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator ESCAPE_CSV = new CsvTranslators.CsvEscaper();\n\n    /* UNESCAPE TRANSLATORS */\n\n    /**\n     * Translator object for escaping Shell command language.\n     *\n     * @see <a href=\"http://pubs.opengroup.org/onlinepubs/7908799/xcu/chap2.html\">Shell Command Language</a>\n     */\n    public static final CharSequenceTranslator ESCAPE_XSI;\n    static {\n        final Map<CharSequence, CharSequence> escapeXsiMap = new HashMap<>();\n        escapeXsiMap.put(\"|\", \"\\\\|\");\n        escapeXsiMap.put(\"&\", \"\\\\&\");\n        escapeXsiMap.put(\";\", \"\\\\;\");\n        escapeXsiMap.put(\"<\", \"\\\\<\");\n        escapeXsiMap.put(\">\", \"\\\\>\");\n        escapeXsiMap.put(\"(\", \"\\\\(\");\n        escapeXsiMap.put(\")\", \"\\\\)\");\n        escapeXsiMap.put(\"$\", \"\\\\$\");\n        escapeXsiMap.put(\"`\", \"\\\\`\");\n        escapeXsiMap.put(\"\\\\\", \"\\\\\\\\\");\n        escapeXsiMap.put(\"\\\"\", \"\\\\\\\"\");\n        escapeXsiMap.put(\"'\", \"\\\\'\");\n        escapeXsiMap.put(\" \", \"\\\\ \");\n        escapeXsiMap.put(\"\\t\", \"\\\\\\t\");\n        escapeXsiMap.put(\"\\r\\n\", StringUtils.EMPTY);\n        escapeXsiMap.put(\"\\n\", StringUtils.EMPTY);\n        escapeXsiMap.put(\"*\", \"\\\\*\");\n        escapeXsiMap.put(\"?\", \"\\\\?\");\n        escapeXsiMap.put(\"[\", \"\\\\[\");\n        escapeXsiMap.put(\"#\", \"\\\\#\");\n        escapeXsiMap.put(\"~\", \"\\\\~\");\n        escapeXsiMap.put(\"=\", \"\\\\=\");\n        escapeXsiMap.put(\"%\", \"\\\\%\");\n        ESCAPE_XSI = new LookupTranslator(\n                Collections.unmodifiableMap(escapeXsiMap)\n        );\n    }\n\n    /**\n     * Translator object for unescaping escaped Java.\n     *\n     * While {@link #unescapeJava(String)} is the expected method of use, this\n     * object allows the Java unescaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator UNESCAPE_JAVA;\n\n    static {\n        final Map<CharSequence, CharSequence> unescapeJavaMap = new HashMap<>();\n        unescapeJavaMap.put(\"\\\\\\\\\", \"\\\\\");\n        unescapeJavaMap.put(\"\\\\\\\"\", \"\\\"\");\n        unescapeJavaMap.put(\"\\\\'\", \"'\");\n        unescapeJavaMap.put(\"\\\\\", StringUtils.EMPTY);\n        UNESCAPE_JAVA = new AggregateTranslator(\n                new OctalUnescaper(),     // .between('\\1', '\\377'),\n                new UnicodeUnescaper(),\n                new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE),\n                new LookupTranslator(Collections.unmodifiableMap(unescapeJavaMap))\n        );\n    }\n\n    /**\n     * Translator object for unescaping escaped EcmaScript.\n     *\n     * While {@link #unescapeEcmaScript(String)} is the expected method of use, this\n     * object allows the EcmaScript unescaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator UNESCAPE_ECMASCRIPT = UNESCAPE_JAVA;\n\n    /**\n     * Translator object for unescaping escaped Json.\n     *\n     * While {@link #unescapeJson(String)} is the expected method of use, this\n     * object allows the Json unescaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator UNESCAPE_JSON = UNESCAPE_JAVA;\n\n    /**\n     * Translator object for unescaping escaped HTML 3.0.\n     *\n     * While {@link #unescapeHtml3(String)} is the expected method of use, this\n     * object allows the HTML unescaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator UNESCAPE_HTML3 =\n            new AggregateTranslator(\n                    new LookupTranslator(EntityArrays.BASIC_UNESCAPE),\n                    new LookupTranslator(EntityArrays.ISO8859_1_UNESCAPE),\n                    new NumericEntityUnescaper()\n            );\n\n    /**\n     * Translator object for unescaping escaped HTML 4.0.\n     *\n     * While {@link #unescapeHtml4(String)} is the expected method of use, this\n     * object allows the HTML unescaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator UNESCAPE_HTML4 =\n            new AggregateTranslator(\n                    new LookupTranslator(EntityArrays.BASIC_UNESCAPE),\n                    new LookupTranslator(EntityArrays.ISO8859_1_UNESCAPE),\n                    new LookupTranslator(EntityArrays.HTML40_EXTENDED_UNESCAPE),\n                    new NumericEntityUnescaper()\n            );\n\n    /**\n     * Translator object for unescaping escaped XML.\n     *\n     * While {@link #unescapeXml(String)} is the expected method of use, this\n     * object allows the XML unescaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator UNESCAPE_XML =\n            new AggregateTranslator(\n                    new LookupTranslator(EntityArrays.BASIC_UNESCAPE),\n                    new LookupTranslator(EntityArrays.APOS_UNESCAPE),\n                    new NumericEntityUnescaper()\n            );\n\n    /**\n     * Translator object for unescaping escaped Comma Separated Value entries.\n     *\n     * While {@link #unescapeCsv(String)} is the expected method of use, this\n     * object allows the CSV unescaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator UNESCAPE_CSV = new CsvTranslators.CsvUnescaper();\n\n    /* Helper functions */\n\n    /**\n     * Translator object for unescaping escaped XSI Value entries.\n     *\n     * While {@link #unescapeXSI(String)}  is the expected method of use, this\n     * object allows the XSI unescaping functionality to be used\n     * as the foundation for a custom translator.\n     */\n    public static final CharSequenceTranslator UNESCAPE_XSI = new XsiUnescaper();\n\n    /**\n     * Get a {@link Builder}.\n     * @param translator the text translator\n     * @return {@link Builder}\n     */\n    public static StringEscapeUtils.Builder builder(final CharSequenceTranslator translator) {\n        return new Builder(translator);\n    }\n\n    /**\n     * Returns a {@code String} value for a CSV column enclosed in double quotes,\n     * if required.\n     *\n     * <p>If the value contains a comma, newline or double quote, then the\n     *    String value is returned enclosed in double quotes.</p>\n     *\n     * <p>Any double quote characters in the value are escaped with another double quote.</p>\n     *\n     * <p>If the value does not contain a comma, newline or double quote, then the\n     *    String value is returned unchanged.</p>\n     *\n     * see <a href=\"http://en.wikipedia.org/wiki/Comma-separated_values\">Wikipedia</a> and\n     * <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * @param input the input CSV column String, may be null\n     * @return The input String, enclosed in double quotes if the value contains a comma,\n     * newline or double quote, {@code null} if null string input\n     */\n    public static final String escapeCsv(final String input) {\n        return ESCAPE_CSV.translate(input);\n    }\n\n    /**\n     * Escapes the characters in a {@code String} using EcmaScript String rules.\n     *\n     * <p>Escapes any values it finds into their EcmaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters {@code '\\\\'} and\n     * {@code 't'}.</p>\n     *\n     * <p>The only difference between Java strings and EcmaScript strings\n     * is that in EcmaScript, a single quote and forward-slash (/) are escaped.</p>\n     *\n     * <p>Note that EcmaScript is best known by the JavaScript and ActionScript dialects.</p>\n     *\n     * <p>Example:</p>\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     *\n     * <b>Security Note.</b> We only provide backslash escaping in this method. For example, {@code '\\\"'} has the output\n     * {@code '\\\\\\\"'} which could result in potential issues in the case where the string being escaped is being used\n     * in an HTML tag like {@code <select onmouseover=\"...\" />}. If you wish to have more rigorous string escaping, you\n     * may consider the\n     * <a href=\"https://www.owasp.org/index.php/Category:OWASP_Enterprise_Security_API_JAVA\">ESAPI Libraries</a>.\n     * Further, you can view the <a href=\"https://github.com/esapi\">ESAPI GitHub Org</a>.\n     *\n     * @param input  String to escape values in, may be null\n     * @return String with escaped values, {@code null} if null string input\n     */\n    public static final String escapeEcmaScript(final String input) {\n        return ESCAPE_ECMASCRIPT.translate(input);\n    }\n\n    /**\n     * Escapes the characters in a {@code String} using HTML entities.\n     *\n     * <p>Supports only the HTML 3.0 entities.</p>\n     *\n     * @param input  the {@code String} to escape, may be null\n     * @return a new escaped {@code String}, {@code null} if null string input\n     */\n    public static final String escapeHtml3(final String input) {\n        return ESCAPE_HTML3.translate(input);\n    }\n\n    // HTML and XML\n    /**\n     * Escapes the characters in a {@code String} using HTML entities.\n     *\n     * <p>\n     * For example:\n     * </p>\n     * <p>{@code \"bread\" &amp; \"butter\"}</p>\n     * becomes:\n     * <p>\n     * {@code &amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;}.\n     * </p>\n     *\n     * <p>Supports all known HTML 4.0 entities, including funky accents.\n     * Note that the commonly used apostrophe escape character (&amp;apos;)\n     * is not a legal entity and so is not supported).</p>\n     *\n     * @param input  the {@code String} to escape, may be null\n     * @return a new escaped {@code String}, {@code null} if null string input\n     *\n     * @see <a href=\"http://hotwired.lycos.com/webmonkey/reference/special_characters/\">ISO Entities</a>\n     * @see <a href=\"http://www.w3.org/TR/REC-html32#latin1\">HTML 3.2 Character Entities for ISO Latin-1</a>\n     * @see <a href=\"http://www.w3.org/TR/REC-html40/sgml/entities.html\">HTML 4.0 Character entity references</a>\n     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#h-5.3\">HTML 4.01 Character References</a>\n     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n     */\n    public static final String escapeHtml4(final String input) {\n        return ESCAPE_HTML4.translate(input);\n    }\n\n    // Java and JavaScript\n    /**\n     * Escapes the characters in a {@code String} using Java String rules.\n     *\n     * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters {@code '\\\\'} and\n     * {@code 't'}.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote and forward-slash (/) are escaped.</p>\n     *\n     * <p>Example:</p>\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn't say, \\\"Stop!\\\"\n     * </pre>\n     *\n     * @param input  String to escape values in, may be null\n     * @return String with escaped values, {@code null} if null string input\n     */\n    public static final String escapeJava(final String input) {\n        return ESCAPE_JAVA.translate(input);\n    }\n\n    /**\n     * Escapes the characters in a {@code String} using Json String rules.\n     *\n     * <p>Escapes any values it finds into their Json String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters {@code '\\\\'} and\n     * {@code 't'}.</p>\n     *\n     * <p>The only difference between Java strings and Json strings\n     * is that in Json, forward-slash (/) is escaped.</p>\n     *\n     * <p>See http://www.ietf.org/rfc/rfc4627.txt for further details.</p>\n     *\n     * <p>Example:</p>\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn't say, \\\"Stop!\\\"\n     * </pre>\n     *\n     * @param input  String to escape values in, may be null\n     * @return String with escaped values, {@code null} if null string input\n     */\n    public static final String escapeJson(final String input) {\n        return ESCAPE_JSON.translate(input);\n    }\n\n    /**\n     * Escapes the characters in a {@code String} using XML entities.\n     *\n     * <p>For example: {@code \"bread\" & \"butter\"} =&gt;\n     * {@code &quot;bread&quot; &amp; &quot;butter&quot;}.\n     * </p>\n     *\n     * <p>Note that XML 1.0 is a text-only format: it cannot represent control\n     * characters or unpaired Unicode surrogate code points, even after escaping.\n     * {@code escapeXml10} will remove characters that do not fit in the\n     * following ranges:</p>\n     *\n     * <p>{@code #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]}</p>\n     *\n     * <p>Though not strictly necessary, {@code escapeXml10} will escape\n     * characters in the following ranges:</p>\n     *\n     * <p>{@code [#x7F-#x84] | [#x86-#x9F]}</p>\n     *\n     * <p>The returned string can be inserted into a valid XML 1.0 or XML 1.1\n     * document. If you want to allow more non-text characters in an XML 1.1\n     * document, use {@link #escapeXml11(String)}.</p>\n     *\n     * @param input  the {@code String} to escape, may be null\n     * @return a new escaped {@code String}, {@code null} if null string input\n     * @see #unescapeXml(String)\n     */\n    public static String escapeXml10(final String input) {\n        return ESCAPE_XML10.translate(input);\n    }\n\n    /**\n     * Escapes the characters in a {@code String} using XML entities.\n     *\n     * <p>For example: {@code \"bread\" & \"butter\"} =&gt;\n     * {@code &quot;bread&quot; &amp; &quot;butter&quot;}.\n     * </p>\n     *\n     * <p>XML 1.1 can represent certain control characters, but it cannot represent\n     * the null byte or unpaired Unicode surrogate code points, even after escaping.\n     * {@code escapeXml11} will remove characters that do not fit in the following\n     * ranges:</p>\n     *\n     * <p>{@code [#x1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]}</p>\n     *\n     * <p>{@code escapeXml11} will escape characters in the following ranges:</p>\n     *\n     * <p>{@code [#x1-#x8] | [#xB-#xC] | [#xE-#x1F] | [#x7F-#x84] | [#x86-#x9F]}</p>\n     *\n     * <p>The returned string can be inserted into a valid XML 1.1 document. Do not\n     * use it for XML 1.0 documents.</p>\n     *\n     * @param input  the {@code String} to escape, may be null\n     * @return a new escaped {@code String}, {@code null} if null string input\n     * @see #unescapeXml(String)\n     */\n    public static String escapeXml11(final String input) {\n        return ESCAPE_XML11.translate(input);\n    }\n\n    /**\n     * Escapes the characters in a {@code String} using XSI rules.\n     *\n     * <p><b>Beware!</b> In most cases you don't want to escape shell commands but use multi-argument\n     * methods provided by {@link java.lang.ProcessBuilder} or {@link java.lang.Runtime#exec(String[])}\n     * instead.</p>\n     *\n     * <p>Example:</p>\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He\\ didn\\'t\\ say,\\ \\\"Stop!\\\"\n     * </pre>\n     *\n     * @see <a href=\"http://pubs.opengroup.org/onlinepubs/7908799/xcu/chap2.html\">Shell Command Language</a>\n     * @param input  String to escape values in, may be null\n     * @return String with escaped values, {@code null} if null string input\n     */\n    public static final String escapeXSI(final String input) {\n        return ESCAPE_XSI.translate(input);\n    }\n\n    /**\n     * Returns a {@code String} value for an unescaped CSV column.\n     *\n     * <p>If the value is enclosed in double quotes, and contains a comma, newline\n     *    or double quote, then quotes are removed.\n     * </p>\n     *\n     * <p>Any double quote escaped characters (a pair of double quotes) are unescaped\n     *    to just one double quote.</p>\n     *\n     * <p>If the value is not enclosed in double quotes, or is and does not contain a\n     *    comma, newline or double quote, then the String value is returned unchanged.</p>\n     *\n     * see <a href=\"http://en.wikipedia.org/wiki/Comma-separated_values\">Wikipedia</a> and\n     * <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * @param input the input CSV column String, may be null\n     * @return The input String, with enclosing double quotes removed and embedded double\n     * quotes unescaped, {@code null} if null string input\n     */\n    public static final String unescapeCsv(final String input) {\n        return UNESCAPE_CSV.translate(input);\n    }\n\n    /**\n     * Unescapes any EcmaScript literals found in the {@code String}.\n     *\n     * <p>For example, it will turn a sequence of {@code '\\'} and {@code 'n'}\n     * into a newline character, unless the {@code '\\'} is preceded by another\n     * {@code '\\'}.</p>\n     *\n     * @see #unescapeJava(String)\n     * @param input  the {@code String} to unescape, may be null\n     * @return A new unescaped {@code String}, {@code null} if null string input\n     */\n    public static final String unescapeEcmaScript(final String input) {\n        return UNESCAPE_ECMASCRIPT.translate(input);\n    }\n\n    /**\n     * Unescapes a string containing entity escapes to a string\n     * containing the actual Unicode characters corresponding to the\n     * escapes. Supports only HTML 3.0 entities.\n     *\n     * @param input  the {@code String} to unescape, may be null\n     * @return a new unescaped {@code String}, {@code null} if null string input\n     */\n    public static final String unescapeHtml3(final String input) {\n        return UNESCAPE_HTML3.translate(input);\n    }\n\n    /**\n     * Unescapes a string containing entity escapes to a string\n     * containing the actual Unicode characters corresponding to the\n     * escapes. Supports HTML 4.0 entities.\n     *\n     * <p>For example, the string {@code \"&lt;Fran&ccedil;ais&gt;\"}\n     * will become {@code \"<Fran\ufffdais>\"}</p>\n     *\n     * <p>If an entity is unrecognized, it is left alone, and inserted\n     * verbatim into the result string. e.g. {@code \"&gt;&zzzz;x\"} will\n     * become {@code \">&zzzz;x\"}.</p>\n     *\n     * @param input  the {@code String} to unescape, may be null\n     * @return a new unescaped {@code String}, {@code null} if null string input\n     */\n    public static final String unescapeHtml4(final String input) {\n        return UNESCAPE_HTML4.translate(input);\n    }\n\n    /**\n     * Unescapes any Java literals found in the {@code String}.\n     * For example, it will turn a sequence of {@code '\\'} and\n     * {@code 'n'} into a newline character, unless the {@code '\\'}\n     * is preceded by another {@code '\\'}.\n     *\n     * @param input  the {@code String} to unescape, may be null\n     * @return a new unescaped {@code String}, {@code null} if null string input\n     */\n    public static final String unescapeJava(final String input) {\n        return UNESCAPE_JAVA.translate(input);\n    }\n\n    /**\n     * Unescapes any Json literals found in the {@code String}.\n     *\n     * <p>For example, it will turn a sequence of {@code '\\'} and {@code 'n'}\n     * into a newline character, unless the {@code '\\'} is preceded by another\n     * {@code '\\'}.</p>\n     *\n     * @see #unescapeJava(String)\n     * @param input  the {@code String} to unescape, may be null\n     * @return A new unescaped {@code String}, {@code null} if null string input\n     */\n    public static final String unescapeJson(final String input) {\n        return UNESCAPE_JSON.translate(input);\n    }\n\n    /**\n     * Unescapes a string containing XML entity escapes to a string\n     * containing the actual Unicode characters corresponding to the\n     * escapes.\n     *\n     * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n     * Does not support DTDs or external entities.</p>\n     *\n     * <p>Note that numerical \\\\u Unicode codes are unescaped to their respective\n     *    Unicode characters. This may change in future releases.</p>\n     *\n     * @param input  the {@code String} to unescape, may be null\n     * @return a new unescaped {@code String}, {@code null} if null string input\n     * @see #escapeXml10(String)\n     * @see #escapeXml11(String)\n     */\n    public static final String unescapeXml(final String input) {\n        return UNESCAPE_XML.translate(input);\n    }\n\n    /**\n     * Unescapes the characters in a {@code String} using XSI rules.\n     *\n     * @see StringEscapeUtils#escapeXSI(String)\n     * @param input  the {@code String} to unescape, may be null\n     * @return a new unescaped {@code String}, {@code null} if null string input\n     */\n    public static final String unescapeXSI(final String input) {\n        return UNESCAPE_XSI.translate(input);\n    }\n\n    /**\n     * {@code StringEscapeUtils} instances should NOT be constructed in\n     * standard programming.\n     *\n     * <p>Instead, the class should be used as:</p>\n     * <pre>StringEscapeUtils.escapeJava(\"foo\");</pre>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public StringEscapeUtils() {\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/StringEscapeUtils.java b/src/main/java/org/apache/commons/text/StringEscapeUtils.java\nindex 5ddbc2324d..5888817e17 100644\n--- a/src/main/java/org/apache/commons/text/StringEscapeUtils.java\n+++ b/src/main/java/org/apache/commons/text/StringEscapeUtils.java\n@@ -567,7 +567,7 @@ public static final String escapeHtml3(final String input) {\n      * <p>{@code \"bread\" &amp; \"butter\"}</p>\n      * becomes:\n      * <p>\n-     * {@code &amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;}.\n+     * {@code &quot;bread&quot; &amp;amp; &quot;butter&quot;}.\n      * </p>\n      *\n      * <p>Supports all known HTML 4.0 entities, including funky accents.\n"
      }
    ]
  },
  {
    "pr_number": 368,
    "title": "Fix formatting.",
    "state": "closed",
    "created_at": "2022-10-09T20:28:37Z",
    "merge_commit_sha": "e651d8cbfcac134f21b5bb25d9a195d53bcc179d",
    "base_sha": "2eec12c3a77da098ab34899b812e6e40ac8677b2",
    "head_sha": "bac571f881655be9f512ca0a1f04ec83712b1ac3",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/AlphabetConverter.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class AlphabetConverterTest2 {\n\n    @Test\n    public void testToStringFormat() {\n        // Create a simple AlphabetConverter instance\n        Map<Integer, String> originalToEncoded = new HashMap<>();\n        originalToEncoded.put(97, \"a\");\n        originalToEncoded.put(98, \"b\");\n        AlphabetConverter ac = AlphabetConverter.createConverterFromMap(originalToEncoded);\n\n        // Expected toString format\n        String expected = \"a -> 97\" + System.lineSeparator() + \"b -> 98\" + System.lineSeparator();\n\n        // Assert the toString method produces the expected format\n        assertThat(ac.toString()).isEqualTo(expected);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * <p>\n * Convert from one alphabet to another, with the possibility of leaving certain\n * characters unencoded.\n * </p>\n *\n * <p>\n * The target and do not encode languages must be in the Unicode BMP, but the\n * source language does not.\n * </p>\n *\n * <p>\n * The encoding will all be of a fixed length, except for the 'do not encode'\n * chars, which will be of length 1\n * </p>\n *\n * <h2>Sample usage</h2>\n *\n * <pre>\n * Character[] originals;   // a, b, c, d\n * Character[] encoding;    // 0, 1, d\n * Character[] doNotEncode; // d\n *\n * AlphabetConverter ac = AlphabetConverter.createConverterFromChars(originals,\n * encoding, doNotEncode);\n *\n * ac.encode(\"a\");    // 00\n * ac.encode(\"b\");    // 01\n * ac.encode(\"c\");    // 0d\n * ac.encode(\"d\");    // d\n * ac.encode(\"abcd\"); // 00010dd\n * </pre>\n *\n * <p>\n * #ThreadSafe# AlphabetConverter class methods are thread-safe as they do not\n * change internal state.\n * </p>\n *\n * @since 1.0\n *\n */\npublic final class AlphabetConverter {\n\n    /**\n     * Arrow constant, used for converting the object into a string.\n     */\n    private static final String ARROW = \" -> \";\n\n    /**\n     * Creates new String that contains just the given code point.\n     *\n     * @param i code point\n     * @return a new string with the new code point\n     * @see \"http://www.oracle.com/us/technologies/java/supplementary-142654.html\"\n     */\n    private static String codePointToString(final int i) {\n        if (Character.charCount(i) == 1) {\n            return String.valueOf((char) i);\n        }\n        return new String(Character.toChars(i));\n    }\n\n    /**\n     * Converts characters to integers.\n     *\n     * @param chars array of characters\n     * @return an equivalent array of integers\n     */\n    private static Integer[] convertCharsToIntegers(final Character[] chars) {\n        if (ArrayUtils.isEmpty(chars)) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] integers = new Integer[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            integers[i] = (int) chars[i];\n        }\n        return integers;\n    }\n\n    /**\n     * Creates an alphabet converter, for converting from the original alphabet,\n     * to the encoded alphabet, while leaving\n     * the characters in <em>doNotEncode</em> as they are (if possible).\n     *\n     * <p>Duplicate letters in either original or encoding will be ignored.</p>\n     *\n     * @param original an array of ints representing the original alphabet in\n     *                 code points\n     * @param encoding an array of ints representing the alphabet to be used for\n     *                 encoding, in code points\n     * @param doNotEncode an array of ints representing the chars to be encoded\n     *                    using the original alphabet - every char\n     *                    here must appear in both the previous params\n     * @return The AlphabetConverter\n     * @throws IllegalArgumentException if an AlphabetConverter cannot be\n     *                                   constructed\n     */\n    public static AlphabetConverter createConverter(\n            final Integer[] original,\n            final Integer[] encoding,\n            final Integer[] doNotEncode) {\n        final Set<Integer> originalCopy = new LinkedHashSet<>(Arrays.asList(original));\n        final Set<Integer> encodingCopy = new LinkedHashSet<>(Arrays.asList(encoding));\n        final Set<Integer> doNotEncodeCopy = new LinkedHashSet<>(Arrays.asList(doNotEncode));\n\n        final Map<Integer, String> originalToEncoded = new LinkedHashMap<>();\n        final Map<String, String> encodedToOriginal = new LinkedHashMap<>();\n        final Map<Integer, String> doNotEncodeMap = new HashMap<>();\n\n        final int encodedLetterLength;\n\n        for (final int i : doNotEncodeCopy) {\n            if (!originalCopy.contains(i)) {\n                throw new IllegalArgumentException(\n                        \"Can not use 'do not encode' list because original \"\n                                + \"alphabet does not contain '\"\n                                + codePointToString(i) + \"'\");\n            }\n\n            if (!encodingCopy.contains(i)) {\n                throw new IllegalArgumentException(\n                        \"Can not use 'do not encode' list because encoding alphabet does not contain '\"\n                                + codePointToString(i) + \"'\");\n            }\n\n            doNotEncodeMap.put(i, codePointToString(i));\n        }\n\n        if (encodingCopy.size() >= originalCopy.size()) {\n            encodedLetterLength = 1;\n\n            final Iterator<Integer> it = encodingCopy.iterator();\n\n            for (final int originalLetter : originalCopy) {\n                final String originalLetterAsString =\n                        codePointToString(originalLetter);\n\n                if (doNotEncodeMap.containsKey(originalLetter)) {\n                    originalToEncoded.put(originalLetter,\n                            originalLetterAsString);\n                    encodedToOriginal.put(originalLetterAsString,\n                            originalLetterAsString);\n                } else {\n                    Integer next = it.next();\n\n                    while (doNotEncodeCopy.contains(next)) {\n                        next = it.next();\n                    }\n\n                    final String encodedLetter = codePointToString(next);\n\n                    originalToEncoded.put(originalLetter, encodedLetter);\n                    encodedToOriginal.put(encodedLetter,\n                            originalLetterAsString);\n                }\n            }\n\n            return new AlphabetConverter(originalToEncoded,\n                    encodedToOriginal,\n                    encodedLetterLength);\n\n        }\n        if (encodingCopy.size() - doNotEncodeCopy.size() < 2) {\n            throw new IllegalArgumentException(\n                    \"Must have at least two encoding characters (excluding \"\n                            + \"those in the 'do not encode' list), but has \"\n                            + (encodingCopy.size() - doNotEncodeCopy.size()));\n        }\n        // we start with one which is our minimum, and because we do the\n        // first division outside the loop\n        int lettersSoFar = 1;\n\n        // the first division takes into account that the doNotEncode\n        // letters can't be in the leftmost place\n        int lettersLeft = (originalCopy.size() - doNotEncodeCopy.size())\n                / (encodingCopy.size() - doNotEncodeCopy.size());\n\n        while (lettersLeft / encodingCopy.size() >= 1) {\n            lettersLeft = lettersLeft / encodingCopy.size();\n            lettersSoFar++;\n        }\n\n        encodedLetterLength = lettersSoFar + 1;\n\n        final AlphabetConverter ac =\n                new AlphabetConverter(originalToEncoded,\n                        encodedToOriginal,\n                        encodedLetterLength);\n\n        ac.addSingleEncoding(encodedLetterLength,\n                StringUtils.EMPTY,\n                encodingCopy,\n                originalCopy.iterator(),\n                doNotEncodeMap);\n\n        return ac;\n    }\n\n    /**\n     * Creates an alphabet converter, for converting from the original alphabet,\n     * to the encoded alphabet, while leaving the characters in\n     * <em>doNotEncode</em> as they are (if possible).\n     *\n     * <p>Duplicate letters in either original or encoding will be ignored.</p>\n     *\n     * @param original an array of chars representing the original alphabet\n     * @param encoding an array of chars representing the alphabet to be used\n     *                 for encoding\n     * @param doNotEncode an array of chars to be encoded using the original\n     *                    alphabet - every char here must appear in\n     *                    both the previous params\n     * @return The AlphabetConverter\n     * @throws IllegalArgumentException if an AlphabetConverter cannot be\n     *                                  constructed\n     */\n    public static AlphabetConverter createConverterFromChars(\n            final Character[] original,\n            final Character[] encoding,\n            final Character[] doNotEncode) {\n        return AlphabetConverter.createConverter(\n                convertCharsToIntegers(original),\n                convertCharsToIntegers(encoding),\n                convertCharsToIntegers(doNotEncode));\n    }\n\n    /**\n     * Creates a new converter from a map.\n     *\n     * @param originalToEncoded a map returned from getOriginalToEncoded()\n     * @return The reconstructed AlphabetConverter\n     * @see AlphabetConverter#getOriginalToEncoded()\n     */\n    public static AlphabetConverter createConverterFromMap(final Map<Integer, String> originalToEncoded) {\n        final Map<Integer, String> unmodifiableOriginalToEncoded = Collections.unmodifiableMap(originalToEncoded);\n        final Map<String, String> encodedToOriginal = new LinkedHashMap<>();\n\n        int encodedLetterLength = 1;\n\n        for (final Entry<Integer, String> e : unmodifiableOriginalToEncoded.entrySet()) {\n            final String originalAsString = codePointToString(e.getKey());\n            encodedToOriginal.put(e.getValue(), originalAsString);\n\n            if (e.getValue().length() > encodedLetterLength) {\n                encodedLetterLength = e.getValue().length();\n            }\n        }\n\n        return new AlphabetConverter(unmodifiableOriginalToEncoded, encodedToOriginal, encodedLetterLength);\n    }\n\n    /**\n     * Original string to be encoded.\n     */\n    private final Map<Integer, String> originalToEncoded;\n\n    /**\n     * Encoding alphabet.\n     */\n    private final Map<String, String> encodedToOriginal;\n\n    /**\n     * Length of the encoded letter.\n     */\n    private final int encodedLetterLength;\n\n    /**\n     * Hidden constructor for alphabet converter. Used by static helper methods.\n     *\n     * @param originalToEncoded original string to be encoded\n     * @param encodedToOriginal encoding alphabet\n     * @param encodedLetterLength length of the encoded letter\n     */\n    private AlphabetConverter(final Map<Integer, String> originalToEncoded,\n                              final Map<String, String> encodedToOriginal,\n                              final int encodedLetterLength) {\n\n        this.originalToEncoded = originalToEncoded;\n        this.encodedToOriginal = encodedToOriginal;\n        this.encodedLetterLength = encodedLetterLength;\n    }\n\n    /**\n     * Recursive method used when creating encoder/decoder.\n     *\n     * @param level at which point it should add a single encoding\n     * @param currentEncoding current encoding\n     * @param encoding letters encoding\n     * @param originals original values\n     * @param doNotEncodeMap map of values that should not be encoded\n     */\n    private void addSingleEncoding(final int level,\n                                   final String currentEncoding,\n                                   final Collection<Integer> encoding,\n                                   final Iterator<Integer> originals,\n                                   final Map<Integer, String> doNotEncodeMap) {\n\n        if (level > 0) {\n            for (final int encodingLetter : encoding) {\n                if (!originals.hasNext()) {\n                    return; // done encoding all the original alphabet\n                }\n                // this skips the doNotEncode chars if they are in the\n                // leftmost place\n                if (level != encodedLetterLength\n                        || !doNotEncodeMap.containsKey(encodingLetter)) {\n                    addSingleEncoding(level - 1,\n                            currentEncoding\n                                    + codePointToString(encodingLetter),\n                            encoding,\n                            originals,\n                            doNotEncodeMap\n                    );\n                }\n            }\n        } else {\n            Integer next = originals.next();\n\n            while (doNotEncodeMap.containsKey(next)) {\n                final String originalLetterAsString = codePointToString(next);\n\n                originalToEncoded.put(next, originalLetterAsString);\n                encodedToOriginal.put(originalLetterAsString,\n                        originalLetterAsString);\n\n                if (!originals.hasNext()) {\n                    return;\n                }\n\n                next = originals.next();\n            }\n\n            final String originalLetterAsString = codePointToString(next);\n\n            originalToEncoded.put(next, currentEncoding);\n            encodedToOriginal.put(currentEncoding, originalLetterAsString);\n        }\n    }\n\n    /**\n     * Decodes a given string.\n     *\n     * @param encoded a string that has been encoded using this\n     *                AlphabetConverter\n     * @return The decoded string, {@code null} if the given string is null\n     * @throws UnsupportedEncodingException if unexpected characters that\n     *                                      cannot be handled are encountered\n     */\n    public String decode(final String encoded)\n            throws UnsupportedEncodingException {\n        if (encoded == null) {\n            return null;\n        }\n\n        final StringBuilder result = new StringBuilder();\n\n        for (int j = 0; j < encoded.length();) {\n            final int i = encoded.codePointAt(j);\n            final String s = codePointToString(i);\n\n            if (s.equals(originalToEncoded.get(i))) {\n                result.append(s);\n                j++; // because we do not encode in Unicode extended the\n                     // length of each encoded char is 1\n            } else {\n                if (j + encodedLetterLength > encoded.length()) {\n                    throw new UnsupportedEncodingException(\"Unexpected end \"\n                            + \"of string while decoding \" + encoded);\n                }\n                final String nextGroup = encoded.substring(j,\n                        j + encodedLetterLength);\n                final String next = encodedToOriginal.get(nextGroup);\n                if (next == null) {\n                    throw new UnsupportedEncodingException(\n                            \"Unexpected string without decoding (\"\n                                    + nextGroup + \") in \" + encoded);\n                }\n                result.append(next);\n                j += encodedLetterLength;\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Encodes a given string.\n     *\n     * @param original the string to be encoded\n     * @return The encoded string, {@code null} if the given string is null\n     * @throws UnsupportedEncodingException if chars that are not supported are\n     *                                      encountered\n     */\n    public String encode(final String original)\n            throws UnsupportedEncodingException {\n        if (original == null) {\n            return null;\n        }\n\n        final StringBuilder sb = new StringBuilder();\n\n        for (int i = 0; i < original.length();) {\n            final int codePoint = original.codePointAt(i);\n\n            final String nextLetter = originalToEncoded.get(codePoint);\n\n            if (nextLetter == null) {\n                throw new UnsupportedEncodingException(\n                        \"Couldn't find encoding for '\"\n                                + codePointToString(codePoint)\n                                + \"' in \"\n                                + original\n                );\n            }\n\n            sb.append(nextLetter);\n\n            i += Character.charCount(codePoint);\n        }\n\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof AlphabetConverter)) {\n            return false;\n        }\n        final AlphabetConverter other = (AlphabetConverter) obj;\n        return originalToEncoded.equals(other.originalToEncoded)\n                && encodedToOriginal.equals(other.encodedToOriginal)\n                && encodedLetterLength == other.encodedLetterLength;\n    }\n\n    /**\n     * Gets the length of characters in the encoded alphabet that are necessary\n     * for each character in the original\n     * alphabet.\n     *\n     * @return The length of the encoded char\n     */\n    public int getEncodedCharLength() {\n        return encodedLetterLength;\n    }\n\n    /**\n     * Gets the mapping from integer code point of source language to encoded\n     * string. Use to reconstruct converter from\n     * serialized map.\n     *\n     * @return The original map\n     */\n    public Map<Integer, String> getOriginalToEncoded() {\n        return Collections.unmodifiableMap(originalToEncoded);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(originalToEncoded,\n                encodedToOriginal,\n                encodedLetterLength);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        // @formatter:off\n        originalToEncoded.forEach((k, v) -> sb.append(codePointToString(k))\n          .append(ARROW)\n          .append(k)\n          .append(System.lineSeparator()));\n        // @formatter:on\n        return sb.toString();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/AlphabetConverter.java b/src/main/java/org/apache/commons/text/AlphabetConverter.java\nindex 1b9138a974..d048b1686b 100644\n--- a/src/main/java/org/apache/commons/text/AlphabetConverter.java\n+++ b/src/main/java/org/apache/commons/text/AlphabetConverter.java\n@@ -504,10 +504,11 @@ public int hashCode() {\n     public String toString() {\n         final StringBuilder sb = new StringBuilder();\n         // @formatter:off\n-        originalToEncoded.forEach((k, v) -> sb.append(codePointToString(k))\n-          .append(ARROW)\n-          .append(k)\n-          .append(System.lineSeparator()));\n+        originalToEncoded.forEach((k, v) ->\n+            sb.append(codePointToString(k))\n+              .append(ARROW)\n+              .append(k)\n+              .append(System.lineSeparator()));\n         // @formatter:on\n         return sb.toString();\n     }\n"
      }
    ]
  },
  {
    "pr_number": 367,
    "title": "Simplify with lambda expression.",
    "state": "closed",
    "created_at": "2022-10-09T19:36:33Z",
    "merge_commit_sha": "2eec12c3a77da098ab34899b812e6e40ac8677b2",
    "base_sha": "a9ae182a92cd549c06d83b3efa60f941b7102d84",
    "head_sha": "742d0fb5ded22f3340ecc5329c5adfd9744935e8",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/AlphabetConverter.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class AlphabetConverterTest2 {\n\n    private static final Character[] LOWER_CASE_ENGLISH = {' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\n            't', 'u', 'v', 'w', 'x', 'y', 'z'};\n    private static final Character[] ENGLISH_AND_NUMBERS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n            'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n            'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' '};\n    private static final Character[] LOWER_CASE_ENGLISH_AND_NUMBERS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\n            'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', ' '};\n    private static final Character[] NUMBERS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n    private static final Character[] BINARY = {'0', '1'};\n    private static final Character[] HEBREW = {'_', ' ', '\\u05e7', '\\u05e8', '\\u05d0', '\\u05d8', '\\u05d5', '\\u05df', '\\u05dd', '\\u05e4', '\\u05e9', '\\u05d3',\n            '\\u05d2', '\\u05db', '\\u05e2', '\\u05d9', '\\u05d7', '\\u05dc', '\\u05da', '\\u05e3', '\\u05d6', '\\u05e1', '\\u05d1', '\\u05d4', '\\u05e0', '\\u05de', '\\u05e6',\n            '\\u05ea', '\\u05e5'};\n    private static final Integer[] UNICODE = {32, 35395, 35397, 36302, 36291, 35203, 35201, 35215, 35219, 35268, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,\n            107, 108, 109, 110, 1001, 1002, 1003, 1004, 1005};\n    private static final Integer[] LOWER_CASE_ENGLISH_CODEPOINTS = {32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,\n            115, 116, 117, 118, 119, 120, 121, 122};\n    private static final Integer[] DO_NOT_ENCODE_CODEPOINTS = {32, 97, 98, 99};\n\n    @Test\n    public void testToStringFormat() throws UnsupportedEncodingException {\n        final AlphabetConverter ac = AlphabetConverter.createConverterFromChars(LOWER_CASE_ENGLISH, BINARY, ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY);\n        final String expectedToString = \"  -> 32\\n\" +\n                \"a -> 97\\n\" +\n                \"b -> 98\\n\" +\n                \"c -> 99\\n\" +\n                \"d -> 100\\n\" +\n                \"e -> 101\\n\" +\n                \"f -> 102\\n\" +\n                \"g -> 103\\n\" +\n                \"h -> 104\\n\" +\n                \"i -> 105\\n\" +\n                \"j -> 106\\n\" +\n                \"k -> 107\\n\" +\n                \"l -> 108\\n\" +\n                \"m -> 109\\n\" +\n                \"n -> 110\\n\" +\n                \"o -> 111\\n\" +\n                \"p -> 112\\n\" +\n                \"q -> 113\\n\" +\n                \"r -> 114\\n\" +\n                \"s -> 115\\n\" +\n                \"t -> 116\\n\" +\n                \"u -> 117\\n\" +\n                \"v -> 118\\n\" +\n                \"w -> 119\\n\" +\n                \"x -> 120\\n\" +\n                \"y -> 121\\n\" +\n                \"z -> 122\\n\";\n        assertThat(ac.toString()).isEqualTo(expectedToString);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * <p>\n * Convert from one alphabet to another, with the possibility of leaving certain\n * characters unencoded.\n * </p>\n *\n * <p>\n * The target and do not encode languages must be in the Unicode BMP, but the\n * source language does not.\n * </p>\n *\n * <p>\n * The encoding will all be of a fixed length, except for the 'do not encode'\n * chars, which will be of length 1\n * </p>\n *\n * <h2>Sample usage</h2>\n *\n * <pre>\n * Character[] originals;   // a, b, c, d\n * Character[] encoding;    // 0, 1, d\n * Character[] doNotEncode; // d\n *\n * AlphabetConverter ac = AlphabetConverter.createConverterFromChars(originals,\n * encoding, doNotEncode);\n *\n * ac.encode(\"a\");    // 00\n * ac.encode(\"b\");    // 01\n * ac.encode(\"c\");    // 0d\n * ac.encode(\"d\");    // d\n * ac.encode(\"abcd\"); // 00010dd\n * </pre>\n *\n * <p>\n * #ThreadSafe# AlphabetConverter class methods are thread-safe as they do not\n * change internal state.\n * </p>\n *\n * @since 1.0\n *\n */\npublic final class AlphabetConverter {\n\n    /**\n     * Arrow constant, used for converting the object into a string.\n     */\n    private static final String ARROW = \" -> \";\n\n    /**\n     * Creates new String that contains just the given code point.\n     *\n     * @param i code point\n     * @return a new string with the new code point\n     * @see \"http://www.oracle.com/us/technologies/java/supplementary-142654.html\"\n     */\n    private static String codePointToString(final int i) {\n        if (Character.charCount(i) == 1) {\n            return String.valueOf((char) i);\n        }\n        return new String(Character.toChars(i));\n    }\n\n    /**\n     * Converts characters to integers.\n     *\n     * @param chars array of characters\n     * @return an equivalent array of integers\n     */\n    private static Integer[] convertCharsToIntegers(final Character[] chars) {\n        if (ArrayUtils.isEmpty(chars)) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] integers = new Integer[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            integers[i] = (int) chars[i];\n        }\n        return integers;\n    }\n\n    /**\n     * Creates an alphabet converter, for converting from the original alphabet,\n     * to the encoded alphabet, while leaving\n     * the characters in <em>doNotEncode</em> as they are (if possible).\n     *\n     * <p>Duplicate letters in either original or encoding will be ignored.</p>\n     *\n     * @param original an array of ints representing the original alphabet in\n     *                 code points\n     * @param encoding an array of ints representing the alphabet to be used for\n     *                 encoding, in code points\n     * @param doNotEncode an array of ints representing the chars to be encoded\n     *                    using the original alphabet - every char\n     *                    here must appear in both the previous params\n     * @return The AlphabetConverter\n     * @throws IllegalArgumentException if an AlphabetConverter cannot be\n     *                                   constructed\n     */\n    public static AlphabetConverter createConverter(\n            final Integer[] original,\n            final Integer[] encoding,\n            final Integer[] doNotEncode) {\n        final Set<Integer> originalCopy = new LinkedHashSet<>(Arrays.asList(original));\n        final Set<Integer> encodingCopy = new LinkedHashSet<>(Arrays.asList(encoding));\n        final Set<Integer> doNotEncodeCopy = new LinkedHashSet<>(Arrays.asList(doNotEncode));\n\n        final Map<Integer, String> originalToEncoded = new LinkedHashMap<>();\n        final Map<String, String> encodedToOriginal = new LinkedHashMap<>();\n        final Map<Integer, String> doNotEncodeMap = new HashMap<>();\n\n        final int encodedLetterLength;\n\n        for (final int i : doNotEncodeCopy) {\n            if (!originalCopy.contains(i)) {\n                throw new IllegalArgumentException(\n                        \"Can not use 'do not encode' list because original \"\n                                + \"alphabet does not contain '\"\n                                + codePointToString(i) + \"'\");\n            }\n\n            if (!encodingCopy.contains(i)) {\n                throw new IllegalArgumentException(\n                        \"Can not use 'do not encode' list because encoding alphabet does not contain '\"\n                                + codePointToString(i) + \"'\");\n            }\n\n            doNotEncodeMap.put(i, codePointToString(i));\n        }\n\n        if (encodingCopy.size() >= originalCopy.size()) {\n            encodedLetterLength = 1;\n\n            final Iterator<Integer> it = encodingCopy.iterator();\n\n            for (final int originalLetter : originalCopy) {\n                final String originalLetterAsString =\n                        codePointToString(originalLetter);\n\n                if (doNotEncodeMap.containsKey(originalLetter)) {\n                    originalToEncoded.put(originalLetter,\n                            originalLetterAsString);\n                    encodedToOriginal.put(originalLetterAsString,\n                            originalLetterAsString);\n                } else {\n                    Integer next = it.next();\n\n                    while (doNotEncodeCopy.contains(next)) {\n                        next = it.next();\n                    }\n\n                    final String encodedLetter = codePointToString(next);\n\n                    originalToEncoded.put(originalLetter, encodedLetter);\n                    encodedToOriginal.put(encodedLetter,\n                            originalLetterAsString);\n                }\n            }\n\n            return new AlphabetConverter(originalToEncoded,\n                    encodedToOriginal,\n                    encodedLetterLength);\n\n        }\n        if (encodingCopy.size() - doNotEncodeCopy.size() < 2) {\n            throw new IllegalArgumentException(\n                    \"Must have at least two encoding characters (excluding \"\n                            + \"those in the 'do not encode' list), but has \"\n                            + (encodingCopy.size() - doNotEncodeCopy.size()));\n        }\n        // we start with one which is our minimum, and because we do the\n        // first division outside the loop\n        int lettersSoFar = 1;\n\n        // the first division takes into account that the doNotEncode\n        // letters can't be in the leftmost place\n        int lettersLeft = (originalCopy.size() - doNotEncodeCopy.size())\n                / (encodingCopy.size() - doNotEncodeCopy.size());\n\n        while (lettersLeft / encodingCopy.size() >= 1) {\n            lettersLeft = lettersLeft / encodingCopy.size();\n            lettersSoFar++;\n        }\n\n        encodedLetterLength = lettersSoFar + 1;\n\n        final AlphabetConverter ac =\n                new AlphabetConverter(originalToEncoded,\n                        encodedToOriginal,\n                        encodedLetterLength);\n\n        ac.addSingleEncoding(encodedLetterLength,\n                StringUtils.EMPTY,\n                encodingCopy,\n                originalCopy.iterator(),\n                doNotEncodeMap);\n\n        return ac;\n    }\n\n    /**\n     * Creates an alphabet converter, for converting from the original alphabet,\n     * to the encoded alphabet, while leaving the characters in\n     * <em>doNotEncode</em> as they are (if possible).\n     *\n     * <p>Duplicate letters in either original or encoding will be ignored.</p>\n     *\n     * @param original an array of chars representing the original alphabet\n     * @param encoding an array of chars representing the alphabet to be used\n     *                 for encoding\n     * @param doNotEncode an array of chars to be encoded using the original\n     *                    alphabet - every char here must appear in\n     *                    both the previous params\n     * @return The AlphabetConverter\n     * @throws IllegalArgumentException if an AlphabetConverter cannot be\n     *                                  constructed\n     */\n    public static AlphabetConverter createConverterFromChars(\n            final Character[] original,\n            final Character[] encoding,\n            final Character[] doNotEncode) {\n        return AlphabetConverter.createConverter(\n                convertCharsToIntegers(original),\n                convertCharsToIntegers(encoding),\n                convertCharsToIntegers(doNotEncode));\n    }\n\n    /**\n     * Creates a new converter from a map.\n     *\n     * @param originalToEncoded a map returned from getOriginalToEncoded()\n     * @return The reconstructed AlphabetConverter\n     * @see AlphabetConverter#getOriginalToEncoded()\n     */\n    public static AlphabetConverter createConverterFromMap(final Map<Integer, String> originalToEncoded) {\n        final Map<Integer, String> unmodifiableOriginalToEncoded = Collections.unmodifiableMap(originalToEncoded);\n        final Map<String, String> encodedToOriginal = new LinkedHashMap<>();\n\n        int encodedLetterLength = 1;\n\n        for (final Entry<Integer, String> e : unmodifiableOriginalToEncoded.entrySet()) {\n            final String originalAsString = codePointToString(e.getKey());\n            encodedToOriginal.put(e.getValue(), originalAsString);\n\n            if (e.getValue().length() > encodedLetterLength) {\n                encodedLetterLength = e.getValue().length();\n            }\n        }\n\n        return new AlphabetConverter(unmodifiableOriginalToEncoded, encodedToOriginal, encodedLetterLength);\n    }\n\n    /**\n     * Original string to be encoded.\n     */\n    private final Map<Integer, String> originalToEncoded;\n\n    /**\n     * Encoding alphabet.\n     */\n    private final Map<String, String> encodedToOriginal;\n\n    /**\n     * Length of the encoded letter.\n     */\n    private final int encodedLetterLength;\n\n    /**\n     * Hidden constructor for alphabet converter. Used by static helper methods.\n     *\n     * @param originalToEncoded original string to be encoded\n     * @param encodedToOriginal encoding alphabet\n     * @param encodedLetterLength length of the encoded letter\n     */\n    private AlphabetConverter(final Map<Integer, String> originalToEncoded,\n                              final Map<String, String> encodedToOriginal,\n                              final int encodedLetterLength) {\n\n        this.originalToEncoded = originalToEncoded;\n        this.encodedToOriginal = encodedToOriginal;\n        this.encodedLetterLength = encodedLetterLength;\n    }\n\n    /**\n     * Recursive method used when creating encoder/decoder.\n     *\n     * @param level at which point it should add a single encoding\n     * @param currentEncoding current encoding\n     * @param encoding letters encoding\n     * @param originals original values\n     * @param doNotEncodeMap map of values that should not be encoded\n     */\n    private void addSingleEncoding(final int level,\n                                   final String currentEncoding,\n                                   final Collection<Integer> encoding,\n                                   final Iterator<Integer> originals,\n                                   final Map<Integer, String> doNotEncodeMap) {\n\n        if (level > 0) {\n            for (final int encodingLetter : encoding) {\n                if (!originals.hasNext()) {\n                    return; // done encoding all the original alphabet\n                }\n                // this skips the doNotEncode chars if they are in the\n                // leftmost place\n                if (level != encodedLetterLength\n                        || !doNotEncodeMap.containsKey(encodingLetter)) {\n                    addSingleEncoding(level - 1,\n                            currentEncoding\n                                    + codePointToString(encodingLetter),\n                            encoding,\n                            originals,\n                            doNotEncodeMap\n                    );\n                }\n            }\n        } else {\n            Integer next = originals.next();\n\n            while (doNotEncodeMap.containsKey(next)) {\n                final String originalLetterAsString = codePointToString(next);\n\n                originalToEncoded.put(next, originalLetterAsString);\n                encodedToOriginal.put(originalLetterAsString,\n                        originalLetterAsString);\n\n                if (!originals.hasNext()) {\n                    return;\n                }\n\n                next = originals.next();\n            }\n\n            final String originalLetterAsString = codePointToString(next);\n\n            originalToEncoded.put(next, currentEncoding);\n            encodedToOriginal.put(currentEncoding, originalLetterAsString);\n        }\n    }\n\n    /**\n     * Decodes a given string.\n     *\n     * @param encoded a string that has been encoded using this\n     *                AlphabetConverter\n     * @return The decoded string, {@code null} if the given string is null\n     * @throws UnsupportedEncodingException if unexpected characters that\n     *                                      cannot be handled are encountered\n     */\n    public String decode(final String encoded)\n            throws UnsupportedEncodingException {\n        if (encoded == null) {\n            return null;\n        }\n\n        final StringBuilder result = new StringBuilder();\n\n        for (int j = 0; j < encoded.length();) {\n            final int i = encoded.codePointAt(j);\n            final String s = codePointToString(i);\n\n            if (s.equals(originalToEncoded.get(i))) {\n                result.append(s);\n                j++; // because we do not encode in Unicode extended the\n                     // length of each encoded char is 1\n            } else {\n                if (j + encodedLetterLength > encoded.length()) {\n                    throw new UnsupportedEncodingException(\"Unexpected end \"\n                            + \"of string while decoding \" + encoded);\n                }\n                final String nextGroup = encoded.substring(j,\n                        j + encodedLetterLength);\n                final String next = encodedToOriginal.get(nextGroup);\n                if (next == null) {\n                    throw new UnsupportedEncodingException(\n                            \"Unexpected string without decoding (\"\n                                    + nextGroup + \") in \" + encoded);\n                }\n                result.append(next);\n                j += encodedLetterLength;\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Encodes a given string.\n     *\n     * @param original the string to be encoded\n     * @return The encoded string, {@code null} if the given string is null\n     * @throws UnsupportedEncodingException if chars that are not supported are\n     *                                      encountered\n     */\n    public String encode(final String original)\n            throws UnsupportedEncodingException {\n        if (original == null) {\n            return null;\n        }\n\n        final StringBuilder sb = new StringBuilder();\n\n        for (int i = 0; i < original.length();) {\n            final int codePoint = original.codePointAt(i);\n\n            final String nextLetter = originalToEncoded.get(codePoint);\n\n            if (nextLetter == null) {\n                throw new UnsupportedEncodingException(\n                        \"Couldn't find encoding for '\"\n                                + codePointToString(codePoint)\n                                + \"' in \"\n                                + original\n                );\n            }\n\n            sb.append(nextLetter);\n\n            i += Character.charCount(codePoint);\n        }\n\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof AlphabetConverter)) {\n            return false;\n        }\n        final AlphabetConverter other = (AlphabetConverter) obj;\n        return originalToEncoded.equals(other.originalToEncoded)\n                && encodedToOriginal.equals(other.encodedToOriginal)\n                && encodedLetterLength == other.encodedLetterLength;\n    }\n\n    /**\n     * Gets the length of characters in the encoded alphabet that are necessary\n     * for each character in the original\n     * alphabet.\n     *\n     * @return The length of the encoded char\n     */\n    public int getEncodedCharLength() {\n        return encodedLetterLength;\n    }\n\n    /**\n     * Gets the mapping from integer code point of source language to encoded\n     * string. Use to reconstruct converter from\n     * serialized map.\n     *\n     * @return The original map\n     */\n    public Map<Integer, String> getOriginalToEncoded() {\n        return Collections.unmodifiableMap(originalToEncoded);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(originalToEncoded,\n                encodedToOriginal,\n                encodedLetterLength);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        // @formatter:off\n        originalToEncoded.forEach((k, v) -> {\n            sb.append(codePointToString(k))\n              .append(ARROW)\n              .append(k)\n              .append(System.lineSeparator());\n        });\n        // @formatter:on\n        return sb.toString();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/AlphabetConverter.java b/src/main/java/org/apache/commons/text/AlphabetConverter.java\nindex 605d32ac4d..1b9138a974 100644\n--- a/src/main/java/org/apache/commons/text/AlphabetConverter.java\n+++ b/src/main/java/org/apache/commons/text/AlphabetConverter.java\n@@ -504,12 +504,10 @@ public int hashCode() {\n     public String toString() {\n         final StringBuilder sb = new StringBuilder();\n         // @formatter:off\n-        originalToEncoded.forEach((k, v) -> {\n-            sb.append(codePointToString(k))\n-              .append(ARROW)\n-              .append(k)\n-              .append(System.lineSeparator());\n-        });\n+        originalToEncoded.forEach((k, v) -> sb.append(codePointToString(k))\n+          .append(ARROW)\n+          .append(k)\n+          .append(System.lineSeparator()));\n         // @formatter:on\n         return sb.toString();\n     }\n"
      }
    ]
  },
  {
    "pr_number": 341,
    "title": "Interpolation Defaults",
    "state": "closed",
    "created_at": "2022-07-16T11:59:41Z",
    "merge_commit_sha": "b9b40b903e2d1f9935039803c9852439576780ea",
    "base_sha": "1f92601a53acb4944311579a8430e30f1e659bb4",
    "head_sha": "365629203dbf46b24278c7d21b5ccfbb7c107f96",
    "user_login": "darkma773r",
    "changed_files": [
      {
        "filename": "src/changes/changes.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/text/StringSubstitutor.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class StringSubstitutorTest2 {\n\n    @Test\n    public void testCreateInterpolatorDefaultLookups() {\n        StringSubstitutor interpolator = StringSubstitutor.createInterpolator();\n        String text = interpolator.replace(\n                \"Base64 Decoder:        ${base64Decoder:SGVsbG9Xb3JsZCE=}\\n\"\n                + \"Base64 Encoder:        ${base64Encoder:HelloWorld!}\\n\"\n                + \"Java Constant:         ${const:java.awt.event.KeyEvent.VK_ESCAPE}\\n\"\n                + \"Date:                  ${date:yyyy-MM-dd}\\n\"\n                + \"Environment Variable:  ${env:USERNAME}\\n\"\n                + \"File Content:          ${file:UTF-8:src/test/resources/document.properties}\\n\"\n                + \"Java:                  ${java:version}\\n\"\n                + \"Localhost:             ${localhost:canonical-name}\\n\"\n                + \"Properties File:       ${properties:src/test/resources/document.properties::mykey}\\n\"\n                + \"Resource Bundle:       ${resourceBundle:org.apache.commons.text.example.testResourceBundleLookup:mykey}\\n\"\n                + \"System Property:       ${sys:user.dir}\\n\"\n                + \"URL Decoder:           ${urlDecoder:Hello%20World%21}\\n\"\n                + \"URL Encoder:           ${urlEncoder:Hello World!}\\n\"\n                + \"XML XPath:             ${xml:src/test/resources/document.xml:/root/path/to/node}\\n\");\n\n        assertThat(text).contains(\"Base64 Decoder:        HelloWorld!\");\n        assertThat(text).contains(\"Base64 Encoder:        SGVsbG9Xb3JsZCE=\");\n        assertThat(text).contains(\"Java Constant:         27\");\n        assertThat(text).contains(\"Date:                  \");\n        assertThat(text).contains(\"Environment Variable:  \");\n        assertThat(text).contains(\"File Content:          \");\n        assertThat(text).contains(\"Java:                  \");\n        assertThat(text).contains(\"Localhost:             \");\n        assertThat(text).contains(\"Properties File:       \");\n        assertThat(text).contains(\"Resource Bundle:       \");\n        assertThat(text).contains(\"System Property:       \");\n        assertThat(text).contains(\"URL Decoder:           Hello World!\");\n        assertThat(text).contains(\"URL Encoder:           Hello%20World%21\");\n        assertThat(text).contains(\"XML XPath:             \");\n    }\n\n    @Test\n    public void testCreateInterpolatorDocumentation() {\n        StringSubstitutor interpolator = StringSubstitutor.createInterpolator();\n        String text = interpolator.replace(\n                \"OS name: ${sys:os.name}, user: ${env:USER}\");\n\n        assertThat(text).contains(\"OS name: \");\n        assertThat(text).contains(\"user: \");\n    }\n\n    @Test\n    public void testDefaultLookupsTable() {\n        StringSubstitutor interpolator = StringSubstitutor.createInterpolator();\n        assertEquals(\"SGVsbG9Xb3JsZCE=\", interpolator.replace(\"${base64Encoder:HelloWorld!}\"));\n        assertEquals(\"HelloWorld!\", interpolator.replace(\"${base64Decoder:SGVsbG9Xb3JsZCE=}\"));\n        assertEquals(\"27\", interpolator.replace(\"${const:java.awt.event.KeyEvent.VK_ESCAPE}\"));\n        assertEquals(\"Hello World!\", interpolator.replace(\"${urlDecoder:Hello%20World%21}\"));\n        assertEquals(\"Hello%20World%21\", interpolator.replace(\"${urlEncoder:Hello World!}\"));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\n\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.text.lookup.StringLookup;\nimport org.apache.commons.text.lookup.StringLookupFactory;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\n\n/**\n * Substitutes variables within a string by values.\n * <p>\n * This class takes a piece of text and substitutes all the variables within it. The default definition of a variable is\n * {@code ${variableName}}. The prefix and suffix can be changed via constructors and set methods.\n * </p>\n * <p>\n * Variable values are typically resolved from a map, but could also be resolved from system properties, or by supplying\n * a custom variable resolver.\n * </p>\n * <h2>Using System Properties</h2>\n * <p>\n * The simplest example is to use this class to replace Java System properties. For example:\n * </p>\n *\n * <pre>\n * StringSubstitutor\n *     .replaceSystemProperties(\"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n * </pre>\n *\n * <h2>Using a Custom Map</h2>\n * <p>\n * Typical usage of this class follows the following pattern:\n * </p>\n * <ul>\n * <li>Create and initialize a StringSubstitutor with the map that contains the values for the variables you want to\n * make available.</li>\n * <li>Optionally set attributes like variable prefix, variable suffix, default value delimiter, and so on.</li>\n * <li>Call the {@code replace()} method with in the source text for interpolation.</li>\n * <li>The returned text contains all variable references (as long as their values are known) as resolved.</li>\n * </ul>\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * // Build map\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n *\n * // Build StringSubstitutor\n * StringSubstitutor sub = new StringSubstitutor(valuesMap);\n *\n * // Replace\n * String resolvedString = sub.replace(templateString);\n * </pre>\n *\n * <p>\n * yielding:\n * </p>\n *\n * <pre>\n * \"The quick brown fox jumped over the lazy dog.\"\n * </pre>\n *\n * <h2>Providing Default Values</h2>\n * <p>\n * You can set a default value for unresolved variables. The default value for a variable can be appended to the\n * variable name after the variable default value delimiter. The default value of the variable default value delimiter\n * is \":-\", as in bash and other *nix shells.\n * </p>\n * <p>\n * You can set the variable value delimiter with {@link #setValueDelimiterMatcher(StringMatcher)},\n * {@link #setValueDelimiter(char)} or {@link #setValueDelimiter(String)}.\n * </p>\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * // Build map\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target} ${undefined.number:-1234567890} times.&quot;;\n *\n * // Build StringSubstitutor\n * StringSubstitutor sub = new StringSubstitutor(valuesMap);\n *\n * // Replace\n * String resolvedString = sub.replace(templateString);\n * </pre>\n *\n * <p>\n * yielding:\n * </p>\n *\n * <pre>\n * \"The quick brown fox jumped over the lazy dog 1234567890 times.\"\n * </pre>\n *\n * <p>\n * {@code StringSubstitutor} supports throwing exceptions for unresolved variables, you enable this by setting calling\n * {@link #setEnableUndefinedVariableException(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Reusing Instances</h2>\n * <p>\n * Static shortcut methods cover the most common use cases. If multiple replace operations are to be performed, creating\n * and reusing an instance of this class will be more efficient.\n * </p>\n *\n * <h2>Using Interpolation</h2>\n * <p>\n * The default interpolator lets you use string lookups like:\n * </p>\n *\n * <pre>\n * final StringSubstitutor interpolator = StringSubstitutor.createInterpolator();\n * interpolator.setEnableSubstitutionInVariables(true); // Allows for nested $'s.\n * final String text = interpolator.replace(\"Base64 Decoder:        ${base64Decoder:SGVsbG9Xb3JsZCE=}\\n\"\n *     + \"Base64 Encoder:        ${base64Encoder:HelloWorld!}\\n\"\n *     + \"Java Constant:         ${const:java.awt.event.KeyEvent.VK_ESCAPE}\\n\"\n *     + \"Date:                  ${date:yyyy-MM-dd}\\n\" + \"DNS:                   ${dns:address|apache.org}\\n\"\n *     + \"Environment Variable:  ${env:USERNAME}\\n\"\n *     + \"File Content:          ${file:UTF-8:src/test/resources/document.properties}\\n\"\n *     + \"Java:                  ${java:version}\\n\" + \"Localhost:             ${localhost:canonical-name}\\n\"\n *     + \"Properties File:       ${properties:src/test/resources/document.properties::mykey}\\n\"\n *     + \"Resource Bundle:       ${resourceBundle:org.apache.commons.text.example.testResourceBundleLookup:mykey}\\n\"\n *     + \"Script:                ${script:javascript:3 + 4}\\n\" + \"System Property:       ${sys:user.dir}\\n\"\n *     + \"URL Decoder:           ${urlDecoder:Hello%20World%21}\\n\"\n *     + \"URL Encoder:           ${urlEncoder:Hello World!}\\n\"\n *     + \"URL Content (HTTP):    ${url:UTF-8:http://www.apache.org}\\n\"\n *     + \"URL Content (HTTPS):   ${url:UTF-8:https://www.apache.org}\\n\"\n *     + \"URL Content (File):    ${url:UTF-8:file:///${sys:user.dir}/src/test/resources/document.properties}\\n\"\n *     + \"XML XPath:             ${xml:src/test/resources/document.xml:/root/path/to/node}\\n\");\n * </pre>\n * <p>\n * For documentation of each lookup, see {@link StringLookupFactory}.\n * </p>\n *\n * <h2>Using Recursive Variable Replacement</h2>\n * <p>\n * Variable replacement can work recursively by calling {@link #setEnableSubstitutionInVariables(boolean)} with\n * {@code true}. If a variable value contains a variable then that variable will also be replaced. Cyclic replacements\n * are detected and will throw an exception.\n * </p>\n * <p>\n * You can get the replace result to contain a variable prefix. For example:\n * </p>\n *\n * <pre>\n * \"The variable ${${name}} must be used.\"\n * </pre>\n *\n * <p>\n * If the value of the \"name\" variable is \"x\", then only the variable \"name\" is replaced resulting in:\n * </p>\n *\n * <pre>\n * \"The variable ${x} must be used.\"\n * </pre>\n *\n * <p>\n * To achieve this effect there are two possibilities: Either set a different prefix and suffix for variables which do\n * not conflict with the result text you want to produce. The other possibility is to use the escape character, by\n * default '$'. If this character is placed before a variable reference, this reference is ignored and won't be\n * replaced. For example:\n * </p>\n *\n * <pre>\n * \"The variable $${${name}} must be used.\"\n * </pre>\n * <p>\n * In some complex scenarios you might even want to perform substitution in the names of variables, for instance\n * </p>\n *\n * <pre>\n * ${jre-${java.specification.version}}\n * </pre>\n *\n * <p>\n * {@code StringSubstitutor} supports this recursive substitution in variable names, but it has to be enabled explicitly\n * by calling {@link #setEnableSubstitutionInVariables(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Thread Safety</h2>\n * <p>\n * This class is <b>not</b> thread safe.\n * </p>\n *\n * @since 1.3\n */\npublic class StringSubstitutor {\n\n    /**\n     * The low-level result of a substitution.\n     *\n     * @since 1.9\n     */\n    private static final class Result {\n\n        /** Whether the buffer is altered. */\n        public final boolean altered;\n\n        /** The length of change. */\n        public final int lengthChange;\n\n        private Result(final boolean altered, final int lengthChange) {\n            this.altered = altered;\n            this.lengthChange = lengthChange;\n        }\n\n        @Override\n        public String toString() {\n            return \"Result [altered=\" + altered + \", lengthChange=\" + lengthChange + \"]\";\n        }\n    }\n\n    /**\n     * Constant for the default escape character.\n     */\n    public static final char DEFAULT_ESCAPE = '$';\n\n    /**\n     * The default variable default separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_DEFAULT = \":-\";\n\n    /**\n     * The default variable end separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_END = \"}\";\n\n    /**\n     * The default variable start separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_START = \"${\";\n\n    /**\n     * Constant for the default variable prefix.\n     */\n    public static final StringMatcher DEFAULT_PREFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_START);\n\n    /**\n     * Constant for the default variable suffix.\n     */\n    public static final StringMatcher DEFAULT_SUFFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_END);\n\n    /**\n     * Constant for the default value delimiter of a variable.\n     */\n    public static final StringMatcher DEFAULT_VALUE_DELIMITER = StringMatcherFactory.INSTANCE\n        .stringMatcher(DEFAULT_VAR_DEFAULT);\n\n    /**\n     * Creates a new instance using the interpolator string lookup\n     * {@link StringLookupFactory#interpolatorStringLookup()}.\n     * <p>\n     * This StringSubstitutor lets you perform substitutions like:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\n     *   \"OS name: ${sys:os.name}, \" + \"3 + 4 = ${script:javascript:3 + 4}\");\n     * </pre>\n     *\n     * @return a new instance using the interpolator string lookup.\n     * @see StringLookupFactory#interpolatorStringLookup()\n     * @since 1.8\n     */\n    public static StringSubstitutor createInterpolator() {\n        return new StringSubstitutor(StringLookupFactory.INSTANCE.interpolatorStringLookup());\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the map.\n     *\n     * @param <V> the type of the values in the map\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueMap the map with the values, may be null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static <V> String replace(final Object source, final Map<String, V> valueMap) {\n        return new StringSubstitutor(valueMap).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the map.\n     * This method allows to specify a custom variable prefix and suffix\n     *\n     * @param <V> the type of the values in the map\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueMap the map with the values, may be null\n     * @param prefix the prefix of variables, not null\n     * @param suffix the suffix of variables, not null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static <V> String replace(final Object source, final Map<String, V> valueMap, final String prefix,\n        final String suffix) {\n        return new StringSubstitutor(valueMap, prefix, suffix).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the\n     * properties.\n     *\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueProperties the properties with values, may be null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static String replace(final Object source, final Properties valueProperties) {\n        if (valueProperties == null) {\n            return source.toString();\n        }\n        final Map<String, String> valueMap = new HashMap<>();\n        final Enumeration<?> propNames = valueProperties.propertyNames();\n        while (propNames.hasMoreElements()) {\n            final String propName = String.valueOf(propNames.nextElement());\n            final String propValue = valueProperties.getProperty(propName);\n            valueMap.put(propName, propValue);\n        }\n        return StringSubstitutor.replace(source, valueMap);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the system\n     * properties.\n     *\n     * @param source the source text containing the variables to substitute, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static String replaceSystemProperties(final Object source) {\n        return new StringSubstitutor(StringLookupFactory.INSTANCE.systemPropertyStringLookup()).replace(source);\n    }\n\n    /**\n     * The flag whether substitution in variable values is disabled.\n     */\n    private boolean disableSubstitutionInValues;\n\n    /**\n     * The flag whether substitution in variable names is enabled.\n     */\n    private boolean enableSubstitutionInVariables;\n\n    /**\n     * The flag whether exception should be thrown on undefined variable.\n     */\n    private boolean enableUndefinedVariableException;\n\n    /**\n     * Stores the escape character.\n     */\n    private char escapeChar;\n\n    /**\n     * Stores the variable prefix.\n     */\n    private StringMatcher prefixMatcher;\n\n    /**\n     * Whether escapes should be preserved. Default is false;\n     */\n    private boolean preserveEscapes;\n\n    /**\n     * Stores the variable suffix.\n     */\n    private StringMatcher suffixMatcher;\n\n    /**\n     * Stores the default variable value delimiter.\n     */\n    private StringMatcher valueDelimiterMatcher;\n\n    /**\n     * Variable resolution is delegated to an implementor of {@link StringLookup}.\n     */\n    private StringLookup variableResolver;\n\n    /**\n     * Creates a new instance with defaults for variable prefix and suffix and the escaping character.\n     */\n    public StringSubstitutor() {\n        this((StringLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses defaults for variable prefix and suffix and the escaping\n     * character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses a default escaping character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n        final char escape) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiter the variable default value delimiter, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n        final char escape, final String valueDelimiter) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape, valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     */\n    public StringSubstitutor(final StringLookup variableResolver) {\n        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,\n        final char escape) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiter the variable default value delimiter string, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,\n        final char escape, final String valueDelimiter) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiter(valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefixMatcher the prefix for variables, not null\n     * @param suffixMatcher the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,\n        final StringMatcher suffixMatcher, final char escape) {\n        this(variableResolver, prefixMatcher, suffixMatcher, escape, DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefixMatcher the prefix for variables, not null\n     * @param suffixMatcher the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiterMatcher the variable default value delimiter matcher, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,\n        final StringMatcher suffixMatcher, final char escape, final StringMatcher valueDelimiterMatcher) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefixMatcher(prefixMatcher);\n        this.setVariableSuffixMatcher(suffixMatcher);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(valueDelimiterMatcher);\n    }\n\n    /**\n     * Creates a new instance based on the given StringSubstitutor.\n     *\n     * @param other The StringSubstitutor used as the source.\n     * @since 1.9\n     */\n    public StringSubstitutor(final StringSubstitutor other) {\n        disableSubstitutionInValues = other.isDisableSubstitutionInValues();\n        enableSubstitutionInVariables = other.isEnableSubstitutionInVariables();\n        enableUndefinedVariableException = other.isEnableUndefinedVariableException();\n        escapeChar = other.getEscapeChar();\n        prefixMatcher = other.getVariablePrefixMatcher();\n        preserveEscapes = other.isPreserveEscapes();\n        suffixMatcher = other.getVariableSuffixMatcher();\n        valueDelimiterMatcher = other.getValueDelimiterMatcher();\n        variableResolver = other.getStringLookup();\n    }\n\n    /**\n     * Checks if the specified variable is already in the stack (list) of variables.\n     *\n     * @param varName the variable name to check\n     * @param priorVariables the list of prior variables\n     */\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\n        if (!priorVariables.contains(varName)) {\n            return;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(256);\n        buf.append(\"Infinite loop in property interpolation of \");\n        buf.append(priorVariables.remove(0));\n        buf.append(\": \");\n        buf.appendWithSeparators(priorVariables, \"->\");\n        throw new IllegalStateException(buf.toString());\n    }\n\n    // Escape\n    /**\n     * Returns the escape character.\n     *\n     * @return The character used for escaping variable references\n     */\n    public char getEscapeChar() {\n        return this.escapeChar;\n    }\n\n    /**\n     * Gets the StringLookup that is used to lookup variables.\n     *\n     * @return The StringLookup\n     */\n    public StringLookup getStringLookup() {\n        return this.variableResolver;\n    }\n\n    /**\n     * Gets the variable default value delimiter matcher currently in use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\n     * value delimiter matches.\n     * </p>\n     * <p>\n     * If it returns null, then the variable default value resolution is disabled.\n     *\n     * @return The variable default value delimiter matcher in use, may be null\n     */\n    public StringMatcher getValueDelimiterMatcher() {\n        return valueDelimiterMatcher;\n    }\n\n    /**\n     * Gets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This prefix is\n     * expressed in terms of a matcher allowing advanced prefix matches.\n     * </p>\n     *\n     * @return The prefix matcher in use\n     */\n    public StringMatcher getVariablePrefixMatcher() {\n        return prefixMatcher;\n    }\n\n    /**\n     * Gets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed\n     * in terms of a matcher allowing advanced suffix matches.\n     * </p>\n     *\n     * @return The suffix matcher in use\n     */\n    public StringMatcher getVariableSuffixMatcher() {\n        return suffixMatcher;\n    }\n\n    /**\n     * Returns a flag whether substitution is disabled in variable values.If set to <b>true</b>, the values of variables\n     * can contain other variables will not be processed and substituted original variable is evaluated, e.g.\n     *\n     * <pre>\n     * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n     * valuesMap.put(&quot;name&quot;, &quot;Douglas ${surname}&quot;);\n     * valuesMap.put(&quot;surname&quot;, &quot;Crockford&quot;);\n     * String templateString = &quot;Hi ${name}&quot;;\n     * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n     * String resolvedString = sub.replace(templateString);\n     * </pre>\n     *\n     * yielding:\n     *\n     * <pre>\n     *      Hi Douglas ${surname}\n     * </pre>\n     *\n     * @return The substitution in variable values flag\n     */\n    public boolean isDisableSubstitutionInValues() {\n        return disableSubstitutionInValues;\n    }\n\n    /**\n     * Returns a flag whether substitution is done in variable names.\n     *\n     * @return The substitution in variable names flag\n     */\n    public boolean isEnableSubstitutionInVariables() {\n        return enableSubstitutionInVariables;\n    }\n\n    /**\n     * Returns a flag whether exception can be thrown upon undefined variable.\n     *\n     * @return The fail on undefined variable flag\n     */\n    public boolean isEnableUndefinedVariableException() {\n        return enableUndefinedVariableException;\n    }\n\n    /**\n     * Returns the flag controlling whether escapes are preserved during substitution.\n     *\n     * @return The preserve escape flag\n     */\n    public boolean isPreserveEscapes() {\n        return preserveEscapes;\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * array as a template. The array is not altered by this method.\n     *\n     * @param source the character array to replace in, not altered, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final char[] source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source.length).append(source);\n        substitute(buf, 0, source.length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * array as a template. The array is not altered by this method.\n     * <p>\n     * Only the specified portion of the array will be processed. The rest of the array is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the character array to replace in, not altered, null returns null\n     * @param offset the start offset within the array, must be valid\n     * @param length the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     * @throws StringIndexOutOfBoundsException if {@code offset} is not in the\n     *  range {@code 0 <= offset <= chars.length}\n     * @throws StringIndexOutOfBoundsException if {@code length < 0}\n     * @throws StringIndexOutOfBoundsException if {@code offset + length > chars.length}\n     */\n    public String replace(final char[] source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as\n     * a template. The source is not altered by this method.\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final CharSequence source) {\n        if (source == null) {\n            return null;\n        }\n        return replace(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as\n     * a template. The source is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @param offset the start offset within the array, must be valid\n     * @param length the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final CharSequence source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source.toString(), offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the\n     * resolver. The input source object is converted to a string using {@code toString} and is not altered.\n     *\n     * @param source the source to replace in, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public String replace(final Object source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder().append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * string as a template.\n     *\n     * @param source the string to replace in, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final String source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source);\n        if (!substitute(buf, 0, source.length())) {\n            return source;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * string as a template.\n     * <p>\n     * Only the specified portion of the string will be processed. The rest of the string is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the string to replace in, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     * @throws StringIndexOutOfBoundsException if {@code offset} is not in the\n     *  range {@code 0 <= offset <= source.length()}\n     * @throws StringIndexOutOfBoundsException if {@code length < 0}\n     * @throws StringIndexOutOfBoundsException if {@code offset + length > source.length()}\n     */\n    public String replace(final String source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return source.substring(offset, offset + length);\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * buffer as a template. The buffer is not altered by this method.\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final StringBuffer source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source.length()).append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * buffer as a template. The buffer is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * builder as a template. The builder is not altered by this method.\n     *\n     * @param source the builder to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final TextStringBuilder source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder builder = new TextStringBuilder(source.length()).append(source);\n        substitute(builder, 0, builder.length());\n        return builder.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * builder as a template. The builder is not altered by this method.\n     * <p>\n     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the builder to use as a template, not changed, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final TextStringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuffer source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver. The builder is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final StringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver.\n     *\n     * @param source the builder to replace in, updated, null returns zero\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final TextStringBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver.\n     * <p>\n     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the builder to replace in, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final TextStringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, offset, length);\n    }\n\n    /**\n     * Internal method that resolves the value of a variable.\n     * <p>\n     * Most users of this class do not need to call this method. This method is called automatically by the substitution\n     * process.\n     * </p>\n     * <p>\n     * Writers of subclasses can override this method if they need to alter how each substitution occurs. The method is\n     * passed the variable's name and must return the corresponding value. This implementation uses the\n     * {@link #getStringLookup()} with the variable's name as the key.\n     * </p>\n     *\n     * @param variableName the name of the variable, not null\n     * @param buf the buffer where the substitution is occurring, not null\n     * @param startPos the start position of the variable including the prefix, valid\n     * @param endPos the end position of the variable including the suffix, valid\n     * @return The variable's value or <b>null</b> if the variable is unknown\n     */\n    protected String resolveVariable(final String variableName, final TextStringBuilder buf, final int startPos,\n        final int endPos) {\n        final StringLookup resolver = getStringLookup();\n        if (resolver == null) {\n            return null;\n        }\n        return resolver.lookup(variableName);\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable values (recursive).\n     *\n     * @param disableSubstitutionInValues true if substitution in variable value are disabled\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setDisableSubstitutionInValues(final boolean disableSubstitutionInValues) {\n        this.disableSubstitutionInValues = disableSubstitutionInValues;\n        return this;\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable names. If set to <b>true</b>, the names of variables can\n     * contain other variables which are processed first before the original variable is evaluated, e.g.\n     * {@code ${jre-${java.version}}}. The default value is <b>false</b>.\n     *\n     * @param enableSubstitutionInVariables the new value of the flag\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {\n        this.enableSubstitutionInVariables = enableSubstitutionInVariables;\n        return this;\n    }\n\n    /**\n     * Sets a flag whether exception should be thrown if any variable is undefined.\n     *\n     * @param failOnUndefinedVariable true if exception should be thrown on undefined variable\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEnableUndefinedVariableException(final boolean failOnUndefinedVariable) {\n        this.enableUndefinedVariableException = failOnUndefinedVariable;\n        return this;\n    }\n\n    /**\n     * Sets the escape character. If this character is placed before a variable reference in the source text, this\n     * variable will be ignored.\n     *\n     * @param escapeCharacter the escape character (0 for disabling escaping)\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEscapeChar(final char escapeCharacter) {\n        this.escapeChar = escapeCharacter;\n        return this;\n    }\n\n    /**\n     * Sets a flag controlling whether escapes are preserved during substitution. If set to <b>true</b>, the escape\n     * character is retained during substitution (e.g. {@code $${this-is-escaped}} remains {@code $${this-is-escaped}}).\n     * If set to <b>false</b>, the escape character is removed during substitution (e.g. {@code $${this-is-escaped}}\n     * becomes {@code ${this-is-escaped}}). The default value is <b>false</b>\n     *\n     * @param preserveEscapes true if escapes are to be preserved\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setPreserveEscapes(final boolean preserveEscapes) {\n        this.preserveEscapes = preserveEscapes;\n        return this;\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This method allows a single character variable default value delimiter to be easily set.\n     * </p>\n     *\n     * @param valueDelimiter the variable default value delimiter character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiter(final char valueDelimiter) {\n        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.charMatcher(valueDelimiter));\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This method allows a string variable default value delimiter to be easily set.\n     * </p>\n     * <p>\n     * If the {@code valueDelimiter} is null or empty string, then the variable default value resolution becomes\n     * disabled.\n     * </p>\n     *\n     * @param valueDelimiter the variable default value delimiter string to use, may be null or empty\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiter(final String valueDelimiter) {\n        if (valueDelimiter == null || valueDelimiter.isEmpty()) {\n            setValueDelimiterMatcher(null);\n            return this;\n        }\n        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.stringMatcher(valueDelimiter));\n    }\n\n    /**\n     * Sets the variable default value delimiter matcher to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\n     * value delimiter matches.\n     * </p>\n     * <p>\n     * If the {@code valueDelimiterMatcher} is null, then the variable default value resolution becomes disabled.\n     * </p>\n     *\n     * @param valueDelimiterMatcher variable default value delimiter matcher to use, may be null\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiterMatcher(final StringMatcher valueDelimiterMatcher) {\n        this.valueDelimiterMatcher = valueDelimiterMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This method allows a\n     * single character prefix to be easily set.\n     * </p>\n     *\n     * @param prefix the prefix character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariablePrefix(final char prefix) {\n        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.charMatcher(prefix));\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This method allows a\n     * string prefix to be easily set.\n     * </p>\n     *\n     * @param prefix the prefix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix is null\n     */\n    public StringSubstitutor setVariablePrefix(final String prefix) {\n        Validate.isTrue(prefix != null, \"Variable prefix must not be null!\");\n        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(prefix));\n    }\n\n    /**\n     * Sets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This prefix is\n     * expressed in terms of a matcher allowing advanced prefix matches.\n     * </p>\n     *\n     * @param prefixMatcher the prefix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix matcher is null\n     */\n    public StringSubstitutor setVariablePrefixMatcher(final StringMatcher prefixMatcher) {\n        Validate.isTrue(prefixMatcher != null, \"Variable prefix matcher must not be null!\");\n        this.prefixMatcher = prefixMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the VariableResolver that is used to lookup variables.\n     *\n     * @param variableResolver the VariableResolver\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariableResolver(final StringLookup variableResolver) {\n        this.variableResolver = variableResolver;\n        return this;\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This method allows a\n     * single character suffix to be easily set.\n     * </p>\n     *\n     * @param suffix the suffix character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariableSuffix(final char suffix) {\n        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.charMatcher(suffix));\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This method allows a\n     * string suffix to be easily set.\n     * </p>\n     *\n     * @param suffix the suffix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix is null\n     */\n    public StringSubstitutor setVariableSuffix(final String suffix) {\n        Validate.isTrue(suffix != null, \"Variable suffix must not be null!\");\n        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(suffix));\n    }\n\n    /**\n     * Sets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed\n     * in terms of a matcher allowing advanced suffix matches.\n     * </p>\n     *\n     * @param suffixMatcher the suffix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix matcher is null\n     */\n    public StringSubstitutor setVariableSuffixMatcher(final StringMatcher suffixMatcher) {\n        Validate.isTrue(suffixMatcher != null, \"Variable suffix matcher must not be null!\");\n        this.suffixMatcher = suffixMatcher;\n        return this;\n    }\n\n    /**\n     * Internal method that substitutes the variables.\n     * <p>\n     * Most users of this class do not need to call this method. This method will be called automatically by another\n     * (public) method.\n     * </p>\n     * <p>\n     * Writers of subclasses can override this method if they need access to the substitution process at the start or\n     * end.\n     * </p>\n     *\n     * @param builder the string builder to substitute into, not null\n     * @param offset the start offset within the builder, must be valid\n     * @param length the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    protected boolean substitute(final TextStringBuilder builder, final int offset, final int length) {\n        return substitute(builder, offset, length, null).altered;\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation. This is the main interpolation method, which resolves the\n     * values of all variable references contained in the passed in text.\n     *\n     * @param builder the string builder to substitute into, not null\n     * @param offset the start offset within the builder, must be valid\n     * @param length the length within the builder to be processed, must be valid\n     * @param priorVariables the stack keeping track of the replaced variables, may be null\n     * @return The result.\n     * @throws IllegalArgumentException if variable is not found and <pre>isEnableUndefinedVariableException()==true</pre>\n     * @since 1.9\n     */\n    private Result substitute(final TextStringBuilder builder, final int offset, final int length,\n        List<String> priorVariables) {\n        Objects.requireNonNull(builder, \"builder\");\n        final StringMatcher prefixMatcher = getVariablePrefixMatcher();\n        final StringMatcher suffixMatcher = getVariableSuffixMatcher();\n        final char escapeCh = getEscapeChar();\n        final StringMatcher valueDelimMatcher = getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n        final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues();\n        final boolean undefinedVariableException = isEnableUndefinedVariableException();\n        final boolean preserveEscapes = isPreserveEscapes();\n\n        boolean altered = false;\n        int lengthChange = 0;\n        int bufEnd = offset + length;\n        int pos = offset;\n        int escPos = -1;\n        outer: while (pos < bufEnd) {\n            final int startMatchLen = prefixMatcher.isMatch(builder, pos, offset, bufEnd);\n            if (startMatchLen == 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos > offset && builder.charAt(pos - 1) == escapeCh) {\n                    // escape detected\n                    if (preserveEscapes) {\n                        // keep escape\n                        pos++;\n                        continue;\n                    }\n                    // mark esc ch for deletion if we find a complete variable\n                    escPos = pos - 1;\n                }\n                // find suffix\n                int startPos = pos;\n                pos += startMatchLen;\n                int endMatchLen = 0;\n                int nestedVarCount = 0;\n                while (pos < bufEnd) {\n                    if (substitutionInVariablesEnabled && prefixMatcher.isMatch(builder, pos, offset, bufEnd) != 0) {\n                        // found a nested variable start\n                        endMatchLen = prefixMatcher.isMatch(builder, pos, offset, bufEnd);\n                        nestedVarCount++;\n                        pos += endMatchLen;\n                        continue;\n                    }\n\n                    endMatchLen = suffixMatcher.isMatch(builder, pos, offset, bufEnd);\n                    if (endMatchLen == 0) {\n                        pos++;\n                    } else {\n                        // found variable end marker\n                        if (nestedVarCount == 0) {\n                            if (escPos >= 0) {\n                                // delete escape\n                                builder.deleteCharAt(escPos);\n                                escPos = -1;\n                                lengthChange--;\n                                altered = true;\n                                bufEnd--;\n                                pos = startPos + 1;\n                                startPos--;\n                                continue outer;\n                            }\n                            // get var name\n                            String varNameExpr = builder.midString(startPos + startMatchLen,\n                                pos - startPos - startMatchLen);\n                            if (substitutionInVariablesEnabled) {\n                                final TextStringBuilder bufName = new TextStringBuilder(varNameExpr);\n                                substitute(bufName, 0, bufName.length());\n                                varNameExpr = bufName.toString();\n                            }\n                            pos += endMatchLen;\n                            final int endPos = pos;\n\n                            String varName = varNameExpr;\n                            String varDefaultValue = null;\n\n                            if (valueDelimMatcher != null) {\n                                final char[] varNameExprChars = varNameExpr.toCharArray();\n                                int valueDelimiterMatchLen = 0;\n                                for (int i = 0; i < varNameExprChars.length; i++) {\n                                    // if there's any nested variable when nested variable substitution disabled,\n                                    // then stop resolving name and default value.\n                                    if (!substitutionInVariablesEnabled && prefixMatcher.isMatch(varNameExprChars, i, i,\n                                        varNameExprChars.length) != 0) {\n                                        break;\n                                    }\n                                    if (valueDelimMatcher.isMatch(varNameExprChars, i, 0,\n                                        varNameExprChars.length) != 0) {\n                                        valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i, 0,\n                                            varNameExprChars.length);\n                                        varName = varNameExpr.substring(0, i);\n                                        varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                        break;\n                                    }\n                                }\n                            }\n\n                            // on the first call initialize priorVariables\n                            if (priorVariables == null) {\n                                priorVariables = new ArrayList<>();\n                                priorVariables.add(builder.midString(offset, length));\n                            }\n\n                            // handle cyclic substitution\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n\n                            // resolve the variable\n                            String varValue = resolveVariable(varName, builder, startPos, endPos);\n                            if (varValue == null) {\n                                varValue = varDefaultValue;\n                            }\n                            if (varValue != null) {\n                                final int varLen = varValue.length();\n                                builder.replace(startPos, endPos, varValue);\n                                altered = true;\n                                int change = 0;\n                                if (!substitutionInValuesDisabled) { // recursive replace\n                                    change = substitute(builder, startPos, varLen, priorVariables).lengthChange;\n                                }\n                                change = change + varLen - (endPos - startPos);\n                                pos += change;\n                                bufEnd += change;\n                                lengthChange += change;\n                            } else if (undefinedVariableException) {\n                                throw new IllegalArgumentException(\n                                    String.format(\"Cannot resolve variable '%s' (enableSubstitutionInVariables=%s).\",\n                                        varName, substitutionInVariablesEnabled));\n                            }\n\n                            // remove variable from the cyclic stack\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                        nestedVarCount--;\n                        pos += endMatchLen;\n                    }\n                }\n            }\n        }\n        return new Result(altered, lengthChange);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/StringSubstitutor.java b/src/main/java/org/apache/commons/text/StringSubstitutor.java\nindex 496727501d..3b1e4cb777 100644\n--- a/src/main/java/org/apache/commons/text/StringSubstitutor.java\n+++ b/src/main/java/org/apache/commons/text/StringSubstitutor.java\n@@ -141,26 +141,28 @@\n  *\n  * <pre>\n  * final StringSubstitutor interpolator = StringSubstitutor.createInterpolator();\n- * interpolator.setEnableSubstitutionInVariables(true); // Allows for nested $'s.\n- * final String text = interpolator.replace(\"Base64 Decoder:        ${base64Decoder:SGVsbG9Xb3JsZCE=}\\n\"\n+ * final String text = interpolator.replace(\n+ *       \"Base64 Decoder:        ${base64Decoder:SGVsbG9Xb3JsZCE=}\\n\"\n  *     + \"Base64 Encoder:        ${base64Encoder:HelloWorld!}\\n\"\n  *     + \"Java Constant:         ${const:java.awt.event.KeyEvent.VK_ESCAPE}\\n\"\n- *     + \"Date:                  ${date:yyyy-MM-dd}\\n\" + \"DNS:                   ${dns:address|apache.org}\\n\"\n+ *     + \"Date:                  ${date:yyyy-MM-dd}\\n\"\n  *     + \"Environment Variable:  ${env:USERNAME}\\n\"\n  *     + \"File Content:          ${file:UTF-8:src/test/resources/document.properties}\\n\"\n- *     + \"Java:                  ${java:version}\\n\" + \"Localhost:             ${localhost:canonical-name}\\n\"\n+ *     + \"Java:                  ${java:version}\\n\"\n+ *     + \"Localhost:             ${localhost:canonical-name}\\n\"\n  *     + \"Properties File:       ${properties:src/test/resources/document.properties::mykey}\\n\"\n  *     + \"Resource Bundle:       ${resourceBundle:org.apache.commons.text.example.testResourceBundleLookup:mykey}\\n\"\n- *     + \"Script:                ${script:javascript:3 + 4}\\n\" + \"System Property:       ${sys:user.dir}\\n\"\n+ *     + \"System Property:       ${sys:user.dir}\\n\"\n  *     + \"URL Decoder:           ${urlDecoder:Hello%20World%21}\\n\"\n  *     + \"URL Encoder:           ${urlEncoder:Hello World!}\\n\"\n- *     + \"URL Content (HTTP):    ${url:UTF-8:http://www.apache.org}\\n\"\n- *     + \"URL Content (HTTPS):   ${url:UTF-8:https://www.apache.org}\\n\"\n- *     + \"URL Content (File):    ${url:UTF-8:file:///${sys:user.dir}/src/test/resources/document.properties}\\n\"\n  *     + \"XML XPath:             ${xml:src/test/resources/document.xml:/root/path/to/node}\\n\");\n  * </pre>\n  * <p>\n- * For documentation of each lookup, see {@link StringLookupFactory}.\n+ * For documentation and a full list of available lookups, see {@link StringLookupFactory}.\n+ * </p>\n+ * <p><strong>NOTE:</strong> The list of lookups available by default in {@link #createInterpolator()} changed\n+ * in version {@code 1.10.0}. See the {@link StringLookupFactory} documentation for details and an explanation\n+ * on how to reproduce the previous functionality.\n  * </p>\n  *\n  * <h2>Using Recursive Variable Replacement</h2>\n@@ -292,9 +294,81 @@ public String toString() {\n      *\n      * <pre>\n      * StringSubstitutor.createInterpolator().replace(\n-     *   \"OS name: ${sys:os.name}, \" + \"3 + 4 = ${script:javascript:3 + 4}\");\n+     *   \"OS name: ${sys:os.name}, user: ${env:USER}\");\n      * </pre>\n      *\n+     * <p>The table below lists the lookups available by default in the returned instance. These\n+     * may be modified through the use of the {@value StringLookupFactory#DEFAULT_STRING_LOOKUPS_PROPERTY}\n+     * system property, as described in the {@link StringLookupFactory} documentation.</p>\n+     *\n+     * <p><strong>NOTE:</strong> The list of lookups available by default changed in version {@code 1.10.0}.\n+     * Configuration via system property (as mentioned above) may be necessary to reproduce previous functionality.\n+     * </p>\n+     *\n+     * <table>\n+     * <caption>Default Lookups</caption>\n+     * <tr>\n+     * <th>Key</th>\n+     * <th>Lookup</th>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_BASE64_DECODER}</td>\n+     * <td>{@link StringLookupFactory#base64DecoderStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_BASE64_ENCODER}</td>\n+     * <td>{@link StringLookupFactory#base64EncoderStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_CONST}</td>\n+     * <td>{@link StringLookupFactory#constantStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_DATE}</td>\n+     * <td>{@link StringLookupFactory#dateStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_ENV}</td>\n+     * <td>{@link StringLookupFactory#environmentVariableStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_FILE}</td>\n+     * <td>{@link StringLookupFactory#fileStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_JAVA}</td>\n+     * <td>{@link StringLookupFactory#javaPlatformStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_LOCALHOST}</td>\n+     * <td>{@link StringLookupFactory#localHostStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_PROPERTIES}</td>\n+     * <td>{@link StringLookupFactory#propertiesStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_RESOURCE_BUNDLE}</td>\n+     * <td>{@link StringLookupFactory#resourceBundleStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_SYS}</td>\n+     * <td>{@link StringLookupFactory#systemPropertyStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_URL_DECODER}</td>\n+     * <td>{@link StringLookupFactory#urlDecoderStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_URL_ENCODER}</td>\n+     * <td>{@link StringLookupFactory#urlEncoderStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value StringLookupFactory#KEY_XML}</td>\n+     * <td>{@link StringLookupFactory#xmlStringLookup()}</td>\n+     * </tr>\n+     * </table>\n+     *\n      * @return a new instance using the interpolator string lookup.\n      * @see StringLookupFactory#interpolatorStringLookup()\n      * @since 1.8\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for the DefaultStringLookup enum.\n * This class specifically tests the changes introduced in the latest update.\n */\npublic class DefaultStringLookupTest2 {\n\n    /**\n     * Tests that the keys of the DefaultStringLookup enum match the expected values.\n     */\n    @Test\n    public void testEnumKeys() {\n        assertEquals(\"base64Decoder\", DefaultStringLookup.BASE64_DECODER.getKey());\n        assertEquals(\"base64Encoder\", DefaultStringLookup.BASE64_ENCODER.getKey());\n        assertEquals(\"const\", DefaultStringLookup.CONST.getKey());\n        assertEquals(\"date\", DefaultStringLookup.DATE.getKey());\n        assertEquals(\"dns\", DefaultStringLookup.DNS.getKey());\n        assertEquals(\"env\", DefaultStringLookup.ENVIRONMENT.getKey());\n        assertEquals(\"file\", DefaultStringLookup.FILE.getKey());\n        assertEquals(\"java\", DefaultStringLookup.JAVA.getKey());\n        assertEquals(\"localhost\", DefaultStringLookup.LOCAL_HOST.getKey());\n        assertEquals(\"properties\", DefaultStringLookup.PROPERTIES.getKey());\n        assertEquals(\"resourceBundle\", DefaultStringLookup.RESOURCE_BUNDLE.getKey());\n        assertEquals(\"script\", DefaultStringLookup.SCRIPT.getKey());\n        assertEquals(\"sys\", DefaultStringLookup.SYSTEM_PROPERTIES.getKey());\n        assertEquals(\"url\", DefaultStringLookup.URL.getKey());\n        assertEquals(\"urlDecoder\", DefaultStringLookup.URL_DECODER.getKey());\n        assertEquals(\"urlEncoder\", DefaultStringLookup.URL_ENCODER.getKey());\n        assertEquals(\"xml\", DefaultStringLookup.XML.getKey());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.lookup;\n\nimport java.util.stream.Stream;\n\n/**\n * An enumeration defining {@link StringLookup} objects available through {@link StringLookupFactory}.\n * <p>\n * This enum was adapted and expanded from Apache Commons Configuration 2.4.\n * </p>\n *\n * @see StringLookupFactory\n * @see StringLookup\n * @since 1.7\n */\npublic enum DefaultStringLookup {\n\n    /**\n     * The lookup for Base64 decoding using the key {@value StringLookupFactory#KEY_BASE64_DECODER}.\n     */\n    BASE64_DECODER(StringLookupFactory.KEY_BASE64_DECODER, StringLookupFactory.INSTANCE.base64DecoderStringLookup()),\n\n    /**\n     * The lookup for Base64 decoding using the key {@value StringLookupFactory#KEY_BASE64_ENCODER}.\n     */\n    BASE64_ENCODER(StringLookupFactory.KEY_BASE64_ENCODER, StringLookupFactory.INSTANCE.base64EncoderStringLookup()),\n\n    /**\n     * The lookup for constants using the key {@value StringLookupFactory#KEY_CONST}.\n     */\n    CONST(StringLookupFactory.KEY_CONST, StringLookupFactory.INSTANCE.constantStringLookup()),\n\n    /**\n     * The lookup for dates using the key {@value StringLookupFactory#KEY_DATE}.\n     */\n    DATE(StringLookupFactory.KEY_DATE, StringLookupFactory.INSTANCE.dateStringLookup()),\n\n    /**\n     * The lookup for DNS using the key {@value StringLookupFactory#KEY_DNS}.\n     *\n     * @since 1.8\n     */\n    DNS(StringLookupFactory.KEY_DNS, StringLookupFactory.INSTANCE.dnsStringLookup()),\n\n    /**\n     * The lookup for environment properties using the key {@value StringLookupFactory#KEY_ENV}.\n     */\n    ENVIRONMENT(StringLookupFactory.KEY_ENV, StringLookupFactory.INSTANCE.environmentVariableStringLookup()),\n\n    /**\n     * The lookup for files using the key {@value StringLookupFactory#KEY_FILE}.\n     */\n    FILE(StringLookupFactory.KEY_FILE, StringLookupFactory.INSTANCE.fileStringLookup()),\n\n    /**\n     * The lookup for Java platform information using the key {@value StringLookupFactory#KEY_JAVA}.\n     */\n    JAVA(StringLookupFactory.KEY_JAVA, StringLookupFactory.INSTANCE.javaPlatformStringLookup()),\n\n    /**\n     * The lookup for localhost information using the key {@value StringLookupFactory#KEY_LOCALHOST}.\n     */\n    LOCAL_HOST(StringLookupFactory.KEY_LOCALHOST, StringLookupFactory.INSTANCE.localHostStringLookup()),\n\n    /**\n     * The lookup for properties using the key {@value StringLookupFactory#KEY_PROPERTIES}.\n     */\n    PROPERTIES(StringLookupFactory.KEY_PROPERTIES, StringLookupFactory.INSTANCE.propertiesStringLookup()),\n\n    /**\n     * The lookup for resource bundles using the key {@value StringLookupFactory#KEY_RESOURCE_BUNDLE}.\n     */\n    RESOURCE_BUNDLE(StringLookupFactory.KEY_RESOURCE_BUNDLE, StringLookupFactory.INSTANCE.resourceBundleStringLookup()),\n\n    /**\n     * The lookup for scripts using the key {@value StringLookupFactory#KEY_SCRIPT}.\n     */\n    SCRIPT(StringLookupFactory.KEY_SCRIPT, StringLookupFactory.INSTANCE.scriptStringLookup()),\n\n    /**\n     * The lookup for system properties using the key {@value StringLookupFactory#KEY_SYS}.\n     */\n    SYSTEM_PROPERTIES(StringLookupFactory.KEY_SYS, StringLookupFactory.INSTANCE.systemPropertyStringLookup()),\n\n    /**\n     * The lookup for URLs using the key {@value StringLookupFactory#KEY_URL}.\n     */\n    URL(StringLookupFactory.KEY_URL, StringLookupFactory.INSTANCE.urlStringLookup()),\n\n    /**\n     * The lookup for URL decoding using the key {@value StringLookupFactory#KEY_URL_DECODER}.\n     */\n    URL_DECODER(StringLookupFactory.KEY_URL_DECODER, StringLookupFactory.INSTANCE.urlDecoderStringLookup()),\n\n    /**\n     * The lookup for URL decoding using the key {@value StringLookupFactory#KEY_URL_ENCODER}.\n     */\n    URL_ENCODER(StringLookupFactory.KEY_URL_ENCODER, StringLookupFactory.INSTANCE.urlEncoderStringLookup()),\n\n    /**\n     * The lookup for URL decoding using the key {@value StringLookupFactory#KEY_XML}.\n     */\n    XML(StringLookupFactory.KEY_XML, StringLookupFactory.INSTANCE.xmlStringLookup());\n\n    /**\n     * Prints out to the console the mapping from enum keys to enum name.\n     * @param args ignored.\n     */\n    public static void main(final String[] args) {\n        Stream.of(values()).forEach(e -> System.out.println(e.getKey() + \"=\" + e.name()));\n    }\n\n    /** The prefix under which the associated lookup object is registered. */\n    private final String key;\n\n    /** The associated lookup instance. */\n    private final StringLookup lookup;\n\n    /**\n     * Creates a new instance of {@link DefaultStringLookup} and sets the key and the associated lookup instance.\n     *\n     * @param prefix the prefix\n     * @param lookup the {@link StringLookup} instance\n     */\n    DefaultStringLookup(final String prefix, final StringLookup lookup) {\n        this.key = prefix;\n        this.lookup = lookup;\n    }\n\n    /**\n     * Returns the standard prefix for the lookup object of this kind.\n     *\n     * @return the prefix\n     */\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     * Returns the standard {@link StringLookup} instance of this kind.\n     *\n     * @return the associated {@link StringLookup} object\n     */\n    public StringLookup getStringLookup() {\n        return lookup;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java b/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\nindex ce01c81ea3..c23d97dd4e 100644\n--- a/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\n@@ -16,13 +16,16 @@\n  */\n package org.apache.commons.text.lookup;\n \n-import java.util.stream.Stream;\n-\n /**\n  * An enumeration defining {@link StringLookup} objects available through {@link StringLookupFactory}.\n  * <p>\n  * This enum was adapted and expanded from Apache Commons Configuration 2.4.\n  * </p>\n+ * <p><strong>NOTE:</strong> Starting in version 1.10.0, not all lookups defined in this class are\n+ * included by default in the\n+ * {@link StringLookupFactory#addDefaultStringLookups(java.util.Map) StringLookupFactory.addDefaultStringLookups}\n+ * method. See the {@link StringLookupFactory} class documentation for details.\n+ * </p>\n  *\n  * @see StringLookupFactory\n  * @see StringLookup\n@@ -31,100 +34,125 @@\n public enum DefaultStringLookup {\n \n     /**\n-     * The lookup for Base64 decoding using the key {@value StringLookupFactory#KEY_BASE64_DECODER}.\n+     * The lookup for Base64 decoding using the key {@code \"base64Decoder\"}.\n+     * @see StringLookupFactory#KEY_BASE64_DECODER\n+     * @see StringLookupFactory#base64DecoderStringLookup()\n      */\n     BASE64_DECODER(StringLookupFactory.KEY_BASE64_DECODER, StringLookupFactory.INSTANCE.base64DecoderStringLookup()),\n \n     /**\n-     * The lookup for Base64 decoding using the key {@value StringLookupFactory#KEY_BASE64_ENCODER}.\n+     * The lookup for Base64 decoding using the key {@code \"base64Encoder\"}.\n+     * @see StringLookupFactory#KEY_BASE64_ENCODER\n+     * @see StringLookupFactory#base64EncoderStringLookup()\n      */\n     BASE64_ENCODER(StringLookupFactory.KEY_BASE64_ENCODER, StringLookupFactory.INSTANCE.base64EncoderStringLookup()),\n \n     /**\n-     * The lookup for constants using the key {@value StringLookupFactory#KEY_CONST}.\n+     * The lookup for Java static class member constants using the key {@code \"const\"}.\n+     * @see StringLookupFactory#KEY_CONST\n+     * @see StringLookupFactory#constantStringLookup()\n      */\n     CONST(StringLookupFactory.KEY_CONST, StringLookupFactory.INSTANCE.constantStringLookup()),\n \n     /**\n-     * The lookup for dates using the key {@value StringLookupFactory#KEY_DATE}.\n+     * The lookup for formatting the current date using the key {@code \"date\"}.\n+     * @see StringLookupFactory#KEY_DATE\n+     * @see StringLookupFactory#dateStringLookup()\n      */\n     DATE(StringLookupFactory.KEY_DATE, StringLookupFactory.INSTANCE.dateStringLookup()),\n \n     /**\n-     * The lookup for DNS using the key {@value StringLookupFactory#KEY_DNS}.\n-     *\n+     * The lookup for DNS using the key {@code \"dns\"}.\n+     * @see StringLookupFactory#KEY_DNS\n+     * @see StringLookupFactory#dnsStringLookup()\n      * @since 1.8\n      */\n     DNS(StringLookupFactory.KEY_DNS, StringLookupFactory.INSTANCE.dnsStringLookup()),\n \n     /**\n-     * The lookup for environment properties using the key {@value StringLookupFactory#KEY_ENV}.\n+     * The lookup for environment properties using the key {@code \"env\"}.\n+     * @see StringLookupFactory#KEY_ENV\n+     * @see StringLookupFactory#environmentVariableStringLookup()\n      */\n     ENVIRONMENT(StringLookupFactory.KEY_ENV, StringLookupFactory.INSTANCE.environmentVariableStringLookup()),\n \n     /**\n-     * The lookup for files using the key {@value StringLookupFactory#KEY_FILE}.\n+     * The lookup for files using the key {@code \"file\"}.\n+     * @see StringLookupFactory#KEY_FILE\n+     * @see StringLookupFactory#fileStringLookup()\n      */\n     FILE(StringLookupFactory.KEY_FILE, StringLookupFactory.INSTANCE.fileStringLookup()),\n \n     /**\n-     * The lookup for Java platform information using the key {@value StringLookupFactory#KEY_JAVA}.\n+     * The lookup for Java platform information using the key {@code \"java\"}.\n+     * @see StringLookupFactory#KEY_JAVA\n+     * @see StringLookupFactory#javaPlatformStringLookup()\n      */\n     JAVA(StringLookupFactory.KEY_JAVA, StringLookupFactory.INSTANCE.javaPlatformStringLookup()),\n \n     /**\n-     * The lookup for localhost information using the key {@value StringLookupFactory#KEY_LOCALHOST}.\n+     * The lookup for localhost information using the key {@code \"localhost\"}.\n+     * @see StringLookupFactory#KEY_LOCALHOST\n+     * @see StringLookupFactory#localHostStringLookup()\n      */\n     LOCAL_HOST(StringLookupFactory.KEY_LOCALHOST, StringLookupFactory.INSTANCE.localHostStringLookup()),\n \n     /**\n-     * The lookup for properties using the key {@value StringLookupFactory#KEY_PROPERTIES}.\n+     * The lookup for properties using the key {@code \"properties\"}.\n+     * @see StringLookupFactory#KEY_PROPERTIES\n+     * @see StringLookupFactory#propertiesStringLookup()\n      */\n     PROPERTIES(StringLookupFactory.KEY_PROPERTIES, StringLookupFactory.INSTANCE.propertiesStringLookup()),\n \n     /**\n-     * The lookup for resource bundles using the key {@value StringLookupFactory#KEY_RESOURCE_BUNDLE}.\n+     * The lookup for resource bundles using the key {@code \"resourceBundle\"}.\n+     * @see StringLookupFactory#KEY_RESOURCE_BUNDLE\n+     * @see StringLookupFactory#resourceBundleStringLookup()\n      */\n     RESOURCE_BUNDLE(StringLookupFactory.KEY_RESOURCE_BUNDLE, StringLookupFactory.INSTANCE.resourceBundleStringLookup()),\n \n     /**\n-     * The lookup for scripts using the key {@value StringLookupFactory#KEY_SCRIPT}.\n+     * The lookup for scripts using the key {@code \"script\"}.\n+     * @see StringLookupFactory#KEY_SCRIPT\n+     * @see StringLookupFactory#scriptStringLookup()\n      */\n     SCRIPT(StringLookupFactory.KEY_SCRIPT, StringLookupFactory.INSTANCE.scriptStringLookup()),\n \n     /**\n-     * The lookup for system properties using the key {@value StringLookupFactory#KEY_SYS}.\n+     * The lookup for system properties using the key {@code \"sys\"}.\n+     * @see StringLookupFactory#KEY_SYS\n+     * @see StringLookupFactory#systemPropertyStringLookup()\n      */\n     SYSTEM_PROPERTIES(StringLookupFactory.KEY_SYS, StringLookupFactory.INSTANCE.systemPropertyStringLookup()),\n \n     /**\n-     * The lookup for URLs using the key {@value StringLookupFactory#KEY_URL}.\n+     * The lookup for URLs using the key {@code \"url\"}.\n+     * @see StringLookupFactory#KEY_URL\n+     * @see StringLookupFactory#urlStringLookup()\n      */\n     URL(StringLookupFactory.KEY_URL, StringLookupFactory.INSTANCE.urlStringLookup()),\n \n     /**\n-     * The lookup for URL decoding using the key {@value StringLookupFactory#KEY_URL_DECODER}.\n+     * The lookup for URL decoding using the key {@code \"urlDecoder\"}.\n+     * @see StringLookupFactory#KEY_URL_DECODER\n+     * @see StringLookupFactory#urlDecoderStringLookup()\n      */\n     URL_DECODER(StringLookupFactory.KEY_URL_DECODER, StringLookupFactory.INSTANCE.urlDecoderStringLookup()),\n \n     /**\n-     * The lookup for URL decoding using the key {@value StringLookupFactory#KEY_URL_ENCODER}.\n+     * The lookup for URL decoding using the key {@code \"urlEncoder\"}.\n+     * @see StringLookupFactory#KEY_URL_ENCODER\n+     * @see StringLookupFactory#urlEncoderStringLookup()\n      */\n     URL_ENCODER(StringLookupFactory.KEY_URL_ENCODER, StringLookupFactory.INSTANCE.urlEncoderStringLookup()),\n \n     /**\n-     * The lookup for URL decoding using the key {@value StringLookupFactory#KEY_XML}.\n+     * The lookup for URL decoding using the key {@code \"xml\"}.\n+     * @see StringLookupFactory#KEY_XML\n+     * @see StringLookupFactory#xmlStringLookup()\n      */\n     XML(StringLookupFactory.KEY_XML, StringLookupFactory.INSTANCE.xmlStringLookup());\n \n-    /**\n-     * Prints out to the console the mapping from enum keys to enum name.\n-     * @param args ignored.\n-     */\n-    public static void main(final String[] args) {\n-        Stream.of(values()).forEach(e -> System.out.println(e.getKey() + \"=\" + e.name()));\n-    }\n-\n     /** The prefix under which the associated lookup object is registered. */\n     private final String key;\n \n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class InterpolatorStringLookupTest2 {\n\n    @Test\n    public void testLookupWithStringLookupFactoryToKey() {\n        final Map<String, StringLookup> map = new HashMap<>();\n        map.put(\"TestKey\", key -> \"TestValue\");\n        final StringLookup lookup = new InterpolatorStringLookup(map, null, false);\n\n        // Test with prefix using StringLookupFactory.toKey\n        String value = lookup.lookup(\"testkey:TestKey\");\n        assertEquals(\"TestValue\", value);\n\n        // Test without prefix\n        value = lookup.lookup(\"TestKey\");\n        assertNull(value);\n    }\n\n    @Test\n    public void testLookupWithPrefixUsingStringLookupFactoryToKey() {\n        final Map<String, StringLookup> map = new HashMap<>();\n        map.put(\"TestKey\", key -> \"TestValue\");\n        final StringLookup lookup = new InterpolatorStringLookup(map, null, false);\n\n        // Test with prefix using StringLookupFactory.toKey\n        String value = lookup.lookup(\"testkey:TestKey\");\n        assertEquals(\"TestValue\", value);\n\n        // Test with a non-existent prefix\n        value = lookup.lookup(\"nonexistent:TestKey\");\n        assertNull(value);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\npackage org.apache.commons.text.lookup;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * Proxies other {@link StringLookup}s using a keys within ${} markers using the format \"${StringLookup:Key}\".\n * <p>\n * Uses the {@link StringLookupFactory default lookups}.\n * </p>\n */\nclass InterpolatorStringLookup extends AbstractStringLookup {\n\n    /**\n     * Defines the singleton for this class.\n     *\n     * @since 1.6\n     */\n    static final AbstractStringLookup INSTANCE = new InterpolatorStringLookup();\n\n    /** Constant for the prefix separator. */\n    private static final char PREFIX_SEPARATOR = ':';\n\n    static String toKey(final String key) {\n        return key.toLowerCase(Locale.ROOT);\n    }\n\n    /** The default string lookup. */\n    private final StringLookup defaultStringLookup;\n\n    /** The map of String lookups keyed by prefix. */\n    private final Map<String, StringLookup> stringLookupMap;\n\n    /**\n     * Constructs an instance using only lookups that work without initial properties and are stateless.\n     * <p>\n     * Uses the {@link StringLookupFactory default lookups}.\n     * </p>\n     */\n    InterpolatorStringLookup() {\n        this((Map<String, String>) null);\n    }\n\n    /**\n     * Constructs a fully customized instance.\n     *\n     * @param stringLookupMap the map of string lookups.\n     * @param defaultStringLookup the default string lookup.\n     * @param addDefaultLookups whether the default lookups should be used.\n     */\n    InterpolatorStringLookup(final Map<String, StringLookup> stringLookupMap, final StringLookup defaultStringLookup,\n        final boolean addDefaultLookups) {\n        this.defaultStringLookup = defaultStringLookup;\n        this.stringLookupMap = new HashMap<>(stringLookupMap.size());\n        for (final Entry<String, StringLookup> entry : stringLookupMap.entrySet()) {\n            this.stringLookupMap.put(toKey(entry.getKey()), entry.getValue());\n        }\n        if (addDefaultLookups) {\n            StringLookupFactory.INSTANCE.addDefaultStringLookups(this.stringLookupMap);\n        }\n    }\n\n    /**\n     * Constructs an instance using only lookups that work without initial properties and are stateless.\n     * <p>\n     * Uses the {@link StringLookupFactory default lookups}.\n     * </p>\n     *\n     * @param <V> the map's value type.\n     * @param defaultMap the default map for string lookups.\n     */\n    <V> InterpolatorStringLookup(final Map<String, V> defaultMap) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(defaultMap));\n    }\n\n    /**\n     * Constructs an instance with the given lookup.\n     *\n     * @param defaultStringLookup the default lookup.\n     */\n    InterpolatorStringLookup(final StringLookup defaultStringLookup) {\n        this(Collections.emptyMap(), defaultStringLookup, true);\n    }\n\n    /**\n     * Gets the lookup map.\n     *\n     * @return The lookup map.\n     */\n    public Map<String, StringLookup> getStringLookupMap() {\n        return stringLookupMap;\n    }\n\n    /**\n     * Resolves the specified variable. This implementation will try to extract a variable prefix from the given\n     * variable name (the first colon (':') is used as prefix separator). It then passes the name of the variable with\n     * the prefix stripped to the lookup object registered for this prefix. If no prefix can be found or if the\n     * associated lookup object cannot resolve this variable, the default lookup object will be used.\n     *\n     * @param key the name of the variable whose value is to be looked up\n     * @return The value of this variable or <b>null</b> if it cannot be resolved\n     */\n    @Override\n    public String lookup(String key) {\n        if (key == null) {\n            return null;\n        }\n\n        final int prefixPos = key.indexOf(PREFIX_SEPARATOR);\n        if (prefixPos >= 0) {\n            final String prefix = toKey(key.substring(0, prefixPos));\n            final String name = key.substring(prefixPos + 1);\n            final StringLookup lookup = stringLookupMap.get(prefix);\n            String value = null;\n            if (lookup != null) {\n                value = lookup.lookup(name);\n            }\n\n            if (value != null) {\n                return value;\n            }\n            key = key.substring(prefixPos + 1);\n        }\n        if (defaultStringLookup != null) {\n            return defaultStringLookup.lookup(key);\n        }\n        return null;\n    }\n\n    @Override\n    public String toString() {\n        return super.toString() + \" [stringLookupMap=\" + stringLookupMap + \", defaultStringLookup=\"\n            + defaultStringLookup + \"]\";\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java b/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java\nindex 7a63ef6158..72b36c31fe 100644\n--- a/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java\n@@ -18,7 +18,6 @@\n \n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.Locale;\n import java.util.Map;\n import java.util.Map.Entry;\n \n@@ -40,10 +39,6 @@ class InterpolatorStringLookup extends AbstractStringLookup {\n     /** Constant for the prefix separator. */\n     private static final char PREFIX_SEPARATOR = ':';\n \n-    static String toKey(final String key) {\n-        return key.toLowerCase(Locale.ROOT);\n-    }\n-\n     /** The default string lookup. */\n     private final StringLookup defaultStringLookup;\n \n@@ -72,7 +67,7 @@ static String toKey(final String key) {\n         this.defaultStringLookup = defaultStringLookup;\n         this.stringLookupMap = new HashMap<>(stringLookupMap.size());\n         for (final Entry<String, StringLookup> entry : stringLookupMap.entrySet()) {\n-            this.stringLookupMap.put(toKey(entry.getKey()), entry.getValue());\n+            this.stringLookupMap.put(StringLookupFactory.toKey(entry.getKey()), entry.getValue());\n         }\n         if (addDefaultLookups) {\n             StringLookupFactory.INSTANCE.addDefaultStringLookups(this.stringLookupMap);\n@@ -127,7 +122,7 @@ public String lookup(String key) {\n \n         final int prefixPos = key.indexOf(PREFIX_SEPARATOR);\n         if (prefixPos >= 0) {\n-            final String prefix = toKey(key.substring(0, prefixPos));\n+            final String prefix = StringLookupFactory.toKey(key.substring(0, prefixPos));\n             final String name = key.substring(prefixPos + 1);\n             final StringLookup lookup = stringLookupMap.get(prefix);\n             String value = null;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.junit.jupiter.api.Test;\n\npublic class StringLookupFactoryTest2 {\n\n    @Test\n    public void testAddDefaultStringLookupsWithSystemProperty() {\n        System.setProperty(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY, \"BASE64_ENCODER,ENVIRONMENT\");\n        final Map<String, StringLookup> stringLookupMap = new HashMap<>();\n        StringLookupFactory.INSTANCE.addDefaultStringLookups(stringLookupMap);\n        assertTrue(stringLookupMap.containsKey(InterpolatorStringLookup.toKey(StringLookupFactory.KEY_BASE64_ENCODER)));\n        assertTrue(stringLookupMap.containsKey(InterpolatorStringLookup.toKey(StringLookupFactory.KEY_ENV)));\n        assertEquals(2, stringLookupMap.size());\n        System.clearProperty(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY);\n    }\n\n    @Test\n    public void testAddDefaultStringLookupsWithEmptySystemProperty() {\n        System.setProperty(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY, \"\");\n        final Map<String, StringLookup> stringLookupMap = new HashMap<>();\n        StringLookupFactory.INSTANCE.addDefaultStringLookups(stringLookupMap);\n        assertTrue(stringLookupMap.isEmpty());\n        System.clearProperty(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY);\n    }\n\n    @Test\n    public void testAddDefaultStringLookupsWithInvalidSystemProperty() {\n        System.setProperty(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY, \"INVALID_LOOKUP\");\n        final Map<String, StringLookup> stringLookupMap = new HashMap<>();\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            StringLookupFactory.INSTANCE.addDefaultStringLookups(stringLookupMap);\n        });\n        assertTrue(exception.getMessage().contains(\"Invalid default string lookups definition\"));\n        System.clearProperty(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY);\n    }\n\n    @Test\n    public void testToKey() {\n        assertEquals(\"testkey\", StringLookupFactory.toKey(\"TestKey\"));\n        assertEquals(\"testkey\", StringLookupFactory.toKey(\"testkey\"));\n        assertEquals(\"testkey\", StringLookupFactory.toKey(\"TESTKEY\"));\n    }\n\n    @Test\n    public void testDefaultStringLookupsHolder() {\n        Properties props = new Properties();\n        props.setProperty(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY, \"BASE64_ENCODER,ENVIRONMENT\");\n        StringLookupFactory.DefaultStringLookupsHolder holder = new StringLookupFactory.DefaultStringLookupsHolder(props);\n        Map<String, StringLookup> lookups = holder.getDefaultStringLookups();\n        assertTrue(lookups.containsKey(InterpolatorStringLookup.toKey(StringLookupFactory.KEY_BASE64_ENCODER)));\n        assertTrue(lookups.containsKey(InterpolatorStringLookup.toKey(StringLookupFactory.KEY_ENV)));\n        assertEquals(2, lookups.size());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\n\npackage org.apache.commons.text.lookup;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport org.apache.commons.text.StringSubstitutor;\n\n/**\n * Create instances of string lookups or access singleton string lookups implemented in this package.\n * <p>\n * The \"classic\" look up is {@link #mapStringLookup(Map)}.\n * </p>\n * <p>\n * The methods for variable interpolation (A.K.A. variable substitution) are:\n * </p>\n * <ul>\n * <li>{@link #interpolatorStringLookup()}.</li>\n * <li>{@link #interpolatorStringLookup(Map)}.</li>\n * <li>{@link #interpolatorStringLookup(StringLookup)}.</li>\n * <li>{@link #interpolatorStringLookup(Map, StringLookup, boolean)}.</li>\n * </ul>\n * <p>\n * The default lookups are:\n * </p>\n * <table>\n * <caption>Default String Lookups</caption>\n * <tr>\n * <th>Key</th>\n * <th>Interface</th>\n * <th>Factory Method</th>\n * <th>Since</th>\n * </tr>\n * <tr>\n * <td>{@value #KEY_BASE64_DECODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #base64DecoderStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_BASE64_ENCODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #base64EncoderStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_CONST}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #constantStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_DATE}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #dateStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_DNS}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #dnsStringLookup()}</td>\n * <td>1.8</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_ENV}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #environmentVariableStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_FILE}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #fileStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_JAVA}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #javaPlatformStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_LOCALHOST}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #localHostStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_PROPERTIES}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #propertiesStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_RESOURCE_BUNDLE}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #resourceBundleStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_SCRIPT}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #scriptStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_SYS}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #systemPropertyStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #urlStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL_DECODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #urlDecoderStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL_ENCODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #urlEncoderStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_XML}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #xmlStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * </table>\n * <p>\n * We also provide functional lookups used as building blocks for other lookups.\n * <table>\n * <caption>Functional String Lookups</caption>\n * <tr>\n * <th>Interface</th>\n * <th>Factory Method</th>\n * <th>Since</th>\n * </tr>\n * <tr>\n * <td>{@link BiStringLookup}</td>\n * <td>{@link #biFunctionStringLookup(BiFunction)}</td>\n * <td>1.9</td>\n * </tr>\n * <tr>\n * <td>{@link StringLookup}</td>\n * <td>{@link #functionStringLookup(Function)}</td>\n * <td>1.9</td>\n * </tr>\n * </table>\n *\n * @since 1.3\n */\npublic final class StringLookupFactory {\n\n    /**\n     * Default properties file classpath location.\n     */\n    private static final String DEFAULT_RESOURCE = \"org/apache/commons/text/lookup/defaults.properties\";\n\n    /**\n     * Default mapping.\n     */\n    private static final Properties DEFAULTS = loadProperties();\n\n    /**\n     * Defines the singleton for this class.\n     */\n    public static final StringLookupFactory INSTANCE = new StringLookupFactory();\n\n    /**\n     * Decodes Base64 Strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64DecoderStringLookup().lookup(\"SGVsbG9Xb3JsZCE=\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Decoder:SGVsbG9Xb3JsZCE=} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"SGVsbG9Xb3JsZCE=\"} to {@code \"HelloWorld!\"}.\n     * </p>\n     */\n    static final FunctionStringLookup<String> INSTANCE_BASE64_DECODER = FunctionStringLookup\n        .on(key -> new String(Base64.getDecoder().decode(key), StandardCharsets.ISO_8859_1));\n\n    /**\n     * Encodes Base64 Strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64EncoderStringLookup().lookup(\"HelloWorld!\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Encoder:HelloWorld!} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"HelloWorld!\"} to {@code \"SGVsbG9Xb3JsZCE=\"}.\n     * </p>\n     * Defines the singleton for this class.\n     */\n    static final FunctionStringLookup<String> INSTANCE_BASE64_ENCODER = FunctionStringLookup\n        .on(key -> Base64.getEncoder().encodeToString(key.getBytes(StandardCharsets.ISO_8859_1)));\n\n    /**\n     * Looks up keys from environment variables.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.dateStringLookup().lookup(\"USER\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${env:USER} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert (on Linux) {@code \"USER\"} to the current user name. On Windows 10, you would use\n     * {@code \"USERNAME\"} to the same effect.\n     * </p>\n     */\n    static final FunctionStringLookup<String> INSTANCE_ENVIRONMENT_VARIABLES = FunctionStringLookup.on(System::getenv);\n\n    /**\n     * Defines the FunctionStringLookup singleton that always returns null.\n     */\n    static final FunctionStringLookup<String> INSTANCE_NULL = FunctionStringLookup.on(key -> null);\n\n    /**\n     * Defines the FunctionStringLookup singleton for looking up system properties.\n     */\n    static final FunctionStringLookup<String> INSTANCE_SYSTEM_PROPERTIES = FunctionStringLookup.on(System::getProperty);\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_BASE64_DECODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_BASE64_DECODER = \"base64Decoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_BASE64_ENCODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_BASE64_ENCODER = \"base64Encoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_CONST}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_CONST = \"const\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_DATE}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_DATE = \"date\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_DNS}.\n     *\n     * @since 1.8\n     */\n    public static final String KEY_DNS = \"dns\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_ENV}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_ENV = \"env\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_FILE}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_FILE = \"file\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_JAVA}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_JAVA = \"java\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_LOCALHOST}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_LOCALHOST = \"localhost\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_PROPERTIES}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_PROPERTIES = \"properties\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_RESOURCE_BUNDLE}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_RESOURCE_BUNDLE = \"resourceBundle\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_SCRIPT}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_SCRIPT = \"script\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_SYS}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_SYS = \"sys\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_URL}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL = \"url\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_URL_DECODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL_DECODER = \"urlDecoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_URL_ENCODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL_ENCODER = \"urlEncoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_XML}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_XML = \"xml\";\n\n    /**\n     * Clears any static resources.\n     *\n     * @since 1.5\n     */\n    public static void clear() {\n        ConstantStringLookup.clear();\n    }\n\n    private static Properties loadProperties() {\n        final Properties properties = new Properties();\n        try (InputStream inputStream = ClassLoader.getSystemResourceAsStream(DEFAULT_RESOURCE)) {\n            properties.load(inputStream);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        return properties;\n    }\n\n    /**\n     * Returns the given map if the input is non-null or an empty immutable map if the input is null.\n     *\n     * @param <K> the class of the map keys\n     * @param <V> the class of the map values\n     * @param map The map to test\n     * @return the given map if the input is non-null or an empty immutable map if the input is null.\n     */\n    static <K, V> Map<K, V> toMap(final Map<K, V> map) {\n        return map == null ? Collections.emptyMap() : map;\n    }\n\n    /**\n     * No need to build instances for now.\n     */\n    private StringLookupFactory() {\n        // empty\n    }\n\n    /**\n     * Adds the {@link StringLookupFactory default lookups} as defined in {@value #DEFAULT_RESOURCE}.\n     *\n     * @param stringLookupMap the map of string lookups to edit.\n     * @since 1.5\n     */\n    public void addDefaultStringLookups(final Map<String, StringLookup> stringLookupMap) {\n        if (stringLookupMap != null) {\n            DEFAULTS.forEach((k, v) -> {\n                final DefaultStringLookup stringLookup = DefaultStringLookup.valueOf(Objects.toString(v));\n                stringLookupMap.put(InterpolatorStringLookup.toKey(Objects.toString(k)), stringLookup.getStringLookup());\n            });\n        }\n    }\n\n    /**\n     * Returns the Base64DecoderStringLookup singleton instance to decode Base64 strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64DecoderStringLookup().lookup(\"SGVsbG9Xb3JsZCE=\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Decoder:SGVsbG9Xb3JsZCE=} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"SGVsbG9Xb3JsZCE=\"} to {@code \"HelloWorld!\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup base64DecoderStringLookup() {\n        return StringLookupFactory.INSTANCE_BASE64_DECODER;\n    }\n\n    /**\n     * Returns the Base64EncoderStringLookup singleton instance to encode strings to Base64.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64EncoderStringLookup().lookup(\"HelloWorld!\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Encoder:HelloWorld!} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code } to {@code \"SGVsbG9Xb3JsZCE=\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup base64EncoderStringLookup() {\n        return StringLookupFactory.INSTANCE_BASE64_ENCODER;\n    }\n\n    /**\n     * Returns the Base64DecoderStringLookup singleton instance to decode Base64 strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64DecoderStringLookup().lookup(\"SGVsbG9Xb3JsZCE=\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Decoder:SGVsbG9Xb3JsZCE=} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"SGVsbG9Xb3JsZCE=\"} to {@code \"HelloWorld!\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     * @since 1.5\n     * @deprecated Use {@link #base64DecoderStringLookup()}.\n     */\n    @Deprecated\n    public StringLookup base64StringLookup() {\n        return StringLookupFactory.INSTANCE_BASE64_DECODER;\n    }\n\n    /**\n     * Returns a new function-based lookup where the request for a lookup is answered by applying the function with a\n     * lookup key.\n     *\n     * @param <R> the function return type.\n     * @param <U> the function's second parameter type.\n     * @param biFunction the function.\n     * @return a new MapStringLookup.\n     * @since 1.9\n     */\n    public <R, U> BiStringLookup<U> biFunctionStringLookup(final BiFunction<String, U, R> biFunction) {\n        return BiFunctionStringLookup.on(biFunction);\n    }\n\n    /**\n     * Returns the ConstantStringLookup singleton instance to look up the value of a fully-qualified static final value.\n     * <p>\n     * Sometimes it is necessary in a configuration file to refer to a constant defined in a class. This can be done\n     * with this lookup implementation. Variable names must be in the format {@code apackage.AClass.AFIELD}. The\n     * {@code lookup(String)} method will split the passed in string at the last dot, separating the fully qualified\n     * class name and the name of the constant (i.e. <b>static final</b>) member field. Then the class is loaded and the\n     * field's value is obtained using reflection.\n     * </p>\n     * <p>\n     * Once retrieved values are cached for fast access. This class is thread-safe. It can be used as a standard (i.e.\n     * global) lookup object and serve multiple clients concurrently.\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.constantStringLookup().lookup(\"java.awt.event.KeyEvent.VK_ESCAPE\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${const:java.awt.event.KeyEvent.VK_ESCAPE} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code java.awt.event.KeyEvent.VK_ESCAPE} to {@code \"27\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup constantStringLookup() {\n        return ConstantStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the DateStringLookup singleton instance to format the current date with the format given in the key in a\n     * format compatible with {@link java.text.SimpleDateFormat}.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.dateStringLookup().lookup(\"yyyy-MM-dd\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${date:yyyy-MM-dd} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"yyyy-MM-dd\"} to todays's date, for example, {@code \"2019-08-04\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     */\n    public StringLookup dateStringLookup() {\n        return DateStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the DnsStringLookup singleton instance where the lookup key is one of:\n     * <ul>\n     * <li><b>name</b>: for the local host name, for example {@code EXAMPLE} but also {@code EXAMPLE.apache.org}.</li>\n     * <li><b>canonical-name</b>: for the local canonical host name, for example {@code EXAMPLE.apache.org}.</li>\n     * <li><b>address</b>: for the local host address, for example {@code 192.168.56.1}.</li>\n     * </ul>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.dnsStringLookup().lookup(\"address|apache.org\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${dns:address|apache.org} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"address|apache.org\"} to {@code \"95.216.24.32} (or {@code \"40.79.78.1\"}).\n     * </p>\n     *\n     * @return the DateStringLookup singleton instance.\n     * @since 1.8\n     */\n    public StringLookup dnsStringLookup() {\n        return DnsStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the EnvironmentVariableStringLookup singleton instance where the lookup key is an environment variable\n     * name.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.dateStringLookup().lookup(\"USER\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${env:USER} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert (on Linux) {@code \"USER\"} to the current user name. On Windows 10, you would use\n     * {@code \"USERNAME\"} to the same effect.\n     * </p>\n     *\n     * @return The EnvironmentVariableStringLookup singleton instance.\n     */\n    public StringLookup environmentVariableStringLookup() {\n        return StringLookupFactory.INSTANCE_ENVIRONMENT_VARIABLES;\n    }\n\n    /**\n     * Returns the FileStringLookup singleton instance.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.fileStringLookup().lookup(\"UTF-8:com/domain/document.properties\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${file:UTF-8:com/domain/document.properties} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"UTF-8:com/domain/document.properties\"} to the contents of the file.\n     * </p>\n     *\n     * @return The FileStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup fileStringLookup() {\n        return FileStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new function-based lookup where the request for a lookup is answered by applying the function with a\n     * lookup key.\n     *\n     * @param <R> the function return type.\n     * @param function the function.\n     * @return a new MapStringLookup.\n     * @since 1.9\n     */\n    public <R> StringLookup functionStringLookup(final Function<String, R> function) {\n        return FunctionStringLookup.on(function);\n    }\n\n    /**\n     * Returns the default {@link InterpolatorStringLookup} configured with the {@link StringLookupFactory default lookups}.\n     * <p>\n     * The lookups available to an interpolator are defined in\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.interpolatorStringLookup().lookup(\"${sys:os.name}, ${env:USER}\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${sys:os.name}, ${env:USER} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"${sys:os.name}, ${env:USER}\"} to the OS name and Linux user name.\n     * </p>\n     *\n     * @return the default {@link InterpolatorStringLookup}.\n     */\n    public StringLookup interpolatorStringLookup() {\n        return InterpolatorStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n     * <p>\n     * If {@code addDefaultLookups} is true, the following lookups are used in addition to the ones provided in\n     * {@code stringLookupMap}:\n     * </p>\n     *\n     * @param stringLookupMap the map of string lookups.\n     * @param defaultStringLookup the default string lookup.\n     * @param addDefaultLookups whether to use lookups as described above.\n     * @return a new InterpolatorStringLookup.\n     * @since 1.4\n     */\n    public StringLookup interpolatorStringLookup(final Map<String, StringLookup> stringLookupMap,\n        final StringLookup defaultStringLookup, final boolean addDefaultLookups) {\n        return new InterpolatorStringLookup(stringLookupMap, defaultStringLookup, addDefaultLookups);\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n     *\n     * @param <V> the value type the default string lookup's map.\n     * @param map the default map for string lookups.\n     * @return a new InterpolatorStringLookup.\n     */\n    public <V> StringLookup interpolatorStringLookup(final Map<String, V> map) {\n        return new InterpolatorStringLookup(map);\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n     *\n     * @param defaultStringLookup the default string lookup.\n     * @return a new InterpolatorStringLookup.\n     */\n    public StringLookup interpolatorStringLookup(final StringLookup defaultStringLookup) {\n        return new InterpolatorStringLookup(defaultStringLookup);\n    }\n\n    /**\n     * Returns the JavaPlatformStringLookup singleton instance. Looks up keys related to Java: Java version, JRE\n     * version, VM version, and so on.\n     * <p>\n     * The lookup keys with examples are:\n     * </p>\n     * <ul>\n     * <li><b>version</b>: \"Java version 1.8.0_181\"</li>\n     * <li><b>runtime</b>: \"Java(TM) SE Runtime Environment (build 1.8.0_181-b13) from Oracle Corporation\"</li>\n     * <li><b>vm</b>: \"Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)\"</li>\n     * <li><b>os</b>: \"Windows 10 10.0, architecture: amd64-64\"</li>\n     * <li><b>hardware</b>: \"processors: 4, architecture: amd64-64, instruction sets: amd64\"</li>\n     * <li><b>locale</b>: \"default locale: en_US, platform encoding: iso-8859-1\"</li>\n     * </ul>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.javaPlatformStringLookup().lookup(\"version\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${java:version} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"version\"} to the current VM version, for example,\n     * {@code \"Java version 1.8.0_181\"}.\n     * </p>\n     *\n     * @return The JavaPlatformStringLookup singleton instance.\n     */\n    public StringLookup javaPlatformStringLookup() {\n        return JavaPlatformStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the LocalHostStringLookup singleton instance where the lookup key is one of:\n     * <ul>\n     * <li><b>name</b>: for the local host name, for example {@code EXAMPLE}.</li>\n     * <li><b>canonical-name</b>: for the local canonical host name, for example {@code EXAMPLE.apache.org}.</li>\n     * <li><b>address</b>: for the local host address, for example {@code 192.168.56.1}.</li>\n     * </ul>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.localHostStringLookup().lookup(\"canonical-name\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${localhost:canonical-name} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"canonical-name\"} to the current host name, for example,\n     * {@code \"EXAMPLE.apache.org\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     */\n    public StringLookup localHostStringLookup() {\n        return LocalHostStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new map-based lookup where the request for a lookup is answered with the value for that key.\n     *\n     * @param <V> the map value type.\n     * @param map the map.\n     * @return a new MapStringLookup.\n     */\n    public <V> StringLookup mapStringLookup(final Map<String, V> map) {\n        return FunctionStringLookup.on(map);\n    }\n\n    /**\n     * Returns the NullStringLookup singleton instance which always returns null.\n     *\n     * @return The NullStringLookup singleton instance.\n     */\n    public StringLookup nullStringLookup() {\n        return StringLookupFactory.INSTANCE_NULL;\n    }\n\n    /**\n     * Returns the PropertiesStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"DocumentPath::MyKey\".\n     * </p>\n     * <p>\n     * Note the use of \"::\" instead of \":\" to allow for \"C:\" drive letters in paths.\n     * </p>\n     * <p>\n     * For example: \"com/domain/document.properties::MyKey\".\n     * </p>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.propertiesStringLookup().lookup(\"com/domain/document.properties::MyKey\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${properties:com/domain/document.properties::MyKey} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"com/domain/document.properties::MyKey\"} to the key value in the properties\n     * file at the path \"com/domain/document.properties\".\n     * </p>\n     *\n     * @return The PropertiesStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup propertiesStringLookup() {\n        return PropertiesStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the ResourceBundleStringLookup singleton instance.\n     * <p>\n     * Looks up the value for a given key in the format \"BundleName:BundleKey\".\n     * </p>\n     * <p>\n     * For example: \"com.domain.messages:MyKey\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.resourceBundleStringLookup().lookup(\"com.domain.messages:MyKey\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${resourceBundle:com.domain.messages:MyKey} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"com.domain.messages:MyKey\"} to the key value in the resource bundle at\n     * {@code \"com.domain.messages\"}.\n     * </p>\n     *\n     * @return The ResourceBundleStringLookup singleton instance.\n     */\n    public StringLookup resourceBundleStringLookup() {\n        return ResourceBundleStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a ResourceBundleStringLookup instance for the given bundle name.\n     * <p>\n     * Looks up the value for a given key in the format \"MyKey\".\n     * </p>\n     * <p>\n     * For example: \"MyKey\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.resourceBundleStringLookup(\"com.domain.messages\").lookup(\"MyKey\");\n     * </pre>\n     * <p>\n     * The above example converts {@code \"MyKey\"} to the key value in the resource bundle at\n     * {@code \"com.domain.messages\"}.\n     * </p>\n     *\n     * @param bundleName Only lookup in this bundle.\n     * @return a ResourceBundleStringLookup instance for the given bundle name.\n     * @since 1.5\n     */\n    public StringLookup resourceBundleStringLookup(final String bundleName) {\n        return new ResourceBundleStringLookup(bundleName);\n    }\n\n    /**\n     * Returns the ScriptStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"ScriptEngineName:Script\".\n     * </p>\n     * <p>\n     * For example: \"javascript:3 + 4\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.scriptStringLookup().lookup(\"javascript:3 + 4\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${javascript:3 + 4} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"javascript:3 + 4\"} to {@code \"7\"}.\n     * </p>\n     *\n     * @return The ScriptStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup scriptStringLookup() {\n        return ScriptStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the SystemPropertyStringLookup singleton instance where the lookup key is a system property name.\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.systemPropertyStringLookup().lookup(\"os.name\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${sys:os.name} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"os.name\"} to the operating system name.\n     * </p>\n     *\n     * @return The SystemPropertyStringLookup singleton instance.\n     */\n    public StringLookup systemPropertyStringLookup() {\n        return StringLookupFactory.INSTANCE_SYSTEM_PROPERTIES;\n    }\n\n    /**\n     * Returns the UrlDecoderStringLookup singleton instance.\n     * <p>\n     * Decodes URL Strings using the UTF-8 encoding.\n     * </p>\n     * <p>\n     * For example: \"Hello%20World%21\" becomes \"Hello World!\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.urlDecoderStringLookup().lookup(\"Hello%20World%21\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${urlDecoder:Hello%20World%21} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"Hello%20World%21\"} to {@code \"Hello World!\"}.\n     * </p>\n     *\n     * @return The UrlStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup urlDecoderStringLookup() {\n        return UrlDecoderStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the UrlDecoderStringLookup singleton instance.\n     * <p>\n     * Decodes URL Strings using the UTF-8 encoding.\n     * </p>\n     * <p>\n     * For example: \"Hello World!\" becomes \"Hello+World%21\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.urlEncoderStringLookup().lookup(\"Hello World!\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${urlEncoder:Hello World!} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"Hello World!\"} to {@code \"Hello%20World%21\"}.\n     * </p>\n     *\n     * @return The UrlStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup urlEncoderStringLookup() {\n        return UrlEncoderStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the UrlStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"CharsetName:URL\".\n     * </p>\n     * <p>\n     * For example, using the HTTP scheme: \"UTF-8:http://www.google.com\"\n     * </p>\n     * <p>\n     * For example, using the file scheme:\n     * \"UTF-8:file:///C:/somehome/commons/commons-text/src/test/resources/document.properties\"\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.urlStringLookup().lookup(\"UTF-8:https://www.apache.org\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${url:UTF-8:https://www.apache.org} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"UTF-8:https://www.apache.org\"} to the contents of that page.\n     * </p>\n     *\n     * @return The UrlStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup urlStringLookup() {\n        return UrlStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the XmlStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"DocumentPath:XPath\".\n     * </p>\n     * <p>\n     * For example: \"com/domain/document.xml:/path/to/node\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.xmlStringLookup().lookup(\"com/domain/document.xml:/path/to/node\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${xml:com/domain/document.xml:/path/to/node} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"com/domain/document.xml:/path/to/node\"} to the value of the XPath in the XML\n     * document.\n     * </p>\n     *\n     * @return The XmlStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup xmlStringLookup() {\n        return XmlStringLookup.INSTANCE;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\nindex 54cd61de15..bd397f8773 100644\n--- a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n+++ b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n@@ -17,14 +17,12 @@\n \n package org.apache.commons.text.lookup;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.UncheckedIOException;\n import java.nio.charset.StandardCharsets;\n import java.util.Base64;\n import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n import java.util.Map;\n-import java.util.Objects;\n import java.util.Properties;\n import java.util.function.BiFunction;\n import java.util.function.Function;\n@@ -46,7 +44,19 @@\n  * <li>{@link #interpolatorStringLookup(Map, StringLookup, boolean)}.</li>\n  * </ul>\n  * <p>\n- * The default lookups are:\n+ * Unless explicitly requested otherwise, a set of default lookups are included for convenience with these\n+ * variable interpolation methods. These defaults are listed in the table below. However, the exact lookups\n+ * included can be configured through the use of the {@value #DEFAULT_STRING_LOOKUPS_PROPERTY} system property.\n+ * If present, this system property will be parsed as a comma-separated list of lookup names, with the names\n+ * being those defined by the {@link DefaultStringLookup} enum. For example, setting this system property to\n+ * {@code \"BASE64_ENCODER,ENVIRONMENT\"} will only include the\n+ * {@link DefaultStringLookup#BASE64_ENCODER BASE64_ENCODER} and {@link DefaultStringLookup#ENVIRONMENT ENVIRONMENT}\n+ * lookups. Setting the property to the empty string will cause no defaults to be configured.\n+ * Note that not all lookups defined here and in {@link DefaultStringLookup} are included by default.\n+ * Specifically, lookups that can execute code (e.g., {@link DefaultStringLookup#SCRIPT SCRIPT}) and those\n+ * that can result in contact with remote servers (e.g., {@link DefaultStringLookup#URL URL} and\n+ * {@link DefaultStringLookup#DNS DNS}) are not included by default. The current set of default lookups can\n+ * be accessed directly with {@link #addDefaultStringLookups(Map)}.\n  * </p>\n  * <table>\n  * <caption>Default String Lookups</caption>\n@@ -81,12 +91,6 @@\n  * <td>1.5</td>\n  * </tr>\n  * <tr>\n- * <td>{@value #KEY_DNS}</td>\n- * <td>{@link StringLookup}</td>\n- * <td>{@link #dnsStringLookup()}</td>\n- * <td>1.8</td>\n- * </tr>\n- * <tr>\n  * <td>{@value #KEY_ENV}</td>\n  * <td>{@link StringLookup}</td>\n  * <td>{@link #environmentVariableStringLookup()}</td>\n@@ -123,24 +127,12 @@\n  * <td>1.6</td>\n  * </tr>\n  * <tr>\n- * <td>{@value #KEY_SCRIPT}</td>\n- * <td>{@link StringLookup}</td>\n- * <td>{@link #scriptStringLookup()}</td>\n- * <td>1.5</td>\n- * </tr>\n- * <tr>\n  * <td>{@value #KEY_SYS}</td>\n  * <td>{@link StringLookup}</td>\n  * <td>{@link #systemPropertyStringLookup()}</td>\n  * <td>1.3</td>\n  * </tr>\n  * <tr>\n- * <td>{@value #KEY_URL}</td>\n- * <td>{@link StringLookup}</td>\n- * <td>{@link #urlStringLookup()}</td>\n- * <td>1.5</td>\n- * </tr>\n- * <tr>\n  * <td>{@value #KEY_URL_DECODER}</td>\n  * <td>{@link StringLookup}</td>\n  * <td>{@link #urlDecoderStringLookup()}</td>\n@@ -159,8 +151,37 @@\n  * <td>1.5</td>\n  * </tr>\n  * </table>\n+ *\n+ * <table>\n+ * <caption>Additional String Lookups (not included by default)</caption>\n+ * <tr>\n+ * <th>Key</th>\n+ * <th>Interface</th>\n+ * <th>Factory Method</th>\n+ * <th>Since</th>\n+ * </tr>\n+ * <tr>\n+ * <td>{@value #KEY_DNS}</td>\n+ * <td>{@link StringLookup}</td>\n+ * <td>{@link #dnsStringLookup()}</td>\n+ * <td>1.8</td>\n+ * </tr>\n+ * <tr>\n+ * <td>{@value #KEY_URL}</td>\n+ * <td>{@link StringLookup}</td>\n+ * <td>{@link #urlStringLookup()}</td>\n+ * <td>1.5</td>\n+ * </tr>\n+ * <tr>\n+ * <td>{@value #KEY_SCRIPT}</td>\n+ * <td>{@link StringLookup}</td>\n+ * <td>{@link #scriptStringLookup()}</td>\n+ * <td>1.5</td>\n+ * </tr>\n+ * </table>\n+ *\n  * <p>\n- * We also provide functional lookups used as building blocks for other lookups.\n+ * This class also provides functional lookups used as building blocks for other lookups.\n  * <table>\n  * <caption>Functional String Lookups</caption>\n  * <tr>\n@@ -184,16 +205,6 @@\n  */\n public final class StringLookupFactory {\n \n-    /**\n-     * Default properties file classpath location.\n-     */\n-    private static final String DEFAULT_RESOURCE = \"org/apache/commons/text/lookup/defaults.properties\";\n-\n-    /**\n-     * Default mapping.\n-     */\n-    private static final Properties DEFAULTS = loadProperties();\n-\n     /**\n      * Defines the singleton for this class.\n      */\n@@ -253,7 +264,7 @@ public final class StringLookupFactory {\n      * </p>\n      *\n      * <pre>\n-     * StringLookupFactory.INSTANCE.dateStringLookup().lookup(\"USER\");\n+     * StringLookupFactory.INSTANCE.environmentVariableStringLookup().lookup(\"USER\");\n      * </pre>\n      * <p>\n      * Using a {@link StringSubstitutor}:\n@@ -398,6 +409,17 @@ public final class StringLookupFactory {\n      */\n     public static final String KEY_XML = \"xml\";\n \n+    /**\n+     * Name of the system property used to determine the string lookups added by the\n+     * {@link #addDefaultStringLookups(Map)} method. Use of this property is only required\n+     * in cases where the set of default lookups must be modified. (See the class documentation\n+     * for details.)\n+     *\n+     * @since 1.10\n+     */\n+    public static final String DEFAULT_STRING_LOOKUPS_PROPERTY =\n+            \"org.apache.commons.text.lookup.StringLookupFactory.defaultStringLookups\";\n+\n     /**\n      * Clears any static resources.\n      *\n@@ -407,16 +429,6 @@ public static void clear() {\n         ConstantStringLookup.clear();\n     }\n \n-    private static Properties loadProperties() {\n-        final Properties properties = new Properties();\n-        try (InputStream inputStream = ClassLoader.getSystemResourceAsStream(DEFAULT_RESOURCE)) {\n-            properties.load(inputStream);\n-        } catch (final IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-        return properties;\n-    }\n-\n     /**\n      * Returns the given map if the input is non-null or an empty immutable map if the input is null.\n      *\n@@ -437,17 +449,17 @@ private StringLookupFactory() {\n     }\n \n     /**\n-     * Adds the {@link StringLookupFactory default lookups} as defined in {@value #DEFAULT_RESOURCE}.\n+     * Adds the default string lookups for this class to {@code stringLookupMap}. The default string\n+     * lookups are a set of built-in lookups added for convenience during string interpolation. The\n+     * defaults may be configured using the {@value #DEFAULT_STRING_LOOKUPS_PROPERTY} system property.\n+     * See the class documentation for details and a list of lookups.\n      *\n      * @param stringLookupMap the map of string lookups to edit.\n      * @since 1.5\n      */\n     public void addDefaultStringLookups(final Map<String, StringLookup> stringLookupMap) {\n         if (stringLookupMap != null) {\n-            DEFAULTS.forEach((k, v) -> {\n-                final DefaultStringLookup stringLookup = DefaultStringLookup.valueOf(Objects.toString(v));\n-                stringLookupMap.put(InterpolatorStringLookup.toKey(Objects.toString(k)), stringLookup.getStringLookup());\n-            });\n+            stringLookupMap.putAll(DefaultStringLookupsHolder.INSTANCE.getDefaultStringLookups());\n         }\n     }\n \n@@ -471,7 +483,7 @@ public void addDefaultStringLookups(final Map<String, StringLookup> stringLookup\n      * The above examples convert {@code \"SGVsbG9Xb3JsZCE=\"} to {@code \"HelloWorld!\"}.\n      * </p>\n      *\n-     * @return The DateStringLookup singleton instance.\n+     * @return The Base64DecoderStringLookup singleton instance.\n      * @since 1.5\n      */\n     public StringLookup base64DecoderStringLookup() {\n@@ -498,7 +510,7 @@ public StringLookup base64DecoderStringLookup() {\n      * The above examples convert {@code } to {@code \"SGVsbG9Xb3JsZCE=\"}.\n      * </p>\n      *\n-     * @return The DateStringLookup singleton instance.\n+     * @return The Base64EncoderStringLookup singleton instance.\n      * @since 1.6\n      */\n     public StringLookup base64EncoderStringLookup() {\n@@ -525,7 +537,7 @@ public StringLookup base64EncoderStringLookup() {\n      * The above examples convert {@code \"SGVsbG9Xb3JsZCE=\"} to {@code \"HelloWorld!\"}.\n      * </p>\n      *\n-     * @return The DateStringLookup singleton instance.\n+     * @return The Base64DecoderStringLookup singleton instance.\n      * @since 1.5\n      * @deprecated Use {@link #base64DecoderStringLookup()}.\n      */\n@@ -579,7 +591,7 @@ public <R, U> BiStringLookup<U> biFunctionStringLookup(final BiFunction<String,\n      * The above examples convert {@code java.awt.event.KeyEvent.VK_ESCAPE} to {@code \"27\"}.\n      * </p>\n      *\n-     * @return The DateStringLookup singleton instance.\n+     * @return The ConstantStringLookup singleton instance.\n      * @since 1.5\n      */\n     public StringLookup constantStringLookup() {\n@@ -629,17 +641,24 @@ public StringLookup dateStringLookup() {\n      * StringLookupFactory.INSTANCE.dnsStringLookup().lookup(\"address|apache.org\");\n      * </pre>\n      * <p>\n-     * Using a {@link StringSubstitutor}:\n+     * When used through a {@link StringSubstitutor}, this lookup must either be added programmatically\n+     * (as below) or enabled as a default lookup using the {@value #DEFAULT_STRING_LOOKUPS_PROPERTY} system property\n+     * (see class documentation).\n      * </p>\n      *\n      * <pre>\n-     * StringSubstitutor.createInterpolator().replace(\"... ${dns:address|apache.org} ...\"));\n+     * Map&lt;String, StringLookup&gt; lookupMap = new HashMap&lt;&gt;();\n+     * lookupMap.put(\"dns\", StringLookupFactory.INSTANCE.dnsStringLookup());\n+     *\n+     * StringLookup variableResolver = StringLookupFactory.INSTANCE.interpolatorStringLookup(lookupMap, null, false);\n+     *\n+     * new StringSubstitutor(variableResolver).replace(\"... ${dns:address|apache.org} ...\");\n      * </pre>\n      * <p>\n-     * The above examples convert {@code \"address|apache.org\"} to {@code \"95.216.24.32} (or {@code \"40.79.78.1\"}).\n+     * The above examples convert {@code \"address|apache.org\"} to the IP address of {@code apache.org}.\n      * </p>\n      *\n-     * @return the DateStringLookup singleton instance.\n+     * @return the DnsStringLookup singleton instance.\n      * @since 1.8\n      */\n     public StringLookup dnsStringLookup() {\n@@ -654,7 +673,7 @@ public StringLookup dnsStringLookup() {\n      * </p>\n      *\n      * <pre>\n-     * StringLookupFactory.INSTANCE.dateStringLookup().lookup(\"USER\");\n+     * StringLookupFactory.INSTANCE.environmentVariableStringLookup().lookup(\"USER\");\n      * </pre>\n      * <p>\n      * Using a {@link StringSubstitutor}:\n@@ -715,10 +734,9 @@ public <R> StringLookup functionStringLookup(final Function<String, R> function)\n     }\n \n     /**\n-     * Returns the default {@link InterpolatorStringLookup} configured with the {@link StringLookupFactory default lookups}.\n-     * <p>\n-     * The lookups available to an interpolator are defined in\n-     * </p>\n+     * Returns a {@link InterpolatorStringLookup} containing the configured\n+     * {@link #addDefaultStringLookups(Map) default lookups}. See the class documentation for\n+     * details on how these defaults are configured.\n      * <p>\n      * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n      * </p>\n@@ -744,15 +762,15 @@ public StringLookup interpolatorStringLookup() {\n     }\n \n     /**\n-     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n-     * <p>\n-     * If {@code addDefaultLookups} is true, the following lookups are used in addition to the ones provided in\n-     * {@code stringLookupMap}:\n-     * </p>\n+     * Returns a new InterpolatorStringLookup. If {@code addDefaultLookups} is {@code true}, the configured\n+     * {@link #addDefaultStringLookups(Map) default lookups} are included in addition to the ones\n+     * provided in {@code stringLookupMap}. (See the class documentation for details on how default lookups\n+     * are configured.)\n      *\n      * @param stringLookupMap the map of string lookups.\n-     * @param defaultStringLookup the default string lookup.\n-     * @param addDefaultLookups whether to use lookups as described above.\n+     * @param defaultStringLookup the default string lookup; this lookup is used when a variable cannot be\n+     *      resolved using the lookups in {@code stringLookupMap} or the configured default lookups (if enabled)\n+     * @param addDefaultLookups whether to use default lookups as described above.\n      * @return a new InterpolatorStringLookup.\n      * @since 1.4\n      */\n@@ -762,7 +780,9 @@ public StringLookup interpolatorStringLookup(final Map<String, StringLookup> str\n     }\n \n     /**\n-     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n+     * Returns a new InterpolatorStringLookup using the given key-value pairs and the configured\n+     * {@link #addDefaultStringLookups(Map) default lookups} to resolve variables. (See the class\n+     * documentation for details on how default lookups are configured.)\n      *\n      * @param <V> the value type the default string lookup's map.\n      * @param map the default map for string lookups.\n@@ -773,7 +793,9 @@ public <V> StringLookup interpolatorStringLookup(final Map<String, V> map) {\n     }\n \n     /**\n-     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n+     * Returns a new InterpolatorStringLookup using the given lookup and the configured\n+     * {@link #addDefaultStringLookups(Map) default lookups} to resolve variables. (See the class\n+     * documentation for details on how default lookups are configured.)\n      *\n      * @param defaultStringLookup the default string lookup.\n      * @return a new InterpolatorStringLookup.\n@@ -975,7 +997,9 @@ public StringLookup resourceBundleStringLookup(final String bundleName) {\n     }\n \n     /**\n-     * Returns the ScriptStringLookup singleton instance.\n+     * Returns the ScriptStringLookup singleton instance. NOTE: This lookup is not included\n+     * as a {@link #addDefaultStringLookups(Map) default lookup} unless explicitly enabled. See\n+     * the class level documentation for details.\n      * <p>\n      * Looks up the value for the key in the format \"ScriptEngineName:Script\".\n      * </p>\n@@ -990,11 +1014,18 @@ public StringLookup resourceBundleStringLookup(final String bundleName) {\n      * StringLookupFactory.INSTANCE.scriptStringLookup().lookup(\"javascript:3 + 4\");\n      * </pre>\n      * <p>\n-     * Using a {@link StringSubstitutor}:\n+     * When used through a {@link StringSubstitutor}, this lookup must either be added programmatically\n+     * (as below) or enabled as a default lookup using the {@value #DEFAULT_STRING_LOOKUPS_PROPERTY} system property\n+     * (see class documentation).\n      * </p>\n      *\n      * <pre>\n-     * StringSubstitutor.createInterpolator().replace(\"... ${javascript:3 + 4} ...\"));\n+     * Map&lt;String, StringLookup&gt; lookupMap = new HashMap&lt;&gt;();\n+     * lookupMap.put(\"script\", StringLookupFactory.INSTANCE.scriptStringLookup());\n+     *\n+     * StringLookup variableResolver = StringLookupFactory.INSTANCE.interpolatorStringLookup(lookupMap, null, false);\n+     *\n+     * String value = new StringSubstitutor(variableResolver).replace(\"${script:javascript:3 + 4}\");\n      * </pre>\n      * <p>\n      * The above examples convert {@code \"javascript:3 + 4\"} to {@code \"7\"}.\n@@ -1101,7 +1132,9 @@ public StringLookup urlEncoderStringLookup() {\n     }\n \n     /**\n-     * Returns the UrlStringLookup singleton instance.\n+     * Returns the UrlStringLookup singleton instance. This lookup is not included\n+     * as a {@link #addDefaultStringLookups(Map) default lookup} unless explicitly enabled. See\n+     * the class level documentation for details.\n      * <p>\n      * Looks up the value for the key in the format \"CharsetName:URL\".\n      * </p>\n@@ -1120,11 +1153,18 @@ public StringLookup urlEncoderStringLookup() {\n      * StringLookupFactory.INSTANCE.urlStringLookup().lookup(\"UTF-8:https://www.apache.org\");\n      * </pre>\n      * <p>\n-     * Using a {@link StringSubstitutor}:\n+     * When used through a {@link StringSubstitutor}, this lookup must either be added programmatically\n+     * (as below) or enabled as a default lookup using the {@value #DEFAULT_STRING_LOOKUPS_PROPERTY} system property\n+     * (see class documentation).\n      * </p>\n      *\n      * <pre>\n-     * StringSubstitutor.createInterpolator().replace(\"... ${url:UTF-8:https://www.apache.org} ...\"));\n+     * Map&lt;String, StringLookup&gt; lookupMap = new HashMap&lt;&gt;();\n+     * lookupMap.put(\"url\", StringLookupFactory.INSTANCE.urlStringLookup());\n+     *\n+     * StringLookup variableResolver = StringLookupFactory.INSTANCE.interpolatorStringLookup(lookupMap, null, false);\n+     *\n+     * String value = new StringSubstitutor(variableResolver).replace(\"${url:UTF-8:https://www.apache.org}\");\n      * </pre>\n      * <p>\n      * The above examples convert {@code \"UTF-8:https://www.apache.org\"} to the contents of that page.\n@@ -1171,4 +1211,109 @@ public StringLookup xmlStringLookup() {\n         return XmlStringLookup.INSTANCE;\n     }\n \n+    /**\n+     * Get a string suitable for use as a key in the string lookup map.\n+     * @param key string to convert to a string lookup map key\n+     * @return string lookup map key\n+     */\n+    static String toKey(final String key) {\n+        return key.toLowerCase(Locale.ROOT);\n+    }\n+\n+    /**\n+     * Internal class used to construct the default {@link StringLookup} map used by\n+     * {@link StringLookupFactory#addDefaultStringLookups(Map)}.\n+     */\n+    static final class DefaultStringLookupsHolder {\n+\n+        /** Singleton instance, initialized with the system properties. */\n+        static final DefaultStringLookupsHolder INSTANCE = new DefaultStringLookupsHolder(System.getProperties());\n+\n+        /** Default string lookup map. */\n+        private final Map<String, StringLookup> defaultStringLookups;\n+\n+        /**\n+         * Construct a new instance initialized with the given properties.\n+         * @param props initialization properties\n+         */\n+        DefaultStringLookupsHolder(final Properties props) {\n+            final Map<String, StringLookup> lookups =\n+                    props.containsKey(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY)\n+                        ? parseStringLookups(props.getProperty(StringLookupFactory.DEFAULT_STRING_LOOKUPS_PROPERTY))\n+                        : createDefaultStringLookups();\n+\n+            defaultStringLookups = Collections.unmodifiableMap(lookups);\n+        }\n+\n+        /**\n+         * Get the default string lookups map.\n+         * @return default string lookups map\n+         */\n+        Map<String, StringLookup> getDefaultStringLookups() {\n+            return defaultStringLookups;\n+        }\n+\n+        /**\n+         * Create the lookup map used when the user has requested no customization.\n+         * @return default lookup map\n+         */\n+        private static Map<String, StringLookup> createDefaultStringLookups() {\n+            final Map<String, StringLookup> lookupMap = new HashMap<>();\n+\n+            addLookup(DefaultStringLookup.BASE64_DECODER, lookupMap);\n+            addLookup(DefaultStringLookup.BASE64_ENCODER, lookupMap);\n+            addLookup(DefaultStringLookup.CONST, lookupMap);\n+            addLookup(DefaultStringLookup.DATE, lookupMap);\n+            addLookup(DefaultStringLookup.ENVIRONMENT, lookupMap);\n+            addLookup(DefaultStringLookup.FILE, lookupMap);\n+            addLookup(DefaultStringLookup.JAVA, lookupMap);\n+            addLookup(DefaultStringLookup.LOCAL_HOST, lookupMap);\n+            addLookup(DefaultStringLookup.PROPERTIES, lookupMap);\n+            addLookup(DefaultStringLookup.RESOURCE_BUNDLE, lookupMap);\n+            addLookup(DefaultStringLookup.SYSTEM_PROPERTIES, lookupMap);\n+            addLookup(DefaultStringLookup.URL_DECODER, lookupMap);\n+            addLookup(DefaultStringLookup.URL_ENCODER, lookupMap);\n+            addLookup(DefaultStringLookup.XML, lookupMap);\n+\n+            return lookupMap;\n+        }\n+\n+        /**\n+         * Construct a lookup map by parsing the given string. The string is expected to contain\n+         * comma or space-separated names of values from the {@link DefaultStringLookup} enum. If\n+         * the given string is null or empty, an empty map is returned.\n+         * @param str string to parse; may be null or empty\n+         * @return lookup map parsed from the given string\n+         */\n+        private static Map<String, StringLookup> parseStringLookups(final String str) {\n+            final Map<String, StringLookup> lookupMap = new HashMap<>();\n+\n+            try {\n+                for (final String lookupName : str.split(\"[\\\\s,]+\")) {\n+                    if (!lookupName.isEmpty()) {\n+                        addLookup(DefaultStringLookup.valueOf(lookupName.toUpperCase()), lookupMap);\n+                    }\n+                }\n+            } catch (IllegalArgumentException exc) {\n+                throw new IllegalArgumentException(\"Invalid default string lookups definition: \" + str, exc);\n+            }\n+\n+            return lookupMap;\n+        }\n+\n+        /**\n+         * Add the key and string lookup from {@code lookup} to {@code map}, also adding any additional\n+         * key aliases if needed. Keys are normalized using the {@link #toKey(String)} method.\n+         * @param lookup lookup to add\n+         * @param map map to add to\n+         */\n+        private static void addLookup(final DefaultStringLookup lookup, final Map<String, StringLookup> map) {\n+            map.put(toKey(lookup.getKey()), lookup.getStringLookup());\n+\n+            if (DefaultStringLookup.BASE64_DECODER.equals(lookup)) {\n+                // \"base64\" is deprecated in favor of KEY_BASE64_DECODER.\n+                map.put(toKey(\"base64\"), lookup.getStringLookup());\n+            }\n+        }\n+    }\n }\n"
      },
      {
        "filename": "src/main/resources/org/apache/commons/text/lookup/defaults.properties",
        "status": "removed",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/site/xdoc/userguide.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/StringSubstitutorWithInterpolatorStringLookupTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/resources/org/apache/commons/text/lookup/defaults.properties",
        "status": "removed",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 335,
    "title": "Use Math.min() call instead of doing it manually.",
    "state": "closed",
    "created_at": "2022-06-13T21:28:21Z",
    "merge_commit_sha": "baee3346849ad6da8a8179bca40f311ceec4d992",
    "base_sha": "ec0ff34c44a8bc7a85dcdafc7fe446c2d7d15955",
    "head_sha": "bcfd4ac880b4d8188f8aac51aa58646eab68e6a7",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/WordUtils.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\nimport org.junit.jupiter.api.Test;\n\npublic class WordUtilsTest2 {\n\n    @Test\n    public void testAbbreviateWithMinIndexUpper() {\n        // Test case to cover the change in the abbreviate method where Math.min(index, upper) is used\n        assertThat(WordUtils.abbreviate(\"012 3456789\", 0, 5, null)).isEqualTo(\"012\");\n        assertThat(WordUtils.abbreviate(\"01234 56789\", 5, 10, null)).isEqualTo(\"01234\");\n        assertThat(WordUtils.abbreviate(\"01 23 45 67 89\", 9, -1, null)).isEqualTo(\"01 23 45 67\");\n        assertThat(WordUtils.abbreviate(\"01 23 45 67 89\", 9, 10, null)).isEqualTo(\"01 23 45 6\");\n        assertThat(WordUtils.abbreviate(\"0123456789\", 15, 20, null)).isEqualTo(\"0123456789\");\n    }\n\n    @Test\n    public void testAbbreviateWithMinIndexUpperAndAppendedString() {\n        // Test case to cover the change in the abbreviate method where Math.min(index, upper) is used with appended string\n        assertThat(WordUtils.abbreviate(\"012 3456789\", 0, 5, \"-\")).isEqualTo(\"012-\");\n        assertThat(WordUtils.abbreviate(\"01234 56789\", 5, 10, \"-\")).isEqualTo(\"01234-\");\n        assertThat(WordUtils.abbreviate(\"01 23 45 67 89\", 9, -1, \"abc\")).isEqualTo(\"01 23 45 67abc\");\n        assertThat(WordUtils.abbreviate(\"01 23 45 67 89\", 9, 10, \"\")).isEqualTo(\"01 23 45 6\");\n    }\n\n    @Test\n    public void testAbbreviateWithMinIndexUpperEdgeCases() {\n        // Test edge cases for the change in the abbreviate method where Math.min(index, upper) is used\n        assertThat(WordUtils.abbreviate(\"0123456789\", 0, 0, \"\")).isEqualTo(\"\");\n        assertThat(WordUtils.abbreviate(\"0123456789\", 0, 1, \"\")).isEqualTo(\"0\");\n        assertThat(WordUtils.abbreviate(\"0123456789\", 0, 10, \"\")).isEqualTo(\"0123456789\");\n        assertThat(WordUtils.abbreviate(\"0123456789\", 0, 11, \"\")).isEqualTo(\"0123456789\");\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\n\n/**\n * Operations on Strings that contain words.\n *\n * <p>\n * This class tries to handle {@code null} input gracefully. An exception will not be thrown for a\n * {@code null} input. Each method documents its behavior in more detail.\n * </p>\n *\n * @since 1.1\n */\npublic class WordUtils {\n\n    /**\n     * Abbreviates the words nicely.\n     *\n     * <p>\n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * </p>\n     *\n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit; negative value is treated as zero.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    The upper limit cannot be lower than the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return The abbreviated String.\n     *\n     * <pre>\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, null));     = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, null));    = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, null));    = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, \"\"));       = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, \"\"));      = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, \"\"));      = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, \" ...\"));   = \"Now ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, \" ...\"));  = \"Now is the ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, \" ...\"));  = \"Now is the time for all ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, -1, \"\"));       = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, -1, \"\"));      = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, -1, \"\"));      = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 50, -1, \"\"));      = \"Now is the time for all good men\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 1000, -1, \"\"));    = \"Now is the time for all good men\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 9, -10, null));    = IllegalArgumentException\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 5, null));     = IllegalArgumentException\n     * </pre>\n     */\n    public static String abbreviate(final String str, int lower, int upper, final String appendToEnd) {\n        Validate.isTrue(upper >= -1, \"upper value cannot be less than -1\");\n        Validate.isTrue(upper >= lower || upper == -1, \"upper value is less than lower value\");\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        if (lower > str.length()) {\n            lower = str.length();\n        }\n\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n\n        final StringBuilder result = new StringBuilder();\n        final int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str, 0, upper);\n            // only if abbreviation has occurred do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else {\n            if (index > upper) {\n                result.append(str, 0, upper);\n            } else {\n                result.append(str, 0, index);\n            }\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Capitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed. To convert the\n     * rest of each word to lowercase at the same time,\n     * use {@link #capitalizeFully(String)}.\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null)        = null\n     * WordUtils.capitalize(\"\")          = \"\"\n     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, {@code null} if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str) {\n        return capitalize(str, null);\n    }\n\n    /**\n     * Capitalizes all the delimiter separated words in a String.\n     * Only the first character of each word is changed. To convert the\n     * rest of each word to lowercase at the same time,\n     * use {@link #capitalizeFully(String, char[])}.\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized.</p>\n     *\n     * <p>A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null, *)            = null\n     * WordUtils.capitalize(\"\", *)              = \"\"\n     * WordUtils.capitalize(*, new char[0])     = *\n     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n     * WordUtils.capitalize(\"i am fine\", new char[]{}) = \"I am fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, {@code null} if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n\n        boolean capitalizeNext = true;\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                capitalizeNext = true;\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            } else if (capitalizeNext) {\n                final int titleCaseCodePoint = Character.toTitleCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                capitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    /**\n     * Converts all the whitespace separated words in a String into capitalized words,\n     * that is each word is made up of a titlecase character and then a series of\n     * lowercase characters.\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null)        = null\n     * WordUtils.capitalizeFully(\"\")          = \"\"\n     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, {@code null} if null String input\n     */\n    public static String capitalizeFully(final String str) {\n        return capitalizeFully(str, null);\n    }\n\n    /**\n     * Converts all the delimiter separated words in a String into capitalized words,\n     * that is each word is made up of a titlecase character and then a series of\n     * lowercase characters.\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized.</p>\n     *\n     * <p>A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null, *)            = null\n     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n     * WordUtils.capitalizeFully(*, null)            = *\n     * WordUtils.capitalizeFully(*, new char[0])     = *\n     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, {@code null} if null String input\n     */\n    public static String capitalizeFully(String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        str = str.toLowerCase();\n        return capitalize(str, delimiters);\n    }\n\n    /**\n     * Checks if the String contains all words in the given array.\n     *\n     * <p>\n     * A {@code null} String will return {@code false}. A {@code null}, zero\n     * length search array or if one element of array is null will return {@code false}.\n     * </p>\n     *\n     * <pre>\n     * WordUtils.containsAllWords(null, *)            = false\n     * WordUtils.containsAllWords(\"\", *)              = false\n     * WordUtils.containsAllWords(*, null)            = false\n     * WordUtils.containsAllWords(*, [])              = false\n     * WordUtils.containsAllWords(\"abcd\", \"ab\", \"cd\") = false\n     * WordUtils.containsAllWords(\"abc def\", \"def\", \"abc\") = true\n     * </pre>\n     *\n     * @param word The CharSequence to check, may be null\n     * @param words The array of String words to search for, may be null\n     * @return {@code true} if all search words are found, {@code false} otherwise\n     */\n    public static boolean containsAllWords(final CharSequence word, final CharSequence... words) {\n        if (StringUtils.isEmpty(word) || ArrayUtils.isEmpty(words)) {\n            return false;\n        }\n        for (final CharSequence w : words) {\n            if (StringUtils.isBlank(w)) {\n                return false;\n            }\n            final Pattern p = Pattern.compile(\".*\\\\b\" + w + \"\\\\b.*\");\n            if (!p.matcher(word).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Converts an array of delimiters to a hash set of code points. Code point of space(32) is added as the default\n     * value if delimiters is null. The generated hash set provides O(1) lookup time.\n     *\n     * @param delimiters set of characters to determine capitalization, null means whitespace\n     * @return Set<Integer>\n     */\n    private static Set<Integer> generateDelimiterSet(final char[] delimiters) {\n        final Set<Integer> delimiterHashSet = new HashSet<>();\n        if (delimiters == null || delimiters.length == 0) {\n            if (delimiters == null) {\n                delimiterHashSet.add(Character.codePointAt(new char[] {' '}, 0));\n            }\n\n            return delimiterHashSet;\n        }\n\n        for (int index = 0; index < delimiters.length; index++) {\n            delimiterHashSet.add(Character.codePointAt(delimiters, index));\n        }\n        return delimiterHashSet;\n    }\n\n    /**\n     * Extracts the initial characters from each word in the String.\n     *\n     * <p>All first characters after whitespace are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null)             = null\n     * WordUtils.initials(\"\")               = \"\"\n     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @return String of initial letters, {@code null} if null String input\n     * @see #initials(String,char[])\n     */\n    public static String initials(final String str) {\n        return initials(str, null);\n    }\n\n    /**\n     * Extracts the initial characters from each word in the String.\n     *\n     * <p>All first characters after the defined delimiters are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>If the delimiters array is null, then Whitespace is used.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.\n     * An empty delimiter array returns an empty String.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null, *)                = null\n     * WordUtils.initials(\"\", *)                  = \"\"\n     * WordUtils.initials(\"Ben John Lee\", null)   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\", null)      = \"BJ\"\n     * WordUtils.initials(\"Ben J.Lee\", [' ','.']) = \"BJL\"\n     * WordUtils.initials(*, new char[0])         = \"\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @param delimiters  set of characters to determine words, null means whitespace\n     * @return String of initial characters, {@code null} if null String input\n     * @see #initials(String)\n     */\n    public static String initials(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (delimiters != null && delimiters.length == 0) {\n            return StringUtils.EMPTY;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen / 2 + 1];\n        int count = 0;\n        boolean lastWasGap = true;\n        for (int i = 0; i < strLen;) {\n            final int codePoint = str.codePointAt(i);\n\n            if (delimiterSet.contains(codePoint) || delimiters == null && Character.isWhitespace(codePoint)) {\n                lastWasGap = true;\n            } else if (lastWasGap) {\n                newCodePoints[count++] = codePoint;\n                lastWasGap = false;\n            }\n\n            i += Character.charCount(codePoint);\n        }\n        return new String(newCodePoints, 0, count);\n    }\n\n    /**\n     * Is the character a delimiter.\n     *\n     * @param ch the character to check\n     * @param delimiters the delimiters\n     * @return true if it is a delimiter\n     * @deprecated as of 1.2 and will be removed in 2.0\n     */\n    @Deprecated\n    public static boolean isDelimiter(final char ch, final char[] delimiters) {\n        if (delimiters == null) {\n            return Character.isWhitespace(ch);\n        }\n        for (final char delimiter : delimiters) {\n            if (ch == delimiter) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Is the codePoint a delimiter.\n     *\n     * @param codePoint the codePint to check\n     * @param delimiters the delimiters\n     * @return true if it is a delimiter\n     * @deprecated as of 1.2 and will be removed in 2.0\n     */\n    @Deprecated\n    public static boolean isDelimiter(final int codePoint, final char[] delimiters) {\n        if (delimiters == null) {\n            return Character.isWhitespace(codePoint);\n        }\n        for (int index = 0; index < delimiters.length; index++) {\n            final int delimiterCodePoint = Character.codePointAt(delimiters, index);\n            if (delimiterCodePoint == codePoint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Swaps the case of a String using a word based algorithm.\n     *\n     * <ul>\n     *  <li>Upper case character converts to Lower case</li>\n     *  <li>Title case character converts to Lower case</li>\n     *  <li>Lower case character after Whitespace or at start converts to Title case</li>\n     *  <li>Other Lower case character converts to Upper case</li>\n     * </ul>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * StringUtils.swapCase(null)                 = null\n     * StringUtils.swapCase(\"\")                   = \"\"\n     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n     * </pre>\n     *\n     * @param str  the String to swap case, may be null\n     * @return The changed String, {@code null} if null String input\n     */\n    public static String swapCase(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n        boolean whitespace = true;\n        for (int index = 0; index < strLen;) {\n            final int oldCodepoint = str.codePointAt(index);\n            final int newCodePoint;\n            if (Character.isUpperCase(oldCodepoint) || Character.isTitleCase(oldCodepoint)) {\n                newCodePoint = Character.toLowerCase(oldCodepoint);\n                whitespace = false;\n            } else if (Character.isLowerCase(oldCodepoint)) {\n                if (whitespace) {\n                    newCodePoint = Character.toTitleCase(oldCodepoint);\n                    whitespace = false;\n                } else {\n                    newCodePoint = Character.toUpperCase(oldCodepoint);\n                }\n            } else {\n                whitespace = Character.isWhitespace(oldCodepoint);\n                newCodePoint = oldCodepoint;\n            }\n            newCodePoints[outOffset++] = newCodePoint;\n            index += Character.charCount(newCodePoint);\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    /**\n     * Uncapitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed.\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null)        = null\n     * WordUtils.uncapitalize(\"\")          = \"\"\n     * WordUtils.uncapitalize(\"I Am FINE\") = \"i am fINE\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @return uncapitalized String, {@code null} if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str) {\n        return uncapitalize(str, null);\n    }\n\n    /**\n     * Uncapitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed.\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be uncapitalized.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null, *)            = null\n     * WordUtils.uncapitalize(\"\", *)              = \"\"\n     * WordUtils.uncapitalize(*, null)            = *\n     * WordUtils.uncapitalize(*, new char[0])     = *\n     * WordUtils.uncapitalize(\"I AM.FINE\", {'.'}) = \"i AM.fINE\"\n     * WordUtils.uncapitalize(\"I am fine\", new char[]{}) = \"i am fine\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @param delimiters  set of characters to determine uncapitalization, null means whitespace\n     * @return uncapitalized String, {@code null} if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n\n        boolean uncapitalizeNext = true;\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                uncapitalizeNext = true;\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            } else if (uncapitalizeNext) {\n                final int titleCaseCodePoint = Character.toLowerCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                uncapitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    /**\n     * Wraps a single line of text, identifying words by {@code ' '}.\n     *\n     * <p>New lines will be separated by the system property line separator.\n     * Very long words, such as URLs will <i>not</i> be wrapped.</p>\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttps://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here, https://commons.apache.org, to jump to the commons website\"</td>\n     *   <td>20</td>\n     *   <td>\"Click here,\\nhttps://commons.apache.org,\\nto jump to the\\ncommons website\"</td>\n     *  </tr>\n     * </table>\n     *\n     * (assuming that '\\n' is the systems line separator)\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @return a line with newlines inserted, {@code null} if null input\n     */\n    public static String wrap(final String str, final int wrapLength) {\n        return wrap(str, wrapLength, null, false);\n    }\n\n    /**\n     * Wraps a single line of text, identifying words by {@code ' '}.\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>newLineString</th>\n     *   <th>wrapLongWords</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"&lt;br /&gt;\"</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of&lt;br /&gt;text that is going&lt;\n     *   br /&gt;to be wrapped after&lt;br /&gt;20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>null</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of\" + systemNewLine + \"text that is going\"\n     *   + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>false</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttps://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apach\\ne.org\"</td>\n     *  </tr>\n     * </table>\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line,\n     *  {@code null} uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @return a line with newlines inserted, {@code null} if null input\n     */\n    public static String wrap(final String str,\n                              final int wrapLength,\n                              final String newLineStr,\n                              final boolean wrapLongWords) {\n        return wrap(str, wrapLength, newLineStr, wrapLongWords, \" \");\n    }\n\n    /**\n     * Wraps a single line of text, identifying words by {@code wrapOn}.\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>newLineString</th>\n     *   <th>wrapLongWords</th>\n     *   <th>wrapOn</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>*</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>*</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"&lt;br /&gt;\"</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of&lt;br /&gt;text that is going&lt;br /&gt;\n     *   to be wrapped after&lt;br /&gt;20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>null</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of\" + systemNewLine + \"text that is going\"\n     *   + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttps://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\" \"</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apach\\ne.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"flammable/inflammable\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\"/\"</td>\n     *   <td>\"flammable\\ninflammable\"</td>\n     *  </tr>\n     * </table>\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line,\n     *  {@code null} uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @param wrapOn regex expression to be used as a breakable characters,\n     *               if blank string is provided a space character will be used\n     * @return a line with newlines inserted, {@code null} if null input\n     */\n    public static String wrap(final String str,\n                              int wrapLength,\n                              String newLineStr,\n                              final boolean wrapLongWords,\n                              String wrapOn) {\n        if (str == null) {\n            return null;\n        }\n        if (newLineStr == null) {\n            newLineStr = System.lineSeparator();\n        }\n        if (wrapLength < 1) {\n            wrapLength = 1;\n        }\n        if (StringUtils.isBlank(wrapOn)) {\n            wrapOn = \" \";\n        }\n        final Pattern patternToWrapOn = Pattern.compile(wrapOn);\n        final int inputLineLength = str.length();\n        int offset = 0;\n        final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n        int matcherSize = -1;\n\n        while (offset < inputLineLength) {\n            int spaceToWrapAt = -1;\n            Matcher matcher = patternToWrapOn.matcher(str.substring(offset,\n                    Math.min((int) Math.min(Integer.MAX_VALUE, offset + wrapLength + 1L), inputLineLength)));\n            if (matcher.find()) {\n                if (matcher.start() == 0) {\n                    matcherSize = matcher.end();\n                    if (matcherSize != 0) {\n                        offset += matcher.end();\n                        continue;\n                    }\n                    offset += 1;\n                }\n                spaceToWrapAt = matcher.start() + offset;\n            }\n\n            // only last line without leading spaces is left\n            if (inputLineLength - offset <= wrapLength) {\n                break;\n            }\n\n            while (matcher.find()) {\n                spaceToWrapAt = matcher.start() + offset;\n            }\n\n            if (spaceToWrapAt >= offset) {\n                // normal case\n                wrappedLine.append(str, offset, spaceToWrapAt);\n                wrappedLine.append(newLineStr);\n                offset = spaceToWrapAt + 1;\n\n            } else // really long word or URL\n            if (wrapLongWords) {\n                if (matcherSize == 0) {\n                    offset--;\n                }\n                // wrap really long word one line at a time\n                wrappedLine.append(str, offset, wrapLength + offset);\n                wrappedLine.append(newLineStr);\n                offset += wrapLength;\n                matcherSize = -1;\n            } else {\n                // do not wrap really long word, just extend beyond limit\n                matcher = patternToWrapOn.matcher(str.substring(offset + wrapLength));\n                if (matcher.find()) {\n                    matcherSize = matcher.end() - matcher.start();\n                    spaceToWrapAt = matcher.start() + offset + wrapLength;\n                }\n\n                if (spaceToWrapAt >= 0) {\n                    if (matcherSize == 0 && offset != 0) {\n                        offset--;\n                    }\n                    wrappedLine.append(str, offset, spaceToWrapAt);\n                    wrappedLine.append(newLineStr);\n                    offset = spaceToWrapAt + 1;\n                } else {\n                    if (matcherSize == 0 && offset != 0) {\n                        offset--;\n                    }\n                    wrappedLine.append(str, offset, str.length());\n                    offset = inputLineLength;\n                    matcherSize = -1;\n                }\n            }\n        }\n\n        if (matcherSize == 0 && offset < inputLineLength) {\n            offset--;\n        }\n\n        // Whatever is left in line is short enough to just pass through\n        wrappedLine.append(str, offset, str.length());\n\n        return wrappedLine.toString();\n    }\n\n    /**\n     * {@code WordUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code WordUtils.wrap(\"foo bar\", 20);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public WordUtils() {\n    }\n }",
        "diff": " a/src/main/java/org/apache/commons/text/WordUtils.java b/src/main/java/org/apache/commons/text/WordUtils.java\nindex 561f1afe77..accd436fb4 100644\n--- a/src/main/java/org/apache/commons/text/WordUtils.java\n+++ b/src/main/java/org/apache/commons/text/WordUtils.java\n@@ -104,11 +104,7 @@ public static String abbreviate(final String str, int lower, int upper, final St\n                 result.append(StringUtils.defaultString(appendToEnd));\n             }\n         } else {\n-            if (index > upper) {\n-                result.append(str, 0, upper);\n-            } else {\n-                result.append(str, 0, index);\n-            }\n+            result.append(str, 0, Math.min(index, upper));\n             result.append(StringUtils.defaultString(appendToEnd));\n         }\n \n"
      }
    ]
  },
  {
    "pr_number": 316,
    "title": "Use Math.max() call instead of doing it manually.",
    "state": "closed",
    "created_at": "2022-04-17T19:17:42Z",
    "merge_commit_sha": "0705fa5e559b375187d0aeaba3c10c626eeea1ae",
    "base_sha": "67daeff6bf00e9fff2fbc020d1ba129beb9db832",
    "head_sha": "0235e0cca28b4f0f9fa6fa73a2a7fb72f801c38c",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/StrBuilder.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport org.junit.jupiter.api.Test;\n\npublic class StrBuilderTest2 {\n\n    @Test\n    public void testIndexOfCharWithNegativeStartIndex() {\n        StrBuilder sb = new StrBuilder(\"abab\");\n        assertEquals(0, sb.indexOf('a', -1));\n        assertEquals(0, sb.indexOf('a', 0));\n        assertEquals(2, sb.indexOf('a', 1));\n        assertEquals(-1, sb.indexOf('a', 4));\n        assertEquals(-1, sb.indexOf('a', 5));\n    }\n\n    @Test\n    public void testIndexOfStringWithNegativeStartIndex() {\n        StrBuilder sb = new StrBuilder(\"abab\");\n        assertEquals(0, sb.indexOf(\"a\", -1));\n        assertEquals(0, sb.indexOf(\"a\", 0));\n        assertEquals(2, sb.indexOf(\"a\", 1));\n        assertEquals(2, sb.indexOf(\"a\", 2));\n        assertEquals(-1, sb.indexOf(\"a\", 3));\n        assertEquals(-1, sb.indexOf(\"a\", 4));\n        assertEquals(-1, sb.indexOf(\"a\", 5));\n    }\n\n    @Test\n    public void testIndexOfStrMatcherWithNegativeStartIndex() {\n        StrBuilder sb = new StrBuilder(\"ab bd\");\n        assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a'), -2));\n        assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a'), 0));\n        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 2));\n        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 20));\n        assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), -1));\n        assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), 0));\n        assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), 1));\n        assertEquals(3, sb.indexOf(StrMatcher.charMatcher('b'), 2));\n        assertEquals(3, sb.indexOf(StrMatcher.charMatcher('b'), 3));\n        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 4));\n        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 5));\n        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 6));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.Writer;\nimport java.nio.CharBuffer;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * Builds a string from constituent parts providing a more flexible and powerful API\n * than StringBuffer.\n * <p>\n * The main differences from StringBuffer/StringBuilder are:\n * </p>\n * <ul>\n * <li>Not synchronized</li>\n * <li>Not final</li>\n * <li>Subclasses have direct access to character array</li>\n * <li>Additional methods\n *  <ul>\n *   <li>appendWithSeparators - adds an array of values, with a separator</li>\n *   <li>appendPadding - adds a length padding characters</li>\n *   <li>appendFixedLength - adds a fixed width field to the builder</li>\n *   <li>toCharArray/getChars - simpler ways to get a range of the character array</li>\n *   <li>delete - delete char or string</li>\n *   <li>replace - search and replace for a char or string</li>\n *   <li>leftString/rightString/midString - substring without exceptions</li>\n *   <li>contains - whether the builder contains a char or string</li>\n *   <li>size/clear/isEmpty - collections style API methods</li>\n *  </ul>\n * </li>\n * <li>Views\n *  <ul>\n *   <li>asTokenizer - uses the internal buffer as the source of a StrTokenizer</li>\n *   <li>asReader - uses the internal buffer as the source of a Reader</li>\n *   <li>asWriter - allows a Writer to write directly to the internal buffer</li>\n *  </ul>\n * </li>\n * </ul>\n * <p>\n * The aim has been to provide an API that mimics very closely what StringBuffer\n * provides, but with additional methods. It should be noted that some edge cases,\n * with invalid indices or null input, have been altered - see individual methods.\n * The biggest of these changes is that by default, null will not output the text\n * 'null'. This can be controlled by a property, {@link #setNullText(String)}.\n * </p>\n *\n * @since 1.0\n * @deprecated Deprecated as of 1.3, use {@link TextStringBuilder} instead. This class will be removed in 2.0.\n */\n@Deprecated\npublic class StrBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Inner class to allow StrBuilder to operate as a reader.\n     */\n    class StrBuilderReader extends Reader {\n\n        /** The current stream position. */\n        private int pos;\n\n        /** The last mark position. */\n        private int mark;\n\n        /**\n         * Default constructor.\n         */\n        StrBuilderReader() {\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void mark(final int readAheadLimit) {\n            mark = pos;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean markSupported() {\n            return true;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int read() {\n            if (!ready()) {\n                return -1;\n            }\n            return StrBuilder.this.charAt(pos++);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int read(final char[] b, final int off, int len) {\n            if (off < 0 || len < 0 || off > b.length\n                    || off + len > b.length || off + len < 0) {\n                throw new IndexOutOfBoundsException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            if (pos >= StrBuilder.this.size()) {\n                return -1;\n            }\n            if (pos + len > size()) {\n                len = StrBuilder.this.size() - pos;\n            }\n            StrBuilder.this.getChars(pos, pos + len, b, off);\n            pos += len;\n            return len;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean ready() {\n            return pos < StrBuilder.this.size();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void reset() {\n            pos = mark;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public long skip(long n) {\n            if (pos + n > StrBuilder.this.size()) {\n                n = StrBuilder.this.size() - pos;\n            }\n            if (n < 0) {\n                return 0;\n            }\n            pos = Math.addExact(pos, Math.toIntExact(n));\n            return n;\n        }\n    }\n\n    /**\n     * Inner class to allow StrBuilder to operate as a tokenizer.\n     */\n    class StrBuilderTokenizer extends StrTokenizer {\n\n        /**\n         * Default constructor.\n         */\n        StrBuilderTokenizer() {\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public String getContent() {\n            final String str = super.getContent();\n            if (str == null) {\n                return StrBuilder.this.toString();\n            }\n            return str;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n            if (chars == null) {\n                return super.tokenize(\n                        StrBuilder.this.buffer, 0, StrBuilder.this.size());\n            }\n            return super.tokenize(chars, offset, count);\n        }\n    }\n\n    /**\n     * Inner class to allow StrBuilder to operate as a writer.\n     */\n    class StrBuilderWriter extends Writer {\n\n        /**\n         * Default constructor.\n         */\n        StrBuilderWriter() {\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void flush() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final char[] cbuf) {\n            StrBuilder.this.append(cbuf);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final char[] cbuf, final int off, final int len) {\n            StrBuilder.this.append(cbuf, off, len);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final int c) {\n            StrBuilder.this.append((char) c);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final String str) {\n            StrBuilder.this.append(str);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final String str, final int off, final int len) {\n            StrBuilder.this.append(str, off, len);\n        }\n    }\n\n    /**\n     * The extra capacity for new builders.\n     */\n    static final int CAPACITY = 32;\n\n    /**\n     * Required for serialization support.\n     *\n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 7628716375283629643L;\n\n    /** Internal data storage. */\n    char[] buffer; // package-protected for test code use only\n\n    /** Current size of the buffer. */\n    private int size;\n\n    /** The new line. */\n    private String newLine;\n\n    /** The null text. */\n    private String nullText;\n\n    /**\n     * Constructs an empty builder initial capacity 32 characters.\n     */\n    public StrBuilder() {\n        this(CAPACITY);\n    }\n\n    /**\n     * Constructs an empty builder the specified initial capacity.\n     *\n     * @param initialCapacity  the initial capacity, zero or less will be converted to 32\n     */\n    public StrBuilder(int initialCapacity) {\n        if (initialCapacity <= 0) {\n            initialCapacity = CAPACITY;\n        }\n        buffer = new char[initialCapacity];\n    }\n\n    /**\n     * Constructs a builder from the string, allocating\n     * 32 extra characters for growth.\n     *\n     * @param str  the string to copy, null treated as blank string\n     */\n    public StrBuilder(final String str) {\n        if (str == null) {\n            buffer = new char[CAPACITY];\n        } else {\n            buffer = new char[str.length() + CAPACITY];\n            append(str);\n        }\n    }\n\n    /**\n     * Appends a boolean value to the string builder.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final boolean value) {\n        if (value) {\n            ensureCapacity(size + 4);\n            buffer[size++] = 't';\n            buffer[size++] = 'r';\n            buffer[size++] = 'u';\n            buffer[size++] = 'e';\n        } else {\n            ensureCapacity(size + 5);\n            buffer[size++] = 'f';\n            buffer[size++] = 'a';\n            buffer[size++] = 'l';\n            buffer[size++] = 's';\n            buffer[size++] = 'e';\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char value to the string builder.\n     *\n     * @param ch  the value to append\n     * @return this, to enable chaining\n     */\n    @Override\n    public StrBuilder append(final char ch) {\n        final int len = length();\n        ensureCapacity(len + 1);\n        buffer[size++] = ch;\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param chars  the char array to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final char[] chars) {\n        if (chars == null) {\n            return appendNull();\n        }\n        final int strLen = chars.length;\n        if (strLen > 0) {\n            final int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(chars, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param chars  the char array to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final char[] chars, final int startIndex, final int length) {\n        if (chars == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n        }\n        if (length < 0 || startIndex + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(chars, startIndex, buffer, len, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends the contents of a char buffer to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param buf  the char buffer to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final CharBuffer buf) {\n        if (buf == null) {\n            return appendNull();\n        }\n        if (buf.hasArray()) {\n            final int length = buf.remaining();\n            final int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(buf.array(), buf.arrayOffset() + buf.position(), buffer, len, length);\n            size += length;\n        } else {\n            append(buf.toString());\n        }\n        return this;\n    }\n\n    /**\n     * Appends the contents of a char buffer to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param buf  the char buffer to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final CharBuffer buf, final int startIndex, final int length) {\n        if (buf == null) {\n            return appendNull();\n        }\n        if (buf.hasArray()) {\n            final int totalLength = buf.remaining();\n            if (startIndex < 0 || startIndex > totalLength) {\n                throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n            }\n            if (length < 0 || startIndex + length > totalLength) {\n                throw new StringIndexOutOfBoundsException(\"length must be valid\");\n            }\n            final int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(buf.array(), buf.arrayOffset() + buf.position() + startIndex, buffer, len, length);\n            size += length;\n        } else {\n            append(buf.toString(), startIndex, length);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a CharSequence to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param seq  the CharSequence to append\n     * @return this, to enable chaining\n     */\n    @Override\n    public StrBuilder append(final CharSequence seq) {\n        if (seq == null) {\n            return appendNull();\n        }\n        if (seq instanceof StrBuilder) {\n            return append((StrBuilder) seq);\n        }\n        if (seq instanceof StringBuilder) {\n            return append((StringBuilder) seq);\n        }\n        if (seq instanceof StringBuffer) {\n            return append((StringBuffer) seq);\n        }\n        if (seq instanceof CharBuffer) {\n            return append((CharBuffer) seq);\n        }\n        return append(seq.toString());\n    }\n\n    /**\n     * Appends part of a CharSequence to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param seq  the CharSequence to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    @Override\n    public StrBuilder append(final CharSequence seq, final int startIndex, final int length) {\n        if (seq == null) {\n            return appendNull();\n        }\n        return append(seq.toString(), startIndex, length);\n    }\n\n    /**\n     * Appends a double value to the string builder using {@code String.valueOf}.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final double value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a float value to the string builder using {@code String.valueOf}.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final float value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends an int value to the string builder using {@code String.valueOf}.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final int value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a long value to the string builder using {@code String.valueOf}.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final long value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends an object to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param obj  the object to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final Object obj) {\n        if (obj == null) {\n            return appendNull();\n        }\n        if (obj instanceof CharSequence) {\n            return append((CharSequence) obj);\n        }\n        return append(obj.toString());\n    }\n\n    /**\n     * Appends another string builder to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string builder to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final StrBuilder str) {\n        if (str == null) {\n            return appendNull();\n        }\n        final int strLen = str.length();\n        if (strLen > 0) {\n            final int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(str.buffer, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends part of a string builder to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final StrBuilder str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a string to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final String str) {\n        if (str == null) {\n            return appendNull();\n        }\n        final int strLen = str.length();\n        if (strLen > 0) {\n            final int len = length();\n            ensureCapacity(len + strLen);\n            str.getChars(0, strLen, buffer, len);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends part of a string to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final String str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Calls {@link String#format(String, Object...)} and appends the result.\n     *\n     * @param format the format string\n     * @param objs the objects to use in the format string\n     * @return {@code this} to enable chaining\n     * @see String#format(String, Object...)\n     */\n    public StrBuilder append(final String format, final Object... objs) {\n        return append(String.format(format, objs));\n    }\n\n    /**\n     * Appends a string buffer to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string buffer to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final StringBuffer str) {\n        if (str == null) {\n            return appendNull();\n        }\n        final int strLen = str.length();\n        if (strLen > 0) {\n            final int len = length();\n            ensureCapacity(len + strLen);\n            str.getChars(0, strLen, buffer, len);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends part of a string buffer to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final StringBuffer str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a StringBuilder to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str the StringBuilder to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final StringBuilder str) {\n        if (str == null) {\n            return appendNull();\n        }\n        final int strLen = str.length();\n        if (strLen > 0) {\n            final int len = length();\n            ensureCapacity(len + strLen);\n            str.getChars(0, strLen, buffer, len);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends part of a StringBuilder to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str the StringBuilder to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(final StringBuilder str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an iterable to the builder without any separators.\n     * Appending a null iterable will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param iterable  the iterable to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendAll(final Iterable<?> iterable) {\n        if (iterable != null) {\n            for (final Object o : iterable) {\n                append(o);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an iterator to the builder without any separators.\n     * Appending a null iterator will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param it  the iterator to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendAll(final Iterator<?> it) {\n        if (it != null) {\n            while (it.hasNext()) {\n                append(it.next());\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an array to the builder without any separators.\n     * Appending a null array will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param <T>  the element type\n     * @param array  the array to append\n     * @return this, to enable chaining\n     */\n    public <T> StrBuilder appendAll(@SuppressWarnings(\"unchecked\") final T... array) {\n        /*\n         * @SuppressWarnings used to hide warning about vararg usage. We cannot\n         * use @SafeVarargs, since this method is not final. Using @SuppressWarnings\n         * is fine, because it isn't inherited by subclasses, so each subclass must\n         * vouch for itself whether its use of 'array' is safe.\n         */\n        if (array != null && array.length > 0) {\n            for (final Object element : array) {\n                append(element);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The {@code String.valueOf} of the {@code int} value is used.\n     * If the formatted value is larger than the length, the left hand side is lost.\n     *\n     * @param value  the value to append\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {\n        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The {@code toString} of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     *\n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = obj == null ? getNullText() : obj.toString();\n            if (str == null) {\n                str = StringUtils.EMPTY;\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The {@code String.valueOf} of the {@code int} value is used.\n     * If the object is larger than the length, the right hand side is lost.\n     *\n     * @param value  the value to append\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {\n        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The {@code toString} of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     *\n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = obj == null ? getNullText() : obj.toString();\n            if (str == null) {\n                str = StringUtils.EMPTY;\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a boolean value followed by a new line to the string builder.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final boolean value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a char value followed by a new line to the string builder.\n     *\n     * @param ch  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final char ch) {\n        return append(ch).appendNewLine();\n    }\n\n    /**\n     * Appends a char array followed by a new line to the string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param chars  the char array to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final char[] chars) {\n        return append(chars).appendNewLine();\n    }\n\n    /**\n     * Appends a char array followed by a new line to the string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param chars  the char array to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final char[] chars, final int startIndex, final int length) {\n        return append(chars, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends a double value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final double value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a float value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final float value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends an int value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final int value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a long value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final long value) {\n        return append(value).appendNewLine();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends an object followed by a new line to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param obj  the object to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final Object obj) {\n        return append(obj).appendNewLine();\n    }\n\n    /**\n     * Appends another string builder followed by a new line to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string builder to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final StrBuilder str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string builder followed by a new line to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final StrBuilder str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends a string followed by a new line to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final String str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string followed by a new line to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final String str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Calls {@link String#format(String, Object...)} and appends the result.\n     *\n     * @param format the format string\n     * @param objs the objects to use in the format string\n     * @return {@code this} to enable chaining\n     * @see String#format(String, Object...)\n     */\n    public StrBuilder appendln(final String format, final Object... objs) {\n        return append(format, objs).appendNewLine();\n    }\n\n    /**\n     * Appends a string buffer followed by a new line to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string buffer to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final StringBuffer str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string buffer followed by a new line to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final StringBuffer str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends a string builder followed by a new line to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string builder to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final StringBuilder str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string builder followed by a new line to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string builder to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendln(final StringBuilder str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends the new line string to this string builder.\n     * <p>\n     * The new line string can be altered using {@link #setNewLineText(String)}.\n     * This might be used to force the output to always use Unix line endings\n     * even when on Windows.\n     * </p>\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendNewLine() {\n        if (newLine == null)  {\n            append(System.lineSeparator());\n            return this;\n        }\n        return append(newLine);\n    }\n\n    /**\n     * Appends the text representing {@code null} to this string builder.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendNull() {\n        if (nullText == null)  {\n            return this;\n        }\n        return append(nullText);\n    }\n\n    /**\n     * Appends the pad character to the builder the specified number of times.\n     *\n     * @param length  the length to append, negative means no append\n     * @param padChar  the character to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendPadding(final int length, final char padChar) {\n        if (length >= 0) {\n            ensureCapacity(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator if the builder is currently non-empty.\n     * The separator is appended using {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the\n     * loop except the first.\n     * </p>\n     * <pre>\n     * for (Iterator it = list.iterator(); it.hasNext();){\n     *   appendSeparator(',');\n     *   append(it.next());\n     * }\n     * </pre>\n     * <p>\n     * Note that for this simple example, you should use\n     * {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator  the separator to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendSeparator(final char separator) {\n        if (isNotEmpty()) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends one of both separators to the builder\n     * If the builder is currently empty it will append the defaultIfEmpty-separator\n     * Otherwise it will append the standard-separator\n     *\n     * The separator is appended using {@link #append(char)}.\n     * @param standard the separator if builder is not empty\n     * @param defaultIfEmpty the separator if builder is empty\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendSeparator(final char standard, final char defaultIfEmpty) {\n        if (isNotEmpty()) {\n            append(standard);\n        } else {\n            append(defaultIfEmpty);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero.\n     * The separator is appended using {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the\n     * loop except the first.\n     * </p>\n     * <pre>\n     * for (int i = 0; i &lt; list.size(); i++) {\n     *   appendSeparator(\",\", i);\n     *   append(list.get(i));\n     * }\n     * </pre>\n     * <p>\n     * Note that for this simple example, you should use\n     * {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator  the separator to use\n     * @param loopIndex  the loop index\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendSeparator(final char separator, final int loopIndex) {\n        if (loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator if the builder is currently non-empty.\n     * Appending a null separator will have no effect.\n     * The separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is useful for adding a separator each time around the\n     * loop except the first.\n     * </p>\n     * <pre>\n     * for (Iterator it = list.iterator(); it.hasNext();){\n     *   appendSeparator(\",\");\n     *   append(it.next());\n     * }\n     * </pre>\n     * <p>\n     * Note that for this simple example, you should use\n     * {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator  the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendSeparator(final String separator) {\n        return appendSeparator(separator, null);\n    }\n\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero.\n     * Appending a null separator will have no effect.\n     * The separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is useful for adding a separator each time around the\n     * loop except the first.\n     * </p>\n     * <pre>\n     * for (int i = 0; i &lt; list.size(); i++) {\n     *   appendSeparator(\",\", i);\n     *   append(list.get(i));\n     * }\n     * </pre>\n     * <p>\n     * Note that for this simple example, you should use\n     * {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator  the separator to use, null means no separator\n     * @param loopIndex  the loop index\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendSeparator(final String separator, final int loopIndex) {\n        if (separator != null && loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends one of both separators to the StrBuilder.\n     * If the builder is currently empty it will append the defaultIfEmpty-separator\n     * Otherwise it will append the standard-separator\n     * <p>\n     * Appending a null separator will have no effect.\n     * The separator is appended using {@link #append(String)}.\n     * </p>\n     * <p>\n     * This method is for example useful for constructing queries\n     * </p>\n     * <pre>\n     * StrBuilder whereClause = new StrBuilder();\n     * if(searchCommand.getPriority() != null) {\n     *   whereClause.appendSeparator(\" and\", \" where\");\n     *   whereClause.append(\" priority = ?\")\n     * }\n     * if(searchCommand.getComponent() != null) {\n     *   whereClause.appendSeparator(\" and\", \" where\");\n     *   whereClause.append(\" component = ?\")\n     * }\n     * selectClause.append(whereClause)\n     * </pre>\n     *\n     * @param standard the separator if builder is not empty, null means no separator\n     * @param defaultIfEmpty the separator if builder is empty, null means no separator\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendSeparator(final String standard, final String defaultIfEmpty) {\n        final String str = isEmpty() ? defaultIfEmpty : standard;\n        if (str != null) {\n            append(str);\n        }\n        return this;\n    }\n\n    /**\n     * Appends current contents of this {@code StrBuilder} to the\n     * provided {@link Appendable}.\n     * <p>\n     * This method tries to avoid doing any extra copies of contents.\n     * </p>\n     *\n     * @param appendable  the appendable to append data to\n     * @throws IOException  if an I/O error occurs\n     *\n     * @see #readFrom(Readable)\n     */\n    public void appendTo(final Appendable appendable) throws IOException {\n        if (appendable instanceof Writer) {\n            ((Writer) appendable).write(buffer, 0, size);\n        } else if (appendable instanceof StringBuilder) {\n            ((StringBuilder) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof StringBuffer) {\n            ((StringBuffer) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof CharBuffer) {\n            ((CharBuffer) appendable).put(buffer, 0, size);\n        } else {\n            appendable.append(this);\n        }\n    }\n\n    /**\n     * Appends an iterable placing separators between each value, but\n     * not before the first or after the last.\n     * Appending a null iterable will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param iterable  the iterable to append\n     * @param separator  the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendWithSeparators(final Iterable<?> iterable, final String separator) {\n        if (iterable != null) {\n            final String sep = Objects.toString(separator, StringUtils.EMPTY);\n            final Iterator<?> it = iterable.iterator();\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(sep);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends an iterator placing separators between each value, but\n     * not before the first or after the last.\n     * Appending a null iterator will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param it  the iterator to append\n     * @param separator  the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendWithSeparators(final Iterator<?> it, final String separator) {\n        if (it != null) {\n            final String sep = Objects.toString(separator, StringUtils.EMPTY);\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(sep);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends an array placing separators between each value, but\n     * not before the first or after the last.\n     * Appending a null array will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param array  the array to append\n     * @param separator  the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendWithSeparators(final Object[] array, final String separator) {\n        if (array != null && array.length > 0) {\n            final String sep = Objects.toString(separator, StringUtils.EMPTY);\n            append(array[0]);\n            for (int i = 1; i < array.length; i++) {\n                append(sep);\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Gets the contents of this builder as a Reader.\n     * <p>\n     * This method allows the contents of the builder to be read\n     * using any standard method that expects a Reader.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder}, populate it with\n     * data, call {@code asReader}, and then read away.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the reader.\n     * This allows you to append to the builder after creating the reader,\n     * and the changes will be picked up.\n     * Note however, that no synchronization occurs, so you must perform\n     * all operations with the builder and the reader in one thread.\n     * </p>\n     * <p>\n     * The returned reader supports marking, and ignores the flush method.\n     * </p>\n     *\n     * @return a reader that reads from this builder\n     */\n    public Reader asReader() {\n        return new StrBuilderReader();\n    }\n\n    /**\n     * Creates a tokenizer that can tokenize the contents of this builder.\n     * <p>\n     * This method allows the contents of this builder to be tokenized.\n     * The tokenizer will be setup by default to tokenize on space, tab,\n     * newline and form feed (as per StringTokenizer). These values can be\n     * changed on the tokenizer class, before retrieving the tokens.\n     * </p>\n     * <p>\n     * The returned tokenizer is linked to this builder. You may intermix\n     * calls to the builder and tokenizer within certain limits, however\n     * there is no synchronization. Once the tokenizer has been used once,\n     * it must be {@link StrTokenizer#reset() reset} to pickup the latest\n     * changes in the builder. For example:\n     * </p>\n     * <pre>\n     * StrBuilder b = new StrBuilder();\n     * b.append(\"a b \");\n     * StrTokenizer t = b.asTokenizer();\n     * String[] tokens1 = t.getTokenArray();  // returns a,b\n     * b.append(\"c d \");\n     * String[] tokens2 = t.getTokenArray();  // returns a,b (c and d ignored)\n     * t.reset();              // reset causes builder changes to be picked up\n     * String[] tokens3 = t.getTokenArray();  // returns a,b,c,d\n     * </pre>\n     * <p>\n     * In addition to simply intermixing appends and tokenization, you can also\n     * call the set methods on the tokenizer to alter how it tokenizes. Just\n     * remember to call reset when you want to pickup builder changes.\n     * </p>\n     * <p>\n     * Calling {@link StrTokenizer#reset(String)} or {@link StrTokenizer#reset(char[])}\n     * with a non-null value will break the link with the builder.\n     * </p>\n     *\n     * @return a tokenizer that is linked to this builder\n     */\n    public StrTokenizer asTokenizer() {\n        return new StrBuilderTokenizer();\n    }\n\n    /**\n     * Gets this builder as a Writer that can be written to.\n     * <p>\n     * This method allows you to populate the contents of the builder\n     * using any standard method that takes a Writer.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder},\n     * call {@code asWriter}, and populate away. The data is available\n     * at any time using the methods of the {@code StrBuilder}.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the writer.\n     * This allows you to intermix calls that append to the builder and\n     * write using the writer and the changes will be occur correctly.\n     * Note however, that no synchronization occurs, so you must perform\n     * all operations with the builder and the writer in one thread.\n     * </p>\n     * <p>\n     * The returned writer ignores the close and flush methods.\n     * </p>\n     *\n     * @return a writer that populates this builder\n     */\n    public Writer asWriter() {\n        return new StrBuilderWriter();\n    }\n\n    /**\n     * Builds a string.\n     *\n     * @return The builder as a String\n     * @see #toString()\n     */\n    @Override\n    public String build() {\n        return toString();\n    }\n\n    /**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return The capacity\n     */\n    public int capacity() {\n        return buffer.length;\n    }\n\n    /**\n     * Gets the character at the specified index.\n     *\n     * @see #setCharAt(int, char)\n     * @see #deleteCharAt(int)\n     * @param index  the index to retrieve, must be valid\n     * @return The character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    @Override\n    public char charAt(final int index) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        return buffer[index];\n    }\n\n    /**\n     * Clears the string builder (convenience Collections API style method).\n     * <p>\n     * This method does not reduce the size of the internal character buffer.\n     * To do that, call {@code clear()} followed by {@link #minimizeCapacity()}.\n     * </p>\n     * <p>\n     * This method is the same as {@link #setLength(int)} called with zero\n     * and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder clear() {\n        size = 0;\n        return this;\n    }\n\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n    public boolean contains(final char ch) {\n        final char[] thisBuf = buffer;\n        for (int i = 0; i < this.size; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Tests if the string builder contains the specified string.\n     *\n     * @param str  the string to find\n     * @return true if the builder contains the string\n     */\n    public boolean contains(final String str) {\n        return indexOf(str, 0) >= 0;\n    }\n\n    /**\n     * Tests if the string builder contains a string matched using the\n     * specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior.\n     * For example you could write a matcher to search for the character\n     * 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return true if the matcher finds a match in the builder\n     */\n    public boolean contains(final StrMatcher matcher) {\n        return indexOf(matcher, 0) >= 0;\n    }\n\n    /**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder delete(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, endIndex, len);\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                final int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                final int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(final String str) {\n        final int len = str == null ? 0 : str.length();\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            while (index >= 0) {\n                deleteImpl(index, index + len, len);\n                index = indexOf(str, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes all parts of the builder that the matcher matches.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior.\n     * For example you could write a matcher to delete all occurrences\n     * where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(final StrMatcher matcher) {\n        return replace(matcher, null, 0, size, -1);\n    }\n\n    /**\n     * Deletes the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #setCharAt(int, char)\n     * @param index  the index to delete\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder deleteCharAt(final int index) {\n        if (index < 0 || index >= size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        deleteImpl(index, index + 1, 1);\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(final String str) {\n        final int len = str == null ? 0 : str.length();\n        if (len > 0) {\n            final int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the first match within the builder using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior.\n     * For example you could write a matcher to delete\n     * where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(final StrMatcher matcher) {\n        return replace(matcher, null, 0, size, 1);\n    }\n\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex  the start index, must be valid\n     * @param endIndex  the end index (exclusive), must be valid\n     * @param len  the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void deleteImpl(final int startIndex, final int endIndex, final int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    /**\n     * Tests whether this builder ends with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str  the string to search for, null returns false\n     * @return true if the builder ends with the string\n     */\n    public boolean endsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        int pos = size - len;\n        for (int i = 0; i < len; i++, pos++) {\n            if (buffer[pos] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests the capacity and ensures that it is at least the size specified.\n     *\n     * @param capacity  the capacity to ensure\n     * @return this, to enable chaining\n     */\n    public StrBuilder ensureCapacity(final int capacity) {\n        if (capacity > buffer.length) {\n            final char[] old = buffer;\n            buffer = new char[capacity * 2];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }\n\n    /**\n     * Tests the contents of this builder against another to see if they\n     * contain the same character content.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        return obj instanceof StrBuilder\n                && equals((StrBuilder) obj);\n    }\n\n    /**\n     * Tests the contents of this builder against another to see if they\n     * contain the same character content.\n     *\n     * @param other  the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equals(final StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (other == null) {\n            return false;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        final char[] thisBuf = this.buffer;\n        final char[] otherBuf = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            if (thisBuf[i] != otherBuf[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests the contents of this builder against another to see if they\n     * contain the same character content ignoring case.\n     *\n     * @param other  the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equalsIgnoreCase(final StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        final char[] thisBuf = this.buffer;\n        final char[] otherBuf = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            final char c1 = thisBuf[i];\n            final char c2 = otherBuf[i];\n            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Copies the character array into the specified array.\n     *\n     * @param destination  the destination array, null will cause an array to be created\n     * @return The input array, unless that was null or too small\n     */\n    public char[] getChars(char[] destination) {\n        final int len = length();\n        if (destination == null || destination.length < len) {\n            destination = new char[len];\n        }\n        System.arraycopy(buffer, 0, destination, 0, len);\n        return destination;\n    }\n\n    /**\n     * Copies the character array into the specified array.\n     *\n     * @param startIndex  first index to copy, inclusive, must be valid\n     * @param endIndex  last index, exclusive, must be valid\n     * @param destination  the destination array, must not be null or too small\n     * @param destinationIndex  the index to start copying in destination\n     * @throws NullPointerException if the array is null\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    public void getChars(final int startIndex,\n                         final int endIndex,\n                         final char[] destination,\n                         final int destinationIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex < 0 || endIndex > length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Gets the text to be appended when a new line is added.\n     *\n     * @return The new line text, null means use system default\n     */\n    public String getNewLineText() {\n        return newLine;\n    }\n\n    /**\n     * Gets the text to be appended when null is added.\n     *\n     * @return The null text, null means no append\n     */\n    public String getNullText() {\n        return nullText;\n    }\n\n    /**\n     * Gets a suitable hash code for this builder.\n     *\n     * @return a hash code\n     */\n    @Override\n    public int hashCode() {\n        final char[] buf = buffer;\n        int hash = 0;\n        for (int i = size - 1; i >= 0; i--) {\n            hash = 31 * hash + buf[i];\n        }\n        return hash;\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     *\n     * @param ch  the character to find\n     * @return The first index of the character, or -1 if not found\n     */\n    public int indexOf(final char ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     *\n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return The first index of the character, or -1 if not found\n     */\n    public int indexOf(final char ch, int startIndex) {\n        startIndex = startIndex < 0 ? 0 : startIndex;\n        if (startIndex >= size) {\n            return -1;\n        }\n        final char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str  the string to find, null returns -1\n     * @return The first index of the string, or -1 if not found\n     */\n    public int indexOf(final String str) {\n        return indexOf(str, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return The first index of the string, or -1 if not found\n     */\n    public int indexOf(final String str, int startIndex) {\n        startIndex = startIndex < 0 ? 0 : startIndex;\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        final int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        final char[] thisBuf = buffer;\n        final int len = size - strLen + 1;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior.\n     * For example you could write a matcher to find the character 'a'\n     * followed by a number.\n     * </p>\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return The first index matched, or -1 if not found\n     */\n    public int indexOf(final StrMatcher matcher) {\n        return indexOf(matcher, 0);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first\n     * match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior.\n     * For example you could write a matcher to find the character 'a'\n     * followed by a number.\n     * </p>\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return The first index matched, or -1 if not found\n     */\n    public int indexOf(final StrMatcher matcher, int startIndex) {\n        startIndex = startIndex < 0 ? 0 : startIndex;\n        if (matcher == null || startIndex >= size) {\n            return -1;\n        }\n        final int len = size;\n        final char[] buf = buffer;\n        for (int i = startIndex; i < len; i++) {\n            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, final boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + 4);\n            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n            buffer[index++] = 't';\n            buffer[index++] = 'r';\n            buffer[index++] = 'u';\n            buffer[index] = 'e';\n            size += 4;\n        } else {\n            ensureCapacity(size + 5);\n            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n            buffer[index++] = 'f';\n            buffer[index++] = 'a';\n            buffer[index++] = 'l';\n            buffer[index++] = 's';\n            buffer[index] = 'e';\n            size += 5;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Inserts the character array into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param chars  the char array to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final char[] chars) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        final int len = chars.length;\n        if (len > 0) {\n            ensureCapacity(size + len);\n            System.arraycopy(buffer, index, buffer, index + len, size - index);\n            System.arraycopy(chars, 0, buffer, index, len);\n            size += len;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts part of the character array into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param chars  the char array to insert\n     * @param offset  the offset into the character array to start at, must be valid\n     * @param length  the length of the character array part to copy, must be positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    public StrBuilder insert(final int index, final char[] chars, final int offset, final int length) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        if (offset < 0 || offset > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n        }\n        if (length < 0 || offset + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            ensureCapacity(size + length);\n            System.arraycopy(buffer, index, buffer, index + length, size - index);\n            System.arraycopy(chars, offset, buffer, index, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inserts the string representation of an object into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param obj  the object to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, final Object obj) {\n        if (obj == null) {\n            return insert(index, nullText);\n        }\n        return insert(index, obj.toString());\n    }\n\n    /**\n     * Inserts the string into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param str  the string to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(final int index, String str) {\n        validateIndex(index);\n        if (str == null) {\n            str = nullText;\n        }\n        if (str != null) {\n            final int strLen = str.length();\n            if (strLen > 0) {\n                final int newSize = size + strLen;\n                ensureCapacity(newSize);\n                System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n                size = newSize;\n                str.getChars(0, strLen, buffer, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tests if the string builder is empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the\n     * API of Collections.\n     * </p>\n     *\n     * @return {@code true} if the size is {@code 0}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Tests if the string builder is not empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the\n     * API of Collections.\n     * </p>\n     *\n     * @return {@code true} if the size is greater than {@code 0}.\n     * @since 1.10.0\n     */\n    public boolean isNotEmpty() {\n        return size > 0;\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     *\n     * @param ch  the character to find\n     * @return The last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(final char ch) {\n        return lastIndexOf(ch, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     *\n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return The last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(final char ch, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (startIndex < 0) {\n            return -1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (buffer[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str  the string to find, null returns -1\n     * @return The last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(final String str) {\n        return lastIndexOf(str, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return The last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(final String str, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (str == null || startIndex < 0) {\n            return -1;\n        }\n        final int strLen = str.length();\n        if (strLen > 0 && strLen <= size) {\n            if (strLen == 1) {\n                return lastIndexOf(str.charAt(0), startIndex);\n            }\n\n            outer:\n            for (int i = startIndex - strLen + 1; i >= 0; i--) {\n                for (int j = 0; j < strLen; j++) {\n                    if (str.charAt(j) != buffer[i + j]) {\n                        continue outer;\n                    }\n                }\n                return i;\n            }\n\n        } else if (strLen == 0) {\n            return startIndex;\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last match.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior.\n     * For example you could write a matcher to find the character 'a'\n     * followed by a number.\n     * </p>\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return The last index matched, or -1 if not found\n     */\n    public int lastIndexOf(final StrMatcher matcher) {\n        return lastIndexOf(matcher, size);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last\n     * match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior.\n     * For example you could write a matcher to find the character 'a'\n     * followed by a number.\n     * </p>\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return The last index matched, or -1 if not found\n     */\n    public int lastIndexOf(final StrMatcher matcher, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (matcher == null || startIndex < 0) {\n            return -1;\n        }\n        final char[] buf = buffer;\n        final int endIndex = startIndex + 1;\n        for (int i = startIndex; i >= 0; i--) {\n            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Extracts the leftmost characters from the string builder without\n     * throwing an exception.\n     * <p>\n     * This method extracts the left {@code length} characters from\n     * the builder. If this many characters are not available, the whole\n     * builder is returned. Thus the returned string may be shorter than the\n     * length requested.\n     * </p>\n     *\n     * @param length  the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String leftString(final int length) {\n        if (length <= 0) {\n            return StringUtils.EMPTY;\n        }\n        if (length >= size) {\n            return new String(buffer, 0, size);\n        }\n        return new String(buffer, 0, length);\n    }\n\n    /**\n     * Gets the length of the string builder.\n     *\n     * @return The length\n     */\n    @Override\n    public int length() {\n        return size;\n    }\n\n    /**\n     * Extracts some characters from the middle of the string builder without\n     * throwing an exception.\n     * <p>\n     * This method extracts {@code length} characters from the builder\n     * at the specified index.\n     * If the index is negative it is treated as zero.\n     * If the index is greater than the builder size, it is treated as the builder size.\n     * If the length is negative, the empty string is returned.\n     * If insufficient characters are available in the builder, as much as possible is returned.\n     * Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param index  the index to start at, negative means zero\n     * @param length  the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String midString(int index, final int length) {\n        if (index < 0) {\n            index = 0;\n        }\n        if (length <= 0 || index >= size) {\n            return StringUtils.EMPTY;\n        }\n        if (size <= index + length) {\n            return new String(buffer, index, size - index);\n        }\n        return new String(buffer, index, length);\n    }\n\n    /**\n     * Minimizes the capacity to the actual length of the string.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder minimizeCapacity() {\n        if (buffer.length > length()) {\n            final char[] old = buffer;\n            buffer = new char[length()];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }\n\n    /**\n     * If possible, reads chars from the provided {@link Readable} directly into underlying\n     * character buffer without making extra copies.\n     *\n     * @param readable  object to read from\n     * @return The number of characters read\n     * @throws IOException if an I/O error occurs.\n     *\n     * @see #appendTo(Appendable)\n     */\n    public int readFrom(final Readable readable) throws IOException {\n        final int oldSize = size;\n        if (readable instanceof Reader) {\n            final Reader r = (Reader) readable;\n            ensureCapacity(size + 1);\n            int read;\n            while ((read = r.read(buffer, size, buffer.length - size)) != -1) {\n                size += read;\n                ensureCapacity(size + 1);\n            }\n        } else if (readable instanceof CharBuffer) {\n            final CharBuffer cb = (CharBuffer) readable;\n            final int remaining = cb.remaining();\n            ensureCapacity(size + remaining);\n            cb.get(buffer, size, remaining);\n            size += remaining;\n        } else {\n            while (true) {\n                ensureCapacity(size + 1);\n                final CharBuffer buf = CharBuffer.wrap(buffer, size, buffer.length - size);\n                final int read = readable.read(buf);\n                if (read == -1) {\n                    break;\n                }\n                size += read;\n            }\n        }\n        return size - oldSize;\n    }\n\n    /**\n     * Replaces a portion of the string builder with another string.\n     * The length of the inserted string does not have to match the removed length.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @param replaceStr  the string to replace with, null means delete range\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int insertLen = replaceStr == null ? 0 : replaceStr.length();\n        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n        return this;\n    }\n\n    /**\n     * Advanced search and replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior.\n     * For example you could write a matcher to delete all occurrences\n     * where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the string to replace the match with, null is a delete\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @param replaceCount  the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if start index is invalid\n     */\n    public StrBuilder replace(\n            final StrMatcher matcher, final String replaceStr,\n            final int startIndex, int endIndex, final int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }\n\n    /**\n     * Replaces the search character with the replace character\n     * throughout the builder.\n     *\n     * @param search  the search character\n     * @param replace  the replace character\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the search string with the replace string throughout the builder.\n     *\n     * @param searchStr  the search string, null causes no action to occur\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(final String searchStr, final String replaceStr) {\n        final int searchLen = searchStr == null ? 0 : searchStr.length();\n        if (searchLen > 0) {\n            final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n            int index = indexOf(searchStr, 0);\n            while (index >= 0) {\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n                index = indexOf(searchStr, index + replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces all matches within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior.\n     * For example you could write a matcher to replace all occurrences\n     * where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }\n\n    /**\n     * Replaces the first instance of the search character with the\n     * replace character in the builder.\n     *\n     * @param search  the search character\n     * @param replace  the replace character\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search string with the replace string.\n     *\n     * @param searchStr  the search string, null causes no action to occur\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(final String searchStr, final String replaceStr) {\n        final int searchLen = searchStr == null ? 0 : searchStr.length();\n        if (searchLen > 0) {\n            final int index = indexOf(searchStr, 0);\n            if (index >= 0) {\n                final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first match within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior.\n     * For example you could write a matcher to replace\n     * where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }\n\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex  the start index, must be valid\n     * @param endIndex  the end index (exclusive), must be valid\n     * @param removeLen  the length to remove (endIndex - startIndex), must be valid\n     * @param insertStr  the string to replace with, null means delete range\n     * @param insertLen  the length of the insert string, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void replaceImpl(final int startIndex,\n                             final int endIndex,\n                             final int removeLen,\n                             final String insertStr,\n                             final int insertLen) {\n        final int newSize = size - removeLen + insertLen;\n        if (insertLen != removeLen) {\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n            size = newSize;\n        }\n        if (insertLen > 0) {\n            insertStr.getChars(0, insertLen, buffer, startIndex);\n        }\n    }\n\n    /**\n     * Replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior.\n     * For example you could write a matcher to delete all occurrences\n     * where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the string to replace the match with, null is a delete\n     * @param from  the start index, must be valid\n     * @param to  the end index (exclusive), must be valid\n     * @param replaceCount  the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private StrBuilder replaceImpl(\n            final StrMatcher matcher, final String replaceStr,\n            final int from, int to, int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            final char[] buf = buffer;\n            final int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Reverses the string builder placing each character in the opposite index.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder reverse() {\n        if (size == 0) {\n            return this;\n        }\n\n        final int half = size / 2;\n        final char[] buf = buffer;\n        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {\n            final char swap = buf[leftIdx];\n            buf[leftIdx] = buf[rightIdx];\n            buf[rightIdx] = swap;\n        }\n        return this;\n    }\n\n    /**\n     * Extracts the rightmost characters from the string builder without\n     * throwing an exception.\n     * <p>\n     * This method extracts the right {@code length} characters from\n     * the builder. If this many characters are not available, the whole\n     * builder is returned. Thus the returned string may be shorter than the\n     * length requested.\n     * </p>\n     *\n     * @param length  the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String rightString(final int length) {\n        if (length <= 0) {\n            return StringUtils.EMPTY;\n        }\n        if (length >= size) {\n            return new String(buffer, 0, size);\n        }\n        return new String(buffer, size - length, length);\n    }\n\n    /**\n     * Sets the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index  the index to set\n     * @param ch  the new character\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder setCharAt(final int index, final char ch) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        buffer[index] = ch;\n        return this;\n    }\n\n    /**\n     * Updates the length of the builder by either dropping the last characters\n     * or adding filler of Unicode zero.\n     *\n     * @param length  the length to set to, must be zero or positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the length is negative\n     */\n    public StrBuilder setLength(final int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacity(length);\n            final int oldEnd = size;\n            size = length;\n            for (int i = oldEnd; i < length; i++) {\n                buffer[i] = '\\0';\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Sets the text to be appended when a new line is added.\n     *\n     * @param newLine  the new line text, null means use system default\n     * @return this, to enable chaining\n     */\n    public StrBuilder setNewLineText(final String newLine) {\n        this.newLine = newLine;\n        return this;\n    }\n\n    /**\n     * Sets the text to be appended when null is added.\n     *\n     * @param nullText  the null text, null means no append\n     * @return this, to enable chaining\n     */\n    public StrBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.isEmpty()) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }\n\n    /**\n     * Gets the length of the string builder.\n     * <p>\n     * This method is the same as {@link #length()} and is provided to match the\n     * API of Collections.\n     * </p>\n     *\n     * @return The length\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Checks whether this builder starts with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str  the string to search for, null returns false\n     * @return true if the builder starts with the string\n     */\n    public boolean startsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        for (int i = 0; i < len; i++) {\n            if (buffer[i] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public CharSequence subSequence(final int startIndex, final int endIndex) {\n      if (startIndex < 0) {\n          throw new StringIndexOutOfBoundsException(startIndex);\n      }\n      if (endIndex > size) {\n          throw new StringIndexOutOfBoundsException(endIndex);\n      }\n      if (startIndex > endIndex) {\n          throw new StringIndexOutOfBoundsException(endIndex - startIndex);\n      }\n      return substring(startIndex, endIndex);\n    }\n\n    /**\n     * Extracts a portion of this string builder as a string.\n     *\n     * @param start  the start index, inclusive, must be valid\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(final int start) {\n        return substring(start, size);\n    }\n\n    /**\n     * Extracts a portion of this string builder as a string.\n     * <p>\n     * Note: This method treats an endIndex greater than the length of the\n     * builder as equal to the length of the builder, and continues\n     * without error, unlike StringBuffer or String.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        return new String(buffer, startIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Copies the builder's character array into a new character array.\n     *\n     * @return a new array that represents the contents of the builder\n     */\n    public char[] toCharArray() {\n        if (size == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] chars = new char[size];\n        System.arraycopy(buffer, 0, chars, 0, size);\n        return chars;\n    }\n\n    /**\n     * Copies part of the builder's character array into a new character array.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except that\n     *  if too large it is treated as end of string\n     * @return a new array that holds part of the contents of the builder\n     * @throws IndexOutOfBoundsException if startIndex is invalid,\n     *  or if endIndex is invalid (but endIndex greater than size is valid)\n     */\n    public char[] toCharArray(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        if (len == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] chars = new char[len];\n        System.arraycopy(buffer, startIndex, chars, 0, len);\n        return chars;\n    }\n\n    /**\n     * Gets a String version of the string builder, creating a new instance\n     * each time the method is called.\n     * <p>\n     * Note that unlike StringBuffer, the string version returned is\n     * independent of the string builder.\n     * </p>\n     *\n     * @return The builder as a String\n     */\n    @Override\n    public String toString() {\n        return new String(buffer, 0, size);\n    }\n\n    /**\n     * Gets a StringBuffer version of the string builder, creating a\n     * new instance each time the method is called.\n     *\n     * @return The builder as a StringBuffer\n     */\n    public StringBuffer toStringBuffer() {\n        return new StringBuffer(size).append(buffer, 0, size);\n    }\n\n    /**\n     * Gets a StringBuilder version of the string builder, creating a\n     * new instance each time the method is called.\n     *\n     * @return The builder as a StringBuilder\n     */\n    public StringBuilder toStringBuilder() {\n        return new StringBuilder(size).append(buffer, 0, size);\n    }\n\n    /**\n     * Trims the builder by removing characters less than or equal to a space\n     * from the beginning and end.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder trim() {\n        if (size == 0) {\n            return this;\n        }\n        int len = size;\n        final char[] buf = buffer;\n        int pos = 0;\n        while (pos < len && buf[pos] <= ' ') {\n            pos++;\n        }\n        while (pos < len && buf[len - 1] <= ' ') {\n            len--;\n        }\n        if (len < size) {\n            delete(len, size);\n        }\n        if (pos > 0) {\n            delete(0, pos);\n        }\n        return this;\n    }\n\n    /**\n     * Validates parameters defining a single index in the builder.\n     *\n     * @param index  the index, must be valid\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected void validateIndex(final int index) {\n        if (index < 0 || index > size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n    }\n\n    /**\n     * Validates parameters defining a range of the builder.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected int validateRange(final int startIndex, int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            endIndex = size;\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        return endIndex;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/StrBuilder.java b/src/main/java/org/apache/commons/text/StrBuilder.java\nindex 2ed8891213..21bc815a26 100644\n--- a/src/main/java/org/apache/commons/text/StrBuilder.java\n+++ b/src/main/java/org/apache/commons/text/StrBuilder.java\n@@ -1970,7 +1970,7 @@ public int indexOf(final char ch) {\n      * @return The first index of the character, or -1 if not found\n      */\n     public int indexOf(final char ch, int startIndex) {\n-        startIndex = startIndex < 0 ? 0 : startIndex;\n+        startIndex = Math.max(startIndex, 0);\n         if (startIndex >= size) {\n             return -1;\n         }\n@@ -2008,7 +2008,7 @@ public int indexOf(final String str) {\n      * @return The first index of the string, or -1 if not found\n      */\n     public int indexOf(final String str, int startIndex) {\n-        startIndex = startIndex < 0 ? 0 : startIndex;\n+        startIndex = Math.max(startIndex, 0);\n         if (str == null || startIndex >= size) {\n             return -1;\n         }\n@@ -2065,7 +2065,7 @@ public int indexOf(final StrMatcher matcher) {\n      * @return The first index matched, or -1 if not found\n      */\n     public int indexOf(final StrMatcher matcher, int startIndex) {\n-        startIndex = startIndex < 0 ? 0 : startIndex;\n+        startIndex = Math.max(startIndex, 0);\n         if (matcher == null || startIndex >= size) {\n             return -1;\n         }\n"
      }
    ]
  },
  {
    "pr_number": 309,
    "title": "(doc) update definition of upper in abbreviate method to match behavior",
    "state": "closed",
    "created_at": "2022-03-23T06:27:19Z",
    "merge_commit_sha": "0ddae3b45d9e8db23e5928a1bb7013697b0b5967",
    "base_sha": "4d898861b35f010bbbbbb04980b3100e99607906",
    "head_sha": "cc10d22d459c89b7dab8ec27d53d7bbb9529df1d",
    "user_login": "CalebChristiansen",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/WordUtils.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport org.junit.jupiter.api.Test;\n\npublic class WordUtilsTest2 {\n\n    @Test\n    public void testAbbreviateUpperCannotBeLowerThanLower() {\n        // Test case to ensure that an IllegalArgumentException is thrown when upper is less than lower\n        assertThatIllegalArgumentException().isThrownBy(() -> WordUtils.abbreviate(\"0123456789\", 5, 2, \"\"));\n    }\n\n    @Test\n    public void testAbbreviateUpperEqualToLower() {\n        // Test case to ensure that the method works correctly when upper is equal to lower\n        assertThat(WordUtils.abbreviate(\"0123456789\", 5, 5, \"\")).isEqualTo(\"01234\");\n    }\n\n    @Test\n    public void testAbbreviateUpperGreaterThanLower() {\n        // Test case to ensure that the method works correctly when upper is greater than lower\n        assertThat(WordUtils.abbreviate(\"0123456789\", 5, 7, \"\")).isEqualTo(\"01234\");\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\n\n/**\n * Operations on Strings that contain words.\n *\n * <p>\n * This class tries to handle {@code null} input gracefully. An exception will not be thrown for a\n * {@code null} input. Each method documents its behavior in more detail.\n * </p>\n *\n * @since 1.1\n */\npublic class WordUtils {\n\n    /**\n     * Abbreviates the words nicely.\n     *\n     * <p>\n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * </p>\n     *\n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit; negative value is treated as zero.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return The abbreviated String.\n     *\n     * <pre>\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, null));     = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, null));    = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, null));    = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, \"\"));       = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, \"\"));      = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, \"\"));      = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, \" ...\"));   = \"Now ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, \" ...\"));  = \"Now is the ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, \" ...\"));  = \"Now is the time for all ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, -1, \"\"));       = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, -1, \"\"));      = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, -1, \"\"));      = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 50, -1, \"\"));      = \"Now is the time for all good men\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 1000, -1, \"\"));    = \"Now is the time for all good men\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 9, -10, null));    = IllegalArgumentException\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 5, null));     = IllegalArgumentException\n     * </pre>\n     */\n    public static String abbreviate(final String str, int lower, int upper, final String appendToEnd) {\n        Validate.isTrue(upper >= -1, \"upper value cannot be less than -1\");\n        Validate.isTrue(upper >= lower || upper == -1, \"upper value is less than lower value\");\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        if (lower > str.length()) {\n            lower = str.length();\n        }\n\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n\n        final StringBuilder result = new StringBuilder();\n        final int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str, 0, upper);\n            // only if abbreviation has occurred do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str, 0, upper);\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str, 0, index);\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Capitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed. To convert the\n     * rest of each word to lowercase at the same time,\n     * use {@link #capitalizeFully(String)}.\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null)        = null\n     * WordUtils.capitalize(\"\")          = \"\"\n     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, {@code null} if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str) {\n        return capitalize(str, null);\n    }\n\n    /**\n     * Capitalizes all the delimiter separated words in a String.\n     * Only the first character of each word is changed. To convert the\n     * rest of each word to lowercase at the same time,\n     * use {@link #capitalizeFully(String, char[])}.\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized.</p>\n     *\n     * <p>A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null, *)            = null\n     * WordUtils.capitalize(\"\", *)              = \"\"\n     * WordUtils.capitalize(*, new char[0])     = *\n     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n     * WordUtils.capitalize(\"i am fine\", new char[]{}) = \"I am fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, {@code null} if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n\n        boolean capitalizeNext = true;\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                capitalizeNext = true;\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            } else if (capitalizeNext) {\n                final int titleCaseCodePoint = Character.toTitleCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                capitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    /**\n     * Converts all the whitespace separated words in a String into capitalized words,\n     * that is each word is made up of a titlecase character and then a series of\n     * lowercase characters.\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null)        = null\n     * WordUtils.capitalizeFully(\"\")          = \"\"\n     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, {@code null} if null String input\n     */\n    public static String capitalizeFully(final String str) {\n        return capitalizeFully(str, null);\n    }\n\n    /**\n     * Converts all the delimiter separated words in a String into capitalized words,\n     * that is each word is made up of a titlecase character and then a series of\n     * lowercase characters.\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized.</p>\n     *\n     * <p>A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null, *)            = null\n     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n     * WordUtils.capitalizeFully(*, null)            = *\n     * WordUtils.capitalizeFully(*, new char[0])     = *\n     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, {@code null} if null String input\n     */\n    public static String capitalizeFully(String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        str = str.toLowerCase();\n        return capitalize(str, delimiters);\n    }\n\n    /**\n     * Checks if the String contains all words in the given array.\n     *\n     * <p>\n     * A {@code null} String will return {@code false}. A {@code null}, zero\n     * length search array or if one element of array is null will return {@code false}.\n     * </p>\n     *\n     * <pre>\n     * WordUtils.containsAllWords(null, *)            = false\n     * WordUtils.containsAllWords(\"\", *)              = false\n     * WordUtils.containsAllWords(*, null)            = false\n     * WordUtils.containsAllWords(*, [])              = false\n     * WordUtils.containsAllWords(\"abcd\", \"ab\", \"cd\") = false\n     * WordUtils.containsAllWords(\"abc def\", \"def\", \"abc\") = true\n     * </pre>\n     *\n     * @param word The CharSequence to check, may be null\n     * @param words The array of String words to search for, may be null\n     * @return {@code true} if all search words are found, {@code false} otherwise\n     */\n    public static boolean containsAllWords(final CharSequence word, final CharSequence... words) {\n        if (StringUtils.isEmpty(word) || ArrayUtils.isEmpty(words)) {\n            return false;\n        }\n        for (final CharSequence w : words) {\n            if (StringUtils.isBlank(w)) {\n                return false;\n            }\n            final Pattern p = Pattern.compile(\".*\\\\b\" + w + \"\\\\b.*\");\n            if (!p.matcher(word).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Converts an array of delimiters to a hash set of code points. Code point of space(32) is added as the default\n     * value if delimiters is null. The generated hash set provides O(1) lookup time.\n     *\n     * @param delimiters set of characters to determine capitalization, null means whitespace\n     * @return Set<Integer>\n     */\n    private static Set<Integer> generateDelimiterSet(final char[] delimiters) {\n        final Set<Integer> delimiterHashSet = new HashSet<>();\n        if (delimiters == null || delimiters.length == 0) {\n            if (delimiters == null) {\n                delimiterHashSet.add(Character.codePointAt(new char[] {' '}, 0));\n            }\n\n            return delimiterHashSet;\n        }\n\n        for (int index = 0; index < delimiters.length; index++) {\n            delimiterHashSet.add(Character.codePointAt(delimiters, index));\n        }\n        return delimiterHashSet;\n    }\n\n    /**\n     * Extracts the initial characters from each word in the String.\n     *\n     * <p>All first characters after whitespace are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null)             = null\n     * WordUtils.initials(\"\")               = \"\"\n     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @return String of initial letters, {@code null} if null String input\n     * @see #initials(String,char[])\n     */\n    public static String initials(final String str) {\n        return initials(str, null);\n    }\n\n    /**\n     * Extracts the initial characters from each word in the String.\n     *\n     * <p>All first characters after the defined delimiters are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>If the delimiters array is null, then Whitespace is used.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.\n     * An empty delimiter array returns an empty String.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null, *)                = null\n     * WordUtils.initials(\"\", *)                  = \"\"\n     * WordUtils.initials(\"Ben John Lee\", null)   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\", null)      = \"BJ\"\n     * WordUtils.initials(\"Ben J.Lee\", [' ','.']) = \"BJL\"\n     * WordUtils.initials(*, new char[0])         = \"\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @param delimiters  set of characters to determine words, null means whitespace\n     * @return String of initial characters, {@code null} if null String input\n     * @see #initials(String)\n     */\n    public static String initials(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (delimiters != null && delimiters.length == 0) {\n            return StringUtils.EMPTY;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen / 2 + 1];\n        int count = 0;\n        boolean lastWasGap = true;\n        for (int i = 0; i < strLen;) {\n            final int codePoint = str.codePointAt(i);\n\n            if (delimiterSet.contains(codePoint) || (delimiters == null && Character.isWhitespace(codePoint))) {\n                lastWasGap = true;\n            } else if (lastWasGap) {\n                newCodePoints[count++] = codePoint;\n                lastWasGap = false;\n            }\n\n            i += Character.charCount(codePoint);\n        }\n        return new String(newCodePoints, 0, count);\n    }\n\n    /**\n     * Is the character a delimiter.\n     *\n     * @param ch the character to check\n     * @param delimiters the delimiters\n     * @return true if it is a delimiter\n     * @deprecated as of 1.2 and will be removed in 2.0\n     */\n    @Deprecated\n    public static boolean isDelimiter(final char ch, final char[] delimiters) {\n        if (delimiters == null) {\n            return Character.isWhitespace(ch);\n        }\n        for (final char delimiter : delimiters) {\n            if (ch == delimiter) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Is the codePoint a delimiter.\n     *\n     * @param codePoint the codePint to check\n     * @param delimiters the delimiters\n     * @return true if it is a delimiter\n     * @deprecated as of 1.2 and will be removed in 2.0\n     */\n    @Deprecated\n    public static boolean isDelimiter(final int codePoint, final char[] delimiters) {\n        if (delimiters == null) {\n            return Character.isWhitespace(codePoint);\n        }\n        for (int index = 0; index < delimiters.length; index++) {\n            final int delimiterCodePoint = Character.codePointAt(delimiters, index);\n            if (delimiterCodePoint == codePoint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Swaps the case of a String using a word based algorithm.\n     *\n     * <ul>\n     *  <li>Upper case character converts to Lower case</li>\n     *  <li>Title case character converts to Lower case</li>\n     *  <li>Lower case character after Whitespace or at start converts to Title case</li>\n     *  <li>Other Lower case character converts to Upper case</li>\n     * </ul>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * StringUtils.swapCase(null)                 = null\n     * StringUtils.swapCase(\"\")                   = \"\"\n     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n     * </pre>\n     *\n     * @param str  the String to swap case, may be null\n     * @return The changed String, {@code null} if null String input\n     */\n    public static String swapCase(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n        boolean whitespace = true;\n        for (int index = 0; index < strLen;) {\n            final int oldCodepoint = str.codePointAt(index);\n            final int newCodePoint;\n            if (Character.isUpperCase(oldCodepoint) || Character.isTitleCase(oldCodepoint)) {\n                newCodePoint = Character.toLowerCase(oldCodepoint);\n                whitespace = false;\n            } else if (Character.isLowerCase(oldCodepoint)) {\n                if (whitespace) {\n                    newCodePoint = Character.toTitleCase(oldCodepoint);\n                    whitespace = false;\n                } else {\n                    newCodePoint = Character.toUpperCase(oldCodepoint);\n                }\n            } else {\n                whitespace = Character.isWhitespace(oldCodepoint);\n                newCodePoint = oldCodepoint;\n            }\n            newCodePoints[outOffset++] = newCodePoint;\n            index += Character.charCount(newCodePoint);\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    /**\n     * Uncapitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed.\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null)        = null\n     * WordUtils.uncapitalize(\"\")          = \"\"\n     * WordUtils.uncapitalize(\"I Am FINE\") = \"i am fINE\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @return uncapitalized String, {@code null} if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str) {\n        return uncapitalize(str, null);\n    }\n\n    /**\n     * Uncapitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed.\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be uncapitalized.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null, *)            = null\n     * WordUtils.uncapitalize(\"\", *)              = \"\"\n     * WordUtils.uncapitalize(*, null)            = *\n     * WordUtils.uncapitalize(*, new char[0])     = *\n     * WordUtils.uncapitalize(\"I AM.FINE\", {'.'}) = \"i AM.fINE\"\n     * WordUtils.uncapitalize(\"I am fine\", new char[]{}) = \"i am fine\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @param delimiters  set of characters to determine uncapitalization, null means whitespace\n     * @return uncapitalized String, {@code null} if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n\n        boolean uncapitalizeNext = true;\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                uncapitalizeNext = true;\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            } else if (uncapitalizeNext) {\n                final int titleCaseCodePoint = Character.toLowerCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                uncapitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    /**\n     * Wraps a single line of text, identifying words by {@code ' '}.\n     *\n     * <p>New lines will be separated by the system property line separator.\n     * Very long words, such as URLs will <i>not</i> be wrapped.</p>\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttps://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here, https://commons.apache.org, to jump to the commons website\"</td>\n     *   <td>20</td>\n     *   <td>\"Click here,\\nhttps://commons.apache.org,\\nto jump to the\\ncommons website\"</td>\n     *  </tr>\n     * </table>\n     *\n     * (assuming that '\\n' is the systems line separator)\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @return a line with newlines inserted, {@code null} if null input\n     */\n    public static String wrap(final String str, final int wrapLength) {\n        return wrap(str, wrapLength, null, false);\n    }\n\n    /**\n     * Wraps a single line of text, identifying words by {@code ' '}.\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>newLineString</th>\n     *   <th>wrapLongWords</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"&lt;br /&gt;\"</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of&lt;br /&gt;text that is going&lt;\n     *   br /&gt;to be wrapped after&lt;br /&gt;20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>null</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of\" + systemNewLine + \"text that is going\"\n     *   + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>false</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttps://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apach\\ne.org\"</td>\n     *  </tr>\n     * </table>\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line,\n     *  {@code null} uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @return a line with newlines inserted, {@code null} if null input\n     */\n    public static String wrap(final String str,\n                              final int wrapLength,\n                              final String newLineStr,\n                              final boolean wrapLongWords) {\n        return wrap(str, wrapLength, newLineStr, wrapLongWords, \" \");\n    }\n\n    /**\n     * Wraps a single line of text, identifying words by {@code wrapOn}.\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>newLineString</th>\n     *   <th>wrapLongWords</th>\n     *   <th>wrapOn</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>*</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>*</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"&lt;br /&gt;\"</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of&lt;br /&gt;text that is going&lt;br /&gt;\n     *   to be wrapped after&lt;br /&gt;20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>null</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of\" + systemNewLine + \"text that is going\"\n     *   + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttps://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\" \"</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apach\\ne.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"flammable/inflammable\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\"/\"</td>\n     *   <td>\"flammable\\ninflammable\"</td>\n     *  </tr>\n     * </table>\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line,\n     *  {@code null} uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @param wrapOn regex expression to be used as a breakable characters,\n     *               if blank string is provided a space character will be used\n     * @return a line with newlines inserted, {@code null} if null input\n     */\n    public static String wrap(final String str,\n                              int wrapLength,\n                              String newLineStr,\n                              final boolean wrapLongWords,\n                              String wrapOn) {\n        if (str == null) {\n            return null;\n        }\n        if (newLineStr == null) {\n            newLineStr = System.lineSeparator();\n        }\n        if (wrapLength < 1) {\n            wrapLength = 1;\n        }\n        if (StringUtils.isBlank(wrapOn)) {\n            wrapOn = \" \";\n        }\n        final Pattern patternToWrapOn = Pattern.compile(wrapOn);\n        final int inputLineLength = str.length();\n        int offset = 0;\n        final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n        int matcherSize = -1;\n\n        while (offset < inputLineLength) {\n            int spaceToWrapAt = -1;\n            Matcher matcher = patternToWrapOn.matcher(str.substring(offset,\n                    Math.min((int) Math.min(Integer.MAX_VALUE, offset + wrapLength + 1L), inputLineLength)));\n            if (matcher.find()) {\n                if (matcher.start() == 0) {\n                    matcherSize = matcher.end();\n                    if (matcherSize != 0) {\n                        offset += matcher.end();\n                        continue;\n                    }\n                    offset += 1;\n                }\n                spaceToWrapAt = matcher.start() + offset;\n            }\n\n            // only last line without leading spaces is left\n            if (inputLineLength - offset <= wrapLength) {\n                break;\n            }\n\n            while (matcher.find()) {\n                spaceToWrapAt = matcher.start() + offset;\n            }\n\n            if (spaceToWrapAt >= offset) {\n                // normal case\n                wrappedLine.append(str, offset, spaceToWrapAt);\n                wrappedLine.append(newLineStr);\n                offset = spaceToWrapAt + 1;\n\n            } else {\n                // really long word or URL\n                if (wrapLongWords) {\n                    if (matcherSize == 0) {\n                        offset--;\n                    }\n                    // wrap really long word one line at a time\n                    wrappedLine.append(str, offset, wrapLength + offset);\n                    wrappedLine.append(newLineStr);\n                    offset += wrapLength;\n                    matcherSize = -1;\n                } else {\n                    // do not wrap really long word, just extend beyond limit\n                    matcher = patternToWrapOn.matcher(str.substring(offset + wrapLength));\n                    if (matcher.find()) {\n                        matcherSize = matcher.end() - matcher.start();\n                        spaceToWrapAt = matcher.start() + offset + wrapLength;\n                    }\n\n                    if (spaceToWrapAt >= 0) {\n                        if (matcherSize == 0 && offset != 0) {\n                            offset--;\n                        }\n                        wrappedLine.append(str, offset, spaceToWrapAt);\n                        wrappedLine.append(newLineStr);\n                        offset = spaceToWrapAt + 1;\n                    } else {\n                        if (matcherSize == 0 && offset != 0) {\n                            offset--;\n                        }\n                        wrappedLine.append(str, offset, str.length());\n                        offset = inputLineLength;\n                        matcherSize = -1;\n                    }\n                }\n            }\n        }\n\n        if (matcherSize == 0 && offset < inputLineLength) {\n            offset--;\n        }\n\n        // Whatever is left in line is short enough to just pass through\n        wrappedLine.append(str, offset, str.length());\n\n        return wrappedLine.toString();\n    }\n\n    /**\n     * {@code WordUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code WordUtils.wrap(\"foo bar\", 20);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public WordUtils() {\n    }\n }",
        "diff": " a/src/main/java/org/apache/commons/text/WordUtils.java b/src/main/java/org/apache/commons/text/WordUtils.java\nindex e0e70ba1f0..fb848b8a33 100644\n--- a/src/main/java/org/apache/commons/text/WordUtils.java\n+++ b/src/main/java/org/apache/commons/text/WordUtils.java\n@@ -51,8 +51,7 @@ public class WordUtils {\n      *                    If the empty String is passed, the empty string is returned.\n      * @param lower       the lower limit; negative value is treated as zero.\n      * @param upper       the upper limit; specify -1 if no limit is desired.\n-     *                    If the upper limit is lower than the lower limit, it will be\n-     *                    adjusted to be the same as the lower limit.\n+     *                    The upper limit cannot be lower than the lower limit.\n      * @param appendToEnd String to be appended to the end of the abbreviated string.\n      *                    This is appended ONLY if the string was indeed abbreviated.\n      *                    The append does not count towards the lower or upper limits.\n"
      }
    ]
  },
  {
    "pr_number": 308,
    "title": "apostrophes, typos and clarifications",
    "state": "closed",
    "created_at": "2022-03-19T20:14:53Z",
    "merge_commit_sha": "d68be8ea04e39f5ab18fd5dc39e46f04cf05921c",
    "base_sha": "54d28f1c858e949b5fa2f670ff0f3954e5fc2854",
    "head_sha": "3ca5c1be1207f76ab07b56948fd5d3e9fd15da42",
    "user_login": "richarda23",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/StringSubstitutor.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatNullPointerException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.commons.text.lookup.StringLookup;\nimport org.apache.commons.text.lookup.StringLookupFactory;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\n\n@TestMethodOrder(MethodOrderer.MethodName.class)\npublic class StringSubstitutorTest2 {\n\n    private static final String ACTUAL_ANIMAL = \"quick brown fox\";\n    private static final String ACTUAL_TARGET = \"lazy dog\";\n    private static final String CLASSIC_RESULT = \"The quick brown fox jumps over the lazy dog.\";\n    private static final String CLASSIC_TEMPLATE = \"The ${animal} jumps over the ${target}.\";\n    private static final String EMPTY_EXPR = \"${}\";\n\n    protected Map<String, String> values;\n\n    private void assertEqualsCharSeq(final CharSequence expected, final CharSequence actual) {\n        assertEquals(expected, actual, () -> String.format(\"expected.length()=%,d, actual.length()=%,d\",\n                StringUtils.length(expected), StringUtils.length(actual)));\n    }\n\n    protected void doNotReplace(final String replaceTemplate) throws IOException {\n        doTestNoReplace(new StringSubstitutor(values), replaceTemplate);\n    }\n\n    protected void doReplace(final String expectedResult, final String replaceTemplate, final boolean substring)\n            throws IOException {\n        doTestReplace(new StringSubstitutor(values), expectedResult, replaceTemplate, substring);\n    }\n\n    protected void doTestNoReplace(final StringSubstitutor substitutor, final String replaceTemplate)\n            throws IOException {\n        if (replaceTemplate == null) {\n            assertNull(replace(substitutor, (String) null));\n            assertNull(substitutor.replace((String) null, 0, 100));\n            assertNull(substitutor.replace((char[]) null));\n            assertNull(substitutor.replace((char[]) null, 0, 100));\n            assertNull(substitutor.replace((StringBuffer) null));\n            assertNull(substitutor.replace((StringBuffer) null, 0, 100));\n            assertNull(substitutor.replace((TextStringBuilder) null));\n            assertNull(substitutor.replace((TextStringBuilder) null, 0, 100));\n            assertNull(substitutor.replace((Object) null));\n            assertFalse(substitutor.replaceIn((StringBuffer) null));\n            assertFalse(substitutor.replaceIn((StringBuffer) null, 0, 100));\n            assertFalse(substitutor.replaceIn((TextStringBuilder) null));\n            assertFalse(substitutor.replaceIn((TextStringBuilder) null, 0, 100));\n        } else {\n            assertEquals(replaceTemplate, replace(substitutor, replaceTemplate));\n            final TextStringBuilder builder = new TextStringBuilder(replaceTemplate);\n            assertFalse(substitutor.replaceIn(builder));\n            assertEquals(replaceTemplate, builder.toString());\n        }\n    }\n\n    protected void doTestReplace(final StringSubstitutor sub, final String expectedResult, final String replaceTemplate,\n            final boolean substring) throws IOException {\n        final String expectedShortResult = substring ? expectedResult.substring(1, expectedResult.length() - 1)\n                : expectedResult;\n        final String actual = replace(sub, replaceTemplate);\n        assertEquals(expectedResult, actual,\n                () -> String.format(\"Index of difference: %,d\", StringUtils.indexOfDifference(expectedResult, actual)));\n        if (substring) {\n            assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2));\n        }\n        final char[] chars = replaceTemplate.toCharArray();\n        assertEquals(expectedResult, sub.replace(chars));\n        if (substring) {\n            assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2));\n        }\n        StringBuffer buf = new StringBuffer(replaceTemplate);\n        assertEquals(expectedResult, sub.replace(buf));\n        if (substring) {\n            assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2));\n        }\n        StringBuilder builder = new StringBuilder(replaceTemplate);\n        assertEquals(expectedResult, sub.replace(builder));\n        if (substring) {\n            assertEquals(expectedShortResult, sub.replace(builder, 1, builder.length() - 2));\n        }\n        TextStringBuilder bld = new TextStringBuilder(replaceTemplate);\n        assertEquals(expectedResult, sub.replace(bld));\n        if (substring) {\n            assertEquals(expectedShortResult, sub.replace(bld, 1, bld.length() - 2));\n        }\n        final MutableObject<String> obj = new MutableObject<>(replaceTemplate);\n        assertEquals(expectedResult, sub.replace(obj));\n        buf = new StringBuffer(replaceTemplate);\n        assertTrue(sub.replaceIn(buf), replaceTemplate);\n        assertEquals(expectedResult, buf.toString());\n        if (substring) {\n            buf = new StringBuffer(replaceTemplate);\n            assertTrue(sub.replaceIn(buf, 1, buf.length() - 2));\n            assertEquals(expectedResult, buf.toString());\n        }\n        builder = new StringBuilder(replaceTemplate);\n        assertTrue(sub.replaceIn(builder));\n        assertEquals(expectedResult, builder.toString());\n        if (substring) {\n            builder = new StringBuilder(replaceTemplate);\n            assertTrue(sub.replaceIn(builder, 1, builder.length() - 2));\n            assertEquals(expectedResult, builder.toString());\n        }\n        bld = new TextStringBuilder(replaceTemplate);\n        assertTrue(sub.replaceIn(bld));\n        assertEquals(expectedResult, bld.toString());\n        if (substring) {\n            bld = new TextStringBuilder(replaceTemplate);\n            assertTrue(sub.replaceIn(bld, 1, bld.length() - 2));\n            assertEquals(expectedResult, bld.toString());\n        }\n    }\n\n    protected String replace(final StringSubstitutor stringSubstitutor, final String template) throws IOException {\n        return stringSubstitutor.replace(template);\n    }\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        values = new HashMap<>();\n        values.put(\"a\", \"1\");\n        values.put(\"aa\", \"11\");\n        values.put(\"aaa\", \"111\");\n        values.put(\"b\", \"2\");\n        values.put(\"bb\", \"22\");\n        values.put(\"bbb\", \"222\");\n        values.put(\"a2b\", \"b\");\n        values.put(\"animal\", ACTUAL_ANIMAL);\n        values.put(\"target\", ACTUAL_TARGET);\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception {\n        values = null;\n    }\n\n    @Test\n    public void testTypoFixInDocumentation() {\n        // This test is to ensure that the typo fix in the documentation does not affect functionality.\n        final String template = \"The default interpolator lets you use string lookups like: ${animal}\";\n        final String expected = \"The default interpolator lets you use string lookups like: quick brown fox\";\n        final StringSubstitutor sub = new StringSubstitutor(values);\n        assertEquals(expected, sub.replace(template));\n    }\n\n    @Test\n    public void testConstructorStringSubstitutorCommentFix() {\n        // This test is to ensure that the comment fix in the constructor does not affect functionality.\n        final StringSubstitutor source = new StringSubstitutor();\n        source.setDisableSubstitutionInValues(true);\n        source.setEnableSubstitutionInVariables(true);\n        source.setEnableUndefinedVariableException(true);\n        source.setEscapeChar('e');\n        source.setValueDelimiter('d');\n        source.setVariablePrefix('p');\n        source.setVariableResolver(StringLookupFactory.INSTANCE.nullStringLookup());\n        source.setVariableSuffix('s');\n        final StringSubstitutor target = new StringSubstitutor(source);\n        assertTrue(target.isDisableSubstitutionInValues());\n        assertTrue(target.isEnableSubstitutionInVariables());\n        assertTrue(target.isEnableUndefinedVariableException());\n        assertEquals('e', target.getEscapeChar());\n        assertTrue(target.getValueDelimiterMatcher().toString().endsWith(\"['d']\"),\n                target.getValueDelimiterMatcher().toString());\n        assertTrue(target.getVariablePrefixMatcher().toString().endsWith(\"['p']\"),\n                target.getValueDelimiterMatcher().toString());\n        assertTrue(target.getVariableSuffixMatcher().toString().endsWith(\"['s']\"),\n                target.getValueDelimiterMatcher().toString());\n    }\n\n    @Test\n    public void testSubstituteThrowsIllegalArgumentException() {\n        // This test is to ensure that the updated IllegalArgumentException message is correct.\n        values.put(\"animal.1\", \"fox\");\n        values.put(\"animal.2\", \"mouse\");\n        values.put(\"species\", \"2\");\n        final StringSubstitutor sub = new StringSubstitutor(values);\n        sub.setEnableUndefinedVariableException(true);\n        assertThatIllegalArgumentException()\n                .isThrownBy(() -> replace(sub, \"The ${animal.${species}} jumps over the ${target}.\"))\n                .withMessage(\"Cannot resolve variable 'animal.${species' (enableSubstitutionInVariables=false).\");\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\n\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.text.lookup.StringLookup;\nimport org.apache.commons.text.lookup.StringLookupFactory;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\n\n/**\n * Substitutes variables within a string by values.\n * <p>\n * This class takes a piece of text and substitutes all the variables within it. The default definition of a variable is\n * {@code ${variableName}}. The prefix and suffix can be changed via constructors and set methods.\n * </p>\n * <p>\n * Variable values are typically resolved from a map, but could also be resolved from system properties, or by supplying\n * a custom variable resolver.\n * </p>\n * <h2>Using System Properties</h2>\n * <p>\n * The simplest example is to use this class to replace Java System properties. For example:\n * </p>\n *\n * <pre>\n * StringSubstitutor\n *     .replaceSystemProperties(\"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n * </pre>\n *\n * <h2>Using a Custom Map</h2>\n * <p>\n * Typical usage of this class follows the following pattern:\n * </p>\n * <ul>\n * <li>Create and initialize a StringSubstitutor with the map that contains the values for the variables you want to\n * make available.</li>\n * <li>Optionally set attributes like variable prefix, variable suffix, default value delimiter, and so on.</li>\n * <li>Call the {@code replace()} method with in the source text for interpolation.</li>\n * <li>The returned text contains all variable references (as long as their values are known) as resolved.</li>\n * </ul>\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * // Build map\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n *\n * // Build StringSubstitutor\n * StringSubstitutor sub = new StringSubstitutor(valuesMap);\n *\n * // Replace\n * String resolvedString = sub.replace(templateString);\n * </pre>\n *\n * <p>\n * yielding:\n * </p>\n *\n * <pre>\n * \"The quick brown fox jumped over the lazy dog.\"\n * </pre>\n *\n * <h2>Providing Default Values</h2>\n * <p>\n * You can set a default value for unresolved variables. The default value for a variable can be appended to the\n * variable name after the variable default value delimiter. The default value of the variable default value delimiter\n * is \":-\", as in bash and other *nix shells.\n * </p>\n * <p>\n * You can set the variable value delimiter with {@link #setValueDelimiterMatcher(StringMatcher)},\n * {@link #setValueDelimiter(char)} or {@link #setValueDelimiter(String)}.\n * </p>\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * // Build map\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target} ${undefined.number:-1234567890} times.&quot;;\n *\n * // Build StringSubstitutor\n * StringSubstitutor sub = new StringSubstitutor(valuesMap);\n *\n * // Replace\n * String resolvedString = sub.replace(templateString);\n * </pre>\n *\n * <p>\n * yielding:\n * </p>\n *\n * <pre>\n * \"The quick brown fox jumped over the lazy dog 1234567890 times.\"\n * </pre>\n *\n * <p>\n * {@code StringSubstitutor} supports throwing exceptions for unresolved variables, you enable this by setting calling\n * {@link #setEnableUndefinedVariableException(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Reusing Instances</h2>\n * <p>\n * Static shortcut methods cover the most common use cases. If multiple replace operations are to be performed, creating\n * and reusing an instance of this class will be more efficient.\n * </p>\n *\n * <h2>Using Interpolation</h2>\n * <p>\n * The default interpolator let's you use string lookups like:\n * </p>\n *\n * <pre>\n * final StringSubstitutor interpolator = StringSubstitutor.createInterpolator();\n * interpolator.setEnableSubstitutionInVariables(true); // Allows for nested $'s.\n * final String text = interpolator.replace(\"Base64 Decoder:        ${base64Decoder:SGVsbG9Xb3JsZCE=}\\n\"\n *     + \"Base64 Encoder:        ${base64Encoder:HelloWorld!}\\n\"\n *     + \"Java Constant:         ${const:java.awt.event.KeyEvent.VK_ESCAPE}\\n\"\n *     + \"Date:                  ${date:yyyy-MM-dd}\\n\" + \"DNS:                   ${dns:address|apache.org}\\n\"\n *     + \"Environment Variable:  ${env:USERNAME}\\n\"\n *     + \"File Content:          ${file:UTF-8:src/test/resources/document.properties}\\n\"\n *     + \"Java:                  ${java:version}\\n\" + \"Localhost:             ${localhost:canonical-name}\\n\"\n *     + \"Properties File:       ${properties:src/test/resources/document.properties::mykey}\\n\"\n *     + \"Resource Bundle:       ${resourceBundle:org.example.testResourceBundleLookup:mykey}\\n\"\n *     + \"Script:                ${script:javascript:3 + 4}\\n\" + \"System Property:       ${sys:user.dir}\\n\"\n *     + \"URL Decoder:           ${urlDecoder:Hello%20World%21}\\n\"\n *     + \"URL Encoder:           ${urlEncoder:Hello World!}\\n\"\n *     + \"URL Content (HTTP):    ${url:UTF-8:http://www.apache.org}\\n\"\n *     + \"URL Content (HTTPS):   ${url:UTF-8:https://www.apache.org}\\n\"\n *     + \"URL Content (File):    ${url:UTF-8:file:///${sys:user.dir}/src/test/resources/document.properties}\\n\"\n *     + \"XML XPath:             ${xml:src/test/resources/document.xml:/root/path/to/node}\\n\");\n * </pre>\n * <p>\n * For documentation of each lookup, see {@link StringLookupFactory}.\n * </p>\n *\n * <h2>Using Recursive Variable Replacement</h2>\n * <p>\n * Variable replacement can work recursively by calling {@link #setEnableSubstitutionInVariables(boolean)} with\n * {@code true}. If a variable value contains a variable then that variable will also be replaced. Cyclic replacements\n * are detected and will throw an exception.\n * </p>\n * <p>\n * You can get the replace result to contain a variable prefix. For example:\n * </p>\n *\n * <pre>\n * \"The variable ${${name}} must be used.\"\n * </pre>\n *\n * <p>\n * If the value of the \"name\" variable is \"x\", then only the variable \"name\" is replaced resulting in:\n * </p>\n *\n * <pre>\n * \"The variable ${x} must be used.\"\n * </pre>\n *\n * <p>\n * To achieve this effect there are two possibilities: Either set a different prefix and suffix for variables which do\n * not conflict with the result text you want to produce. The other possibility is to use the escape character, by\n * default '$'. If this character is placed before a variable reference, this reference is ignored and won't be\n * replaced. For example:\n * </p>\n *\n * <pre>\n * \"The variable $${${name}} must be used.\"\n * </pre>\n * <p>\n * In some complex scenarios you might even want to perform substitution in the names of variables, for instance\n * </p>\n *\n * <pre>\n * ${jre-${java.specification.version}}\n * </pre>\n *\n * <p>\n * {@code StringSubstitutor} supports this recursive substitution in variable names, but it has to be enabled explicitly\n * by calling {@link #setEnableSubstitutionInVariables(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Thread Safety</h2>\n * <p>\n * This class is <b>not</b> thread safe.\n * </p>\n *\n * @since 1.3\n */\npublic class StringSubstitutor {\n\n    /**\n     * The low-level result of a substitution.\n     *\n     * @since 1.9\n     */\n    private static final class Result {\n\n        /** Whether the buffer is altered. */\n        public final boolean altered;\n\n        /** The length of change. */\n        public final int lengthChange;\n\n        private Result(final boolean altered, final int lengthChange) {\n            this.altered = altered;\n            this.lengthChange = lengthChange;\n        }\n\n        @Override\n        public String toString() {\n            return \"Result [altered=\" + altered + \", lengthChange=\" + lengthChange + \"]\";\n        }\n    }\n\n    /**\n     * Constant for the default escape character.\n     */\n    public static final char DEFAULT_ESCAPE = '$';\n\n    /**\n     * The default variable default separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_DEFAULT = \":-\";\n\n    /**\n     * The default variable end separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_END = \"}\";\n\n    /**\n     * The default variable start separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_START = \"${\";\n\n    /**\n     * Constant for the default variable prefix.\n     */\n    public static final StringMatcher DEFAULT_PREFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_START);\n\n    /**\n     * Constant for the default variable suffix.\n     */\n    public static final StringMatcher DEFAULT_SUFFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_END);\n\n    /**\n     * Constant for the default value delimiter of a variable.\n     */\n    public static final StringMatcher DEFAULT_VALUE_DELIMITER = StringMatcherFactory.INSTANCE\n        .stringMatcher(DEFAULT_VAR_DEFAULT);\n\n    /**\n     * Creates a new instance using the interpolator string lookup\n     * {@link StringLookupFactory#interpolatorStringLookup()}.\n     * <p>\n     * This StringSubstitutor lets you perform substituions like:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\n     *   \"OS name: ${sys:os.name}, \" + \"3 + 4 = ${script:javascript:3 + 4}\");\n     * </pre>\n     *\n     * @return a new instance using the interpolator string lookup.\n     * @see StringLookupFactory#interpolatorStringLookup()\n     * @since 1.8\n     */\n    public static StringSubstitutor createInterpolator() {\n        return new StringSubstitutor(StringLookupFactory.INSTANCE.interpolatorStringLookup());\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the map.\n     *\n     * @param <V> the type of the values in the map\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueMap the map with the values, may be null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static <V> String replace(final Object source, final Map<String, V> valueMap) {\n        return new StringSubstitutor(valueMap).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the map.\n     * This method allows to specify a custom variable prefix and suffix\n     *\n     * @param <V> the type of the values in the map\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueMap the map with the values, may be null\n     * @param prefix the prefix of variables, not null\n     * @param suffix the suffix of variables, not null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static <V> String replace(final Object source, final Map<String, V> valueMap, final String prefix,\n        final String suffix) {\n        return new StringSubstitutor(valueMap, prefix, suffix).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the\n     * properties.\n     *\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueProperties the properties with values, may be null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static String replace(final Object source, final Properties valueProperties) {\n        if (valueProperties == null) {\n            return source.toString();\n        }\n        final Map<String, String> valueMap = new HashMap<>();\n        final Enumeration<?> propNames = valueProperties.propertyNames();\n        while (propNames.hasMoreElements()) {\n            final String propName = (String) propNames.nextElement();\n            final String propValue = valueProperties.getProperty(propName);\n            valueMap.put(propName, propValue);\n        }\n        return StringSubstitutor.replace(source, valueMap);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the system\n     * properties.\n     *\n     * @param source the source text containing the variables to substitute, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static String replaceSystemProperties(final Object source) {\n        return new StringSubstitutor(StringLookupFactory.INSTANCE.systemPropertyStringLookup()).replace(source);\n    }\n\n    /**\n     * The flag whether substitution in variable values is disabled.\n     */\n    private boolean disableSubstitutionInValues;\n\n    /**\n     * The flag whether substitution in variable names is enabled.\n     */\n    private boolean enableSubstitutionInVariables;\n\n    /**\n     * The flag whether exception should be thrown on undefined variable.\n     */\n    private boolean enableUndefinedVariableException;\n\n    /**\n     * Stores the escape character.\n     */\n    private char escapeChar;\n\n    /**\n     * Stores the variable prefix.\n     */\n    private StringMatcher prefixMatcher;\n\n    /**\n     * Whether escapes should be preserved. Default is false;\n     */\n    private boolean preserveEscapes;\n\n    /**\n     * Stores the variable suffix.\n     */\n    private StringMatcher suffixMatcher;\n\n    /**\n     * Stores the default variable value delimiter.\n     */\n    private StringMatcher valueDelimiterMatcher;\n\n    /**\n     * Variable resolution is delegated to an implementor of {@link StringLookup}.\n     */\n    private StringLookup variableResolver;\n\n    /**\n     * Creates a new instance with defaults for variable prefix and suffix and the escaping character.\n     */\n    public StringSubstitutor() {\n        this((StringLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses defaults for variable prefix and suffix and the escaping\n     * character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses a default escaping character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n        final char escape) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiter the variable default value delimiter, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n        final char escape, final String valueDelimiter) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape, valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     */\n    public StringSubstitutor(final StringLookup variableResolver) {\n        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,\n        final char escape) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiter the variable default value delimiter string, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,\n        final char escape, final String valueDelimiter) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiter(valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefixMatcher the prefix for variables, not null\n     * @param suffixMatcher the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,\n        final StringMatcher suffixMatcher, final char escape) {\n        this(variableResolver, prefixMatcher, suffixMatcher, escape, DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefixMatcher the prefix for variables, not null\n     * @param suffixMatcher the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiterMatcher the variable default value delimiter matcher, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,\n        final StringMatcher suffixMatcher, final char escape, final StringMatcher valueDelimiterMatcher) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefixMatcher(prefixMatcher);\n        this.setVariableSuffixMatcher(suffixMatcher);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(valueDelimiterMatcher);\n    }\n\n    /**\n     * Creates a new instance based on the given StringSubstitutor.\n     *\n     * @param other The StringSubstitutor is use as the source.\n     * @since 1.9\n     */\n    public StringSubstitutor(final StringSubstitutor other) {\n        disableSubstitutionInValues = other.isDisableSubstitutionInValues();\n        enableSubstitutionInVariables = other.isEnableSubstitutionInVariables();\n        enableUndefinedVariableException = other.isEnableUndefinedVariableException();\n        escapeChar = other.getEscapeChar();\n        prefixMatcher = other.getVariablePrefixMatcher();\n        preserveEscapes = other.isPreserveEscapes();\n        suffixMatcher = other.getVariableSuffixMatcher();\n        valueDelimiterMatcher = other.getValueDelimiterMatcher();\n        variableResolver = other.getStringLookup();\n    }\n\n    /**\n     * Checks if the specified variable is already in the stack (list) of variables.\n     *\n     * @param varName the variable name to check\n     * @param priorVariables the list of prior variables\n     */\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\n        if (!priorVariables.contains(varName)) {\n            return;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(256);\n        buf.append(\"Infinite loop in property interpolation of \");\n        buf.append(priorVariables.remove(0));\n        buf.append(\": \");\n        buf.appendWithSeparators(priorVariables, \"->\");\n        throw new IllegalStateException(buf.toString());\n    }\n\n    // Escape\n    /**\n     * Returns the escape character.\n     *\n     * @return The character used for escaping variable references\n     */\n    public char getEscapeChar() {\n        return this.escapeChar;\n    }\n\n    /**\n     * Gets the StringLookup that is used to lookup variables.\n     *\n     * @return The StringLookup\n     */\n    public StringLookup getStringLookup() {\n        return this.variableResolver;\n    }\n\n    /**\n     * Gets the variable default value delimiter matcher currently in use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\n     * value delimiter matches.\n     * </p>\n     * <p>\n     * If it returns null, then the variable default value resolution is disabled.\n     *\n     * @return The variable default value delimiter matcher in use, may be null\n     */\n    public StringMatcher getValueDelimiterMatcher() {\n        return valueDelimiterMatcher;\n    }\n\n    /**\n     * Gets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This prefix is\n     * expressed in terms of a matcher allowing advanced prefix matches.\n     * </p>\n     *\n     * @return The prefix matcher in use\n     */\n    public StringMatcher getVariablePrefixMatcher() {\n        return prefixMatcher;\n    }\n\n    /**\n     * Gets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed\n     * in terms of a matcher allowing advanced suffix matches.\n     * </p>\n     *\n     * @return The suffix matcher in use\n     */\n    public StringMatcher getVariableSuffixMatcher() {\n        return suffixMatcher;\n    }\n\n    /**\n     * Returns a flag whether substitution is disabled in variable values.If set to <b>true</b>, the values of variables\n     * can contain other variables will not be processed and substituted original variable is evaluated, e.g.\n     *\n     * <pre>\n     * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n     * valuesMap.put(&quot;name&quot;, &quot;Douglas ${surname}&quot;);\n     * valuesMap.put(&quot;surname&quot;, &quot;Crockford&quot;);\n     * String templateString = &quot;Hi ${name}&quot;;\n     * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n     * String resolvedString = sub.replace(templateString);\n     * </pre>\n     *\n     * yielding:\n     *\n     * <pre>\n     *      Hi Douglas ${surname}\n     * </pre>\n     *\n     * @return The substitution in variable values flag\n     */\n    public boolean isDisableSubstitutionInValues() {\n        return disableSubstitutionInValues;\n    }\n\n    /**\n     * Returns a flag whether substitution is done in variable names.\n     *\n     * @return The substitution in variable names flag\n     */\n    public boolean isEnableSubstitutionInVariables() {\n        return enableSubstitutionInVariables;\n    }\n\n    /**\n     * Returns a flag whether exception can be thrown upon undefined variable.\n     *\n     * @return The fail on undefined variable flag\n     */\n    public boolean isEnableUndefinedVariableException() {\n        return enableUndefinedVariableException;\n    }\n\n    /**\n     * Returns the flag controlling whether escapes are preserved during substitution.\n     *\n     * @return The preserve escape flag\n     */\n    public boolean isPreserveEscapes() {\n        return preserveEscapes;\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * array as a template. The array is not altered by this method.\n     *\n     * @param source the character array to replace in, not altered, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final char[] source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source.length).append(source);\n        substitute(buf, 0, source.length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * array as a template. The array is not altered by this method.\n     * <p>\n     * Only the specified portion of the array will be processed. The rest of the array is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the character array to replace in, not altered, null returns null\n     * @param offset the start offset within the array, must be valid\n     * @param length the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final char[] source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as\n     * a template. The source is not altered by this method.\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final CharSequence source) {\n        if (source == null) {\n            return null;\n        }\n        return replace(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as\n     * a template. The source is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @param offset the start offset within the array, must be valid\n     * @param length the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final CharSequence source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source.toString(), offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the\n     * resolver. The input source object is converted to a string using {@code toString} and is not altered.\n     *\n     * @param source the source to replace in, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public String replace(final Object source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder().append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * string as a template.\n     *\n     * @param source the string to replace in, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final String source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source);\n        if (!substitute(buf, 0, source.length())) {\n            return source;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * string as a template.\n     * <p>\n     * Only the specified portion of the string will be processed. The rest of the string is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the string to replace in, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final String source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return source.substring(offset, offset + length);\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * buffer as a template. The buffer is not altered by this method.\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final StringBuffer source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source.length()).append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * buffer as a template. The buffer is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * builder as a template. The builder is not altered by this method.\n     *\n     * @param source the builder to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final TextStringBuilder source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder builder = new TextStringBuilder(source.length()).append(source);\n        substitute(builder, 0, builder.length());\n        return builder.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * builder as a template. The builder is not altered by this method.\n     * <p>\n     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the builder to use as a template, not changed, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final TextStringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuffer source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver. The builder is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final StringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver.\n     *\n     * @param source the builder to replace in, updated, null returns zero\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final TextStringBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver.\n     * <p>\n     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the builder to replace in, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final TextStringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, offset, length);\n    }\n\n    /**\n     * Internal method that resolves the value of a variable.\n     * <p>\n     * Most users of this class do not need to call this method. This method is called automatically by the substitution\n     * process.\n     * </p>\n     * <p>\n     * Writers of subclasses can override this method if they need to alter how each substitution occurs. The method is\n     * passed the variable's name and must return the corresponding value. This implementation uses the\n     * {@link #getStringLookup()} with the variable's name as the key.\n     * </p>\n     *\n     * @param variableName the name of the variable, not null\n     * @param buf the buffer where the substitution is occurring, not null\n     * @param startPos the start position of the variable including the prefix, valid\n     * @param endPos the end position of the variable including the suffix, valid\n     * @return The variable's value or <b>null</b> if the variable is unknown\n     */\n    protected String resolveVariable(final String variableName, final TextStringBuilder buf, final int startPos,\n        final int endPos) {\n        final StringLookup resolver = getStringLookup();\n        if (resolver == null) {\n            return null;\n        }\n        return resolver.lookup(variableName);\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable values (recursive).\n     *\n     * @param disableSubstitutionInValues true if substitution in variable value are disabled\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setDisableSubstitutionInValues(final boolean disableSubstitutionInValues) {\n        this.disableSubstitutionInValues = disableSubstitutionInValues;\n        return this;\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable names. If set to <b>true</b>, the names of variables can\n     * contain other variables which are processed first before the original variable is evaluated, e.g.\n     * {@code ${jre-${java.version}}}. The default value is <b>false</b>.\n     *\n     * @param enableSubstitutionInVariables the new value of the flag\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {\n        this.enableSubstitutionInVariables = enableSubstitutionInVariables;\n        return this;\n    }\n\n    /**\n     * Sets a flag whether exception should be thrown if any variable is undefined.\n     *\n     * @param failOnUndefinedVariable true if exception should be thrown on undefined variable\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEnableUndefinedVariableException(final boolean failOnUndefinedVariable) {\n        this.enableUndefinedVariableException = failOnUndefinedVariable;\n        return this;\n    }\n\n    /**\n     * Sets the escape character. If this character is placed before a variable reference in the source text, this\n     * variable will be ignored.\n     *\n     * @param escapeCharacter the escape character (0 for disabling escaping)\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEscapeChar(final char escapeCharacter) {\n        this.escapeChar = escapeCharacter;\n        return this;\n    }\n\n    /**\n     * Sets a flag controlling whether escapes are preserved during substitution. If set to <b>true</b>, the escape\n     * character is retained during substitution (e.g. {@code $${this-is-escaped}} remains {@code $${this-is-escaped}}).\n     * If set to <b>false</b>, the escape character is removed during substitution (e.g. {@code $${this-is-escaped}}\n     * becomes {@code ${this-is-escaped}}). The default value is <b>false</b>\n     *\n     * @param preserveEscapes true if escapes are to be preserved\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setPreserveEscapes(final boolean preserveEscapes) {\n        this.preserveEscapes = preserveEscapes;\n        return this;\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This method allows a single character variable default value delimiter to be easily set.\n     * </p>\n     *\n     * @param valueDelimiter the variable default value delimiter character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiter(final char valueDelimiter) {\n        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.charMatcher(valueDelimiter));\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This method allows a string variable default value delimiter to be easily set.\n     * </p>\n     * <p>\n     * If the {@code valueDelimiter} is null or empty string, then the variable default value resolution becomes\n     * disabled.\n     * </p>\n     *\n     * @param valueDelimiter the variable default value delimiter string to use, may be null or empty\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiter(final String valueDelimiter) {\n        if (valueDelimiter == null || valueDelimiter.isEmpty()) {\n            setValueDelimiterMatcher(null);\n            return this;\n        }\n        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.stringMatcher(valueDelimiter));\n    }\n\n    /**\n     * Sets the variable default value delimiter matcher to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the variable name and the\n     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\n     * value delimiter matches.\n     * </p>\n     * <p>\n     * If the {@code valueDelimiterMatcher} is null, then the variable default value resolution becomes disabled.\n     * </p>\n     *\n     * @param valueDelimiterMatcher variable default value delimiter matcher to use, may be null\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiterMatcher(final StringMatcher valueDelimiterMatcher) {\n        this.valueDelimiterMatcher = valueDelimiterMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This method allows a\n     * single character prefix to be easily set.\n     * </p>\n     *\n     * @param prefix the prefix character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariablePrefix(final char prefix) {\n        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.charMatcher(prefix));\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This method allows a\n     * string prefix to be easily set.\n     * </p>\n     *\n     * @param prefix the prefix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix is null\n     */\n    public StringSubstitutor setVariablePrefix(final String prefix) {\n        Validate.isTrue(prefix != null, \"Variable prefix must not be null!\");\n        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(prefix));\n    }\n\n    /**\n     * Sets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This prefix is\n     * expressed in terms of a matcher allowing advanced prefix matches.\n     * </p>\n     *\n     * @param prefixMatcher the prefix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix matcher is null\n     */\n    public StringSubstitutor setVariablePrefixMatcher(final StringMatcher prefixMatcher) {\n        Validate.isTrue(prefixMatcher != null, \"Variable prefix matcher must not be null!\");\n        this.prefixMatcher = prefixMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the VariableResolver that is used to lookup variables.\n     *\n     * @param variableResolver the VariableResolver\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariableResolver(final StringLookup variableResolver) {\n        this.variableResolver = variableResolver;\n        return this;\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This method allows a\n     * single character suffix to be easily set.\n     * </p>\n     *\n     * @param suffix the suffix character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariableSuffix(final char suffix) {\n        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.charMatcher(suffix));\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This method allows a\n     * string suffix to be easily set.\n     * </p>\n     *\n     * @param suffix the suffix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix is null\n     */\n    public StringSubstitutor setVariableSuffix(final String suffix) {\n        Validate.isTrue(suffix != null, \"Variable suffix must not be null!\");\n        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(suffix));\n    }\n\n    /**\n     * Sets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed\n     * in terms of a matcher allowing advanced suffix matches.\n     * </p>\n     *\n     * @param suffixMatcher the suffix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix matcher is null\n     */\n    public StringSubstitutor setVariableSuffixMatcher(final StringMatcher suffixMatcher) {\n        Validate.isTrue(suffixMatcher != null, \"Variable suffix matcher must not be null!\");\n        this.suffixMatcher = suffixMatcher;\n        return this;\n    }\n\n    /**\n     * Internal method that substitutes the variables.\n     * <p>\n     * Most users of this class do not need to call this method. This method will be called automatically by another\n     * (public) method.\n     * </p>\n     * <p>\n     * Writers of subclasses can override this method if they need access to the substitution process at the start or\n     * end.\n     * </p>\n     *\n     * @param builder the string builder to substitute into, not null\n     * @param offset the start offset within the builder, must be valid\n     * @param length the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    protected boolean substitute(final TextStringBuilder builder, final int offset, final int length) {\n        return substitute(builder, offset, length, null).altered;\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation. This is the main interpolation method, which resolves the\n     * values of all variable references contained in the passed in text.\n     *\n     * @param builder the string builder to substitute into, not null\n     * @param offset the start offset within the builder, must be valid\n     * @param length the length within the builder to be processed, must be valid\n     * @param priorVariables the stack keeping track of the replaced variables, may be null\n     * @return The result.\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     * @since 1.9\n     */\n    private Result substitute(final TextStringBuilder builder, final int offset, final int length,\n        List<String> priorVariables) {\n        Objects.requireNonNull(builder, \"builder\");\n        final StringMatcher prefixMatcher = getVariablePrefixMatcher();\n        final StringMatcher suffixMatcher = getVariableSuffixMatcher();\n        final char escapeCh = getEscapeChar();\n        final StringMatcher valueDelimMatcher = getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n        final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues();\n        final boolean undefinedVariableException = isEnableUndefinedVariableException();\n        final boolean preserveEscapes = isPreserveEscapes();\n\n        boolean altered = false;\n        int lengthChange = 0;\n        int bufEnd = offset + length;\n        int pos = offset;\n        int escPos = -1;\n        outer: while (pos < bufEnd) {\n            final int startMatchLen = prefixMatcher.isMatch(builder, pos, offset, bufEnd);\n            if (startMatchLen == 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos > offset && builder.charAt(pos - 1) == escapeCh) {\n                    // escape detected\n                    if (preserveEscapes) {\n                        // keep escape\n                        pos++;\n                        continue;\n                    }\n                    // mark esc ch for deletion if we find a complete variable\n                    escPos = pos - 1;\n                }\n                // find suffix\n                int startPos = pos;\n                pos += startMatchLen;\n                int endMatchLen = 0;\n                int nestedVarCount = 0;\n                while (pos < bufEnd) {\n                    if (substitutionInVariablesEnabled && prefixMatcher.isMatch(builder, pos, offset, bufEnd) != 0) {\n                        // found a nested variable start\n                        endMatchLen = prefixMatcher.isMatch(builder, pos, offset, bufEnd);\n                        nestedVarCount++;\n                        pos += endMatchLen;\n                        continue;\n                    }\n\n                    endMatchLen = suffixMatcher.isMatch(builder, pos, offset, bufEnd);\n                    if (endMatchLen == 0) {\n                        pos++;\n                    } else {\n                        // found variable end marker\n                        if (nestedVarCount == 0) {\n                            if (escPos >= 0) {\n                                // delete escape\n                                builder.deleteCharAt(escPos);\n                                escPos = -1;\n                                lengthChange--;\n                                altered = true;\n                                bufEnd--;\n                                pos = startPos + 1;\n                                startPos--;\n                                continue outer;\n                            }\n                            // get var name\n                            String varNameExpr = builder.midString(startPos + startMatchLen,\n                                pos - startPos - startMatchLen);\n                            if (substitutionInVariablesEnabled) {\n                                final TextStringBuilder bufName = new TextStringBuilder(varNameExpr);\n                                substitute(bufName, 0, bufName.length());\n                                varNameExpr = bufName.toString();\n                            }\n                            pos += endMatchLen;\n                            final int endPos = pos;\n\n                            String varName = varNameExpr;\n                            String varDefaultValue = null;\n\n                            if (valueDelimMatcher != null) {\n                                final char[] varNameExprChars = varNameExpr.toCharArray();\n                                int valueDelimiterMatchLen = 0;\n                                for (int i = 0; i < varNameExprChars.length; i++) {\n                                    // if there's any nested variable when nested variable substitution disabled,\n                                    // then stop resolving name and default value.\n                                    if (!substitutionInVariablesEnabled && prefixMatcher.isMatch(varNameExprChars, i, i,\n                                        varNameExprChars.length) != 0) {\n                                        break;\n                                    }\n                                    if (valueDelimMatcher.isMatch(varNameExprChars, i, 0,\n                                        varNameExprChars.length) != 0) {\n                                        valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i, 0,\n                                            varNameExprChars.length);\n                                        varName = varNameExpr.substring(0, i);\n                                        varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                        break;\n                                    }\n                                }\n                            }\n\n                            // on the first call initialize priorVariables\n                            if (priorVariables == null) {\n                                priorVariables = new ArrayList<>();\n                                priorVariables.add(builder.midString(offset, length));\n                            }\n\n                            // handle cyclic substitution\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n\n                            // resolve the variable\n                            String varValue = resolveVariable(varName, builder, startPos, endPos);\n                            if (varValue == null) {\n                                varValue = varDefaultValue;\n                            }\n                            if (varValue != null) {\n                                final int varLen = varValue.length();\n                                builder.replace(startPos, endPos, varValue);\n                                altered = true;\n                                int change = 0;\n                                if (!substitutionInValuesDisabled) { // recursive replace\n                                    change = substitute(builder, startPos, varLen, priorVariables).lengthChange;\n                                }\n                                change = change + varLen - (endPos - startPos);\n                                pos += change;\n                                bufEnd += change;\n                                lengthChange += change;\n                            } else if (undefinedVariableException) {\n                                throw new IllegalArgumentException(\n                                    String.format(\"Cannot resolve variable '%s' (enableSubstitutionInVariables=%s).\",\n                                        varName, substitutionInVariablesEnabled));\n                            }\n\n                            // remove variable from the cyclic stack\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                        nestedVarCount--;\n                        pos += endMatchLen;\n                    }\n                }\n            }\n        }\n        return new Result(altered, lengthChange);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/StringSubstitutor.java b/src/main/java/org/apache/commons/text/StringSubstitutor.java\nindex 64b9f36bd2..5502943a6b 100644\n--- a/src/main/java/org/apache/commons/text/StringSubstitutor.java\n+++ b/src/main/java/org/apache/commons/text/StringSubstitutor.java\n@@ -136,7 +136,7 @@\n  *\n  * <h2>Using Interpolation</h2>\n  * <p>\n- * The default interpolator let's you use string lookups like:\n+ * The default interpolator lets you use string lookups like:\n  * </p>\n  *\n  * <pre>\n@@ -558,7 +558,7 @@ public StringSubstitutor(final StringLookup variableResolver, final StringMatche\n     /**\n      * Creates a new instance based on the given StringSubstitutor.\n      *\n-     * @param other The StringSubstitutor is use as the source.\n+     * @param other The StringSubstitutor used as the source.\n      * @since 1.9\n      */\n     public StringSubstitutor(final StringSubstitutor other) {\n@@ -1316,7 +1316,7 @@ protected boolean substitute(final TextStringBuilder builder, final int offset,\n      * @param length the length within the builder to be processed, must be valid\n      * @param priorVariables the stack keeping track of the replaced variables, may be null\n      * @return The result.\n-     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n+     * @throws IllegalArgumentException if variable is not found and <pre>isEnableUndefinedVariableException()==true</pre>\n      * @since 1.9\n      */\n     private Result substitute(final TextStringBuilder builder, final int offset, final int length,\n"
      },
      {
        "filename": "src/site/xdoc/userguide.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 281,
    "title": "[TEXT-211] TextStringBuilder.equals whatever the capacity is",
    "state": "closed",
    "created_at": "2021-11-03T10:07:39Z",
    "merge_commit_sha": "400fb6541a887fc6cb46cc03ff3ce93fcba16333",
    "base_sha": "1f14677b9c1f74e446e4fd3213df1d71aaa02f30",
    "head_sha": "a5dec75d59e7ffa167dc711347c667ae5a17b5b0",
    "user_login": "sebx59",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/TextStringBuilder.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class TextStringBuilderTest2 {\n\n    @Test\n    public void testEqualsWithDifferentSizes() {\n        TextStringBuilder sb1 = new TextStringBuilder(\"abc\");\n        TextStringBuilder sb2 = new TextStringBuilder(\"abcd\");\n        assertFalse(sb1.equals(sb2));\n    }\n\n    @Test\n    public void testEqualsWithSameSizesDifferentContent() {\n        TextStringBuilder sb1 = new TextStringBuilder(\"abc\");\n        TextStringBuilder sb2 = new TextStringBuilder(\"abd\");\n        assertFalse(sb1.equals(sb2));\n    }\n\n    @Test\n    public void testEqualsWithSameSizesSameContent() {\n        TextStringBuilder sb1 = new TextStringBuilder(\"abc\");\n        TextStringBuilder sb2 = new TextStringBuilder(\"abc\");\n        assertTrue(sb1.equals(sb2));\n    }\n\n    @Test\n    public void testEqualsWithSelf() {\n        TextStringBuilder sb = new TextStringBuilder(\"abc\");\n        assertTrue(sb.equals(sb));\n    }\n\n    @Test\n    public void testHashCodeConsistency() {\n        TextStringBuilder sb = new TextStringBuilder(\"abc\");\n        int initialHashCode = sb.hashCode();\n        assertEquals(initialHashCode, sb.hashCode());\n        sb.append(\"def\");\n        assertNotEquals(initialHashCode, sb.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithDifferentContent() {\n        TextStringBuilder sb1 = new TextStringBuilder(\"abc\");\n        TextStringBuilder sb2 = new TextStringBuilder(\"abd\");\n        assertNotEquals(sb1.hashCode(), sb2.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithSameContent() {\n        TextStringBuilder sb1 = new TextStringBuilder(\"abc\");\n        TextStringBuilder sb2 = new TextStringBuilder(\"abc\");\n        assertEquals(sb1.hashCode(), sb2.hashCode());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.Writer;\nimport java.nio.CharBuffer;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.matcher.StringMatcher;\n\n/**\n * Builds a string from constituent parts providing a more flexible and powerful API than StringBuffer.\n * <p>\n * The main differences from StringBuffer/StringBuilder are:\n * </p>\n * <ul>\n * <li>Not synchronized</li>\n * <li>Not final</li>\n * <li>Subclasses have direct access to character array</li>\n * <li>Additional methods\n * <ul>\n * <li>appendWithSeparators - adds an array of values, with a separator</li>\n * <li>appendPadding - adds a length padding characters</li>\n * <li>appendFixedLength - adds a fixed width field to the builder</li>\n * <li>toCharArray/getChars - simpler ways to get a range of the character array</li>\n * <li>delete - delete char or string</li>\n * <li>replace - search and replace for a char or string</li>\n * <li>leftString/rightString/midString - substring without exceptions</li>\n * <li>contains - whether the builder contains a char or string</li>\n * <li>size/clear/isEmpty - collections style API methods</li>\n * </ul>\n * </li>\n * <li>Views\n * <ul>\n * <li>asTokenizer - uses the internal buffer as the source of a StrTokenizer</li>\n * <li>asReader - uses the internal buffer as the source of a Reader</li>\n * <li>asWriter - allows a Writer to write directly to the internal buffer</li>\n * </ul>\n * </li>\n * </ul>\n * <p>\n * The aim has been to provide an API that mimics very closely what StringBuffer provides, but with additional methods.\n * It should be noted that some edge cases, with invalid indices or null input, have been altered - see individual\n * methods. The biggest of these changes is that by default, null will not output the text 'null'. This can be\n * controlled by a property, {@link #setNullText(String)}.\n * </p>\n * <p>\n * This class is called {@code TextStringBuilder} instead of {@code StringBuilder} to avoid clashing with\n * {@link java.lang.StringBuilder}.\n * </p>\n *\n * @since 1.3\n */\npublic class TextStringBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Inner class to allow StrBuilder to operate as a reader.\n     */\n    class TextStringBuilderReader extends Reader {\n\n        /** The last mark position. */\n        private int mark;\n\n        /** The current stream position. */\n        private int pos;\n\n        /**\n         * Default constructor.\n         */\n        TextStringBuilderReader() {\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void mark(final int readAheadLimit) {\n            mark = pos;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean markSupported() {\n            return true;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int read() {\n            if (!ready()) {\n                return -1;\n            }\n            return TextStringBuilder.this.charAt(pos++);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int read(final char[] b, final int off, int len) {\n            if (off < 0 || len < 0 || off > b.length || off + len > b.length || off + len < 0) {\n                throw new IndexOutOfBoundsException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            if (pos >= TextStringBuilder.this.size()) {\n                return -1;\n            }\n            if (pos + len > size()) {\n                len = TextStringBuilder.this.size() - pos;\n            }\n            TextStringBuilder.this.getChars(pos, pos + len, b, off);\n            pos += len;\n            return len;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean ready() {\n            return pos < TextStringBuilder.this.size();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void reset() {\n            pos = mark;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public long skip(long n) {\n            if (pos + n > TextStringBuilder.this.size()) {\n                n = TextStringBuilder.this.size() - pos;\n            }\n            if (n < 0) {\n                return 0;\n            }\n            pos = Math.addExact(pos, Math.toIntExact(n));\n            return n;\n        }\n    }\n\n    /**\n     * Inner class to allow StrBuilder to operate as a tokenizer.\n     */\n    class TextStringBuilderTokenizer extends StringTokenizer {\n\n        /**\n         * Default constructor.\n         */\n        TextStringBuilderTokenizer() {\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public String getContent() {\n            final String str = super.getContent();\n            if (str == null) {\n                return TextStringBuilder.this.toString();\n            }\n            return str;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n            if (chars == null) {\n                return super.tokenize(TextStringBuilder.this.getBuffer(), 0, TextStringBuilder.this.size());\n            }\n            return super.tokenize(chars, offset, count);\n        }\n    }\n\n    /**\n     * Inner class to allow StrBuilder to operate as a writer.\n     */\n    class TextStringBuilderWriter extends Writer {\n\n        /**\n         * Default constructor.\n         */\n        TextStringBuilderWriter() {\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void flush() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final char[] cbuf) {\n            TextStringBuilder.this.append(cbuf);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final char[] cbuf, final int off, final int len) {\n            TextStringBuilder.this.append(cbuf, off, len);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final int c) {\n            TextStringBuilder.this.append((char) c);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final String str) {\n            TextStringBuilder.this.append(str);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final String str, final int off, final int len) {\n            TextStringBuilder.this.append(str, off, len);\n        }\n    }\n\n    /** The space character. */\n    private static final char SPACE = ' ';\n\n    /**\n     * The extra capacity for new builders.\n     */\n    static final int CAPACITY = 32;\n\n    /**\n     * End-Of-Stream.\n     */\n    private static final int EOS = -1;\n\n    /**\n     * The size of the string {@code \"false\"}.\n     */\n    private static final int FALSE_STRING_SIZE = Boolean.FALSE.toString().length();\n\n    /**\n     * Required for serialization support.\n     *\n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * The size of the string {@code \"true\"}.\n     */\n    private static final int TRUE_STRING_SIZE = Boolean.TRUE.toString().length();\n\n    /**\n     * Constructs an instance from a reference to a character array. Changes to the input chars are reflected in this\n     * instance until the internal buffer needs to be reallocated. Using a reference to an array allows the instance to\n     * be initialized without copying the input array.\n     *\n     * @param initialBuffer The initial array that will back the new builder.\n     * @return A new instance.\n     * @since 1.9\n     */\n    public static TextStringBuilder wrap(final char[] initialBuffer) {\n        Objects.requireNonNull(initialBuffer, \"initialBuffer\");\n        return new TextStringBuilder(initialBuffer, initialBuffer.length);\n    }\n\n    /**\n     * Constructs an instance from a reference to a character array. Changes to the input chars are reflected in this\n     * instance until the internal buffer needs to be reallocated. Using a reference to an array allows the instance to\n     * be initialized without copying the input array.\n     *\n     * @param initialBuffer The initial array that will back the new builder.\n     * @param length The length of the subarray to be used; must be non-negative and no larger than\n     *        {@code initialBuffer.length}. The new builder's size will be set to {@code length}.\n     * @return A new instance.\n     * @since 1.9\n     */\n    public static TextStringBuilder wrap(final char[] initialBuffer, final int length) {\n        return new TextStringBuilder(initialBuffer, length);\n    }\n\n    /** Internal data storage. */\n    private char[] buffer;\n\n    /** The new line. */\n    private String newLine;\n\n    /** The null text. */\n    private String nullText;\n\n    /** Incremented when the buffer is reallocated. */\n    private int reallocations;\n\n    /** Current size of the buffer. */\n    private int size;\n\n    /**\n     * Constructs an empty builder initial capacity 32 characters.\n     */\n    public TextStringBuilder() {\n        this(CAPACITY);\n    }\n\n    /**\n     * Constructs an instance from a reference to a character array.\n     *\n     * @param initialBuffer a reference to a character array, must not be null.\n     * @param length The length of the subarray to be used; must be non-negative and no larger than\n     *        {@code initialBuffer.length}. The new builder's size will be set to {@code length}.\n     * @throws NullPointerException If {@code initialBuffer} is null.\n     * @throws IllegalArgumentException if {@code length} is bad.\n     */\n    private TextStringBuilder(final char[] initialBuffer, final int length) {\n        this.buffer = Objects.requireNonNull(initialBuffer, \"initialBuffer\");\n        if (length < 0 || length > initialBuffer.length) {\n            throw new IllegalArgumentException(\"initialBuffer.length=\" + initialBuffer.length + \", length=\" + length);\n        }\n        this.size = length;\n    }\n\n    /**\n     * Constructs an instance from a character sequence, allocating 32 extra characters for growth.\n     *\n     * @param seq the string to copy, null treated as blank string\n     * @since 1.9\n     */\n    public TextStringBuilder(final CharSequence seq) {\n        this(StringUtils.length(seq) + CAPACITY);\n        if (seq != null) {\n            append(seq);\n        }\n    }\n\n    /**\n     * Constructs an instance with the specified initial capacity.\n     *\n     * @param initialCapacity the initial capacity, zero or less will be converted to 32\n     */\n    public TextStringBuilder(final int initialCapacity) {\n        buffer = new char[initialCapacity <= 0 ? CAPACITY : initialCapacity];\n    }\n\n    /**\n     * Constructs an instance from a string, allocating 32 extra characters for growth.\n     *\n     * @param str the string to copy, null treated as blank string\n     */\n    public TextStringBuilder(final String str) {\n        this(StringUtils.length(str) + CAPACITY);\n        if (str != null) {\n            append(str);\n        }\n    }\n\n    /**\n     * Appends a boolean value to the string builder.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final boolean value) {\n        if (value) {\n            ensureCapacity(size + TRUE_STRING_SIZE);\n            appendTrue(size);\n        } else {\n            ensureCapacity(size + FALSE_STRING_SIZE);\n            appendFalse(size);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char value to the string builder.\n     *\n     * @param ch the value to append\n     * @return this, to enable chaining\n     */\n    @Override\n    public TextStringBuilder append(final char ch) {\n        final int len = length();\n        ensureCapacity(len + 1);\n        buffer[size++] = ch;\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final char[] chars) {\n        if (chars == null) {\n            return appendNull();\n        }\n        final int strLen = chars.length;\n        if (strLen > 0) {\n            final int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(chars, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     * @throws StringIndexOutOfBoundsException if {@code startIndex} is not in the\n     *  range {@code 0 <= startIndex <= chars.length}\n     * @throws StringIndexOutOfBoundsException if {@code length < 0}\n     * @throws StringIndexOutOfBoundsException if {@code startIndex + length > chars.length}\n     */\n    public TextStringBuilder append(final char[] chars, final int startIndex, final int length) {\n        if (chars == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n        }\n        if (length < 0 || startIndex + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(chars, startIndex, buffer, len, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends the contents of a char buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the char buffer to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final CharBuffer str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends the contents of a char buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param buf the char buffer to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final CharBuffer buf, final int startIndex, final int length) {\n        if (buf == null) {\n            return appendNull();\n        }\n        if (buf.hasArray()) {\n            final int totalLength = buf.remaining();\n            if (startIndex < 0 || startIndex > totalLength) {\n                throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n            }\n            if (length < 0 || startIndex + length > totalLength) {\n                throw new StringIndexOutOfBoundsException(\"length must be valid\");\n            }\n            final int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(buf.array(), buf.arrayOffset() + buf.position() + startIndex, buffer, len, length);\n            size += length;\n        } else {\n            append(buf.toString(), startIndex, length);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a CharSequence to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param seq the CharSequence to append\n     * @return this, to enable chaining\n     */\n    @Override\n    public TextStringBuilder append(final CharSequence seq) {\n        if (seq == null) {\n            return appendNull();\n        }\n        if (seq instanceof TextStringBuilder) {\n            return append((TextStringBuilder) seq);\n        }\n        if (seq instanceof StringBuilder) {\n            return append((StringBuilder) seq);\n        }\n        if (seq instanceof StringBuffer) {\n            return append((StringBuffer) seq);\n        }\n        if (seq instanceof CharBuffer) {\n            return append((CharBuffer) seq);\n        }\n        return append(seq.toString());\n    }\n\n    /**\n     * Appends part of a CharSequence to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param seq the CharSequence to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid\n     * @return this, to enable chaining\n     */\n    @Override\n    public TextStringBuilder append(final CharSequence seq, final int startIndex, final int endIndex) {\n        if (seq == null) {\n            return appendNull();\n        }\n        if (endIndex <= 0) {\n            throw new StringIndexOutOfBoundsException(\"endIndex must be valid\");\n        }\n        if (startIndex >= endIndex) {\n            throw new StringIndexOutOfBoundsException(\"endIndex must be greater than startIndex\");\n        }\n        return append(seq.toString(), startIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Appends a double value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final double value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a float value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final float value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends an int value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final int value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a long value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final long value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends an object to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param obj the object to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final Object obj) {\n        if (obj == null) {\n            return appendNull();\n        }\n        if (obj instanceof CharSequence) {\n            return append((CharSequence) obj);\n        }\n        return append(obj.toString());\n    }\n\n    /**\n     * Appends a string to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final String str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a string to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     * @throws StringIndexOutOfBoundsException if {@code startIndex} is not in the\n     *  range {@code 0 <= startIndex <= str.length()}\n     * @throws StringIndexOutOfBoundsException if {@code length < 0}\n     * @throws StringIndexOutOfBoundsException if {@code startIndex + length > str.length()}\n     */\n    public TextStringBuilder append(final String str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Calls {@link String#format(String, Object...)} and appends the result.\n     *\n     * @param format the format string\n     * @param objs the objects to use in the format string\n     * @return {@code this} to enable chaining\n     * @see String#format(String, Object...)\n     */\n    public TextStringBuilder append(final String format, final Object... objs) {\n        return append(String.format(format, objs));\n    }\n\n    /**\n     * Appends a string buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string buffer to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuffer str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a string buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuffer str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a StringBuilder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the StringBuilder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuilder str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a StringBuilder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the StringBuilder to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuilder str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends another string builder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final TextStringBuilder str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a string builder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final TextStringBuilder str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an iterable to the builder without any separators. Appending a null iterable will have no\n     * effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param iterable the iterable to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendAll(final Iterable<?> iterable) {\n        if (iterable != null) {\n            for (final Object o : iterable) {\n                append(o);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an iterator to the builder without any separators. Appending a null iterator will have no\n     * effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param it the iterator to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendAll(final Iterator<?> it) {\n        if (it != null) {\n            while (it.hasNext()) {\n                append(it.next());\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an array to the builder without any separators. Appending a null array will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param <T> the element type\n     * @param array the array to append\n     * @return this, to enable chaining\n     */\n    public <T> TextStringBuilder appendAll(@SuppressWarnings(\"unchecked\") final T... array) {\n        /*\n         * @SuppressWarnings used to hide warning about vararg usage. We cannot use @SafeVarargs, since this method is\n         * not final. Using @SuppressWarnings is fine, because it isn't inherited by subclasses, so each subclass must\n         * vouch for itself whether its use of 'array' is safe.\n         */\n        if (array != null && array.length > 0) {\n            for (final Object element : array) {\n                append(element);\n            }\n        }\n        return this;\n    }\n\n    /** Appends {@code \"false\"}. */\n    private void appendFalse(int index) {\n        buffer[index++] = 'f';\n        buffer[index++] = 'a';\n        buffer[index++] = 'l';\n        buffer[index++] = 's';\n        buffer[index] = 'e';\n        size += FALSE_STRING_SIZE;\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width. The {@code String.valueOf} of the\n     * {@code int} value is used. If the formatted value is larger than the length, the left hand side is lost.\n     *\n     * @param value the value to append\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {\n        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width. The {@code toString} of the object is\n     * used. If the object is larger than the length, the left hand side is lost. If the object is null, the null text\n     * value is used.\n     *\n     * @param obj the object to append, null uses null text\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = obj == null ? getNullText() : obj.toString();\n            if (str == null) {\n                str = StringUtils.EMPTY;\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length. The {@code String.valueOf} of the\n     * {@code int} value is used. If the object is larger than the length, the right hand side is lost.\n     *\n     * @param value the value to append\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {\n        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length. The {@code toString} of the object is\n     * used. If the object is larger than the length, the right hand side is lost. If the object is null, null text\n     * value is used.\n     *\n     * @param obj the object to append, null uses null text\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = obj == null ? getNullText() : obj.toString();\n            if (str == null) {\n                str = StringUtils.EMPTY;\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a boolean value followed by a new line to the string builder.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final boolean value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a char value followed by a new line to the string builder.\n     *\n     * @param ch the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final char ch) {\n        return append(ch).appendNewLine();\n    }\n\n    /**\n     * Appends a char array followed by a new line to the string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final char[] chars) {\n        return append(chars).appendNewLine();\n    }\n\n    /**\n     * Appends a char array followed by a new line to the string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final char[] chars, final int startIndex, final int length) {\n        return append(chars, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends a double value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final double value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a float value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final float value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends an int value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final int value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a long value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final long value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends an object followed by a new line to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param obj the object to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final Object obj) {\n        return append(obj).appendNewLine();\n    }\n\n    /**\n     * Appends a string followed by a new line to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final String str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final String str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Calls {@link String#format(String, Object...)} and appends the result.\n     *\n     * @param format the format string\n     * @param objs the objects to use in the format string\n     * @return {@code this} to enable chaining\n     * @see String#format(String, Object...)\n     */\n    public TextStringBuilder appendln(final String format, final Object... objs) {\n        return append(format, objs).appendNewLine();\n    }\n\n    /**\n     * Appends a string buffer followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string buffer to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuffer str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string buffer followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuffer str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends a string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuilder str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuilder str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends another string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final TextStringBuilder str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final TextStringBuilder str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends the new line string to this string builder.\n     * <p>\n     * The new line string can be altered using {@link #setNewLineText(String)}. This might be used to force the output\n     * to always use Unix line endings even when on Windows.\n     * </p>\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendNewLine() {\n        if (newLine == null) {\n            append(System.lineSeparator());\n            return this;\n        }\n        return append(newLine);\n    }\n\n    /**\n     * Appends the text representing {@code null} to this string builder.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendNull() {\n        if (nullText == null) {\n            return this;\n        }\n        return append(nullText);\n    }\n\n    /**\n     * Appends the pad character to the builder the specified number of times.\n     *\n     * @param length the length to append, negative means no append\n     * @param padChar the character to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendPadding(final int length, final char padChar) {\n        if (length >= 0) {\n            ensureCapacity(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator if the builder is currently non-empty. The separator is appended using {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (Iterator it = list.iterator(); it.hasNext();) {\n     *     appendSeparator(',');\n     *     append(it.next());\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final char separator) {\n        if (isNotEmpty()) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends one of both separators to the builder If the builder is currently empty it will append the\n     * defaultIfEmpty-separator Otherwise it will append the standard-separator\n     *\n     * The separator is appended using {@link #append(char)}.\n     *\n     * @param standard the separator if builder is not empty\n     * @param defaultIfEmpty the separator if builder is empty\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final char standard, final char defaultIfEmpty) {\n        if (isEmpty()) {\n            append(defaultIfEmpty);\n        } else {\n            append(standard);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero. The separator is appended using\n     * {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (int i = 0; i &lt; list.size(); i++) {\n     *     appendSeparator(\",\", i);\n     *     append(list.get(i));\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use\n     * @param loopIndex the loop index\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final char separator, final int loopIndex) {\n        if (loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator if the builder is currently non-empty. Appending a null separator will have no effect. The\n     * separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (Iterator it = list.iterator(); it.hasNext();) {\n     *     appendSeparator(\",\");\n     *     append(it.next());\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final String separator) {\n        return appendSeparator(separator, null);\n    }\n\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero. Appending a null separator will have\n     * no effect. The separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (int i = 0; i &lt; list.size(); i++) {\n     *     appendSeparator(\",\", i);\n     *     append(list.get(i));\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use, null means no separator\n     * @param loopIndex the loop index\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final String separator, final int loopIndex) {\n        if (separator != null && loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends one of both separators to the StrBuilder. If the builder is currently empty it will append the\n     * defaultIfEmpty-separator Otherwise it will append the standard-separator\n     *\n     * Appending a null separator will have no effect. The separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is for example useful for constructing queries\n     * </p>\n     *\n     * <pre>\n     * StrBuilder whereClause = new StrBuilder();\n     * if(searchCommand.getPriority() != null) {\n     *  whereClause.appendSeparator(\" and\", \" where\");\n     *  whereClause.append(\" priority = ?\")\n     * }\n     * if(searchCommand.getComponent() != null) {\n     *  whereClause.appendSeparator(\" and\", \" where\");\n     *  whereClause.append(\" component = ?\")\n     * }\n     * selectClause.append(whereClause)\n     * </pre>\n     *\n     * @param standard the separator if builder is not empty, null means no separator\n     * @param defaultIfEmpty the separator if builder is empty, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final String standard, final String defaultIfEmpty) {\n        final String str = isEmpty() ? defaultIfEmpty : standard;\n        if (str != null) {\n            append(str);\n        }\n        return this;\n    }\n\n    /**\n     * Appends current contents of this {@code StrBuilder} to the provided {@link Appendable}.\n     * <p>\n     * This method tries to avoid doing any extra copies of contents.\n     * </p>\n     *\n     * @param appendable the appendable to append data to\n     * @throws IOException if an I/O error occurs.\n     *\n     * @see #readFrom(Readable)\n     */\n    public void appendTo(final Appendable appendable) throws IOException {\n        if (appendable instanceof Writer) {\n            ((Writer) appendable).write(buffer, 0, size);\n        } else if (appendable instanceof StringBuilder) {\n            ((StringBuilder) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof StringBuffer) {\n            ((StringBuffer) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof CharBuffer) {\n            ((CharBuffer) appendable).put(buffer, 0, size);\n        } else {\n            appendable.append(this);\n        }\n    }\n\n    /** Appends {@code \"true\"}. */\n    private void appendTrue(int index) {\n        buffer[index++] = 't';\n        buffer[index++] = 'r';\n        buffer[index++] = 'u';\n        buffer[index] = 'e';\n        size += TRUE_STRING_SIZE;\n    }\n\n    /**\n     * Appends an iterable placing separators between each value, but not before the first or after the last. Appending\n     * a null iterable will have no effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param iterable the iterable to append\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendWithSeparators(final Iterable<?> iterable, final String separator) {\n        if (iterable != null) {\n            final String sep = Objects.toString(separator, StringUtils.EMPTY);\n            final Iterator<?> it = iterable.iterator();\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(sep);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends an iterator placing separators between each value, but not before the first or after the last. Appending\n     * a null iterator will have no effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param it the iterator to append\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendWithSeparators(final Iterator<?> it, final String separator) {\n        if (it != null) {\n            final String sep = Objects.toString(separator, StringUtils.EMPTY);\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(sep);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends an array placing separators between each value, but not before the first or after the last. Appending a\n     * null array will have no effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param array the array to append\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendWithSeparators(final Object[] array, final String separator) {\n        if (array != null && array.length > 0) {\n            final String sep = Objects.toString(separator, StringUtils.EMPTY);\n            append(array[0]);\n            for (int i = 1; i < array.length; i++) {\n                append(sep);\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Gets the contents of this builder as a Reader.\n     * <p>\n     * This method allows the contents of the builder to be read using any standard method that expects a Reader.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder}, populate it with data, call {@code asReader}, and then read away.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the reader. This allows you to append to the\n     * builder after creating the reader, and the changes will be picked up. Note however, that no synchronization\n     * occurs, so you must perform all operations with the builder and the reader in one thread.\n     * </p>\n     * <p>\n     * The returned reader supports marking, and ignores the flush method.\n     * </p>\n     *\n     * @return a reader that reads from this builder\n     */\n    public Reader asReader() {\n        return new TextStringBuilderReader();\n    }\n\n    /**\n     * Creates a tokenizer that can tokenize the contents of this builder.\n     * <p>\n     * This method allows the contents of this builder to be tokenized. The tokenizer will be setup by default to\n     * tokenize on space, tab, newline and form feed (as per StringTokenizer). These values can be changed on the\n     * tokenizer class, before retrieving the tokens.\n     * </p>\n     * <p>\n     * The returned tokenizer is linked to this builder. You may intermix calls to the builder and tokenizer within\n     * certain limits, however there is no synchronization. Once the tokenizer has been used once, it must be\n     * {@link StringTokenizer#reset() reset} to pickup the latest changes in the builder. For example:\n     * </p>\n     *\n     * <pre>\n     * StrBuilder b = new StrBuilder();\n     * b.append(\"a b \");\n     * StrTokenizer t = b.asTokenizer();\n     * String[] tokens1 = t.getTokenArray(); // returns a,b\n     * b.append(\"c d \");\n     * String[] tokens2 = t.getTokenArray(); // returns a,b (c and d ignored)\n     * t.reset(); // reset causes builder changes to be picked up\n     * String[] tokens3 = t.getTokenArray(); // returns a,b,c,d\n     * </pre>\n     *\n     * <p>\n     * In addition to simply intermixing appends and tokenization, you can also call the set methods on the tokenizer to\n     * alter how it tokenizes. Just remember to call reset when you want to pickup builder changes.\n     * </p>\n     * <p>\n     * Calling {@link StringTokenizer#reset(String)} or {@link StringTokenizer#reset(char[])} with a non-null value will\n     * break the link with the builder.\n     * </p>\n     *\n     * @return a tokenizer that is linked to this builder\n     */\n    public StringTokenizer asTokenizer() {\n        return new TextStringBuilderTokenizer();\n    }\n\n    /**\n     * Gets this builder as a Writer that can be written to.\n     * <p>\n     * This method allows you to populate the contents of the builder using any standard method that takes a Writer.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder}, call {@code asWriter}, and populate away. The data is available at\n     * any time using the methods of the {@code StrBuilder}.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the writer. This allows you to intermix calls that\n     * append to the builder and write using the writer and the changes will be occur correctly. Note however, that no\n     * synchronization occurs, so you must perform all operations with the builder and the writer in one thread.\n     * </p>\n     * <p>\n     * The returned writer ignores the close and flush methods.\n     * </p>\n     *\n     * @return a writer that populates this builder\n     */\n    public Writer asWriter() {\n        return new TextStringBuilderWriter();\n    }\n\n    /**\n     * Implement the {@link Builder} interface.\n     *\n     * @return The builder as a String\n     * @see #toString()\n     */\n    @Override\n    public String build() {\n        return toString();\n    }\n\n    /**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return The capacity\n     */\n    public int capacity() {\n        return buffer.length;\n    }\n\n    /**\n     * Gets the character at the specified index.\n     *\n     * @see #setCharAt(int, char)\n     * @see #deleteCharAt(int)\n     * @param index the index to retrieve, must be valid\n     * @return The character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    @Override\n    public char charAt(final int index) {\n        validateIndex(index);\n        return buffer[index];\n    }\n\n    /**\n     * Clears the string builder (convenience Collections API style method).\n     * <p>\n     * This method does not reduce the size of the internal character buffer. To do that, call {@code clear()} followed\n     * by {@link #minimizeCapacity()}.\n     * </p>\n     * <p>\n     * This method is the same as {@link #setLength(int)} called with zero and is provided to match the API of\n     * Collections.\n     * </p>\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder clear() {\n        size = 0;\n        return this;\n    }\n\n    /**\n     * Tests if the string builder contains the specified char.\n     *\n     * @param ch the character to find\n     * @return true if the builder contains the character\n     */\n    public boolean contains(final char ch) {\n        final char[] thisBuf = buffer;\n        for (int i = 0; i < this.size; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Tests if the string builder contains the specified string.\n     *\n     * @param str the string to find\n     * @return true if the builder contains the string\n     */\n    public boolean contains(final String str) {\n        return indexOf(str, 0) >= 0;\n    }\n\n    /**\n     * Tests if the string builder contains a string matched using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to search for\n     * the character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @return true if the matcher finds a match in the builder\n     */\n    public boolean contains(final StringMatcher matcher) {\n        return indexOf(matcher, 0) >= 0;\n    }\n\n    /**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder delete(final int startIndex, final int endIndex) {\n        final int actualEndIndex = validateRange(startIndex, endIndex);\n        final int len = actualEndIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, actualEndIndex, len);\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch the character to delete\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteAll(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                final int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                final int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteAll(final String str) {\n        final int len = str == null ? 0 : str.length();\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            while (index >= 0) {\n                deleteImpl(index, index + len, len);\n                index = indexOf(str, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes all parts of the builder that the matcher matches.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteAll(final StringMatcher matcher) {\n        return replace(matcher, null, 0, size, -1);\n    }\n\n    /**\n     * Deletes the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #setCharAt(int, char)\n     * @param index the index to delete\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder deleteCharAt(final int index) {\n        validateIndex(index);\n        deleteImpl(index, index + 1, 1);\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch the character to delete\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteFirst(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteFirst(final String str) {\n        final int len = str == null ? 0 : str.length();\n        if (len > 0) {\n            final int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the first match within the builder using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior. For example you could write a matcher to delete where\n     * the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteFirst(final StringMatcher matcher) {\n        return replace(matcher, null, 0, size, 1);\n    }\n\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex the start index, must be valid\n     * @param endIndex the end index (exclusive), must be valid\n     * @param len the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void deleteImpl(final int startIndex, final int endIndex, final int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    /**\n     * Gets the character at the specified index before deleting it.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index the index to retrieve, must be valid\n     * @return The character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 1.9\n     */\n    public char drainChar(final int index) {\n        validateIndex(index);\n        final char c = buffer[index];\n        deleteCharAt(index);\n        return c;\n    }\n\n    /**\n     * Drains (copies, then deletes) this character sequence into the specified array. This is equivalent to copying the\n     * characters from this sequence into the target and then deleting those character from this sequence.\n     *\n     * @param startIndex first index to copy, inclusive.\n     * @param endIndex last index to copy, exclusive.\n     * @param target the target array, must not be {@code null}.\n     * @param targetIndex the index to start copying in the target.\n     * @return How many characters where copied (then deleted). If this builder is empty, return {@code 0}.\n     * @since 1.9\n     */\n    public int drainChars(final int startIndex, final int endIndex, final char[] target, final int targetIndex) {\n        final int length = endIndex - startIndex;\n        if (isEmpty() || length == 0 || target.length == 0) {\n            return 0;\n        }\n        final int actualLen = Math.min(Math.min(size, length), target.length - targetIndex);\n        getChars(startIndex, actualLen, target, targetIndex);\n        delete(startIndex, actualLen);\n        return actualLen;\n    }\n\n    /**\n     * Checks whether this builder ends with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str the string to search for, null returns false\n     * @return true if the builder ends with the string\n     */\n    public boolean endsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        int pos = size - len;\n        for (int i = 0; i < len; i++, pos++) {\n            if (buffer[pos] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests the capacity and ensures that it is at least the size specified.\n     *\n     * @param capacity the capacity to ensure\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder ensureCapacity(final int capacity) {\n        if (capacity > buffer.length) {\n            reallocate(capacity * 2);\n        }\n        return this;\n    }\n\n    /**\n     * Tests the contents of this builder against another to see if they contain the same character content.\n     *\n     * @param obj the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        return obj instanceof TextStringBuilder && equals((TextStringBuilder) obj);\n    }\n\n    /**\n     * Tests the contents of this builder against another to see if they contain the same character content.\n     *\n     * @param other the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equals(final TextStringBuilder other) {\n        return other != null && Arrays.equals(buffer, other.buffer);\n    }\n\n    /**\n     * Tests the contents of this builder against another to see if they contain the same character content ignoring\n     * case.\n     *\n     * @param other the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equalsIgnoreCase(final TextStringBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        final char[] thisBuf = this.buffer;\n        final char[] otherBuf = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            final char c1 = thisBuf[i];\n            final char c2 = otherBuf[i];\n            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /** Gets a direct reference to internal storage, not for public consumption. */\n    char[] getBuffer() {\n        return buffer;\n    }\n\n    /**\n     * Copies this character array into the specified array.\n     *\n     * @param target the target array, null will cause an array to be created\n     * @return The input array, unless that was null or too small\n     */\n    public char[] getChars(char[] target) {\n        final int len = length();\n        if (target == null || target.length < len) {\n            target = new char[len];\n        }\n        System.arraycopy(buffer, 0, target, 0, len);\n        return target;\n    }\n\n    /**\n     * Copies this character array into the specified array.\n     *\n     * @param startIndex first index to copy, inclusive, must be valid.\n     * @param endIndex last index to copy, exclusive, must be valid.\n     * @param target the target array, must not be null or too small.\n     * @param targetIndex the index to start copying in target.\n     * @throws NullPointerException if the array is null.\n     * @throws IndexOutOfBoundsException if any index is invalid.\n     */\n    public void getChars(final int startIndex, final int endIndex, final char[] target, final int targetIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex < 0 || endIndex > length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        System.arraycopy(buffer, startIndex, target, targetIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Gets the text to be appended when a new line is added.\n     *\n     * @return The new line text, null means use system default\n     */\n    public String getNewLineText() {\n        return newLine;\n    }\n\n    /**\n     * Gets the text to be appended when null is added.\n     *\n     * @return The null text, null means no append\n     */\n    public String getNullText() {\n        return nullText;\n    }\n\n    /**\n     * Gets a suitable hash code for this builder.\n     *\n     * @return a hash code\n     */\n    @Override\n    public int hashCode() {\n        return Arrays.hashCode(buffer);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     *\n     * @param ch the character to find\n     * @return The first index of the character, or -1 if not found\n     */\n    public int indexOf(final char ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     *\n     * @param ch the character to find\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The first index of the character, or -1 if not found\n     */\n    public int indexOf(final char ch, int startIndex) {\n        startIndex = Math.max(0, startIndex);\n        if (startIndex >= size) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str the string to find, null returns -1\n     * @return The first index of the string, or -1 if not found\n     */\n    public int indexOf(final String str) {\n        return indexOf(str, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified string starting searching from the given\n     * index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str the string to find, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The first index of the string, or -1 if not found\n     */\n    public int indexOf(final String str, int startIndex) {\n        startIndex = Math.max(0, startIndex);\n        if (str == null || startIndex >= size) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final char[] thisBuf = buffer;\n        final int len = size - strLen + 1;\n        outer: for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @return The first index matched, or -1 if not found\n     */\n    public int indexOf(final StringMatcher matcher) {\n        return indexOf(matcher, 0);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The first index matched, or -1 if not found\n     */\n    public int indexOf(final StringMatcher matcher, int startIndex) {\n        startIndex = Math.max(0, startIndex);\n        if (matcher == null || startIndex >= size) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final int len = size;\n        final char[] buf = buffer;\n        for (int i = startIndex; i < len; i++) {\n            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + TRUE_STRING_SIZE);\n            System.arraycopy(buffer, index, buffer, index + TRUE_STRING_SIZE, size - index);\n            appendTrue(index);\n        } else {\n            ensureCapacity(size + FALSE_STRING_SIZE);\n            System.arraycopy(buffer, index, buffer, index + FALSE_STRING_SIZE, size - index);\n            appendFalse(index);\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Inserts the character array into this builder. Inserting null will use the stored null text value.\n     *\n     * @param index the index to add at, must be valid\n     * @param chars the char array to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final char[] chars) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        final int len = chars.length;\n        if (len > 0) {\n            ensureCapacity(size + len);\n            System.arraycopy(buffer, index, buffer, index + len, size - index);\n            System.arraycopy(chars, 0, buffer, index, len);\n            size += len;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts part of the character array into this builder. Inserting null will use the stored null text value.\n     *\n     * @param index the index to add at, must be valid\n     * @param chars the char array to insert\n     * @param offset the offset into the character array to start at, must be valid\n     * @param length the length of the character array part to copy, must be positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    public TextStringBuilder insert(final int index, final char[] chars, final int offset, final int length) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        if (offset < 0 || offset > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n        }\n        if (length < 0 || offset + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            ensureCapacity(size + length);\n            System.arraycopy(buffer, index, buffer, index + length, size - index);\n            System.arraycopy(chars, offset, buffer, index, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the string representation of an object into this builder. Inserting null will use the stored null text\n     * value.\n     *\n     * @param index the index to add at, must be valid\n     * @param obj the object to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final Object obj) {\n        if (obj == null) {\n            return insert(index, nullText);\n        }\n        return insert(index, obj.toString());\n    }\n\n    /**\n     * Inserts the string into this builder. Inserting null will use the stored null text value.\n     *\n     * @param index the index to add at, must be valid\n     * @param str the string to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, String str) {\n        validateIndex(index);\n        if (str == null) {\n            str = nullText;\n        }\n        if (str != null) {\n            final int strLen = str.length();\n            if (strLen > 0) {\n                final int newSize = size + strLen;\n                ensureCapacity(newSize);\n                System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n                size = newSize;\n                str.getChars(0, strLen, buffer, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Checks is the string builder is empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return {@code true} if the size is {@code 0}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Checks is the string builder is not empty.\n     * <p>\n     * This method is the same as checking {@link #length()}.\n     * </p>\n     *\n     * @return {@code true} if the size is not {@code 0}.\n     * @since 1.9\n     */\n    public boolean isNotEmpty() {\n        return size != 0;\n    }\n\n    /**\n     * Gets whether the internal buffer has been reallocated.\n     *\n     * @return Whether the internal buffer has been reallocated.\n     * @since 1.9\n     */\n    public boolean isReallocated() {\n        return reallocations > 0;\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     *\n     * @param ch the character to find\n     * @return The last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(final char ch) {\n        return lastIndexOf(ch, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     *\n     * @param ch the character to find\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(final char ch, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (startIndex < 0) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (buffer[i] == ch) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str the string to find, null returns -1\n     * @return The last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(final String str) {\n        return lastIndexOf(str, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified string starting searching from the given\n     * index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str the string to find, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(final String str, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (str == null || startIndex < 0) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final int strLen = str.length();\n        if (strLen > 0 && strLen <= size) {\n            if (strLen == 1) {\n                return lastIndexOf(str.charAt(0), startIndex);\n            }\n\n            outer: for (int i = startIndex - strLen + 1; i >= 0; i--) {\n                for (int j = 0; j < strLen; j++) {\n                    if (str.charAt(j) != buffer[i + j]) {\n                        continue outer;\n                    }\n                }\n                return i;\n            }\n\n        } else if (strLen == 0) {\n            return startIndex;\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last match.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @return The last index matched, or -1 if not found\n     */\n    public int lastIndexOf(final StringMatcher matcher) {\n        return lastIndexOf(matcher, size);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The last index matched, or -1 if not found\n     */\n    public int lastIndexOf(final StringMatcher matcher, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (matcher == null || startIndex < 0) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final char[] buf = buffer;\n        final int endIndex = startIndex + 1;\n        for (int i = startIndex; i >= 0; i--) {\n            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Extracts the leftmost characters from the string builder without throwing an exception.\n     * <p>\n     * This method extracts the left {@code length} characters from the builder. If this many characters are not\n     * available, the whole builder is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String leftString(final int length) {\n        if (length <= 0) {\n            return StringUtils.EMPTY;\n        }\n        if (length >= size) {\n            return new String(buffer, 0, size);\n        }\n        return new String(buffer, 0, length);\n    }\n\n    /**\n     * Gets the length of the string builder.\n     *\n     * @return The length\n     */\n    @Override\n    public int length() {\n        return size;\n    }\n\n    /**\n     * Extracts some characters from the middle of the string builder without throwing an exception.\n     * <p>\n     * This method extracts {@code length} characters from the builder at the specified index. If the index is negative\n     * it is treated as zero. If the index is greater than the builder size, it is treated as the builder size. If the\n     * length is negative, the empty string is returned. If insufficient characters are available in the builder, as\n     * much as possible is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param index the index to start at, negative means zero\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String midString(int index, final int length) {\n        if (index < 0) {\n            index = 0;\n        }\n        if (length <= 0 || index >= size) {\n            return StringUtils.EMPTY;\n        }\n        if (size <= index + length) {\n            return new String(buffer, index, size - index);\n        }\n        return new String(buffer, index, length);\n    }\n\n    /**\n     * Minimizes the capacity to the actual length of the string.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder minimizeCapacity() {\n        if (buffer.length > size) {\n            reallocate(size);\n        }\n        return this;\n    }\n\n    /**\n     * If possible, reads chars from the provided {@link CharBuffer} directly into underlying character buffer without\n     * making extra copies.\n     *\n     * @param charBuffer CharBuffer to read.\n     * @return The number of characters read.\n     *\n     * @see #appendTo(Appendable)\n     * @since 1.9\n     */\n    public int readFrom(final CharBuffer charBuffer) {\n        final int oldSize = size;\n        final int remaining = charBuffer.remaining();\n        ensureCapacity(size + remaining);\n        charBuffer.get(buffer, size, remaining);\n        size += remaining;\n        return size - oldSize;\n    }\n\n    /**\n     * If possible, reads all chars from the provided {@link Readable} directly into underlying character buffer without\n     * making extra copies.\n     *\n     * @param readable object to read from\n     * @return The number of characters read\n     * @throws IOException if an I/O error occurs.\n     *\n     * @see #appendTo(Appendable)\n     */\n    public int readFrom(final Readable readable) throws IOException {\n        if (readable instanceof Reader) {\n            return readFrom((Reader) readable);\n        }\n        if (readable instanceof CharBuffer) {\n            return readFrom((CharBuffer) readable);\n        }\n        final int oldSize = size;\n        while (true) {\n            ensureCapacity(size + 1);\n            final CharBuffer buf = CharBuffer.wrap(buffer, size, buffer.length - size);\n            final int read = readable.read(buf);\n            if (read == EOS) {\n                break;\n            }\n            size += read;\n        }\n        return size - oldSize;\n    }\n\n    /**\n     * If possible, reads all chars from the provided {@link Reader} directly into underlying character buffer without\n     * making extra copies.\n     *\n     * @param reader Reader to read.\n     * @return The number of characters read or -1 if we reached the end of stream.\n     * @throws IOException if an I/O error occurs.\n     *\n     * @see #appendTo(Appendable)\n     * @since 1.9\n     */\n    public int readFrom(final Reader reader) throws IOException {\n        final int oldSize = size;\n        ensureCapacity(size + 1);\n        int readCount = reader.read(buffer, size, buffer.length - size);\n        if (readCount == EOS) {\n            return EOS;\n        }\n        do {\n            size += readCount;\n            ensureCapacity(size + 1);\n            readCount = reader.read(buffer, size, buffer.length - size);\n        } while (readCount != EOS);\n        return size - oldSize;\n    }\n\n    /**\n     * If possible, reads {@code count} chars from the provided {@link Reader} directly into underlying character buffer\n     * without making extra copies.\n     *\n     * @param reader Reader to read.\n     * @param count The maximum characters to read, a value &lt;= 0 returns 0.\n     * @return The number of characters read. If less than {@code count}, then we've reached the end-of-stream, or -1 if\n     *         we reached the end of stream.\n     * @throws IOException if an I/O error occurs.\n     * @see #appendTo(Appendable)\n     * @since 1.9\n     */\n    public int readFrom(final Reader reader, final int count) throws IOException {\n        if (count <= 0) {\n            return 0;\n        }\n        final int oldSize = size;\n        ensureCapacity(size + count);\n        int target = count;\n        int readCount = reader.read(buffer, size, target);\n        if (readCount == EOS) {\n            return EOS;\n        }\n        do {\n            target -= readCount;\n            size += readCount;\n            readCount = reader.read(buffer, size, target);\n        } while (target > 0 && readCount != EOS);\n        return size - oldSize;\n    }\n\n    /**\n     * Reallocates the buffer to the new length.\n     *\n     * @param newLength the length of the copy to be returned\n     */\n    private void reallocate(final int newLength) {\n        this.buffer = Arrays.copyOf(buffer, newLength);\n        this.reallocations++;\n    }\n\n    /**\n     * Replaces a portion of the string builder with another string. The length of the inserted string does not have to\n     * match the removed length.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @param replaceStr the string to replace with, null means delete range\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder replace(final int startIndex, int endIndex, final String replaceStr) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int insertLen = replaceStr == null ? 0 : replaceStr.length();\n        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n        return this;\n    }\n\n    /**\n     * Advanced search and replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the string to replace the match with, null is a delete\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @param replaceCount the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if start index is invalid\n     */\n    public TextStringBuilder replace(final StringMatcher matcher, final String replaceStr, final int startIndex,\n        int endIndex, final int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }\n\n    /**\n     * Replaces the search character with the replace character throughout the builder.\n     *\n     * @param search the search character\n     * @param replace the replace character\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceAll(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the search string with the replace string throughout the builder.\n     *\n     * @param searchStr the search string, null causes no action to occur\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceAll(final String searchStr, final String replaceStr) {\n        final int searchLen = searchStr == null ? 0 : searchStr.length();\n        if (searchLen > 0) {\n            final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n            int index = indexOf(searchStr, 0);\n            while (index >= 0) {\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n                index = indexOf(searchStr, index + replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces all matches within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior. For example you could write a matcher to replace all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceAll(final StringMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }\n\n    /**\n     * Replaces the first instance of the search character with the replace character in the builder.\n     *\n     * @param search the search character\n     * @param replace the replace character\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceFirst(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search string with the replace string.\n     *\n     * @param searchStr the search string, null causes no action to occur\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceFirst(final String searchStr, final String replaceStr) {\n        final int searchLen = searchStr == null ? 0 : searchStr.length();\n        if (searchLen > 0) {\n            final int index = indexOf(searchStr, 0);\n            if (index >= 0) {\n                final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first match within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior. For example you could write a matcher to replace where\n     * the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceFirst(final StringMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }\n\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex the start index, must be valid\n     * @param endIndex the end index (exclusive), must be valid\n     * @param removeLen the length to remove (endIndex - startIndex), must be valid\n     * @param insertStr the string to replace with, null means delete range\n     * @param insertLen the length of the insert string, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr,\n        final int insertLen) {\n        final int newSize = size - removeLen + insertLen;\n        if (insertLen != removeLen) {\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n            size = newSize;\n        }\n        if (insertLen > 0) {\n            insertStr.getChars(0, insertLen, buffer, startIndex);\n        }\n    }\n\n    /**\n     * Replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the string to replace the match with, null is a delete\n     * @param from the start index, must be valid\n     * @param to the end index (exclusive), must be valid\n     * @param replaceCount the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private TextStringBuilder replaceImpl(final StringMatcher matcher, final String replaceStr, final int from, int to,\n        int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            final char[] buf = buffer;\n            final int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Reverses the string builder placing each character in the opposite index.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder reverse() {\n        if (size == 0) {\n            return this;\n        }\n\n        final int half = size / 2;\n        final char[] buf = buffer;\n        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {\n            final char swap = buf[leftIdx];\n            buf[leftIdx] = buf[rightIdx];\n            buf[rightIdx] = swap;\n        }\n        return this;\n    }\n\n    /**\n     * Extracts the rightmost characters from the string builder without throwing an exception.\n     * <p>\n     * This method extracts the right {@code length} characters from the builder. If this many characters are not\n     * available, the whole builder is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String rightString(final int length) {\n        if (length <= 0) {\n            return StringUtils.EMPTY;\n        }\n        if (length >= size) {\n            return new String(buffer, 0, size);\n        }\n        return new String(buffer, size - length, length);\n    }\n\n    /**\n     * Clears and sets this builder to the given value.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param str the new value.\n     * @return this, to enable chaining\n     * @since 1.9\n     */\n    public TextStringBuilder set(final CharSequence str) {\n        clear();\n        append(str);\n        return this;\n    }\n\n    /**\n     * Sets the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index the index to set\n     * @param ch the new character\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder setCharAt(final int index, final char ch) {\n        validateIndex(index);\n        buffer[index] = ch;\n        return this;\n    }\n\n    /**\n     * Updates the length of the builder by either dropping the last characters or adding filler of Unicode zero.\n     *\n     * @param length the length to set to, must be zero or positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the length is negative\n     */\n    public TextStringBuilder setLength(final int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacity(length);\n            final int oldEnd = size;\n            size = length;\n            Arrays.fill(buffer, oldEnd, length, '\\0');\n        }\n        return this;\n    }\n\n    /**\n     * Sets the text to be appended when a new line is added.\n     *\n     * @param newLine the new line text, null means use system default\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder setNewLineText(final String newLine) {\n        this.newLine = newLine;\n        return this;\n    }\n\n    /**\n     * Sets the text to be appended when null is added.\n     *\n     * @param nullText the null text, null means no append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.isEmpty()) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }\n\n    /**\n     * Gets the length of the string builder.\n     * <p>\n     * This method is the same as {@link #length()} and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return The length\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Checks whether this builder starts with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str the string to search for, null returns false\n     * @return true if the builder starts with the string\n     */\n    public boolean startsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        for (int i = 0; i < len; i++) {\n            if (buffer[i] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public CharSequence subSequence(final int startIndex, final int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(endIndex - startIndex);\n        }\n        return substring(startIndex, endIndex);\n    }\n\n    /**\n     * Extracts a portion of this string builder as a string.\n     *\n     * @param start the start index, inclusive, must be valid\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(final int start) {\n        return substring(start, size);\n    }\n\n    /**\n     * Extracts a portion of this string builder as a string.\n     * <p>\n     * Note: This method treats an endIndex greater than the length of the builder as equal to the length of the\n     * builder, and continues without error, unlike StringBuffer or String.\n     * </p>\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        return new String(buffer, startIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Copies the builder's character array into a new character array.\n     *\n     * @return a new array that represents the contents of the builder\n     */\n    public char[] toCharArray() {\n        return size == 0 ? ArrayUtils.EMPTY_CHAR_ARRAY : Arrays.copyOf(buffer, size);\n    }\n\n    /**\n     * Copies part of the builder's character array into a new character array.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return a new array that holds part of the contents of the builder\n     * @throws IndexOutOfBoundsException if startIndex is invalid, or if endIndex is invalid (but endIndex greater than\n     *         size is valid)\n     */\n    public char[] toCharArray(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        return len == 0 ? ArrayUtils.EMPTY_CHAR_ARRAY : Arrays.copyOfRange(buffer, startIndex, endIndex);\n    }\n\n    /**\n     * Gets a String version of the string builder, creating a new instance each time the method is called.\n     * <p>\n     * Note that unlike StringBuffer, the string version returned is independent of the string builder.\n     * </p>\n     *\n     * @return The builder as a String\n     */\n    @Override\n    public String toString() {\n        return new String(buffer, 0, size);\n    }\n\n    /**\n     * Gets a StringBuffer version of the string builder, creating a new instance each time the method is called.\n     *\n     * @return The builder as a StringBuffer\n     */\n    public StringBuffer toStringBuffer() {\n        return new StringBuffer(size).append(buffer, 0, size);\n    }\n\n    /**\n     * Gets a StringBuilder version of the string builder, creating a new instance each time the method is called.\n     *\n     * @return The builder as a StringBuilder\n     */\n    public StringBuilder toStringBuilder() {\n        return new StringBuilder(size).append(buffer, 0, size);\n    }\n\n    /**\n     * Trims the builder by removing characters less than or equal to a space from the beginning and end.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder trim() {\n        if (size == 0) {\n            return this;\n        }\n        int len = size;\n        final char[] buf = buffer;\n        int pos = 0;\n        while (pos < len && buf[pos] <= SPACE) {\n            pos++;\n        }\n        while (pos < len && buf[len - 1] <= SPACE) {\n            len--;\n        }\n        if (len < size) {\n            delete(len, size);\n        }\n        if (pos > 0) {\n            delete(0, pos);\n        }\n        return this;\n    }\n\n    /**\n     * Validates that an index is in the range {@code 0 <= index <= size}.\n     *\n     * @param index the index to test.\n     * @throws IndexOutOfBoundsException Thrown when the index is not the range {@code 0 <= index <= size}.\n     */\n    protected void validateIndex(final int index) {\n        if (index < 0 || index >= size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n    }\n\n    /**\n     * Validates parameters defining a range of the builder.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return A valid end index.\n     * @throws StringIndexOutOfBoundsException if the index is invalid\n     */\n    protected int validateRange(final int startIndex, int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            endIndex = size;\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        return endIndex;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/TextStringBuilder.java b/src/main/java/org/apache/commons/text/TextStringBuilder.java\nindex aba3ccaf0e..ac9a0852d7 100644\n--- a/src/main/java/org/apache/commons/text/TextStringBuilder.java\n+++ b/src/main/java/org/apache/commons/text/TextStringBuilder.java\n@@ -1850,7 +1850,25 @@ public boolean equals(final Object obj) {\n      * @return true if the builders contain the same characters in the same order\n      */\n     public boolean equals(final TextStringBuilder other) {\n-        return other != null && Arrays.equals(buffer, other.buffer);\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other == null) {\n+            return false;\n+        }\n+        if (this.size != other.size) {\n+            return false;\n+        }\n+        // Be aware not to use Arrays.equals(buffer, other.buffer) for equals() method\n+        // as length of the buffers may be different (TEXT-211)\n+        final char[] thisBuf = this.buffer;\n+        final char[] otherBuf = other.buffer;\n+        for (int i = size - 1; i >= 0; i--) {\n+            if (thisBuf[i] != otherBuf[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n@@ -1947,7 +1965,7 @@ public String getNullText() {\n      */\n     @Override\n     public int hashCode() {\n-        return Arrays.hashCode(buffer);\n+        return this.toString().hashCode();\n     }\n \n     /**\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/TextStringBuilderTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 249,
    "title": "TEXT-210: fixing spotbugs failures",
    "state": "closed",
    "created_at": "2021-07-07T02:37:35Z",
    "merge_commit_sha": "0ec85b01b043e0d838e706d14b0cd1d21dc48d54",
    "base_sha": "b2b1729fd070ef29f7df0e940f368ae1b7815817",
    "head_sha": "0ec85b01b043e0d838e706d14b0cd1d21dc48d54",
    "user_login": "darkma773r",
    "changed_files": [
      {
        "filename": "spotbugs-exclude-filter.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/text/ExtendedMessageFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.MessageFormat;\nimport java.text.NumberFormat;\nimport java.text.ParsePosition;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class ExtendedMessageFormatTest2 {\n\n    private static class LowerCaseFormat extends Format {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n            return toAppendTo.append(((String) obj).toLowerCase(Locale.ROOT));\n        }\n\n        @Override\n        public Object parseObject(final String source, final ParsePosition pos) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class LowerCaseFormatFactory implements FormatFactory {\n        private static final Format LOWER_INSTANCE = new LowerCaseFormat();\n\n        @Override\n        public Format getFormat(final String name, final String arguments, final Locale locale) {\n            return LOWER_INSTANCE;\n        }\n    }\n\n    private final Map<String, FormatFactory> registry = new HashMap<>();\n\n    @BeforeEach\n    public void setUp() {\n        registry.put(\"lower\", new LowerCaseFormatFactory());\n    }\n\n    @Test\n    public void testRegistryIsUnmodifiable() {\n        Map<String, FormatFactory> modifiableRegistry = new HashMap<>();\n        modifiableRegistry.put(\"lower\", new LowerCaseFormatFactory());\n\n        ExtendedMessageFormat emf = new ExtendedMessageFormat(\"Pattern: {0,lower}\", Locale.US, modifiableRegistry);\n\n        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> {\n            emf.registry.put(\"upper\", new LowerCaseFormatFactory());\n        });\n    }\n\n    @Test\n    public void testNullRegistry() {\n        ExtendedMessageFormat emf = new ExtendedMessageFormat(\"Pattern: {0,lower}\", Locale.US, null);\n        assertEquals(\"Pattern: {0,lower}\", emf.toPattern());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.text.Format;\nimport java.text.MessageFormat;\nimport java.text.ParsePosition;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Locale.Category;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\n\n/**\n * Extends {@code java.text.MessageFormat} to allow pluggable/additional formatting\n * options for embedded format elements.  Client code should specify a registry\n * of {@code FormatFactory} instances associated with {@code String}\n * format names.  This registry will be consulted when the format elements are\n * parsed from the message pattern.  In this way custom patterns can be specified,\n * and the formats supported by {@code java.text.MessageFormat} can be overridden\n * at the format and/or format style level (see MessageFormat).  A \"format element\"\n * embedded in the message pattern is specified (<b>()?</b> signifies optionality):<br>\n * {@code {}<i>argument-number</i><b>(</b>{@code ,}<i>format-name</i><b>\n * (</b>{@code ,}<i>format-style</i><b>)?)?</b>{@code }}\n *\n * <p>\n * <i>format-name</i> and <i>format-style</i> values are trimmed of surrounding whitespace\n * in the manner of {@code java.text.MessageFormat}.  If <i>format-name</i> denotes\n * {@code FormatFactory formatFactoryInstance} in {@code registry}, a {@code Format}\n * matching <i>format-name</i> and <i>format-style</i> is requested from\n * {@code formatFactoryInstance}.  If this is successful, the {@code Format}\n * found is used for this format element.\n * </p>\n *\n * <p><b>NOTICE:</b> The various subformat mutator methods are considered unnecessary; they exist on the parent\n * class to allow the type of customization which it is the job of this class to provide in\n * a configurable fashion.  These methods have thus been disabled and will throw\n * {@code UnsupportedOperationException} if called.\n * </p>\n *\n * <p>Limitations inherited from {@code java.text.MessageFormat}:</p>\n * <ul>\n * <li>When using \"choice\" subformats, support for nested formatting instructions is limited\n *     to that provided by the base class.</li>\n * <li>Thread-safety of {@code Format}s, including {@code MessageFormat} and thus\n *     {@code ExtendedMessageFormat}, is not guaranteed.</li>\n * </ul>\n *\n * @since 1.0\n */\npublic class ExtendedMessageFormat extends MessageFormat {\n\n    /**\n     * Serializable Object.\n     */\n    private static final long serialVersionUID = -2362048321261811743L;\n\n    /**\n     * Our initial seed value for calculating hashes.\n     */\n    private static final int HASH_SEED = 31;\n\n    /**\n     * The empty string.\n     */\n    private static final String DUMMY_PATTERN = StringUtils.EMPTY;\n\n    /**\n     * A comma.\n     */\n    private static final char START_FMT = ',';\n\n    /**\n     * A right side squiggly brace.\n     */\n    private static final char END_FE = '}';\n\n    /**\n     * A left side squiggly brace.\n     */\n    private static final char START_FE = '{';\n\n    /**\n     * A properly escaped character representing a single quote.\n     */\n    private static final char QUOTE = '\\'';\n\n    /**\n     * To pattern string.\n     */\n    private String toPattern;\n\n    /**\n     * Our registry of FormatFactory's.\n     */\n    private final Map<String, ? extends FormatFactory> registry;\n\n    /**\n     * Create a new ExtendedMessageFormat for the default locale.\n     *\n     * @param pattern  the pattern to use, not null\n     * @throws IllegalArgumentException in case of a bad pattern.\n     */\n    public ExtendedMessageFormat(final String pattern) {\n        this(pattern, Locale.getDefault(Category.FORMAT));\n    }\n\n    /**\n     * Create a new ExtendedMessageFormat.\n     *\n     * @param pattern  the pattern to use, not null\n     * @param locale  the locale to use, not null\n     * @throws IllegalArgumentException in case of a bad pattern.\n     */\n    public ExtendedMessageFormat(final String pattern, final Locale locale) {\n        this(pattern, locale, null);\n    }\n\n    /**\n     * Create a new ExtendedMessageFormat for the default locale.\n     *\n     * @param pattern  the pattern to use, not null\n     * @param registry  the registry of format factories, may be null\n     * @throws IllegalArgumentException in case of a bad pattern.\n     */\n    public ExtendedMessageFormat(final String pattern,\n                                 final Map<String, ? extends FormatFactory> registry) {\n        this(pattern, Locale.getDefault(Category.FORMAT), registry);\n    }\n\n    /**\n     * Create a new ExtendedMessageFormat.\n     *\n     * @param pattern  the pattern to use, not null\n     * @param locale  the locale to use, not null\n     * @param registry  the registry of format factories, may be null\n     * @throws IllegalArgumentException in case of a bad pattern.\n     */\n    public ExtendedMessageFormat(final String pattern,\n                                 final Locale locale,\n                                 final Map<String, ? extends FormatFactory> registry) {\n        super(DUMMY_PATTERN);\n        setLocale(locale);\n        this.registry = registry;\n        applyPattern(pattern);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toPattern() {\n        return toPattern;\n    }\n\n    /**\n     * Apply the specified pattern.\n     *\n     * @param pattern String\n     */\n    @Override\n    public final void applyPattern(final String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        final ArrayList<Format> foundFormats = new ArrayList<>();\n        final ArrayList<String> foundDescriptions = new ArrayList<>();\n        final StringBuilder stripCustom = new StringBuilder(pattern.length());\n\n        final ParsePosition pos = new ParsePosition(0);\n        final char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                final int start = pos.getIndex();\n                final int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                if (foundFormats.size() != fmtCount) {\n                    throw new IllegalArgumentException(\"The validated expression is false\");\n                }\n                if (foundDescriptions.size() != fmtCount) {\n                    throw new IllegalArgumentException(\"The validated expression is false\");\n                }\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                //$FALL-THROUGH$\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            final Format[] origFormats = getFormats();\n            // only loop over what we know we have, as MessageFormat on Java 1.3\n            // seems to provide an extra format element:\n            int i = 0;\n            for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n                final Format f = it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param formatElementIndex format element index\n     * @param newFormat the new format\n     * @throws UnsupportedOperationException always thrown since this isn't\n     *                                       supported by ExtendMessageFormat\n     */\n    @Override\n    public void setFormat(final int formatElementIndex, final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param argumentIndex argument index\n     * @param newFormat the new format\n     * @throws UnsupportedOperationException always thrown since this isn't\n     *                                       supported by ExtendMessageFormat\n     */\n    @Override\n    public void setFormatByArgumentIndex(final int argumentIndex,\n                                         final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param newFormats new formats\n     * @throws UnsupportedOperationException always thrown since this isn't\n     *                                       supported by ExtendMessageFormat\n     */\n    @Override\n    public void setFormats(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param newFormats new formats\n     * @throws UnsupportedOperationException always thrown since this isn't\n     *                                       supported by ExtendMessageFormat\n     */\n    @Override\n    public void setFormatsByArgumentIndex(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Check if this extended message format is equal to another object.\n     *\n     * @param obj the object to compare to\n     * @return true if this object equals the other, otherwise false\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!Objects.equals(getClass(), obj.getClass())) {\n          return false;\n        }\n        final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj;\n        if (!Objects.equals(toPattern, rhs.toPattern)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        return Objects.equals(registry, rhs.registry);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = HASH_SEED * result + Objects.hashCode(registry);\n        result = HASH_SEED * result + Objects.hashCode(toPattern);\n        return result;\n    }\n\n    /**\n     * Get a custom format from a format description.\n     *\n     * @param desc String\n     * @return Format\n     */\n    private Format getFormat(final String desc) {\n        if (registry != null) {\n            String name = desc;\n            String args = null;\n            final int i = desc.indexOf(START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            final FormatFactory factory = registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Read the argument index from the current format element.\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @return argument index\n     */\n    private int readArgumentIndex(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final StringBuilder result = new StringBuilder();\n        boolean error = false;\n        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if (c != START_FMT && c != END_FE) {\n                    error = true;\n                    continue;\n                }\n            }\n            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n                try {\n                    return Integer.parseInt(result.toString());\n                } catch (final NumberFormatException e) { // NOPMD\n                    // we've already ensured only digits, so unless something\n                    // outlandishly large was specified we should be okay.\n                }\n            }\n            error = !Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new IllegalArgumentException(\n                    \"Invalid format argument index at position \" + start + \": \"\n                            + pattern.substring(start, pos.getIndex()));\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    /**\n     * Parse the format component of a format element.\n     *\n     * @param pattern string to parse\n     * @param pos current parse position\n     * @return Format description String\n     */\n    private String parseFormatDescription(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        int depth = 1;\n        while (pos.getIndex() < pattern.length()) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                next(pos);\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    return pattern.substring(text, pos.getIndex());\n                }\n                next(pos);\n                break;\n            case QUOTE:\n                getQuotedString(pattern, pos);\n                break;\n            default:\n                next(pos);\n                break;\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    /**\n     * Insert formats back into the pattern for toPattern() support.\n     *\n     * @param pattern source\n     * @param customPatterns The custom patterns to re-insert, if any\n     * @return full pattern\n     */\n    private String insertFormats(final String pattern, final ArrayList<String> customPatterns) {\n        if (!containsElements(customPatterns)) {\n            return pattern;\n        }\n        final StringBuilder sb = new StringBuilder(pattern.length() * 2);\n        final ParsePosition pos = new ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            final char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, sb);\n                break;\n            case START_FE:\n                depth++;\n                sb.append(START_FE).append(readArgumentIndex(pattern, next(pos)));\n                // do not look for custom patterns when they are embedded, e.g. in a choice\n                if (depth == 1) {\n                    fe++;\n                    final String customPattern = customPatterns.get(fe);\n                    if (customPattern != null) {\n                        sb.append(START_FMT).append(customPattern);\n                    }\n                }\n                break;\n            case END_FE:\n                depth--;\n                //$FALL-THROUGH$\n            default:\n                sb.append(c);\n                next(pos);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Consume whitespace from the current parse position.\n     *\n     * @param pattern String to read\n     * @param pos current position\n     */\n    private void seekNonWs(final String pattern, final ParsePosition pos) {\n        int len = 0;\n        final char[] buffer = pattern.toCharArray();\n        do {\n            len = StringMatcherFactory.INSTANCE.splitMatcher().isMatch(buffer, pos.getIndex(), 0, buffer.length);\n            pos.setIndex(pos.getIndex() + len);\n        } while (len > 0 && pos.getIndex() < pattern.length());\n    }\n\n    /**\n     * Convenience method to advance parse position by 1.\n     *\n     * @param pos ParsePosition\n     * @return {@code pos}\n     */\n    private ParsePosition next(final ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }\n\n    /**\n     * Consume a quoted string, adding it to {@code appendTo} if\n     * specified.\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuilder to append\n     */\n    private void appendQuotedString(final String pattern, final ParsePosition pos,\n            final StringBuilder appendTo) {\n        assert pattern.toCharArray()[pos.getIndex()] == QUOTE\n                : \"Quoted string must start with quote character\";\n\n        // handle quote character at the beginning of the string\n        if (appendTo != null) {\n            appendTo.append(QUOTE);\n        }\n        next(pos);\n\n        final int start = pos.getIndex();\n        final char[] c = pattern.toCharArray();\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                if (appendTo != null) {\n                    appendTo.append(c, start, pos.getIndex() - start);\n                }\n                return;\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n\n    /**\n     * Consume quoted string only.\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position\n     */\n    private void getQuotedString(final String pattern, final ParsePosition pos) {\n        appendQuotedString(pattern, pos, null);\n    }\n\n    /**\n     * Learn whether the specified Collection contains non-null elements.\n     * @param coll to check\n     * @return {@code true} if some Object was found, {@code false} otherwise.\n     */\n    private boolean containsElements(final Collection<?> coll) {\n        if (coll == null || coll.isEmpty()) {\n            return false;\n        }\n        for (final Object name : coll) {\n            if (name != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/ExtendedMessageFormat.java b/src/main/java/org/apache/commons/text/ExtendedMessageFormat.java\nindex f24efb7d7d..56ad987630 100644\n--- a/src/main/java/org/apache/commons/text/ExtendedMessageFormat.java\n+++ b/src/main/java/org/apache/commons/text/ExtendedMessageFormat.java\n@@ -21,6 +21,8 @@\n import java.text.ParsePosition;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Locale;\n import java.util.Locale.Category;\n@@ -160,7 +162,9 @@ public ExtendedMessageFormat(final String pattern,\n                                  final Map<String, ? extends FormatFactory> registry) {\n         super(DUMMY_PATTERN);\n         setLocale(locale);\n-        this.registry = registry;\n+        this.registry = registry != null\n+                ? Collections.unmodifiableMap(new HashMap<>(registry))\n+                : null;\n         applyPattern(pattern);\n     }\n \n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/io/StringSubstitutorReader.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.io;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.io.Reader;\n\nimport org.apache.commons.text.StringSubstitutor;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class StringSubstitutorReaderTest {\n\n    private Reader mockReader;\n    private StringSubstitutor mockStringSubstitutor;\n\n    @BeforeEach\n    public void setUp() {\n        mockReader = mock(Reader.class);\n        mockStringSubstitutor = mock(StringSubstitutor.class);\n    }\n\n    @Test\n    public void testConstructorWithNonNullStringSubstitutor() {\n        when(mockStringSubstitutor.getEscapeChar()).thenReturn('\\\\');\n        when(mockStringSubstitutor.getVariablePrefixMatcher()).thenReturn(StringMatcherFactory.INSTANCE.stringMatcher(\"${\"));\n        \n        StringSubstitutorReader reader = new StringSubstitutorReader(mockReader, mockStringSubstitutor);\n        assertNotNull(reader);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.text.io;\n\nimport java.io.FilterReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.util.Objects;\n\nimport org.apache.commons.text.StringSubstitutor;\nimport org.apache.commons.text.TextStringBuilder;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\n\n/**\n * A {@link Reader} that performs string substitution on a source {@code Reader} using a {@link StringSubstitutor}.\n *\n * <p>\n * Using this Reader avoids reading a whole file into memory as a {@code String} to perform string substitution, for\n * example, when a Servlet filters a file to a client.\n * </p>\n * <p>\n * This class is not thread-safe.\n * </p>\n *\n * @since 1.9\n */\npublic class StringSubstitutorReader extends FilterReader {\n\n    /** The end-of-stream character marker. */\n    private static final int EOS = -1;\n\n    /** Our internal buffer. */\n    private final TextStringBuilder buffer = new TextStringBuilder();\n\n    /** End-of-Stream flag. */\n    private boolean eos;\n\n    /** Matches escaped variable starts. */\n    private final StringMatcher prefixEscapeMatcher;\n\n    /** Internal buffer for {@link #read()} method. */\n    private final char[] read1CharBuffer = {0};\n\n    /** The underlying StringSubstitutor. */\n    private final StringSubstitutor stringSubstitutor;\n\n    /** We don't always want to drain the whole buffer. */\n    private int toDrain;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param reader the underlying reader containing the template text known to the given {@code StringSubstitutor}.\n     * @param stringSubstitutor How to replace as we read.\n     * @throws NullPointerException if {@code reader} is {@code null}.\n     * @throws NullPointerException if {@code stringSubstitutor} is {@code null}.\n     */\n    public StringSubstitutorReader(final Reader reader, final StringSubstitutor stringSubstitutor) {\n        super(reader);\n        this.stringSubstitutor = Objects.requireNonNull(stringSubstitutor);\n        this.prefixEscapeMatcher = StringMatcherFactory.INSTANCE.charMatcher(stringSubstitutor.getEscapeChar())\n            .andThen(stringSubstitutor.getVariablePrefixMatcher());\n    }\n\n    /**\n     * Buffers the requested number of characters if available.\n     */\n    private int buffer(final int requestReadCount) throws IOException {\n        final int actualReadCount = buffer.readFrom(super.in, requestReadCount);\n        eos = actualReadCount == EOS;\n        return actualReadCount;\n    }\n\n    /**\n     * Reads a requested number of chars from the underlying reader into the buffer. On EOS, set the state is DRAINING,\n     * drain, and return a drain count, otherwise, returns the actual read count.\n     */\n    private int bufferOrDrainOnEos(final int requestReadCount, final char[] target, final int targetIndex,\n        final int targetLength) throws IOException {\n        final int actualReadCount = buffer(requestReadCount);\n        return drainOnEos(actualReadCount, target, targetIndex, targetLength);\n    }\n\n    /**\n     * Drains characters from our buffer to the given {@code target}.\n     */\n    private int drain(final char[] target, final int targetIndex, final int targetLength) {\n        final int actualLen = Math.min(buffer.length(), targetLength);\n        final int drainCount = buffer.drainChars(0, actualLen, target, targetIndex);\n        toDrain -= drainCount;\n        if (buffer.isEmpty() || toDrain == 0) {\n            // nothing or everything drained.\n            toDrain = 0;\n        }\n        return drainCount;\n    }\n\n    /**\n     * Drains from the buffer to the target only if we are at EOS per the input count. If input count is EOS, drain and\n     * returns the drain count, otherwise return the input count. If draining, the state is set to DRAINING.\n     */\n    private int drainOnEos(final int readCountOrEos, final char[] target, final int targetIndex,\n        final int targetLength) {\n        if (readCountOrEos == EOS) {\n            // At EOS, drain.\n            if (buffer.isNotEmpty()) {\n                toDrain = buffer.size();\n                return drain(target, targetIndex, targetLength);\n            }\n            return EOS;\n        }\n        return readCountOrEos;\n    }\n\n    /**\n     * Tests if our buffer matches the given string matcher at the given position in the buffer.\n     */\n    private boolean isBufferMatchAt(final StringMatcher stringMatcher, final int pos) {\n        return stringMatcher.isMatch(buffer, pos) == stringMatcher.size();\n    }\n\n    /**\n     * Tests if we are draining.\n     */\n    private boolean isDraining() {\n        return toDrain > 0;\n    }\n\n    /**\n     * Reads a single character.\n     *\n     * @return a character as an {@code int} or {@code -1} for end-of-stream.\n     * @throws IOException If an I/O error occurs\n     */\n    @Override\n    public int read() throws IOException {\n        int count = 0;\n        // ask until we get a char or EOS\n        do {\n            count = read(read1CharBuffer, 0, 1);\n            if (count == EOS) {\n                return EOS;\n            }\n            // keep on buffering\n        } while (count < 1);\n        return read1CharBuffer[0];\n    }\n\n    /**\n     * Reads characters into a portion of an array.\n     *\n     * @param target Target buffer.\n     * @param targetIndexIn Index in the target at which to start storing characters.\n     * @param targetLengthIn Maximum number of characters to read.\n     *\n     * @return The number of characters read, or -1 on end of stream.\n     * @throws IOException If an I/O error occurs\n     */\n    @Override\n    public int read(final char[] target, final int targetIndexIn, final int targetLengthIn) throws IOException {\n        // The whole thing is inefficient because we must look for a balanced suffix to match the starting prefix\n        // Trying to substitute an incomplete expression can perform replacements when it should not.\n        // At a high level:\n        // - if draining, drain until empty or target length hit\n        // - copy to target until we find a variable start\n        // - buffer until a balanced suffix is read, then substitute.\n        if (eos && buffer.isEmpty()) {\n            return EOS;\n        }\n        if (targetLengthIn <= 0) {\n            // short-circuit: ask nothing, give nothing\n            return 0;\n        }\n        // drain check\n        int targetIndex = targetIndexIn;\n        int targetLength = targetLengthIn;\n        if (isDraining()) {\n            // drain as much as possible\n            final int drainCount = drain(target, targetIndex, Math.min(toDrain, targetLength));\n            if (drainCount == targetLength) {\n                // drained length requested, target is full, can only do more in the next invocation\n                return targetLength;\n            }\n            // drained less than requested, target not full.\n            targetIndex += drainCount;\n            targetLength -= drainCount;\n        }\n        // BUFFER from the underlying reader\n        final int minReadLenPrefix = prefixEscapeMatcher.size();\n        // READ enough to test for an [optionally escaped] variable start\n        int readCount = buffer(readCount(minReadLenPrefix, 0));\n        if (buffer.length() < minReadLenPrefix && targetLength < minReadLenPrefix) {\n            // read less than minReadLenPrefix, no variable possible\n            final int drainCount = drain(target, targetIndex, targetLength);\n            targetIndex += drainCount;\n            final int targetSize = targetIndex - targetIndexIn;\n            return eos && targetSize <= 0 ? EOS : targetSize;\n        }\n        if (eos) {\n            // EOS\n            stringSubstitutor.replaceIn(buffer);\n            toDrain = buffer.size();\n            final int drainCount = drain(target, targetIndex, targetLength);\n            targetIndex += drainCount;\n            final int targetSize = targetIndex - targetIndexIn;\n            return eos && targetSize <= 0 ? EOS : targetSize;\n        }\n        // PREFIX\n        // buffer and drain until we find a variable start, escaped or plain.\n        int balance = 0;\n        final StringMatcher prefixMatcher = stringSubstitutor.getVariablePrefixMatcher();\n        int pos = 0;\n        while (targetLength > 0) {\n            if (isBufferMatchAt(prefixMatcher, 0)) {\n                balance = 1;\n                pos = prefixMatcher.size();\n                break;\n            }\n            if (isBufferMatchAt(prefixEscapeMatcher, 0)) {\n                balance = 1;\n                pos = prefixEscapeMatcher.size();\n                break;\n            }\n            // drain first char\n            final int drainCount = drain(target, targetIndex, 1);\n            targetIndex += drainCount;\n            targetLength -= drainCount;\n            if (buffer.size() < minReadLenPrefix) {\n                readCount = bufferOrDrainOnEos(minReadLenPrefix, target, targetIndex, targetLength);\n                if (eos || isDraining()) {\n                    // if draining, readCount is a drain count\n                    if (readCount != EOS) {\n                        targetIndex += readCount;\n                        targetLength -= readCount;\n                    }\n                    final int actual = targetIndex - targetIndexIn;\n                    return actual > 0 ? actual : EOS;\n                }\n            }\n        }\n        // we found a variable start\n        if (targetLength <= 0) {\n            // no more room in target\n            return targetLengthIn;\n        }\n        // SUFFIX\n        // buffer more to find a balanced suffix\n        final StringMatcher suffixMatcher = stringSubstitutor.getVariableSuffixMatcher();\n        final int minReadLenSuffix = Math.max(minReadLenPrefix, suffixMatcher.size());\n        readCount = buffer(readCount(minReadLenSuffix, pos));\n        if (eos) {\n            // EOS\n            stringSubstitutor.replaceIn(buffer);\n            toDrain = buffer.size();\n            final int drainCount = drain(target, targetIndex, targetLength);\n            return targetIndex + drainCount - targetIndexIn;\n        }\n        // buffer and break out when we find the end or a balanced suffix\n        while (true) {\n            if (isBufferMatchAt(suffixMatcher, pos)) {\n                balance--;\n                pos++;\n                if (balance == 0) {\n                    break;\n                }\n            } else if (isBufferMatchAt(prefixMatcher, pos)) {\n                balance++;\n                pos += prefixMatcher.size();\n            } else if (isBufferMatchAt(prefixEscapeMatcher, pos)) {\n                balance++;\n                pos += prefixEscapeMatcher.size();\n            } else {\n                pos++;\n            }\n            readCount = buffer(readCount(minReadLenSuffix, pos));\n            if (readCount == EOS && pos >= buffer.size()) {\n                break;\n            }\n        }\n        // substitute\n        final int endPos = pos + 1;\n        final int leftover = Math.max(0, buffer.size() - pos);\n        stringSubstitutor.replaceIn(buffer, 0, Math.min(buffer.size(), endPos));\n        pos = buffer.size() - leftover;\n        final int drainLen = Math.min(targetLength, pos);\n        // only drain up to what we've substituted\n        toDrain = pos;\n        drain(target, targetIndex, drainLen);\n        return targetIndex - targetIndexIn + drainLen;\n    }\n\n    /**\n     * Returns how many chars to attempt reading to have room in the buffer for {@code count} chars starting at position\n     * {@code pos}.\n     */\n    private int readCount(final int count, final int pos) {\n        final int avail = buffer.size() - pos;\n        return avail >= count ? 0 : count - avail;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/io/StringSubstitutorReader.java b/src/main/java/org/apache/commons/text/io/StringSubstitutorReader.java\nindex f5a26d90fe..8f17ba844a 100644\n--- a/src/main/java/org/apache/commons/text/io/StringSubstitutorReader.java\n+++ b/src/main/java/org/apache/commons/text/io/StringSubstitutorReader.java\n@@ -20,7 +20,6 @@\n import java.io.FilterReader;\n import java.io.IOException;\n import java.io.Reader;\n-import java.util.Objects;\n \n import org.apache.commons.text.StringSubstitutor;\n import org.apache.commons.text.TextStringBuilder;\n@@ -73,7 +72,7 @@ public class StringSubstitutorReader extends FilterReader {\n      */\n     public StringSubstitutorReader(final Reader reader, final StringSubstitutor stringSubstitutor) {\n         super(reader);\n-        this.stringSubstitutor = Objects.requireNonNull(stringSubstitutor);\n+        this.stringSubstitutor = new StringSubstitutor(stringSubstitutor);\n         this.prefixEscapeMatcher = StringMatcherFactory.INSTANCE.charMatcher(stringSubstitutor.getEscapeChar())\n             .andThen(stringSubstitutor.getVariablePrefixMatcher());\n     }\n"
      }
    ]
  },
  {
    "pr_number": 248,
    "title": "TEXT-207: adding DoubleFormat utility",
    "state": "closed",
    "created_at": "2021-07-06T03:18:21Z",
    "merge_commit_sha": "ff372c2dd5400c636433ac1d40c885692f7195ac",
    "base_sha": "23a17acd1fa408b41988866e3df480e9c89b4903",
    "head_sha": "ff372c2dd5400c636433ac1d40c885692f7195ac",
    "user_login": "darkma773r",
    "changed_files": [
      {
        "filename": "pom.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/changes/changes.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/text/numbers/DoubleFormat.java",
        "status": "added",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.numbers;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.text.DecimalFormatSymbols;\nimport java.util.Locale;\nimport java.util.function.DoubleFunction;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class DoubleFormatTest {\n\n    @Test\n    public void testPlainFormat() {\n        DoubleFunction<String> formatter = DoubleFormat.PLAIN.builder().build();\n        assertEquals(\"0.0\", formatter.apply(0.0));\n        assertEquals(\"12.401\", formatter.apply(12.401));\n        assertEquals(\"100000.0\", formatter.apply(100000.0));\n        assertEquals(\"1450000000.0\", formatter.apply(1450000000.0));\n        assertEquals(\"0.0000000000123\", formatter.apply(0.0000000000123));\n    }\n\n    @Test\n    public void testScientificFormat() {\n        DoubleFunction<String> formatter = DoubleFormat.SCIENTIFIC.builder().build();\n        assertEquals(\"0.0\", formatter.apply(0.0));\n        assertEquals(\"1.2401E1\", formatter.apply(12.401));\n        assertEquals(\"1.0E5\", formatter.apply(100000.0));\n        assertEquals(\"1.45E9\", formatter.apply(1450000000.0));\n        assertEquals(\"1.23E-11\", formatter.apply(0.0000000000123));\n    }\n\n    @Test\n    public void testEngineeringFormat() {\n        DoubleFunction<String> formatter = DoubleFormat.ENGINEERING.builder().build();\n        assertEquals(\"0.0\", formatter.apply(0.0));\n        assertEquals(\"12.401\", formatter.apply(12.401));\n        assertEquals(\"100.0E3\", formatter.apply(100000.0));\n        assertEquals(\"1.45E9\", formatter.apply(1450000000.0));\n        assertEquals(\"12.3E-12\", formatter.apply(0.0000000000123));\n    }\n\n    @Test\n    public void testMixedFormat() {\n        DoubleFunction<String> formatter = DoubleFormat.MIXED.builder().build();\n        assertEquals(\"0.0\", formatter.apply(0.0));\n        assertEquals(\"12.401\", formatter.apply(12.401));\n        assertEquals(\"100000.0\", formatter.apply(100000.0));\n        assertEquals(\"1.45E9\", formatter.apply(1450000000.0));\n        assertEquals(\"1.23E-11\", formatter.apply(0.0000000000123));\n    }\n\n    @Test\n    public void testCustomFormatSymbols() {\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(Locale.FRANCE);\n        DoubleFunction<String> formatter = DoubleFormat.PLAIN.builder()\n                .formatSymbols(symbols)\n                .build();\n        assertEquals(\"0,0\", formatter.apply(0.0));\n        assertEquals(\"12,401\", formatter.apply(12.401));\n        assertEquals(\"100000,0\", formatter.apply(100000.0));\n        assertEquals(\"1450000000,0\", formatter.apply(1450000000.0));\n        assertEquals(\"0,0000000000123\", formatter.apply(0.0000000000123));\n    }\n\n    @Test\n    public void testMaxPrecision() {\n        DoubleFunction<String> formatter = DoubleFormat.PLAIN.builder()\n                .maxPrecision(4)\n                .build();\n        assertEquals(\"12.40\", formatter.apply(12.401));\n        assertEquals(\"100000.0\", formatter.apply(100000.0));\n    }\n\n    @Test\n    public void testMinDecimalExponent() {\n        DoubleFunction<String> formatter = DoubleFormat.PLAIN.builder()\n                .minDecimalExponent(-2)\n                .build();\n        assertEquals(\"3.14\", formatter.apply(3.14159));\n        assertEquals(\"0.0\", formatter.apply(0.001));\n    }\n\n    @Test\n    public void testPlainFormatMaxDecimalExponent() {\n        DoubleFunction<String> formatter = DoubleFormat.MIXED.builder()\n                .plainFormatMaxDecimalExponent(2)\n                .build();\n        assertEquals(\"999.0\", formatter.apply(999));\n        assertEquals(\"1.0E3\", formatter.apply(1000));\n    }\n\n    @Test\n    public void testPlainFormatMinDecimalExponent() {\n        DoubleFunction<String> formatter = DoubleFormat.MIXED.builder()\n                .plainFormatMinDecimalExponent(-2)\n                .build();\n        assertEquals(\"0.01\", formatter.apply(0.01));\n        assertEquals(\"9.9E-3\", formatter.apply(0.0099));\n    }\n\n    @Test\n    public void testAllowSignedZero() {\n        DoubleFunction<String> formatter = DoubleFormat.PLAIN.builder()\n                .allowSignedZero(true)\n                .build();\n        assertEquals(\"-0.0\", formatter.apply(-0.0));\n    }\n\n    @Test\n    public void testIncludeFractionPlaceholder() {\n        DoubleFunction<String> formatter = DoubleFormat.PLAIN.builder()\n                .includeFractionPlaceholder(true)\n                .build();\n        assertEquals(\"1.0\", formatter.apply(1));\n    }\n\n    @Test\n    public void testMinusSign() {\n        DoubleFunction<String> formatter = DoubleFormat.PLAIN.builder()\n                .minusSign('\u2212')\n                .build();\n        assertEquals(\"\u221212.401\", formatter.apply(-12.401));\n    }\n\n    @Test\n    public void testDecimalSeparator() {\n        DoubleFunction<String> formatter = DoubleFormat.PLAIN.builder()\n                .decimalSeparator(',')\n                .build();\n        assertEquals(\"12,401\", formatter.apply(12.401));\n    }\n\n    @Test\n    public void testGroupingSeparator() {\n        DoubleFunction<String> formatter = DoubleFormat.PLAIN.builder()\n                .groupingSeparator(' ')\n                .groupThousands(true)\n                .build();\n        assertEquals(\"1 000\", formatter.apply(1000));\n    }\n\n    @Test\n    public void testExponentSeparator() {\n        DoubleFunction<String> formatter = DoubleFormat.SCIENTIFIC.builder()\n                .exponentSeparator(\"e\")\n                .build();\n        assertEquals(\"1.0e5\", formatter.apply(100000.0));\n    }\n\n    @Test\n    public void testAlwaysIncludeExponent() {\n        DoubleFunction<String> formatter = DoubleFormat.SCIENTIFIC.builder()\n                .alwaysIncludeExponent(true)\n                .build();\n        assertEquals(\"1.0E0\", formatter.apply(1.0));\n    }\n\n    @Test\n    public void testInfinity() {\n        DoubleFunction<String> formatter = DoubleFormat.PLAIN.builder()\n                .infinity(\"Inf\")\n                .build();\n        assertEquals(\"Inf\", formatter.apply(Double.POSITIVE_INFINITY));\n        assertEquals(\"-Inf\", formatter.apply(Double.NEGATIVE_INFINITY));\n    }\n\n    @Test\n    public void testNaN() {\n        DoubleFunction<String> formatter = DoubleFormat.PLAIN.builder()\n                .nan(\"NotANumber\")\n                .build();\n        assertEquals(\"NotANumber\", formatter.apply(Double.NaN));\n    }\n}",
        "file_content": null,
        "diff": " a/src/main/java/org/apache/commons/text/numbers/DoubleFormat.java b/src/main/java/org/apache/commons/text/numbers/DoubleFormat.java\nnew file mode 100644\nindex 0000000000..3f3fc74a89\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/numbers/DoubleFormat.java\n@@ -0,0 +1,730 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.text.numbers;\n+\n+import java.text.DecimalFormatSymbols;\n+import java.util.Objects;\n+import java.util.function.DoubleFunction;\n+import java.util.function.Function;\n+\n+/** Enum containing standard double format types with methods to produce\n+ * configured formatter instances. This type is intended to provide a\n+ * quick and convenient way to create lightweight, thread-safe double format functions\n+ * for common format types using a builder pattern. Output can be localized by\n+ * passing a {@link DecimalFormatSymbols} instance to the\n+ * {@link Builder#formatSymbols(DecimalFormatSymbols) formatSymbols} method or by\n+ * directly calling the various other builder configuration methods, such as\n+ * {@link Builder#digits(String) digits}.\n+ *\n+ * <p><strong>Comparison with DecimalFormat</strong>\n+ * <p>This type provides some of the same functionality as Java's own\n+ * {@link java.text.DecimalFormat}. However, unlike {@code DecimalFormat}, the format\n+ * functions produced by this type are lightweight and thread-safe, making them\n+ * much easier to work with in multi-threaded environments. They also provide performance\n+ * comparable to, and in many cases faster than, {@code DecimalFormat}.\n+ *\n+ * <p><strong>Examples</strong>\n+ * <pre>\n+ * // construct a formatter equivalent to Double.toString()\n+ * DoubleFunction&lt;String&gt; fmt = DoubleFormat.MIXED.builder().build();\n+ *\n+ * // construct a formatter equivalent to Double.toString() but using\n+ * // format symbols for a specific locale\n+ * DoubleFunction&lt;String&gt; fmt = DoubleFormat.MIXED.builder()\n+ *      .formatSymbols(DecimalFormatSymbols.getInstance(locale))\n+ *      .build();\n+ *\n+ * // construct a formatter equivalent to the DecimalFormat pattern \"0.0##\"\n+ * DoubleFunction&lt;String&gt; fmt = DoubleFormat.PLAIN.builder()\n+ *      .minDecimalExponent(-3)\n+ *      .build();\n+ *\n+ * // construct a formatter equivalent to the DecimalFormat pattern \"#,##0.0##\",\n+ * // where whole number groups of thousands are separated\n+ * DoubleFunction&lt;String&gt; fmt = DoubleFormat.PLAIN.builder()\n+ *      .minDecimalExponent(-3)\n+ *      .groupThousands(true)\n+ *      .build();\n+ *\n+ * // construct a formatter equivalent to the DecimalFormat pattern \"0.0##E0\"\n+ * DoubleFunction&lt;String&gt; fmt = DoubleFormat.SCIENTIFIC.builder()\n+ *      .maxPrecision(4)\n+ *      .alwaysIncludeExponent(true)\n+ *      .build()\n+ *\n+ * // construct a formatter equivalent to the DecimalFormat pattern \"##0.0##E0\",\n+ * // i.e. \"engineering format\"\n+ * DoubleFunction&lt;String&gt; fmt = DoubleFormat.ENGINEERING.builder()\n+ *      .maxPrecision(6)\n+ *      .alwaysIncludeExponent(true)\n+ *      .build()\n+ * </pre>\n+ *\n+ * <p><strong>Implementation Notes</strong>\n+ * <p>{@link java.math.RoundingMode#HALF_EVEN Half-even} rounding is used in cases where the\n+ * decimal value must be rounded in order to meet the configuration requirements of the formatter\n+ * instance.\n+ */\n+public enum DoubleFormat {\n+\n+    /** Number format without exponents.\n+     * Ex:\n+     * <pre>\n+     * 0.0\n+     * 12.401\n+     * 100000.0\n+     * 1450000000.0\n+     * 0.0000000000123\n+     * </pre>\n+     */\n+    PLAIN(PlainDoubleFormat::new),\n+\n+    /** Number format that uses exponents and contains a single digit\n+     * to the left of the decimal point.\n+     * Ex:\n+     * <pre>\n+     * 0.0\n+     * 1.2401E1\n+     * 1.0E5\n+     * 1.45E9\n+     * 1.23E-11\n+     * </pre>\n+     */\n+    SCIENTIFIC(ScientificDoubleFormat::new),\n+\n+    /** Number format similar to {@link #SCIENTIFIC scientific format} but adjusted\n+     * so that the exponent value is always a multiple of 3, allowing easier alignment\n+     * with SI prefixes.\n+     * Ex:\n+     * <pre>\n+     * 0.0\n+     * 12.401\n+     * 100.0E3\n+     * 1.45E9\n+     * 12.3E-12\n+     * </pre>\n+     */\n+    ENGINEERING(EngineeringDoubleFormat::new),\n+\n+    /** Number format that uses {@link #PLAIN plain format} for small numbers and\n+     * {@link #SCIENTIFIC scientific format} for large numbers. The number thresholds\n+     * can be configured through the\n+     * {@link Builder#plainFormatMinDecimalExponent plainFormatMinDecimalExponent}\n+     * and\n+     * {@link Builder#plainFormatMaxDecimalExponent plainFormatMaxDecimalExponent}\n+     * properties.\n+     * Ex:\n+     * <pre>\n+     * 0.0\n+     * 12.401\n+     * 100000.0\n+     * 1.45E9\n+     * 1.23E-11\n+     * </pre>\n+     */\n+    MIXED(MixedDoubleFormat::new);\n+\n+    /** Function used to construct instances for this format type. */\n+    private final Function<Builder, DoubleFunction<String>> factory;\n+\n+    /** Construct a new instance.\n+     * @param factory function used to construct format instances\n+     */\n+    DoubleFormat(final Function<Builder, DoubleFunction<String>> factory) {\n+        this.factory = factory;\n+    }\n+\n+    /** Return a {@link Builder} for constructing formatter functions for this format type.\n+     * @return builder instance\n+     */\n+    public Builder builder() {\n+        return new Builder(factory);\n+    }\n+\n+    /** Class for constructing configured format functions for standard double format types.\n+     */\n+    public static final class Builder {\n+\n+        /** Default value for the plain format max decimal exponent. */\n+        private static final int DEFAULT_PLAIN_FORMAT_MAX_DECIMAL_EXPONENT = 6;\n+\n+        /** Default value for the plain format min decimal exponent. */\n+        private static final int DEFAULT_PLAIN_FORMAT_MIN_DECIMAL_EXPONENT = -3;\n+\n+        /** Default decimal digit characters. */\n+        private static final String DEFAULT_DECIMAL_DIGITS = \"0123456789\";\n+\n+        /** Function used to construct format instances. */\n+        private final Function<Builder, DoubleFunction<String>> factory;\n+\n+        /** Maximum number of significant decimal digits in formatted strings. */\n+        private int maxPrecision = 0;\n+\n+        /** Minimum decimal exponent. */\n+        private int minDecimalExponent = Integer.MIN_VALUE;\n+\n+        /** Max decimal exponent to use with plain formatting with the mixed format type. */\n+        private int plainFormatMaxDecimalExponent = DEFAULT_PLAIN_FORMAT_MAX_DECIMAL_EXPONENT;\n+\n+        /** Min decimal exponent to use with plain formatting with the mixed format type. */\n+        private int plainFormatMinDecimalExponent = DEFAULT_PLAIN_FORMAT_MIN_DECIMAL_EXPONENT;\n+\n+        /** String representing infinity. */\n+        private String infinity = \"Infinity\";\n+\n+        /** String representing NaN. */\n+        private String nan = \"NaN\";\n+\n+        /** Flag determining if fraction placeholders should be used. */\n+        private boolean fractionPlaceholder = true;\n+\n+        /** Flag determining if signed zero strings are allowed. */\n+        private boolean signedZero = true;\n+\n+        /** String of digit characters 0-9. */\n+        private String digits = DEFAULT_DECIMAL_DIGITS;\n+\n+        /** Decimal separator character. */\n+        private char decimalSeparator = '.';\n+\n+        /** Character used to separate groups of thousands. */\n+        private char groupingSeparator = ',';\n+\n+        /** If {@code true}, thousands groups will be separated by the grouping separator. */\n+        private boolean groupThousands = false;\n+\n+        /** Minus sign character. */\n+        private char minusSign = '-';\n+\n+        /** Exponent separator character. */\n+        private String exponentSeparator = \"E\";\n+\n+        /** Flag indicating if the exponent value should always be included, even if zero. */\n+        private boolean alwaysIncludeExponent = false;\n+\n+        /** Construct a new instance that delegates double function construction\n+         * to the given factory object.\n+         * @param factory factory function\n+         */\n+        private Builder(final Function<Builder, DoubleFunction<String>> factory) {\n+            this.factory = factory;\n+        }\n+\n+        /** Set the maximum number of significant decimal digits used in format\n+         * results. A value of {@code 0} indicates no limit. The default value is {@code 0}.\n+         * @param maxPrecision maximum precision\n+         * @return this instance\n+         */\n+        public Builder maxPrecision(final int maxPrecision) {\n+            this.maxPrecision = maxPrecision;\n+            return this;\n+        }\n+\n+        /** Set the minimum decimal exponent for formatted strings. No digits with an\n+         * absolute value of less than <code>10<sup>minDecimalExponent</sup></code> will\n+         * be included in format results. If the number being formatted does not contain\n+         * any such digits, then zero is returned. For example, if {@code minDecimalExponent}\n+         * is set to {@code -2} and the number {@code 3.14159} is formatted, the plain\n+         * format result will be {@code \"3.14\"}. If {@code 0.001} is formatted, then the\n+         * result is the zero string.\n+         * @param minDecimalExponent minimum decimal exponent\n+         * @return this instance\n+         */\n+        public Builder minDecimalExponent(final int minDecimalExponent) {\n+            this.minDecimalExponent = minDecimalExponent;\n+            return this;\n+        }\n+\n+        /** Set the maximum decimal exponent for numbers formatted as plain decimal strings when\n+         * using the {@link DoubleFormat#MIXED MIXED} format type. If the number being formatted\n+         * has an absolute value less than <code>10<sup>plainFormatMaxDecimalExponent + 1</sup></code> and\n+         * greater than or equal to <code>10<sup>plainFormatMinDecimalExponent</sup></code> after any\n+         * necessary rounding, then the formatted result will use the {@link DoubleFormat#PLAIN PLAIN} format type.\n+         * Otherwise, {@link DoubleFormat#SCIENTIFIC SCIENTIFIC} format will be used. For example,\n+         * if this value is set to {@code 2}, the number {@code 999} will be formatted as {@code \"999.0\"}\n+         * while {@code 1000} will be formatted as {@code \"1.0E3\"}.\n+         *\n+         * <p>The default value is {@value #DEFAULT_PLAIN_FORMAT_MAX_DECIMAL_EXPONENT}.\n+         *\n+         * <p>This value is ignored for formats other than {@link DoubleFormat#MIXED}.\n+         * @param plainFormatMaxDecimalExponent maximum decimal exponent for values formatted as plain\n+         *      strings when using the {@link DoubleFormat#MIXED MIXED} format type.\n+         * @return this instance\n+         * @see #plainFormatMinDecimalExponent(int)\n+         */\n+        public Builder plainFormatMaxDecimalExponent(final int plainFormatMaxDecimalExponent) {\n+            this.plainFormatMaxDecimalExponent = plainFormatMaxDecimalExponent;\n+            return this;\n+        }\n+\n+        /** Set the minimum decimal exponent for numbers formatted as plain decimal strings when\n+         * using the {@link DoubleFormat#MIXED MIXED} format type. If the number being formatted\n+         * has an absolute value less than <code>10<sup>plainFormatMaxDecimalExponent + 1</sup></code> and\n+         * greater than or equal to <code>10<sup>plainFormatMinDecimalExponent</sup></code> after any\n+         * necessary rounding, then the formatted result will use the {@link DoubleFormat#PLAIN PLAIN} format type.\n+         * Otherwise, {@link DoubleFormat#SCIENTIFIC SCIENTIFIC} format will be used. For example,\n+         * if this value is set to {@code -2}, the number {@code 0.01} will be formatted as {@code \"0.01\"}\n+         * while {@code 0.0099} will be formatted as {@code \"9.9E-3\"}.\n+         *\n+         * <p>The default value is {@value #DEFAULT_PLAIN_FORMAT_MIN_DECIMAL_EXPONENT}.\n+         *\n+         * <p>This value is ignored for formats other than {@link DoubleFormat#MIXED}.\n+         * @param plainFormatMinDecimalExponent maximum decimal exponent for values formatted as plain\n+         *      strings when using the {@link DoubleFormat#MIXED MIXED} format type.\n+         * @return this instance\n+         * @see #plainFormatMinDecimalExponent(int)\n+         */\n+        public Builder plainFormatMinDecimalExponent(final int plainFormatMinDecimalExponent) {\n+            this.plainFormatMinDecimalExponent = plainFormatMinDecimalExponent;\n+            return this;\n+        }\n+\n+        /** Set the flag determining whether or not the zero string may be returned with the minus\n+         * sign or if it will always be returned in the positive form. For example, if set to {@code true},\n+         * the string {@code \"-0.0\"} may be returned for some input numbers. If {@code false}, only {@code \"0.0\"}\n+         * will be returned, regardless of the sign of the input number. The default value is {@code true}.\n+         * @param signedZero if {@code true}, the zero string may be returned with a preceding minus sign;\n+         *      if {@code false}, the zero string will only be returned in its positive form\n+         * @return this instance\n+         */\n+        public Builder allowSignedZero(final boolean signedZero) {\n+            this.signedZero = signedZero;\n+            return this;\n+        }\n+\n+        /** Set the string containing the digit characters 0-9, in that order. The\n+         * default value is the string {@code \"0123456789\"}.\n+         * @param digits string containing the digit characters 0-9\n+         * @return this instance\n+         * @throws NullPointerException if the argument is {@code null}\n+         * @throws IllegalArgumentException if the argument does not have a length of exactly 10\n+         */\n+        public Builder digits(final String digits) {\n+            Objects.requireNonNull(digits, \"Digits string cannot be null\");\n+            if (digits.length() != DEFAULT_DECIMAL_DIGITS.length()) {\n+                throw new IllegalArgumentException(\"Digits string must contain exactly \"\n+                        + DEFAULT_DECIMAL_DIGITS.length() + \" characters.\");\n+            }\n+\n+            this.digits = digits;\n+            return this;\n+        }\n+\n+        /** Set the flag determining whether or not a zero character is added in the fraction position\n+         * when no fractional value is present. For example, if set to {@code true}, the number {@code 1} would\n+         * be formatted as {@code \"1.0\"}. If {@code false}, it would be formatted as {@code \"1\"}. The default\n+         * value is {@code true}.\n+         * @param fractionPlaceholder if {@code true}, a zero character is placed in the fraction position when\n+         *      no fractional value is present; if {@code false}, fractional digits are only included when needed\n+         * @return this instance\n+         */\n+        public Builder includeFractionPlaceholder(final boolean fractionPlaceholder) {\n+            this.fractionPlaceholder = fractionPlaceholder;\n+            return this;\n+        }\n+\n+        /** Set the character used as the minus sign.\n+         * @param minusSign character to use as the minus sign\n+         * @return this instance\n+         */\n+        public Builder minusSign(final char minusSign) {\n+            this.minusSign = minusSign;\n+            return this;\n+        }\n+\n+        /** Set the decimal separator character, i.e., the character placed between the\n+         * whole number and fractional portions of the formatted strings. The default value\n+         * is {@code '.'}.\n+         * @param decimalSeparator decimal separator character\n+         * @return this instance\n+         */\n+        public Builder decimalSeparator(final char decimalSeparator) {\n+            this.decimalSeparator = decimalSeparator;\n+            return this;\n+        }\n+\n+        /** Set the character used to separate groups of thousands. Default value is {@code ','}.\n+         * @param groupingSeparator character used to separate groups of thousands\n+         * @return this instance\n+         * @see #groupThousands(boolean)\n+         */\n+        public Builder groupingSeparator(final char groupingSeparator) {\n+            this.groupingSeparator = groupingSeparator;\n+            return this;\n+        }\n+\n+        /** If set to {@code true}, thousands will be grouped with the\n+         * {@link #groupingSeparator(char) grouping separator}. For example, if set to {@code true},\n+         * the number {@code 1000} could be formatted as {@code \"1,000\"}. This property only applies\n+         * to the {@link DoubleFormat#PLAIN PLAIN} format. Default value is {@code false}.\n+         * @param groupThousands if {@code true}, thousands will be grouped\n+         * @return this instance\n+         * @see #groupingSeparator(char)\n+         */\n+        public Builder groupThousands(final boolean groupThousands) {\n+            this.groupThousands = groupThousands;\n+            return this;\n+        }\n+\n+        /** Set the exponent separator character, i.e., the string placed between\n+         * the mantissa and the exponent. The default value is {@code \"E\"}, as in\n+         * {@code \"1.2E6\"}.\n+         * @param exponentSeparator exponent separator string\n+         * @return this instance\n+         * @throws NullPointerException if the argument is {@code null}\n+         */\n+        public Builder exponentSeparator(final String exponentSeparator) {\n+            this.exponentSeparator = Objects.requireNonNull(exponentSeparator, \"Exponent separator cannot be null\");\n+            return this;\n+        }\n+\n+        /** Set the flag indicating if an exponent value should always be included in the\n+         * formatted value, even if the exponent value is zero. This property only applies\n+         * to formats that use scientific notation, namely\n+         * {@link DoubleFormat#SCIENTIFIC SCIENTIFIC},\n+         * {@link DoubleFormat#ENGINEERING ENGINEERING}, and\n+         * {@link DoubleFormat#MIXED MIXED}. The default value is {@code false}.\n+         * @param alwaysIncludeExponent if {@code true}, exponents will always be included in formatted\n+         *      output even if the exponent value is zero\n+         * @return this instance\n+         */\n+        public Builder alwaysIncludeExponent(final boolean alwaysIncludeExponent) {\n+            this.alwaysIncludeExponent = alwaysIncludeExponent;\n+            return this;\n+        }\n+\n+        /** Set the string used to represent infinity. For negative infinity, this string\n+         * is prefixed with the {@link #minusSign(char) minus sign}.\n+         * @param infinity string used to represent infinity\n+         * @return this instance\n+         * @throws NullPointerException if the argument is {@code null}\n+         */\n+        public Builder infinity(final String infinity) {\n+            this.infinity = Objects.requireNonNull(infinity, \"Infinity string cannot be null\");\n+            return this;\n+        }\n+\n+        /** Set the string used to represent {@link Double#NaN}.\n+         * @param nan string used to represent {@link Double#NaN}\n+         * @return this instance\n+         * @throws NullPointerException if the argument is {@code null}\n+         */\n+        public Builder nan(final String nan) {\n+            this.nan = Objects.requireNonNull(nan, \"NaN string cannot be null\");\n+            return this;\n+        }\n+\n+        /** Configure this instance with the given format symbols. The following values\n+         * are set:\n+         * <ul>\n+         *  <li>{@link #digits(String) digit characters}</li>\n+         *  <li>{@link #decimalSeparator(char) decimal separator}</li>\n+         *  <li>{@link #groupingSeparator(char) thousands grouping separator}</li>\n+         *  <li>{@link #minusSign(char) minus sign}</li>\n+         *  <li>{@link #exponentSeparator(String) exponent separator}</li>\n+         *  <li>{@link #infinity(String) infinity}</li>\n+         *  <li>{@link #nan(String) NaN}</li>\n+         * </ul>\n+         * The digit character string is constructed by starting at the configured\n+         * {@link DecimalFormatSymbols#getZeroDigit() zero digit} and adding the next\n+         * 9 consecutive characters.\n+         * @param symbols format symbols\n+         * @return this instance\n+         * @throws NullPointerException if the argument is {@code null}\n+         */\n+        public Builder formatSymbols(final DecimalFormatSymbols symbols) {\n+            Objects.requireNonNull(symbols, \"Decimal format symbols cannot be null\");\n+\n+            return digits(getDigitString(symbols))\n+                    .decimalSeparator(symbols.getDecimalSeparator())\n+                    .groupingSeparator(symbols.getGroupingSeparator())\n+                    .minusSign(symbols.getMinusSign())\n+                    .exponentSeparator(symbols.getExponentSeparator())\n+                    .infinity(symbols.getInfinity())\n+                    .nan(symbols.getNaN());\n+        }\n+\n+        /** Get a string containing the localized digits 0-9 for the given symbols object. The\n+         * string is constructed by starting at the {@link DecimalFormatSymbols#getZeroDigit() zero digit}\n+         * and adding the next 9 consecutive characters.\n+         * @param symbols symbols object\n+         * @return string containing the localized digits 0-9\n+         */\n+        private String getDigitString(final DecimalFormatSymbols symbols) {\n+            final int zeroDelta = symbols.getZeroDigit() - DEFAULT_DECIMAL_DIGITS.charAt(0);\n+\n+            final char[] digitChars = new char[DEFAULT_DECIMAL_DIGITS.length()];\n+            for (int i = 0; i < DEFAULT_DECIMAL_DIGITS.length(); ++i) {\n+                digitChars[i] = (char) (DEFAULT_DECIMAL_DIGITS.charAt(i) + zeroDelta);\n+            }\n+\n+            return String.valueOf(digitChars);\n+        }\n+\n+        /** Construct a new double format function.\n+         * @return format function\n+         */\n+        public DoubleFunction<String> build() {\n+            return factory.apply(this);\n+        }\n+    }\n+\n+    /** Base class for standard double formatting classes.\n+     */\n+    private abstract static class AbstractDoubleFormat\n+        implements DoubleFunction<String>, ParsedDecimal.FormatOptions {\n+\n+        /** Maximum precision; 0 indicates no limit. */\n+        private final int maxPrecision;\n+\n+        /** Minimum decimal exponent. */\n+        private final int minDecimalExponent;\n+\n+        /** String representing positive infinity. */\n+        private final String positiveInfinity;\n+\n+        /** String representing negative infinity. */\n+        private final String negativeInfinity;\n+\n+        /** String representing NaN. */\n+        private final String nan;\n+\n+        /** Flag determining if fraction placeholders should be used. */\n+        private final boolean fractionPlaceholder;\n+\n+        /** Flag determining if signed zero strings are allowed. */\n+        private final boolean signedZero;\n+\n+        /** String containing the digits 0-9. */\n+        private final char[] digits;\n+\n+        /** Decimal separator character. */\n+        private final char decimalSeparator;\n+\n+        /** Thousands grouping separator. */\n+        private final char groupingSeparator;\n+\n+        /** Flag indicating if thousands should be grouped. */\n+        private final boolean groupThousands;\n+\n+        /** Minus sign character. */\n+        private final char minusSign;\n+\n+        /** Exponent separator character. */\n+        private final char[] exponentSeparatorChars;\n+\n+        /** Flag indicating if exponent values should always be included, even if zero. */\n+        private final boolean alwaysIncludeExponent;\n+\n+        /** Construct a new instance.\n+         * @param builder builder instance containing configuration values\n+         */\n+        AbstractDoubleFormat(final Builder builder) {\n+            this.maxPrecision = builder.maxPrecision;\n+            this.minDecimalExponent = builder.minDecimalExponent;\n+\n+            this.positiveInfinity = builder.infinity;\n+            this.negativeInfinity = builder.minusSign + builder.infinity;\n+            this.nan = builder.nan;\n+\n+            this.fractionPlaceholder = builder.fractionPlaceholder;\n+            this.signedZero = builder.signedZero;\n+            this.digits = builder.digits.toCharArray();\n+            this.decimalSeparator = builder.decimalSeparator;\n+            this.groupingSeparator = builder.groupingSeparator;\n+            this.groupThousands = builder.groupThousands;\n+            this.minusSign = builder.minusSign;\n+            this.exponentSeparatorChars = builder.exponentSeparator.toCharArray();\n+            this.alwaysIncludeExponent = builder.alwaysIncludeExponent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean isIncludeFractionPlaceholder() {\n+            return fractionPlaceholder;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean isSignedZero() {\n+            return signedZero;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public char[] getDigits() {\n+            return digits;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public char getDecimalSeparator() {\n+            return decimalSeparator;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public char getGroupingSeparator() {\n+            return groupingSeparator;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean isGroupThousands() {\n+            return groupThousands;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public char getMinusSign() {\n+            return minusSign;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public char[] getExponentSeparatorChars() {\n+            return exponentSeparatorChars;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean isAlwaysIncludeExponent() {\n+            return alwaysIncludeExponent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public String apply(final double d) {\n+            if (Double.isFinite(d)) {\n+                return applyFinite(d);\n+            } else if (Double.isInfinite(d)) {\n+                return d > 0.0\n+                        ? positiveInfinity\n+                        : negativeInfinity;\n+            }\n+            return nan;\n+        }\n+\n+        /** Return a formatted string representation of the given finite value.\n+         * @param d double value\n+         */\n+        private String applyFinite(final double d) {\n+            final ParsedDecimal n = ParsedDecimal.from(d);\n+\n+            int roundExponent = Math.max(n.getExponent(), minDecimalExponent);\n+            if (maxPrecision > 0) {\n+                roundExponent = Math.max(n.getScientificExponent() - maxPrecision + 1, roundExponent);\n+            }\n+            n.round(roundExponent);\n+\n+            return applyFiniteInternal(n);\n+        }\n+\n+        /** Return a formatted representation of the given rounded decimal value to {@code dst}.\n+         * @param val value to format\n+         */\n+        protected abstract String applyFiniteInternal(ParsedDecimal val);\n+    }\n+\n+    /** Format class that produces plain decimal strings that do not use\n+     * scientific notation.\n+     */\n+    private static class PlainDoubleFormat extends AbstractDoubleFormat {\n+\n+        /** Construct a new instance.\n+         * @param builder builder instance containing configuration values\n+         */\n+        PlainDoubleFormat(final Builder builder) {\n+            super(builder);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        protected String applyFiniteInternal(final ParsedDecimal val) {\n+            return val.toPlainString(this);\n+        }\n+    }\n+\n+    /** Format class producing results similar to {@link Double#toString()}, with\n+     * plain decimal notation for small numbers relatively close to zero and scientific\n+     * notation otherwise.\n+     */\n+    private static final class MixedDoubleFormat extends AbstractDoubleFormat {\n+\n+        /** Max decimal exponent for plain format. */\n+        private final int plainMaxExponent;\n+\n+        /** Min decimal exponent for plain format. */\n+        private final int plainMinExponent;\n+\n+        /** Construct a new instance.\n+         * @param builder builder instance containing configuration values\n+         */\n+        MixedDoubleFormat(final Builder builder) {\n+            super(builder);\n+\n+            this.plainMaxExponent = builder.plainFormatMaxDecimalExponent;\n+            this.plainMinExponent = builder.plainFormatMinDecimalExponent;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        protected String applyFiniteInternal(final ParsedDecimal val) {\n+            final int sciExp = val.getScientificExponent();\n+            if (sciExp <= plainMaxExponent && sciExp >= plainMinExponent) {\n+                return val.toPlainString(this);\n+            }\n+            return val.toScientificString(this);\n+        }\n+    }\n+\n+    /** Format class that uses scientific notation for all values.\n+     */\n+    private static class ScientificDoubleFormat extends AbstractDoubleFormat {\n+\n+        /** Construct a new instance.\n+         * @param builder builder instance containing configuration values\n+         */\n+        ScientificDoubleFormat(final Builder builder) {\n+            super(builder);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public String applyFiniteInternal(final ParsedDecimal val) {\n+            return val.toScientificString(this);\n+        }\n+    }\n+\n+    /** Format class that uses engineering notation for all values.\n+     */\n+    private static class EngineeringDoubleFormat extends AbstractDoubleFormat {\n+\n+        /** Construct a new instance.\n+         * @param builder builder instance containing configuration values\n+         */\n+        EngineeringDoubleFormat(final Builder builder) {\n+            super(builder);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public String applyFiniteInternal(final ParsedDecimal val) {\n+            return val.toEngineeringString(this);\n+        }\n+    }\n+}\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/numbers/ParsedDecimal.java",
        "status": "added",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.numbers;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ParsedDecimalTest {\n\n    @Test\n    void testFromDouble() {\n        ParsedDecimal pd = ParsedDecimal.from(1.2);\n        assertFalse(pd.negative);\n        assertArrayEquals(new int[]{1, 2}, pd.digits);\n        assertEquals(2, pd.digitCount);\n        assertEquals(-1, pd.exponent);\n    }\n\n    @Test\n    void testFromDoubleNegative() {\n        ParsedDecimal pd = ParsedDecimal.from(-0.00971);\n        assertTrue(pd.negative);\n        assertArrayEquals(new int[]{9, 7, 1}, pd.digits);\n        assertEquals(3, pd.digitCount);\n        assertEquals(-5, pd.exponent);\n    }\n\n    @Test\n    void testFromDoubleZero() {\n        ParsedDecimal pd = ParsedDecimal.from(0.0);\n        assertFalse(pd.negative);\n        assertArrayEquals(new int[]{0}, pd.digits);\n        assertEquals(1, pd.digitCount);\n        assertEquals(0, pd.exponent);\n    }\n\n    @Test\n    void testFromDoubleNegativeZero() {\n        ParsedDecimal pd = ParsedDecimal.from(-0.0);\n        assertTrue(pd.negative);\n        assertArrayEquals(new int[]{0}, pd.digits);\n        assertEquals(1, pd.digitCount);\n        assertEquals(0, pd.exponent);\n    }\n\n    @Test\n    void testFromDoubleLarge() {\n        ParsedDecimal pd = ParsedDecimal.from(56300);\n        assertFalse(pd.negative);\n        assertArrayEquals(new int[]{5, 6, 3}, pd.digits);\n        assertEquals(3, pd.digitCount);\n        assertEquals(2, pd.exponent);\n    }\n\n    @Test\n    void testRound() {\n        ParsedDecimal pd = ParsedDecimal.from(1.2345);\n        pd.round(-2);\n        assertArrayEquals(new int[]{1, 2, 3}, pd.digits);\n        assertEquals(3, pd.digitCount);\n        assertEquals(-2, pd.exponent);\n    }\n\n    @Test\n    void testMaxPrecision() {\n        ParsedDecimal pd = ParsedDecimal.from(1.2345);\n        pd.maxPrecision(2);\n        assertArrayEquals(new int[]{1, 2}, pd.digits);\n        assertEquals(2, pd.digitCount);\n        assertEquals(-1, pd.exponent);\n    }\n\n    @Test\n    void testToPlainString() {\n        ParsedDecimal pd = ParsedDecimal.from(1.2345);\n        String result = pd.toPlainString(new FormatOptions() {\n            @Override\n            public boolean isIncludeFractionPlaceholder() {\n                return true;\n            }\n\n            @Override\n            public boolean isSignedZero() {\n                return false;\n            }\n\n            @Override\n            public char[] getDigits() {\n                return new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n            }\n\n            @Override\n            public char getDecimalSeparator() {\n                return '.';\n            }\n\n            @Override\n            public char getGroupingSeparator() {\n                return ',';\n            }\n\n            @Override\n            public boolean isGroupThousands() {\n                return false;\n            }\n\n            @Override\n            public char getMinusSign() {\n                return '-';\n            }\n\n            @Override\n            public char[] getExponentSeparatorChars() {\n                return new char[]{'E'};\n            }\n\n            @Override\n            public boolean isAlwaysIncludeExponent() {\n                return false;\n            }\n        });\n        assertEquals(\"1.2345\", result);\n    }\n\n    @Test\n    void testToScientificString() {\n        ParsedDecimal pd = ParsedDecimal.from(1.2345);\n        String result = pd.toScientificString(new FormatOptions() {\n            @Override\n            public boolean isIncludeFractionPlaceholder() {\n                return true;\n            }\n\n            @Override\n            public boolean isSignedZero() {\n                return false;\n            }\n\n            @Override\n            public char[] getDigits() {\n                return new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n            }\n\n            @Override\n            public char getDecimalSeparator() {\n                return '.';\n            }\n\n            @Override\n            public char getGroupingSeparator() {\n                return ',';\n            }\n\n            @Override\n            public boolean isGroupThousands() {\n                return false;\n            }\n\n            @Override\n            public char getMinusSign() {\n                return '-';\n            }\n\n            @Override\n            public char[] getExponentSeparatorChars() {\n                return new char[]{'E'};\n            }\n\n            @Override\n            public boolean isAlwaysIncludeExponent() {\n                return false;\n            }\n        });\n        assertEquals(\"1.2345E0\", result);\n    }\n\n    @Test\n    void testToEngineeringString() {\n        ParsedDecimal pd = ParsedDecimal.from(12345);\n        String result = pd.toEngineeringString(new FormatOptions() {\n            @Override\n            public boolean isIncludeFractionPlaceholder() {\n                return true;\n            }\n\n            @Override\n            public boolean isSignedZero() {\n                return false;\n            }\n\n            @Override\n            public char[] getDigits() {\n                return new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n            }\n\n            @Override\n            public char getDecimalSeparator() {\n                return '.';\n            }\n\n            @Override\n            public char getGroupingSeparator() {\n                return ',';\n            }\n\n            @Override\n            public boolean isGroupThousands() {\n                return false;\n            }\n\n            @Override\n            public char getMinusSign() {\n                return '-';\n            }\n\n            @Override\n            public char[] getExponentSeparatorChars() {\n                return new char[]{'E'};\n            }\n\n            @Override\n            public boolean isAlwaysIncludeExponent() {\n                return false;\n            }\n        });\n        assertEquals(\"12.345E3\", result);\n    }\n}",
        "file_content": null,
        "diff": " a/src/main/java/org/apache/commons/text/numbers/ParsedDecimal.java b/src/main/java/org/apache/commons/text/numbers/ParsedDecimal.java\nnew file mode 100644\nindex 0000000000..953eb7660c\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/numbers/ParsedDecimal.java\n@@ -0,0 +1,723 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.text.numbers;\n+\n+/** Internal class representing a decimal value parsed into separate components. Each number\n+ * is represented with\n+ * <ul>\n+ *  <li>a boolean flag for the sign,</li>\n+ *  <li> a sequence of the digits {@code 0 - 10} representing an unsigned integer with leading and trailing zeros\n+ *      removed, and</li>\n+ *  <li>an exponent value that when applied to the base 10 digits produces a floating point value with the\n+ *      correct magnitude.</li>\n+ * </ul>\n+ * <p><strong>Examples</strong></p>\n+ * <table>\n+ *  <tr><th>Double</th><th>Negative</th><th>Digits</th><th>Exponent</th></tr>\n+ *  <tr><td>0.0</td><td>false</td><td>[0]</td><td>0</td></tr>\n+ *  <tr><td>1.2</td><td>false</td><td>[1, 2]</td><td>-1</td></tr>\n+ *  <tr><td>-0.00971</td><td>true</td><td>[9, 7, 1]</td><td>-5</td></tr>\n+ *  <tr><td>56300</td><td>true</td><td>[5, 6, 3]</td><td>2</td></tr>\n+ * </table>\n+ */\n+final class ParsedDecimal {\n+\n+    /** Interface containing values used during string formatting.\n+     */\n+    interface FormatOptions {\n+\n+        /** Return {@code true} if fraction placeholders (e.g., {@code \".0\"} in {@code \"1.0\"})\n+         * should be included.\n+         * @return {@code true} if fraction placeholders should be included\n+         */\n+        boolean isIncludeFractionPlaceholder();\n+\n+        /** Return {@code true} if the string zero should be prefixed with the minus sign\n+         * for negative zero values.\n+         * @return {@code true} if the minus zero string should be allowed\n+         */\n+        boolean isSignedZero();\n+\n+        /** Get an array containing the localized digit characters 0-9 in that order.\n+         * This string <em>must</em> be non-null and have a length of 10.\n+         * @return array containing the digit characters 0-9\n+         */\n+        char[] getDigits();\n+\n+        /** Get the decimal separator character.\n+         * @return decimal separator character\n+         */\n+        char getDecimalSeparator();\n+\n+        /** Get the character used to separate thousands groupings.\n+         * @return character used to separate thousands groupings\n+         */\n+        char getGroupingSeparator();\n+\n+        /** Return {@code true} if thousands should be grouped.\n+         * @return {@code true} if thousand should be grouped\n+         */\n+        boolean isGroupThousands();\n+\n+        /** Get the minus sign character.\n+         * @return minus sign character\n+         */\n+        char getMinusSign();\n+\n+        /** Get the exponent separator as an array of characters.\n+         * @return exponent separator as an array of characters\n+         */\n+        char[] getExponentSeparatorChars();\n+\n+        /** Return {@code true} if exponent values should always be included in\n+         * formatted output, even if the value is zero.\n+         * @return {@code true} if exponent values should always be included\n+         */\n+        boolean isAlwaysIncludeExponent();\n+    }\n+\n+    /** Minus sign character. */\n+    private static final char MINUS_CHAR = '-';\n+\n+    /** Decimal separator character. */\n+    private static final char DECIMAL_SEP_CHAR = '.';\n+\n+    /** Exponent character. */\n+    private static final char EXPONENT_CHAR = 'E';\n+\n+    /** Zero digit character. */\n+    private static final char ZERO_CHAR = '0';\n+\n+    /** Number of characters in thousands groupings. */\n+    private static final int THOUSANDS_GROUP_SIZE = 3;\n+\n+    /** Radix for decimal numbers. */\n+    private static final int DECIMAL_RADIX = 10;\n+\n+    /** Center value used when rounding. */\n+    private static final int ROUND_CENTER = DECIMAL_RADIX / 2;\n+\n+    /** Number that exponents in engineering format must be a multiple of. */\n+    private static final int ENG_EXPONENT_MOD = 3;\n+\n+    /** True if the value is negative. */\n+    final boolean negative;\n+\n+    /** Array containing the significant decimal digits for the value. */\n+    final int[] digits;\n+\n+    /** Number of digits used in the digits array; not necessarily equal to the length. */\n+    int digitCount;\n+\n+    /** Exponent for the value. */\n+    int exponent;\n+\n+    /** Output buffer for use in creating string representations. */\n+    private char[] outputChars;\n+\n+    /** Output buffer index. */\n+    private int outputIdx;\n+\n+    /** Construct a new instance from its parts.\n+     * @param negative {@code true} if the value is negative\n+     * @param digits array containing significant digits\n+     * @param digitCount number of digits used from the {@code digits} array\n+     * @param exponent exponent value\n+     */\n+    private ParsedDecimal(final boolean negative, final int[] digits, final int digitCount,\n+            final int exponent) {\n+        this.negative = negative;\n+        this.digits = digits;\n+        this.digitCount = digitCount;\n+        this.exponent = exponent;\n+    }\n+\n+    /** Get the exponent value. This exponent produces a floating point value with the\n+     * correct magnitude when applied to the internal unsigned integer.\n+     * @return exponent value\n+     */\n+    public int getExponent() {\n+        return exponent;\n+    }\n+\n+    /** Get the exponent that would be used when representing this number in scientific\n+     * notation (i.e., with a single non-zero digit in front of the decimal point).\n+     * @return the exponent that would be used when representing this number in scientific\n+     *      notation\n+     */\n+    public int getScientificExponent() {\n+        return digitCount + exponent - 1;\n+    }\n+\n+    /** Round the instance to the given decimal exponent position using\n+     * {@link java.math.RoundingMode#HALF_EVEN half-even rounding}. For example, a value of {@code -2}\n+     * will round the instance to the digit at the position 10<sup>-2</sup> (i.e. to the closest multiple of 0.01).\n+     * @param roundExponent exponent defining the decimal place to round to\n+     */\n+    public void round(final int roundExponent) {\n+        if (roundExponent > exponent) {\n+            final int max = digitCount + exponent;\n+\n+            if (roundExponent < max) {\n+                // rounding to a decimal place less than the max; set max precision\n+                maxPrecision(max - roundExponent);\n+            } else if (roundExponent == max && shouldRoundUp(0)) {\n+                // rounding up directly on the max decimal place\n+                setSingleDigitValue(1, roundExponent);\n+            } else {\n+                // change to zero\n+                setSingleDigitValue(0, 0);\n+            }\n+        }\n+    }\n+\n+    /** Ensure that this instance has <em>at most</em> the given number of significant digits\n+     * (i.e. precision). If this instance already has a precision less than or equal\n+     * to the argument, nothing is done. If the given precision requires a reduction in the number\n+     * of digits, then the value is rounded using {@link java.math.RoundingMode#HALF_EVEN half-even rounding}.\n+     * @param precision maximum number of significant digits to include\n+     */\n+    public void maxPrecision(final int precision) {\n+        if (precision > 0 && precision < digitCount) {\n+            if (shouldRoundUp(precision)) {\n+                roundUp(precision);\n+            } else {\n+                truncate(precision);\n+            }\n+        }\n+    }\n+\n+    /** Return a string representation of this value with no exponent field. Ex:\n+     * <pre>\n+     * 10 = \"10.0\"\n+     * 1e-6 = \"0.000001\"\n+     * 1e11 = \"100000000000.0\"\n+     * </pre>\n+     * @param opts format options\n+     * @return value in plain format\n+     */\n+    public String toPlainString(final FormatOptions opts) {\n+        final int decimalPos = digitCount + exponent;\n+        final int fractionZeroCount = decimalPos < 1\n+                ? Math.abs(decimalPos)\n+                : 0;\n+\n+        prepareOutput(getPlainStringSize(decimalPos, opts));\n+\n+        final int fractionStartIdx = opts.isGroupThousands()\n+                ? appendWholeGrouped(decimalPos, opts)\n+                : appendWhole(decimalPos, opts);\n+\n+        appendFraction(fractionZeroCount, fractionStartIdx, opts);\n+\n+        return outputString();\n+    }\n+\n+    /** Return a string representation of this value in scientific notation. Ex:\n+     * <pre>\n+     * 0 = \"0.0\"\n+     * 10 = \"1.0E1\"\n+     * 1e-6 = \"1.0E-6\"\n+     * 1e11 = \"1.0E11\"\n+     * </pre>\n+     * @param opts format options\n+     * @return value in scientific format\n+     */\n+    public String toScientificString(final FormatOptions opts) {\n+        return toScientificString(1, opts);\n+    }\n+\n+    /** Return a string representation of this value in engineering notation. This\n+     * is similar to {@link #toScientificString(FormatOptions) scientific notation}\n+     * but with the exponent forced to be a multiple of 3, allowing easier alignment with SI prefixes.\n+     * <pre>\n+     * 0 = \"0.0\"\n+     * 10 = \"10.0\"\n+     * 1e-6 = \"1.0E-6\"\n+     * 1e11 = \"100.0E9\"\n+     * </pre>\n+     * @param opts format options\n+     * @return value in engineering format\n+     */\n+    public String toEngineeringString(final FormatOptions opts) {\n+        final int decimalPos = 1 + Math.floorMod(getScientificExponent(), ENG_EXPONENT_MOD);\n+        return toScientificString(decimalPos, opts);\n+    }\n+\n+    /** Return a string representation of the value in scientific notation using the\n+     * given decimal point position.\n+     * @param decimalPos decimal position relative to the {@code digits} array; this value\n+     *      is expected to be greater than 0\n+     * @param opts format options\n+     * @return value in scientific format\n+     */\n+    private String toScientificString(final int decimalPos, final FormatOptions opts) {\n+        final int targetExponent = digitCount + exponent - decimalPos;\n+        final int absTargetExponent = Math.abs(targetExponent);\n+        final boolean includeExponent = shouldIncludeExponent(targetExponent, opts);\n+        final boolean negativeExponent = targetExponent < 0;\n+\n+        // determine the size of the full formatted string, including the number of\n+        // characters needed for the exponent digits\n+        int size = getDigitStringSize(decimalPos, opts);\n+        int exponentDigitCount = 0;\n+        if (includeExponent) {\n+            exponentDigitCount = absTargetExponent > 0\n+                    ? (int) Math.floor(Math.log10(absTargetExponent)) + 1\n+                    : 1;\n+\n+            size += opts.getExponentSeparatorChars().length + exponentDigitCount;\n+            if (negativeExponent) {\n+                ++size;\n+            }\n+        }\n+\n+        prepareOutput(size);\n+\n+        // append the portion before the exponent field\n+        final int fractionStartIdx = appendWhole(decimalPos, opts);\n+        appendFraction(0, fractionStartIdx, opts);\n+\n+        if (includeExponent) {\n+            // append the exponent field\n+            append(opts.getExponentSeparatorChars());\n+\n+            if (negativeExponent) {\n+                append(opts.getMinusSign());\n+            }\n+\n+            // append the exponent digits themselves; compute the\n+            // string representation directly and add it to the output\n+            // buffer to avoid the overhead of Integer.toString()\n+            final char[] localizedDigits = opts.getDigits();\n+            int rem = absTargetExponent;\n+            for (int i = size - 1; i >= outputIdx; --i) {\n+                outputChars[i] = localizedDigits[rem % DECIMAL_RADIX];\n+                rem /= DECIMAL_RADIX;\n+            }\n+            outputIdx = size;\n+        }\n+\n+        return outputString();\n+    }\n+\n+    /** Prepare the output buffer for a string of the given size.\n+     * @param size buffer size\n+     */\n+    private void prepareOutput(final int size) {\n+        outputChars = new char[size];\n+        outputIdx = 0;\n+    }\n+\n+    /** Get the output buffer as a string.\n+     * @return output buffer as a string\n+     */\n+    private String outputString() {\n+        final String str = String.valueOf(outputChars);\n+        outputChars = null;\n+        return str;\n+    }\n+\n+    /** Append the given character to the output buffer.\n+     * @param ch character to append\n+     */\n+    private void append(final char ch) {\n+        outputChars[outputIdx++] = ch;\n+    }\n+\n+    /** Append the given character array directly to the output buffer.\n+     * @param chars characters to append\n+     */\n+    private void append(final char[] chars) {\n+        for (final char c : chars) {\n+            append(c);\n+        }\n+    }\n+\n+    /** Append the localized representation of the digit {@code n} to the output buffer.\n+     * @param n digit to append\n+     * @param digitChars character array containing localized versions of the digits {@code 0-9}\n+     *      in that order\n+     */\n+    private void appendLocalizedDigit(final int n, final char[] digitChars) {\n+        append(digitChars[n]);\n+    }\n+\n+    /** Append the whole number portion of this value to the output buffer. No thousands\n+     * separators are added.\n+     * @param wholeCount total number of digits required to the left of the decimal point\n+     * @param opts format options\n+     * @return number of digits from {@code digits} appended to the output buffer\n+     * @see #appendWholeGrouped(int, FormatOptions)\n+     */\n+    private int appendWhole(final int wholeCount, final FormatOptions opts) {\n+        if (shouldIncludeMinus(opts)) {\n+            append(opts.getMinusSign());\n+        }\n+\n+        final char[] localizedDigits = opts.getDigits();\n+        final char localizedZero = localizedDigits[0];\n+\n+        final int significantDigitCount = Math.max(0, Math.min(wholeCount, digitCount));\n+\n+        if (significantDigitCount > 0) {\n+            int i;\n+            for (i = 0; i < significantDigitCount; ++i) {\n+                appendLocalizedDigit(digits[i], localizedDigits);\n+            }\n+\n+            for (; i < wholeCount; ++i) {\n+                append(localizedZero);\n+            }\n+        } else {\n+            append(localizedZero);\n+        }\n+\n+        return significantDigitCount;\n+    }\n+\n+    /** Append the whole number portion of this value to the output buffer, adding thousands\n+     * separators as needed.\n+     * @param wholeCount total number of digits required to the right of the decimal point\n+     * @param opts format options\n+     * @return number of digits from {@code digits} appended to the output buffer\n+     * @see #appendWhole(int, FormatOptions)\n+     */\n+    private int appendWholeGrouped(final int wholeCount, final FormatOptions opts) {\n+        if (shouldIncludeMinus(opts)) {\n+            append(opts.getMinusSign());\n+        }\n+\n+        final char[] localizedDigits = opts.getDigits();\n+        final char localizedZero = localizedDigits[0];\n+        final char groupingChar = opts.getGroupingSeparator();\n+\n+        final int appendCount = Math.max(0, Math.min(wholeCount, digitCount));\n+\n+        if (appendCount > 0) {\n+            int i;\n+            int pos = wholeCount;\n+            for (i = 0; i < appendCount; ++i, --pos) {\n+                appendLocalizedDigit(digits[i], localizedDigits);\n+                if (requiresGroupingSeparatorAfterPosition(pos)) {\n+                    append(groupingChar);\n+                }\n+            }\n+\n+            for (; i < wholeCount; ++i, --pos) {\n+                append(localizedZero);\n+                if (requiresGroupingSeparatorAfterPosition(pos)) {\n+                    append(groupingChar);\n+                }\n+            }\n+        } else {\n+            append(localizedZero);\n+        }\n+\n+        return appendCount;\n+    }\n+\n+    /** Return {@code true} if a grouping separator should be added after the whole digit\n+     * character at the given position.\n+     * @param pos whole digit character position, with values starting at 1 and increasing\n+     *      from right to left.\n+     * @return {@code true} if a grouping separator should be added\n+     */\n+    private boolean requiresGroupingSeparatorAfterPosition(final int pos) {\n+        return pos > 1 && (pos % THOUSANDS_GROUP_SIZE) == 1;\n+    }\n+\n+    /** Append the fractional component of the number to the current output buffer.\n+     * @param zeroCount number of zeros to add after the decimal point and before the\n+     *      first significant digit\n+     * @param startIdx significant digit start index\n+     * @param opts format options\n+     */\n+    private void appendFraction(final int zeroCount, final int startIdx, final FormatOptions opts) {\n+        final char[] localizedDigits = opts.getDigits();\n+        final char localizedZero = localizedDigits[0];\n+\n+        if (startIdx < digitCount) {\n+            append(opts.getDecimalSeparator());\n+\n+            // add the zero prefix\n+            for (int i = 0; i < zeroCount; ++i) {\n+                append(localizedZero);\n+            }\n+\n+            // add the fraction digits\n+            for (int i = startIdx; i < digitCount; ++i) {\n+                appendLocalizedDigit(digits[i], localizedDigits);\n+            }\n+        } else if (opts.isIncludeFractionPlaceholder()) {\n+            append(opts.getDecimalSeparator());\n+            append(localizedZero);\n+        }\n+    }\n+\n+    /** Get the number of characters required to create a plain format representation\n+     * of this value.\n+     * @param decimalPos decimal position relative to the {@code digits} array\n+     * @param opts format options\n+     * @return number of characters in the plain string representation of this value,\n+     *      created using the given parameters\n+     */\n+    private int getPlainStringSize(final int decimalPos, final FormatOptions opts) {\n+        int size = getDigitStringSize(decimalPos, opts);\n+\n+        // adjust for groupings if needed\n+        if (opts.isGroupThousands() && decimalPos > 0) {\n+            size += (decimalPos - 1) / THOUSANDS_GROUP_SIZE;\n+        }\n+\n+        return size;\n+    }\n+\n+    /** Get the number of characters required for the digit portion of a string representation of\n+     * this value. This excludes any exponent or thousands groupings characters.\n+     * @param decimalPos decimal point position relative to the {@code digits} array\n+     * @param opts format options\n+     * @return number of characters required for the digit portion of a string representation of\n+     *      this value\n+     */\n+    private int getDigitStringSize(final int decimalPos, final FormatOptions opts) {\n+        int size = digitCount;\n+        if (shouldIncludeMinus(opts)) {\n+            ++size;\n+        }\n+        if (decimalPos < 1) {\n+            // no whole component;\n+            // add decimal point and leading zeros\n+            size += 2 + Math.abs(decimalPos);\n+        } else if (decimalPos >= digitCount) {\n+            // no fraction component;\n+            // add trailing zeros\n+            size += decimalPos - digitCount;\n+            if (opts.isIncludeFractionPlaceholder()) {\n+                size += 2;\n+            }\n+        } else {\n+            // whole and fraction components;\n+            // add decimal point\n+            size += 1;\n+        }\n+\n+        return size;\n+    }\n+\n+    /** Return {@code true} if formatted strings should include the minus sign, considering\n+     * the value of this instance and the given format options.\n+     * @param opts format options\n+     * @return {@code true} if a minus sign should be included in the output\n+     */\n+    private boolean shouldIncludeMinus(final FormatOptions opts) {\n+        return negative && (opts.isSignedZero() || !isZero());\n+    }\n+\n+    /** Return {@code true} if a formatted string with the given target exponent should include\n+     * the exponent field.\n+     * @param targetExponent exponent of the formatted result\n+     * @param opts format options\n+     * @return {@code true} if the formatted string should include the exponent field\n+     */\n+    private boolean shouldIncludeExponent(final int targetExponent, final FormatOptions opts) {\n+        return targetExponent != 0 || opts.isAlwaysIncludeExponent();\n+    }\n+\n+    /** Return {@code true} if a rounding operation for the given number of digits should\n+     * round up.\n+     * @param count number of digits to round to; must be greater than zero and less\n+     *      than the current number of digits\n+     * @return {@code true} if a rounding operation for the given number of digits should\n+     *      round up\n+     */\n+    private boolean shouldRoundUp(final int count) {\n+        // Round up in the following cases:\n+        // 1. The digit after the last digit is greater than 5.\n+        // 2. The digit after the last digit is 5 and there are additional (non-zero)\n+        //      digits after it.\n+        // 3. The digit after the last digit is 5, there are no additional digits afterward,\n+        //      and the last digit is odd (half-even rounding).\n+        final int digitAfterLast = digits[count];\n+\n+        return digitAfterLast > ROUND_CENTER || (digitAfterLast == ROUND_CENTER\n+                && (count < digitCount - 1 || (digits[count - 1] % 2) != 0));\n+    }\n+\n+    /** Round the value up to the given number of digits.\n+     * @param count target number of digits; must be greater than zero and\n+     *      less than the current number of digits\n+     */\n+    private void roundUp(final int count) {\n+        int removedDigits = digitCount - count;\n+        int i;\n+        for (i = count - 1; i >= 0; --i) {\n+            final int d = digits[i] + 1;\n+\n+            if (d < DECIMAL_RADIX) {\n+                // value did not carry over; done adding\n+                digits[i] = d;\n+                break;\n+            } else {\n+                // value carried over; the current position is 0\n+                // which we will ignore by shortening the digit count\n+                ++removedDigits;\n+            }\n+        }\n+\n+        if (i < 0) {\n+            // all values carried over\n+            setSingleDigitValue(1, exponent + removedDigits);\n+        } else {\n+            // values were updated in-place; just need to update the length\n+            truncate(digitCount - removedDigits);\n+        }\n+    }\n+\n+    /** Return {@code true} if this value is equal to zero. The sign field is ignored,\n+     * meaning that this method will return {@code true} for both {@code +0} and {@code -0}.\n+     * @return {@code true} if the value is equal to zero\n+     */\n+    boolean isZero() {\n+        return digits[0] == 0;\n+    }\n+\n+    /** Set the value of this instance to a single digit with the given exponent.\n+     * The sign of the value is retained.\n+     * @param digit digit value\n+     * @param newExponent new exponent value\n+     */\n+    private void setSingleDigitValue(final int digit, final int newExponent) {\n+        digits[0] = digit;\n+        digitCount = 1;\n+        exponent = newExponent;\n+    }\n+\n+    /** Truncate the value to the given number of digits.\n+     * @param count number of digits; must be greater than zero and less than\n+     *      the current number of digits\n+     */\n+    private void truncate(final int count) {\n+        // trim all trailing zero digits, making sure to leave\n+        // at least one digit left\n+        int nonZeroCount = count;\n+        for (int i = count - 1;\n+                i > 0 && digits[i] == 0;\n+                --i) {\n+            --nonZeroCount;\n+        }\n+        exponent += digitCount - nonZeroCount;\n+        digitCount = nonZeroCount;\n+    }\n+\n+    /** Construct a new instance from the given double value.\n+     * @param d double value\n+     * @return a new instance containing the parsed components of the given double value\n+     * @throws IllegalArgumentException if {@code d} is {@code NaN} or infinite\n+     */\n+    public static ParsedDecimal from(final double d) {\n+        if (!Double.isFinite(d)) {\n+            throw new IllegalArgumentException(\"Double is not finite\");\n+        }\n+\n+        // Get the canonical string representation of the double value and parse\n+        // it to extract the components of the decimal value. From the documentation\n+        // of Double.toString() and the fact that d is finite, we are guaranteed the\n+        // following:\n+        // - the string will not be empty\n+        // - it will contain exactly one decimal point character\n+        // - all digit characters are in the ASCII range\n+        final char[] strChars = Double.toString(d).toCharArray();\n+\n+        final boolean negative = strChars[0] == MINUS_CHAR;\n+        final int digitStartIdx = negative ? 1 : 0;\n+\n+        final int[] digits = new int[strChars.length - digitStartIdx - 1];\n+\n+        boolean foundDecimalPoint = false;\n+        int digitCount = 0;\n+        int significantDigitCount = 0;\n+        int decimalPos = 0;\n+\n+        int i;\n+        for (i = digitStartIdx; i < strChars.length; ++i) {\n+            final char ch = strChars[i];\n+\n+            if (ch == DECIMAL_SEP_CHAR) {\n+                foundDecimalPoint = true;\n+                decimalPos = digitCount;\n+            } else if (ch == EXPONENT_CHAR) {\n+                // no more mantissa digits\n+                break;\n+            } else if (ch != ZERO_CHAR || digitCount > 0) {\n+                // this is either the first non-zero digit or one after it\n+                final int val = digitValue(ch);\n+                digits[digitCount++] = val;\n+\n+                if (val > 0) {\n+                    significantDigitCount = digitCount;\n+                }\n+            } else if (foundDecimalPoint) {\n+                // leading zero in a fraction; adjust the decimal position\n+                --decimalPos;\n+            }\n+        }\n+\n+        if (digitCount > 0) {\n+            // determine the exponent\n+            final int explicitExponent = i < strChars.length\n+                    ? parseExponent(strChars, i + 1)\n+                    : 0;\n+            final int exponent = explicitExponent + decimalPos - significantDigitCount;\n+\n+            return new ParsedDecimal(negative, digits, significantDigitCount, exponent);\n+        }\n+\n+        // no non-zero digits, so value is zero\n+        return new ParsedDecimal(negative, new int[] {0}, 1, 0);\n+    }\n+\n+    /** Parse a double exponent value from {@code chars}, starting at the {@code start}\n+     * index and continuing through the end of the array.\n+     * @param chars character array to parse a double exponent value from\n+     * @param start start index\n+     * @return parsed exponent value\n+     */\n+    private static int parseExponent(final char[] chars, final int start) {\n+        int i = start;\n+        boolean neg = chars[i] == MINUS_CHAR;\n+        if (neg) {\n+            ++i;\n+        }\n+\n+        int exp = 0;\n+        for (; i < chars.length; ++i) {\n+            exp = (exp * DECIMAL_RADIX) + digitValue(chars[i]);\n+        }\n+\n+        return neg ? -exp : exp;\n+    }\n+\n+    /** Get the numeric value of the given digit character. No validation of the\n+     * character type is performed.\n+     * @param ch digit character\n+     * @return numeric value of the digit character, ex: '1' = 1\n+     */\n+    private static int digitValue(final char ch) {\n+        return ch - ZERO_CHAR;\n+    }\n+}\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/numbers/package-info.java",
        "status": "added",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.numbers;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * Test class for the package org.apache.commons.text.numbers.\n */\npublic class PackageInfoTest {\n\n    @Test\n    public void testPackageInfo() {\n        // Verify the package name\n        Package pkg = Package.getPackage(\"org.apache.commons.text.numbers\");\n        assertNotNull(pkg, \"Package org.apache.commons.text.numbers should exist\");\n\n        // Verify the package specification title\n        assertEquals(\"Apache Commons Text\", pkg.getSpecificationTitle(), \"Specification title should be 'Apache Commons Text'\");\n\n        // Verify the package specification version\n        assertEquals(\"1.10\", pkg.getSpecificationVersion(), \"Specification version should be '1.10'\");\n\n        // Verify the package specification vendor\n        assertEquals(\"The Apache Software Foundation\", pkg.getSpecificationVendor(), \"Specification vendor should be 'The Apache Software Foundation'\");\n\n        // Verify the package implementation title\n        assertEquals(\"org.apache.commons.text.numbers\", pkg.getImplementationTitle(), \"Implementation title should be 'org.apache.commons.text.numbers'\");\n\n        // Verify the package implementation version\n        assertNotNull(pkg.getImplementationVersion(), \"Implementation version should not be null\");\n\n        // Verify the package implementation vendor\n        assertEquals(\"The Apache Software Foundation\", pkg.getImplementationVendor(), \"Implementation vendor should be 'The Apache Software Foundation'\");\n    }\n}",
        "file_content": null,
        "diff": " a/src/main/java/org/apache/commons/text/numbers/package-info.java b/src/main/java/org/apache/commons/text/numbers/package-info.java\nnew file mode 100644\nindex 0000000000..0e9e671e0c\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/numbers/package-info.java\n@@ -0,0 +1,24 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * <p>\n+ * Provides algorithms for converting numbers to strings.\n+ * </p>\n+ *\n+ * @since 1.10\n+ */\n+package org.apache.commons.text.numbers;\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/jmh/DoubleFormatPerformance.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/numbers/DoubleFormatTest.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/numbers/ParsedDecimalTest.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 242,
    "title": "Simplify conditions and avoid extra checks.",
    "state": "closed",
    "created_at": "2021-06-19T08:26:58Z",
    "merge_commit_sha": "55e666bead302da5871c5b91879ef6807f386c82",
    "base_sha": "38eb80048863b58135783040072696c31537afd3",
    "head_sha": "8e4430c89f91ba7ff5b3e263470f70f0d27faa88",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/WordUtils.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport org.junit.jupiter.api.Test;\n\npublic class WordUtilsTest2 {\n\n    @Test\n    public void testWrapWithMatcherSizeChange() {\n        // Test case to verify the change in matcherSize calculation\n        final String input = \"This is a test string to check the wrap functionality.\";\n        final String expected = \"This is a test\\nstring to check\\nthe wrap\\nfunctionality.\";\n        assertThat(WordUtils.wrap(input, 15, \"\\n\", false)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testWrapWithMatcherSizeChangeAtStart() {\n        // Test case to verify the change in matcherSize calculation when the match is at the start\n        final String input = \" test string to check the wrap functionality.\";\n        final String expected = \" test string\\nto check the\\nwrap\\nfunctionality.\";\n        assertThat(WordUtils.wrap(input, 15, \"\\n\", false)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testWrapWithMatcherSizeChangeWithLongWords() {\n        // Test case to verify the change in matcherSize calculation with long words\n        final String input = \"Thisisaverylongwordthatneedstobewrappedproperly.\";\n        final String expected = \"Thisisaverylong\\nwordthatneedsto\\nbewrappedproper\\nly.\";\n        assertThat(WordUtils.wrap(input, 15, \"\\n\", true)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testWrapWithMatcherSizeChangeWithSpecialCharacters() {\n        // Test case to verify the change in matcherSize calculation with special characters\n        final String input = \"This is a test-string to check the wrap functionality.\";\n        final String expected = \"This is a\\ntest-string to\\ncheck the wrap\\nfunctionality.\";\n        assertThat(WordUtils.wrap(input, 15, \"\\n\", false, \"-\")).isEqualTo(expected);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\n\n/**\n * <p>\n * Operations on Strings that contain words.\n * </p>\n *\n * <p>\n * This class tries to handle {@code null} input gracefully. An exception will not be thrown for a\n * {@code null} input. Each method documents its behavior in more detail.\n * </p>\n *\n * @since 1.1\n */\npublic class WordUtils {\n\n    /**\n     * <p>{@code WordUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code WordUtils.wrap(\"foo bar\", 20);}.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public WordUtils() {\n    }\n\n    // Wrapping\n    //--------------------------------------------------------------------------\n    /**\n     * <p>Wraps a single line of text, identifying words by {@code ' '}.</p>\n     *\n     * <p>New lines will be separated by the system property line separator.\n     * Very long words, such as URLs will <i>not</i> be wrapped.</p>\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttps://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here, https://commons.apache.org, to jump to the commons website\"</td>\n     *   <td>20</td>\n     *   <td>\"Click here,\\nhttps://commons.apache.org,\\nto jump to the\\ncommons website\"</td>\n     *  </tr>\n     * </table>\n     *\n     * (assuming that '\\n' is the systems line separator)\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @return a line with newlines inserted, {@code null} if null input\n     */\n    public static String wrap(final String str, final int wrapLength) {\n        return wrap(str, wrapLength, null, false);\n    }\n\n    /**\n     * <p>Wraps a single line of text, identifying words by {@code ' '}.</p>\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>newLineString</th>\n     *   <th>wrapLongWords</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"&lt;br /&gt;\"</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of&lt;br /&gt;text that is going&lt;\n     *   br /&gt;to be wrapped after&lt;br /&gt;20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>null</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of\" + systemNewLine + \"text that is going\"\n     *   + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>false</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttps://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apach\\ne.org\"</td>\n     *  </tr>\n     * </table>\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line,\n     *  {@code null} uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @return a line with newlines inserted, {@code null} if null input\n     */\n    public static String wrap(final String str,\n                              final int wrapLength,\n                              final String newLineStr,\n                              final boolean wrapLongWords) {\n        return wrap(str, wrapLength, newLineStr, wrapLongWords, \" \");\n    }\n\n    /**\n     * <p>Wraps a single line of text, identifying words by {@code wrapOn}.</p>\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>newLineString</th>\n     *   <th>wrapLongWords</th>\n     *   <th>wrapOn</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>*</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>*</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"&lt;br /&gt;\"</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of&lt;br /&gt;text that is going&lt;br /&gt;\n     *   to be wrapped after&lt;br /&gt;20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>null</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of\" + systemNewLine + \"text that is going\"\n     *   + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttps://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - https://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\" \"</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apach\\ne.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"flammable/inflammable\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\"/\"</td>\n     *   <td>\"flammable\\ninflammable\"</td>\n     *  </tr>\n     * </table>\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line,\n     *  {@code null} uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @param wrapOn regex expression to be used as a breakable characters,\n     *               if blank string is provided a space character will be used\n     * @return a line with newlines inserted, {@code null} if null input\n     */\n    public static String wrap(final String str,\n                              int wrapLength,\n                              String newLineStr,\n                              final boolean wrapLongWords,\n                              String wrapOn) {\n        if (str == null) {\n            return null;\n        }\n        if (newLineStr == null) {\n            newLineStr = System.lineSeparator();\n        }\n        if (wrapLength < 1) {\n            wrapLength = 1;\n        }\n        if (StringUtils.isBlank(wrapOn)) {\n            wrapOn = \" \";\n        }\n        final Pattern patternToWrapOn = Pattern.compile(wrapOn);\n        final int inputLineLength = str.length();\n        int offset = 0;\n        final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n        int matcherSize = -1;\n\n        while (offset < inputLineLength) {\n            int spaceToWrapAt = -1;\n            Matcher matcher = patternToWrapOn.matcher(str.substring(offset,\n                    Math.min((int) Math.min(Integer.MAX_VALUE, offset + wrapLength + 1L), inputLineLength)));\n            if (matcher.find()) {\n                if (matcher.start() == 0) {\n                    matcherSize = matcher.end() - matcher.start();\n                    if (matcherSize != 0) {\n                        offset += matcher.end();\n                        continue;\n                    }\n                    offset += 1;\n                }\n                spaceToWrapAt = matcher.start() + offset;\n            }\n\n            // only last line without leading spaces is left\n            if (inputLineLength - offset <= wrapLength) {\n                break;\n            }\n\n            while (matcher.find()) {\n                spaceToWrapAt = matcher.start() + offset;\n            }\n\n            if (spaceToWrapAt >= offset) {\n                // normal case\n                wrappedLine.append(str, offset, spaceToWrapAt);\n                wrappedLine.append(newLineStr);\n                offset = spaceToWrapAt + 1;\n\n            } else {\n                // really long word or URL\n                if (wrapLongWords) {\n                    if (matcherSize == 0) {\n                        offset--;\n                    }\n                    // wrap really long word one line at a time\n                    wrappedLine.append(str, offset, wrapLength + offset);\n                    wrappedLine.append(newLineStr);\n                    offset += wrapLength;\n                    matcherSize = -1;\n                } else {\n                    // do not wrap really long word, just extend beyond limit\n                    matcher = patternToWrapOn.matcher(str.substring(offset + wrapLength));\n                    if (matcher.find()) {\n                        matcherSize = matcher.end() - matcher.start();\n                        spaceToWrapAt = matcher.start() + offset + wrapLength;\n                    }\n\n                    if (spaceToWrapAt >= 0) {\n                        if (matcherSize == 0 && offset != 0) {\n                            offset--;\n                        }\n                        wrappedLine.append(str, offset, spaceToWrapAt);\n                        wrappedLine.append(newLineStr);\n                        offset = spaceToWrapAt + 1;\n                    } else {\n                        if (matcherSize == 0 && offset != 0) {\n                            offset--;\n                        }\n                        wrappedLine.append(str, offset, str.length());\n                        offset = inputLineLength;\n                        matcherSize = -1;\n                    }\n                }\n            }\n        }\n\n        if (matcherSize == 0 && offset < inputLineLength) {\n            offset--;\n        }\n\n        // Whatever is left in line is short enough to just pass through\n        wrappedLine.append(str, offset, str.length());\n\n        return wrappedLine.toString();\n    }\n\n    // Capitalizing\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Capitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed. To convert the\n     * rest of each word to lowercase at the same time,\n     * use {@link #capitalizeFully(String)}.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null)        = null\n     * WordUtils.capitalize(\"\")          = \"\"\n     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, {@code null} if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str) {\n        return capitalize(str, null);\n    }\n\n    /**\n     * <p>Capitalizes all the delimiter separated words in a String.\n     * Only the first character of each word is changed. To convert the\n     * rest of each word to lowercase at the same time,\n     * use {@link #capitalizeFully(String, char[])}.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized.</p>\n     *\n     * <p>A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null, *)            = null\n     * WordUtils.capitalize(\"\", *)              = \"\"\n     * WordUtils.capitalize(*, new char[0])     = *\n     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n     * WordUtils.capitalize(\"i am fine\", new char[]{}) = \"I am fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, {@code null} if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n\n        boolean capitalizeNext = true;\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                capitalizeNext = true;\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            } else if (capitalizeNext) {\n                final int titleCaseCodePoint = Character.toTitleCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                capitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Converts all the whitespace separated words in a String into capitalized words,\n     * that is each word is made up of a titlecase character and then a series of\n     * lowercase characters.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null)        = null\n     * WordUtils.capitalizeFully(\"\")          = \"\"\n     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, {@code null} if null String input\n     */\n    public static String capitalizeFully(final String str) {\n        return capitalizeFully(str, null);\n    }\n\n    /**\n     * <p>Converts all the delimiter separated words in a String into capitalized words,\n     * that is each word is made up of a titlecase character and then a series of\n     * lowercase characters.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized.</p>\n     *\n     * <p>A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null, *)            = null\n     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n     * WordUtils.capitalizeFully(*, null)            = *\n     * WordUtils.capitalizeFully(*, new char[0])     = *\n     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, {@code null} if null String input\n     */\n    public static String capitalizeFully(String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        str = str.toLowerCase();\n        return capitalize(str, delimiters);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Uncapitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null)        = null\n     * WordUtils.uncapitalize(\"\")          = \"\"\n     * WordUtils.uncapitalize(\"I Am FINE\") = \"i am fINE\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @return uncapitalized String, {@code null} if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str) {\n        return uncapitalize(str, null);\n    }\n\n    /**\n     * <p>Uncapitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be uncapitalized.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null, *)            = null\n     * WordUtils.uncapitalize(\"\", *)              = \"\"\n     * WordUtils.uncapitalize(*, null)            = *\n     * WordUtils.uncapitalize(*, new char[0])     = *\n     * WordUtils.uncapitalize(\"I AM.FINE\", {'.'}) = \"i AM.fINE\"\n     * WordUtils.uncapitalize(\"I am fine\", new char[]{}) = \"i am fine\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @param delimiters  set of characters to determine uncapitalization, null means whitespace\n     * @return uncapitalized String, {@code null} if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n\n        boolean uncapitalizeNext = true;\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                uncapitalizeNext = true;\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            } else if (uncapitalizeNext) {\n                final int titleCaseCodePoint = Character.toLowerCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                uncapitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Swaps the case of a String using a word based algorithm.</p>\n     *\n     * <ul>\n     *  <li>Upper case character converts to Lower case</li>\n     *  <li>Title case character converts to Lower case</li>\n     *  <li>Lower case character after Whitespace or at start converts to Title case</li>\n     *  <li>Other Lower case character converts to Upper case</li>\n     * </ul>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * StringUtils.swapCase(null)                 = null\n     * StringUtils.swapCase(\"\")                   = \"\"\n     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n     * </pre>\n     *\n     * @param str  the String to swap case, may be null\n     * @return The changed String, {@code null} if null String input\n     */\n    public static String swapCase(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n        boolean whitespace = true;\n        for (int index = 0; index < strLen;) {\n            final int oldCodepoint = str.codePointAt(index);\n            final int newCodePoint;\n            if (Character.isUpperCase(oldCodepoint) || Character.isTitleCase(oldCodepoint)) {\n                newCodePoint = Character.toLowerCase(oldCodepoint);\n                whitespace = false;\n            } else if (Character.isLowerCase(oldCodepoint)) {\n                if (whitespace) {\n                    newCodePoint = Character.toTitleCase(oldCodepoint);\n                    whitespace = false;\n                } else {\n                    newCodePoint = Character.toUpperCase(oldCodepoint);\n                }\n            } else {\n                whitespace = Character.isWhitespace(oldCodepoint);\n                newCodePoint = oldCodepoint;\n            }\n            newCodePoints[outOffset++] = newCodePoint;\n            index += Character.charCount(newCodePoint);\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Extracts the initial characters from each word in the String.</p>\n     *\n     * <p>All first characters after whitespace are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null)             = null\n     * WordUtils.initials(\"\")               = \"\"\n     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @return String of initial letters, {@code null} if null String input\n     * @see #initials(String,char[])\n     */\n    public static String initials(final String str) {\n        return initials(str, null);\n    }\n\n    /**\n     * <p>Extracts the initial characters from each word in the String.</p>\n     *\n     * <p>All first characters after the defined delimiters are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>If the delimiters array is null, then Whitespace is used.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A {@code null} input String returns {@code null}.\n     * An empty delimiter array returns an empty String.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null, *)                = null\n     * WordUtils.initials(\"\", *)                  = \"\"\n     * WordUtils.initials(\"Ben John Lee\", null)   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\", null)      = \"BJ\"\n     * WordUtils.initials(\"Ben J.Lee\", [' ','.']) = \"BJL\"\n     * WordUtils.initials(*, new char[0])         = \"\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @param delimiters  set of characters to determine words, null means whitespace\n     * @return String of initial characters, {@code null} if null String input\n     * @see #initials(String)\n     */\n    public static String initials(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (delimiters != null && delimiters.length == 0) {\n            return StringUtils.EMPTY;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen / 2 + 1];\n        int count = 0;\n        boolean lastWasGap = true;\n        for (int i = 0; i < strLen;) {\n            final int codePoint = str.codePointAt(i);\n\n            if (delimiterSet.contains(codePoint) || (delimiters == null && Character.isWhitespace(codePoint))) {\n                lastWasGap = true;\n            } else if (lastWasGap) {\n                newCodePoints[count++] = codePoint;\n                lastWasGap = false;\n            }\n\n            i += Character.charCount(codePoint);\n        }\n        return new String(newCodePoints, 0, count);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if the String contains all words in the given array.</p>\n     *\n     * <p>\n     * A {@code null} String will return {@code false}. A {@code null}, zero\n     * length search array or if one element of array is null will return {@code false}.\n     * </p>\n     *\n     * <pre>\n     * WordUtils.containsAllWords(null, *)            = false\n     * WordUtils.containsAllWords(\"\", *)              = false\n     * WordUtils.containsAllWords(*, null)            = false\n     * WordUtils.containsAllWords(*, [])              = false\n     * WordUtils.containsAllWords(\"abcd\", \"ab\", \"cd\") = false\n     * WordUtils.containsAllWords(\"abc def\", \"def\", \"abc\") = true\n     * </pre>\n     *\n     * @param word The CharSequence to check, may be null\n     * @param words The array of String words to search for, may be null\n     * @return {@code true} if all search words are found, {@code false} otherwise\n     */\n    public static boolean containsAllWords(final CharSequence word, final CharSequence... words) {\n        if (StringUtils.isEmpty(word) || ArrayUtils.isEmpty(words)) {\n            return false;\n        }\n        for (final CharSequence w : words) {\n            if (StringUtils.isBlank(w)) {\n                return false;\n            }\n            final Pattern p = Pattern.compile(\".*\\\\b\" + w + \"\\\\b.*\");\n            if (!p.matcher(word).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Is the character a delimiter.\n     *\n     * @param ch the character to check\n     * @param delimiters the delimiters\n     * @return true if it is a delimiter\n     * @deprecated as of 1.2 and will be removed in 2.0\n     */\n    @Deprecated\n    public static boolean isDelimiter(final char ch, final char[] delimiters) {\n        if (delimiters == null) {\n            return Character.isWhitespace(ch);\n        }\n        for (final char delimiter : delimiters) {\n            if (ch == delimiter) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n  //-----------------------------------------------------------------------\n    /**\n     * Is the codePoint a delimiter.\n     *\n     * @param codePoint the codePint to check\n     * @param delimiters the delimiters\n     * @return true if it is a delimiter\n     * @deprecated as of 1.2 and will be removed in 2.0\n     */\n    @Deprecated\n    public static boolean isDelimiter(final int codePoint, final char[] delimiters) {\n        if (delimiters == null) {\n            return Character.isWhitespace(codePoint);\n        }\n        for (int index = 0; index < delimiters.length; index++) {\n            final int delimiterCodePoint = Character.codePointAt(delimiters, index);\n            if (delimiterCodePoint == codePoint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Abbreviates the words nicely.\n     *\n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     *\n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit; negative value is treated as zero.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return The abbreviated String.\n     *\n     * <pre>\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, null));     = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, null));    = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, null));    = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, \"\"));       = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, \"\"));      = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, \"\"));      = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, \" ...\"));   = \"Now ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, \" ...\"));  = \"Now is the ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, \" ...\"));  = \"Now is the time for all ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, -1, \"\"));       = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, -1, \"\"));      = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, -1, \"\"));      = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 50, -1, \"\"));      = \"Now is the time for all good men\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 1000, -1, \"\"));    = \"Now is the time for all good men\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 9, -10, null));    = IllegalArgumentException\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 5, null));     = IllegalArgumentException\n     * </pre>\n     */\n    public static String abbreviate(final String str, int lower, int upper, final String appendToEnd) {\n        Validate.isTrue(upper >= -1, \"upper value cannot be less than -1\");\n        Validate.isTrue(upper >= lower || upper == -1, \"upper value is less than lower value\");\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        if (lower > str.length()) {\n            lower = str.length();\n        }\n\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n\n        final StringBuilder result = new StringBuilder();\n        final int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str, 0, upper);\n            // only if abbreviation has occurred do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str, 0, upper);\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str, 0, index);\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n\n        return result.toString();\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * <p>\n     * Converts an array of delimiters to a hash set of code points. Code point of space(32) is added as the default\n     * value if delimiters is null. The generated hash set provides O(1) lookup time.\n     * </p>\n     *\n     * @param delimiters set of characters to determine capitalization, null means whitespace\n     * @return Set<Integer>\n     */\n    private static Set<Integer> generateDelimiterSet(final char[] delimiters) {\n        final Set<Integer> delimiterHashSet = new HashSet<>();\n        if (delimiters == null || delimiters.length == 0) {\n            if (delimiters == null) {\n                delimiterHashSet.add(Character.codePointAt(new char[] {' '}, 0));\n            }\n\n            return delimiterHashSet;\n        }\n\n        for (int index = 0; index < delimiters.length; index++) {\n            delimiterHashSet.add(Character.codePointAt(delimiters, index));\n        }\n        return delimiterHashSet;\n    }\n }",
        "diff": " a/src/main/java/org/apache/commons/text/WordUtils.java b/src/main/java/org/apache/commons/text/WordUtils.java\nindex 76306968b6..dd4b448129 100644\n--- a/src/main/java/org/apache/commons/text/WordUtils.java\n+++ b/src/main/java/org/apache/commons/text/WordUtils.java\n@@ -308,7 +308,7 @@ public static String wrap(final String str,\n                     Math.min((int) Math.min(Integer.MAX_VALUE, offset + wrapLength + 1L), inputLineLength)));\n             if (matcher.find()) {\n                 if (matcher.start() == 0) {\n-                    matcherSize = matcher.end() - matcher.start();\n+                    matcherSize = matcher.end();\n                     if (matcherSize != 0) {\n                         offset += matcher.end();\n                         continue;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class InterpolatorStringLookupTest2 {\n\n    @Test\n    public void testConstructorWithNullDefaultMap() {\n        // Test the constructor with a null default map\n        InterpolatorStringLookup lookup = new InterpolatorStringLookup((Map<String, Object>) null);\n        String value = lookup.lookup(\"anyKey\");\n        assertNull(value);\n    }\n\n    @Test\n    public void testConstructorWithEmptyDefaultMap() {\n        // Test the constructor with an empty default map\n        Map<String, Object> emptyMap = new HashMap<>();\n        InterpolatorStringLookup lookup = new InterpolatorStringLookup(emptyMap);\n        String value = lookup.lookup(\"anyKey\");\n        assertNull(value);\n    }\n\n    @Test\n    public void testConstructorWithNonEmptyDefaultMap() {\n        // Test the constructor with a non-empty default map\n        Map<String, Object> defaultMap = new HashMap<>();\n        defaultMap.put(\"key1\", \"value1\");\n        InterpolatorStringLookup lookup = new InterpolatorStringLookup(defaultMap);\n        String value = lookup.lookup(\"key1\");\n        assertEquals(\"value1\", value);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\npackage org.apache.commons.text.lookup;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * Proxies other {@link StringLookup}s using a keys within ${} markers using the format \"${StringLookup:Key}\".\n * <p>\n * Uses the {@link StringLookupFactory default lookups}.\n * </p>\n */\nclass InterpolatorStringLookup extends AbstractStringLookup {\n\n    /**\n     * Defines the singleton for this class.\n     *\n     * @since 1.6\n     */\n    static final AbstractStringLookup INSTANCE = new InterpolatorStringLookup();\n\n    /** Constant for the prefix separator. */\n    private static final char PREFIX_SEPARATOR = ':';\n\n    static String toKey(final String key) {\n        return key.toLowerCase(Locale.ROOT);\n    }\n\n    /** The default string lookup. */\n    private final StringLookup defaultStringLookup;\n\n    /** The map of String lookups keyed by prefix. */\n    private final Map<String, StringLookup> stringLookupMap;\n\n    /**\n     * Creates an instance using only lookups that work without initial properties and are stateless.\n     * <p>\n     * Uses the {@link StringLookupFactory default lookups}.\n     * </p>\n     */\n    InterpolatorStringLookup() {\n        this((Map<String, String>) null);\n    }\n\n    /**\n     * Creates a fully customized instance.\n     *\n     * @param stringLookupMap the map of string lookups.\n     * @param defaultStringLookup the default string lookup.\n     * @param addDefaultLookups whether the default lookups should be used.\n     */\n    InterpolatorStringLookup(final Map<String, StringLookup> stringLookupMap, final StringLookup defaultStringLookup,\n        final boolean addDefaultLookups) {\n        this.defaultStringLookup = defaultStringLookup;\n        this.stringLookupMap = new HashMap<>(stringLookupMap.size());\n        for (final Entry<String, StringLookup> entry : stringLookupMap.entrySet()) {\n            this.stringLookupMap.put(toKey(entry.getKey()), entry.getValue());\n        }\n        if (addDefaultLookups) {\n            StringLookupFactory.INSTANCE.addDefaultStringLookups(this.stringLookupMap);\n        }\n    }\n\n    /**\n     * Creates an instance using only lookups that work without initial properties and are stateless.\n     * <p>\n     * Uses the {@link StringLookupFactory default lookups}.\n     * </p>\n     *\n     * @param <V> the map's value type.\n     * @param defaultMap the default map for string lookups.\n     */\n    <V> InterpolatorStringLookup(final Map<String, V> defaultMap) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(defaultMap == null ? new HashMap<String, V>() : defaultMap));\n    }\n\n    /**\n     * Creates an instance with the given lookup.\n     *\n     * @param defaultStringLookup the default lookup.\n     */\n    InterpolatorStringLookup(final StringLookup defaultStringLookup) {\n        this(new HashMap<>(), defaultStringLookup, true);\n    }\n\n    /**\n     * Gets the lookup map.\n     *\n     * @return The lookup map.\n     */\n    public Map<String, StringLookup> getStringLookupMap() {\n        return stringLookupMap;\n    }\n\n    /**\n     * Resolves the specified variable. This implementation will try to extract a variable prefix from the given\n     * variable name (the first colon (':') is used as prefix separator). It then passes the name of the variable with\n     * the prefix stripped to the lookup object registered for this prefix. If no prefix can be found or if the\n     * associated lookup object cannot resolve this variable, the default lookup object will be used.\n     *\n     * @param key the name of the variable whose value is to be looked up\n     * @return The value of this variable or <b>null</b> if it cannot be resolved\n     */\n    @Override\n    public String lookup(String key) {\n        if (key == null) {\n            return null;\n        }\n\n        final int prefixPos = key.indexOf(PREFIX_SEPARATOR);\n        if (prefixPos >= 0) {\n            final String prefix = toKey(key.substring(0, prefixPos));\n            final String name = key.substring(prefixPos + 1);\n            final StringLookup lookup = stringLookupMap.get(prefix);\n            String value = null;\n            if (lookup != null) {\n                value = lookup.lookup(name);\n            }\n\n            if (value != null) {\n                return value;\n            }\n            key = key.substring(prefixPos + 1);\n        }\n        if (defaultStringLookup != null) {\n            return defaultStringLookup.lookup(key);\n        }\n        return null;\n    }\n\n    @Override\n    public String toString() {\n        return super.toString() + \" [stringLookupMap=\" + stringLookupMap + \", defaultStringLookup=\"\n            + defaultStringLookup + \"]\";\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java b/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java\nindex 476ea1461e..9b88d80586 100644\n--- a/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java\n@@ -88,7 +88,7 @@ static String toKey(final String key) {\n      * @param defaultMap the default map for string lookups.\n      */\n     <V> InterpolatorStringLookup(final Map<String, V> defaultMap) {\n-        this(StringLookupFactory.INSTANCE.mapStringLookup(defaultMap == null ? new HashMap<String, V>() : defaultMap));\n+        this(StringLookupFactory.INSTANCE.mapStringLookup(defaultMap == null ? new HashMap<>() : defaultMap));\n     }\n \n     /**\n"
      }
    ]
  },
  {
    "pr_number": 239,
    "title": "Remove use of restricted identifier",
    "state": "closed",
    "created_at": "2021-06-14T18:05:16Z",
    "merge_commit_sha": "38eb80048863b58135783040072696c31537afd3",
    "base_sha": "0065576125d2e25055ee33b8681a903f48cab55a",
    "head_sha": "6967b34de5857ce6aca70f260300749865f75e67",
    "user_login": "fykidwai",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport org.junit.jupiter.api.Test;\n\npublic class InterpolatorStringLookupTest2 {\n\n    @Test\n    public void testLookupWithKey() {\n        final Map<String, String> map = new HashMap<>();\n        map.put(\"testKey\", \"testValue\");\n        final StringLookup lookup = new InterpolatorStringLookup(StringLookupFactory.INSTANCE.mapStringLookup(map));\n        \n        // Test with key containing prefix separator\n        String value = lookup.lookup(\"ctx:testKey\");\n        assertEquals(\"testValue\", value);\n        \n        // Test with key without prefix separator\n        value = lookup.lookup(\"testKey\");\n        assertEquals(\"testValue\", value);\n        \n        // Test with key that does not exist\n        value = lookup.lookup(\"nonExistentKey\");\n        assertNull(value);\n    }\n\n    @Test\n    public void testLookupWithNullKey() {\n        final StringLookup lookup = new InterpolatorStringLookup();\n        \n        // Test with null key\n        String value = lookup.lookup(null);\n        assertNull(value);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\npackage org.apache.commons.text.lookup;\n\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * Proxies other {@link StringLookup}s using a keys within ${} markers using the format \"${StringLookup:Key}\".\n * <p>\n * Uses the {@link StringLookupFactory default lookups}.\n * </p>\n */\nclass InterpolatorStringLookup extends AbstractStringLookup {\n\n    /**\n     * Defines the singleton for this class.\n     *\n     * @since 1.6\n     */\n    static final AbstractStringLookup INSTANCE = new InterpolatorStringLookup();\n\n    /** Constant for the prefix separator. */\n    private static final char PREFIX_SEPARATOR = ':';\n\n    static String toKey(final String key) {\n        return key.toLowerCase(Locale.ROOT);\n    }\n\n    /** The default string lookup. */\n    private final StringLookup defaultStringLookup;\n\n    /** The map of String lookups keyed by prefix. */\n    private final Map<String, StringLookup> stringLookupMap;\n\n    /**\n     * Creates an instance using only lookups that work without initial properties and are stateless.\n     * <p>\n     * Uses the {@link StringLookupFactory default lookups}.\n     * </p>\n     */\n    InterpolatorStringLookup() {\n        this((Map<String, String>) null);\n    }\n\n    /**\n     * Creates a fully customized instance.\n     *\n     * @param stringLookupMap the map of string lookups.\n     * @param defaultStringLookup the default string lookup.\n     * @param addDefaultLookups whether the default lookups should be used.\n     */\n    InterpolatorStringLookup(final Map<String, StringLookup> stringLookupMap, final StringLookup defaultStringLookup,\n        final boolean addDefaultLookups) {\n        this.defaultStringLookup = defaultStringLookup;\n        this.stringLookupMap = new HashMap<>(stringLookupMap.size());\n        for (final Entry<String, StringLookup> entry : stringLookupMap.entrySet()) {\n            this.stringLookupMap.put(toKey(entry.getKey()), entry.getValue());\n        }\n        if (addDefaultLookups) {\n            StringLookupFactory.INSTANCE.addDefaultStringLookups(this.stringLookupMap);\n        }\n    }\n\n    /**\n     * Creates an instance using only lookups that work without initial properties and are stateless.\n     * <p>\n     * Uses the {@link StringLookupFactory default lookups}.\n     * </p>\n     *\n     * @param <V> the map's value type.\n     * @param defaultMap the default map for string lookups.\n     */\n    <V> InterpolatorStringLookup(final Map<String, V> defaultMap) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(defaultMap == null ? new HashMap<String, V>() : defaultMap));\n    }\n\n    /**\n     * Creates an instance with the given lookup.\n     *\n     * @param defaultStringLookup the default lookup.\n     */\n    InterpolatorStringLookup(final StringLookup defaultStringLookup) {\n        this(new HashMap<>(), defaultStringLookup, true);\n    }\n\n    /**\n     * Gets the lookup map.\n     *\n     * @return The lookup map.\n     */\n    public Map<String, StringLookup> getStringLookupMap() {\n        return stringLookupMap;\n    }\n\n    /**\n     * Resolves the specified variable. This implementation will try to extract a variable prefix from the given\n     * variable name (the first colon (':') is used as prefix separator). It then passes the name of the variable with\n     * the prefix stripped to the lookup object registered for this prefix. If no prefix can be found or if the\n     * associated lookup object cannot resolve this variable, the default lookup object will be used.\n     *\n     * @param var the name of the variable whose value is to be looked up\n     * @return The value of this variable or <b>null</b> if it cannot be resolved\n     */\n    @Override\n    public String lookup(String var) {\n        if (var == null) {\n            return null;\n        }\n\n        final int prefixPos = var.indexOf(PREFIX_SEPARATOR);\n        if (prefixPos >= 0) {\n            final String prefix = toKey(var.substring(0, prefixPos));\n            final String name = var.substring(prefixPos + 1);\n            final StringLookup lookup = stringLookupMap.get(prefix);\n            String value = null;\n            if (lookup != null) {\n                value = lookup.lookup(name);\n            }\n\n            if (value != null) {\n                return value;\n            }\n            var = var.substring(prefixPos + 1);\n        }\n        if (defaultStringLookup != null) {\n            return defaultStringLookup.lookup(var);\n        }\n        return null;\n    }\n\n    @Override\n    public String toString() {\n        return super.toString() + \" [stringLookupMap=\" + stringLookupMap + \", defaultStringLookup=\"\n            + defaultStringLookup + \"]\";\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java b/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java\nindex 3e02f6048e..476ea1461e 100644\n--- a/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java\n@@ -115,19 +115,19 @@ public Map<String, StringLookup> getStringLookupMap() {\n      * the prefix stripped to the lookup object registered for this prefix. If no prefix can be found or if the\n      * associated lookup object cannot resolve this variable, the default lookup object will be used.\n      *\n-     * @param var the name of the variable whose value is to be looked up\n+     * @param key the name of the variable whose value is to be looked up\n      * @return The value of this variable or <b>null</b> if it cannot be resolved\n      */\n     @Override\n-    public String lookup(String var) {\n-        if (var == null) {\n+    public String lookup(String key) {\n+        if (key == null) {\n             return null;\n         }\n \n-        final int prefixPos = var.indexOf(PREFIX_SEPARATOR);\n+        final int prefixPos = key.indexOf(PREFIX_SEPARATOR);\n         if (prefixPos >= 0) {\n-            final String prefix = toKey(var.substring(0, prefixPos));\n-            final String name = var.substring(prefixPos + 1);\n+            final String prefix = toKey(key.substring(0, prefixPos));\n+            final String name = key.substring(prefixPos + 1);\n             final StringLookup lookup = stringLookupMap.get(prefix);\n             String value = null;\n             if (lookup != null) {\n@@ -137,10 +137,10 @@ public String lookup(String var) {\n             if (value != null) {\n                 return value;\n             }\n-            var = var.substring(prefixPos + 1);\n+            key = key.substring(prefixPos + 1);\n         }\n         if (defaultStringLookup != null) {\n-            return defaultStringLookup.lookup(var);\n+            return defaultStringLookup.lookup(key);\n         }\n         return null;\n     }\n"
      }
    ]
  },
  {
    "pr_number": 214,
    "title": "[TEXT-191] Fixed JaroWinklerDistance returns the same values as JaroWinklerSimilarity",
    "state": "closed",
    "created_at": "2021-04-08T12:25:51Z",
    "merge_commit_sha": "96080b3c25c97fe5731fd0e9de972e03a23f66d2",
    "base_sha": "7afa58a3c873e2f1c6b8ca225fe8ca7f8698d155",
    "head_sha": "380cbb0e1e54e229c69f86d810ea354a8271882b",
    "user_login": "bradleyrumball",
    "changed_files": [
      {
        "filename": "src/changes/changes.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class JaroWinklerDistanceTest2 {\n\n    private static JaroWinklerDistance distance;\n\n    @BeforeAll\n    public static void setUp() {\n        distance = new JaroWinklerDistance();\n    }\n\n    /**\n     * Test to verify the new implementation using JaroWinklerSimilarity.\n     */\n    @Test\n    public void testGetJaroWinklerDistance_NewImplementation() {\n        assertEquals(0.07501d, distance.apply(\"frog\", \"fog\"), 0.00001d);\n        assertEquals(1.0d, distance.apply(\"fly\", \"ant\"), 0.00000000000000000001d);\n        assertEquals(0.55834d, distance.apply(\"elephant\", \"hippo\"), 0.00001d);\n        assertEquals(0.09334d, distance.apply(\"ABC Corporation\", \"ABC Corp\"), 0.00001d);\n        assertEquals(0.04749d, distance.apply(\"D N H Enterprises Inc\", \"D & H Enterprises, Inc.\"), 0.00001d);\n        assertEquals(0.058d, distance.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\"), 0.00001d);\n        assertEquals(0.101982d, distance.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\"), 0.00001d);\n        assertEquals(0.028572d, distance.apply(\"/opt/software1\", \"/opt/software2\"), 0.00001d);\n        assertEquals(0.058334d, distance.apply(\"aaabcd\", \"aaacdb\"), 0.00001d);\n        assertEquals(0.088889d, distance.apply(\"John Horn\", \"John Hopkins\"), 0.00001d);\n    }\n\n    /**\n     * Test to verify IllegalArgumentException is thrown for null inputs.\n     */\n    @Test\n    public void testGetJaroWinklerDistance_NullInputs() {\n        assertThatIllegalArgumentException().isThrownBy(() -> {\n            distance.apply(null, null);\n        });\n        assertThatIllegalArgumentException().isThrownBy(() -> {\n            distance.apply(\" \", null);\n        });\n        assertThatIllegalArgumentException().isThrownBy(() -> {\n            distance.apply(null, \"clear\");\n        });\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.Arrays;\n\n/**\n * Measures the Jaro-Winkler distance of two character sequences.\n * It is the complementary of Jaro-Winkler similarity.\n *\n * @since 1.0\n */\npublic class JaroWinklerDistance implements EditDistance<Double> {\n\n    /**\n     * @deprecated Deprecated as of 1.7. This constant will be removed in 2.0.\n     */\n    @Deprecated\n    public static final int INDEX_NOT_FOUND = -1;\n\n    /**\n     * Computes the Jaro Winkler Distance between two character sequences.\n     *\n     * <pre>\n     * distance.apply(null, null)          = IllegalArgumentException\n     * distance.apply(\"foo\", null)         = IllegalArgumentException\n     * distance.apply(null, \"foo\")         = IllegalArgumentException\n     * distance.apply(\"\", \"\")              = 0.0\n     * distance.apply(\"foo\", \"foo\")        = 0.0\n     * distance.apply(\"foo\", \"foo \")       = 0.06\n     * distance.apply(\"foo\", \"foo  \")      = 0.09\n     * distance.apply(\"foo\", \" foo \")      = 0.13\n     * distance.apply(\"foo\", \"  foo\")      = 0.49\n     * distance.apply(\"\", \"a\")             = 1.0\n     * distance.apply(\"aaapppp\", \"\")       = 1.0\n     * distance.apply(\"frog\", \"fog\")       = 0.07\n     * distance.apply(\"fly\", \"ant\")        = 1.0\n     * distance.apply(\"elephant\", \"hippo\") = 0.56\n     * distance.apply(\"hippo\", \"elephant\") = 0.56\n     * distance.apply(\"hippo\", \"zzzzzzzz\") = 1.0\n     * distance.apply(\"hello\", \"hallo\")    = 0.12\n     * distance.apply(\"ABC Corporation\", \"ABC Corp\") = 0.09\n     * distance.apply(\"D N H Enterprises Inc\", \"D &amp; H Enterprises, Inc.\") = 0.05\n     * distance.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\") = 0.08\n     * distance.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\") = 0.12\n     * </pre>\n     *\n     * @param left the first CharSequence, must not be null\n     * @param right the second CharSequence, must not be null\n     * @return result distance\n     * @throws IllegalArgumentException if either CharSequence input is {@code null}\n     */\n    @Override\n    public Double apply(final CharSequence left, final CharSequence right) {\n\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n\n        // TODO: replace the rest of the code by this in 2.0, see TEXT-104\n        //\n        // JaroWinklerSimilarity similarity = new JaroWinklerSimilarity();\n        // return 1 - similarity.apply(left, right);\n\n        final double defaultScalingFactor = 0.1;\n        final int[] mtp = matches(left, right);\n        final double m = mtp[0];\n        if (m == 0) {\n            return 0D;\n        }\n        final double j = ((m / left.length() + m / right.length() + (m - (double) mtp[1] / 2) / m)) / 3;\n        final double jw = j < 0.7D ? j : j + defaultScalingFactor * mtp[2] * (1D - j);\n        return jw;\n    }\n\n    // TODO: remove this method in 2.0, see TEXT-104\n    /**\n     * This method returns the Jaro-Winkler string matches, half transpositions, prefix array.\n     *\n     * @param first the first string to be matched\n     * @param second the second string to be matched\n     * @return mtp array containing: matches, half transpositions, and prefix\n     * @deprecated Deprecated as of 1.7. This method will be removed in 2.0, and moved to a Jaro Winkler similarity\n     *             class.\n     */\n    @Deprecated\n    protected static int[] matches(final CharSequence first, final CharSequence second) {\n        final CharSequence max;\n        final CharSequence min;\n        if (first.length() > second.length()) {\n            max = first;\n            min = second;\n        } else {\n            max = second;\n            min = first;\n        }\n        final int range = Math.max(max.length() / 2 - 1, 0);\n        final int[] matchIndexes = new int[min.length()];\n        Arrays.fill(matchIndexes, -1);\n        final boolean[] matchFlags = new boolean[max.length()];\n        int matches = 0;\n        for (int mi = 0; mi < min.length(); mi++) {\n            final char c1 = min.charAt(mi);\n            for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max.length()); xi < xn; xi++) {\n                if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n                    matchIndexes[mi] = xi;\n                    matchFlags[xi] = true;\n                    matches++;\n                    break;\n                }\n            }\n        }\n        final char[] ms1 = new char[matches];\n        final char[] ms2 = new char[matches];\n        for (int i = 0, si = 0; i < min.length(); i++) {\n            if (matchIndexes[i] != -1) {\n                ms1[si] = min.charAt(i);\n                si++;\n            }\n        }\n        for (int i = 0, si = 0; i < max.length(); i++) {\n            if (matchFlags[i]) {\n                ms2[si] = max.charAt(i);\n                si++;\n            }\n        }\n        int halfTranspositions = 0;\n        for (int mi = 0; mi < ms1.length; mi++) {\n            if (ms1[mi] != ms2[mi]) {\n                halfTranspositions++;\n            }\n        }\n        int prefix = 0;\n        for (int mi = 0; mi < Math.min(4, min.length()); mi++) {\n            if (first.charAt(mi) != second.charAt(mi)) {\n                break;\n            }\n            prefix++;\n        }\n        return new int[] {matches, halfTranspositions, prefix};\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java b/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\nindex d5f0a56891..ef6619f5af 100644\n--- a/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\n+++ b/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\n@@ -32,6 +32,11 @@ public class JaroWinklerDistance implements EditDistance<Double> {\n     @Deprecated\n     public static final int INDEX_NOT_FOUND = -1;\n \n+    /**\n+     * Jaro Winkler similarity object used to calculate the distance (1 - similarity).\n+     */\n+    private final JaroWinklerSimilarity similarity = new JaroWinklerSimilarity();\n+\n     /**\n      * Computes the Jaro Winkler Distance between two character sequences.\n      *\n@@ -71,20 +76,7 @@ public Double apply(final CharSequence left, final CharSequence right) {\n             throw new IllegalArgumentException(\"CharSequences must not be null\");\n         }\n \n-        // TODO: replace the rest of the code by this in 2.0, see TEXT-104\n-        //\n-        // JaroWinklerSimilarity similarity = new JaroWinklerSimilarity();\n-        // return 1 - similarity.apply(left, right);\n-\n-        final double defaultScalingFactor = 0.1;\n-        final int[] mtp = matches(left, right);\n-        final double m = mtp[0];\n-        if (m == 0) {\n-            return 0D;\n-        }\n-        final double j = ((m / left.length() + m / right.length() + (m - (double) mtp[1] / 2) / m)) / 3;\n-        final double jw = j < 0.7D ? j : j + defaultScalingFactor * mtp[2] * (1D - j);\n-        return jw;\n+        return 1 - similarity.apply(left, right);\n     }\n \n     // TODO: remove this method in 2.0, see TEXT-104\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/similarity/JaroWinklerDistanceTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 196,
    "title": "Minor Improvements",
    "state": "closed",
    "created_at": "2021-01-17T12:05:28Z",
    "merge_commit_sha": "29b60f5788d8a7bc51ed195634063cf7e02c9ff0",
    "base_sha": "f0f6347040618a04c6b9bc4351dd8dff84b178be",
    "head_sha": "1cab6c0552de36ce5176c2feb139094a451d0fa6",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/StrSubstitutor.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\npublic class StrSubstitutorTest2 {\n\n    @Test\n    public void testPreserveEscapesDefault() {\n        // Test that the default value of preserveEscapes is false\n        StrSubstitutor sub = new StrSubstitutor();\n        assertFalse(sub.isPreserveEscapes());\n    }\n\n    @Test\n    public void testSetPreserveEscapes() {\n        // Test setting the preserveEscapes flag\n        StrSubstitutor sub = new StrSubstitutor();\n        sub.setPreserveEscapes(true);\n        assertTrue(sub.isPreserveEscapes());\n        sub.setPreserveEscapes(false);\n        assertFalse(sub.isPreserveEscapes());\n    }\n\n    @Test\n    public void testPreserveEscapesFunctionality() {\n        // Test the functionality of preserveEscapes flag\n        Map<String, String> values = new HashMap<>();\n        values.put(\"animal\", \"fox\");\n        StrSubstitutor sub = new StrSubstitutor(values, \"${\", \"}\", '$');\n        \n        // When preserveEscapes is false\n        sub.setPreserveEscapes(false);\n        assertEquals(\"The ${animal} jumps over the lazy dog.\", sub.replace(\"The $${animal} jumps over the lazy dog.\"));\n        \n        // When preserveEscapes is true\n        sub.setPreserveEscapes(true);\n        assertEquals(\"The $${animal} jumps over the lazy dog.\", sub.replace(\"The $${animal} jumps over the lazy dog.\"));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.lang3.Validate;\n\n/**\n * Substitutes variables within a string by values.\n * <p>\n * This class takes a piece of text and substitutes all the variables within it.\n * The default definition of a variable is {@code ${variableName}}.\n * The prefix and suffix can be changed via constructors and set methods.\n * <p>\n * Variable values are typically resolved from a map, but could also be resolved\n * from system properties, or by supplying a custom variable resolver.\n * <p>\n * The simplest example is to use this class to replace Java System properties. For example:\n * <pre>\n * StrSubstitutor.replaceSystemProperties(\n *      \"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n * </pre>\n * <p>\n * Typical usage of this class follows the following pattern: First an instance is created\n * and initialized with the map that contains the values for the available variables.\n * If a prefix and/or suffix for variables should be used other than the default ones,\n * the appropriate settings can be performed. After that the {@code replace()}\n * method can be called passing in the source text for interpolation. In the returned\n * text all variable references (as long as their values are known) will be resolved.\n * The following example demonstrates this:\n * <pre>\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n * String resolvedString = sub.replace(templateString);\n * </pre>\n * yielding:\n * <pre>\n *      The quick brown fox jumped over the lazy dog.\n * </pre>\n * <p>\n * Also, this class allows to set a default value for unresolved variables.\n * The default value for a variable can be appended to the variable name after the variable\n * default value delimiter. The default value of the variable default value delimiter is ':-',\n * as in bash and other *nix shells, as those are arguably where the default ${} delimiter set originated.\n * The variable default value delimiter can be manually set by calling {@link #setValueDelimiterMatcher(StrMatcher)},\n * {@link #setValueDelimiter(char)} or {@link #setValueDelimiter(String)}.\n * The following shows an example with variable default value settings:\n * <pre>\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target}. ${undefined.number:-1234567890}.&quot;;\n * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n * String resolvedString = sub.replace(templateString);\n * </pre>\n * yielding:\n * <pre>\n *      The quick brown fox jumped over the lazy dog. 1234567890.\n * </pre>\n * <p>\n * In addition to this usage pattern there are some static convenience methods that\n * cover the most common use cases. These methods can be used without the need of\n * manually creating an instance. However if multiple replace operations are to be\n * performed, creating and reusing an instance of this class will be more efficient.\n * <p>\n * Variable replacement works in a recursive way. Thus, if a variable value contains\n * a variable then that variable will also be replaced. Cyclic replacements are\n * detected and will cause an exception to be thrown.\n * <p>\n * Sometimes the interpolation's result must contain a variable prefix. As an example\n * take the following source text:\n * <pre>\n *   The variable ${${name}} must be used.\n * </pre>\n * Here only the variable's name referred to in the text should be replaced resulting\n * in the text (assuming that the value of the {@code name} variable is {@code x}):\n * <pre>\n *   The variable ${x} must be used.\n * </pre>\n * To achieve this effect there are two possibilities: Either set a different prefix\n * and suffix for variables which do not conflict with the result text you want to\n * produce. The other possibility is to use the escape character, by default '$'.\n * If this character is placed before a variable reference, this reference is ignored\n * and won't be replaced. For example:\n * <pre>\n *   The variable $${${name}} must be used.\n * </pre>\n * <p>\n * In some complex scenarios you might even want to perform substitution in the\n * names of variables, for instance\n * <pre>\n * ${jre-${java.specification.version}}\n * </pre>\n * {@code StrSubstitutor} supports this recursive substitution in variable\n * names, but it has to be enabled explicitly by setting the\n * {@link #setEnableSubstitutionInVariables(boolean) enableSubstitutionInVariables}\n * property to <b>true</b>.\n * <p>This class is <b>not</b> thread safe.</p>\n *\n * @since 1.0\n * @deprecated Deprecated as of 1.3, use {@link StringSubstitutor} instead. This class will be removed in 2.0.\n */\n@Deprecated\npublic class StrSubstitutor {\n\n    /**\n     * Constant for the default escape character.\n     */\n    public static final char DEFAULT_ESCAPE = '$';\n\n    /**\n     * Constant for the default variable prefix.\n     */\n    public static final StrMatcher DEFAULT_PREFIX = StrMatcher.stringMatcher(\"${\");\n\n    /**\n     * Constant for the default variable suffix.\n     */\n    public static final StrMatcher DEFAULT_SUFFIX = StrMatcher.stringMatcher(\"}\");\n\n    /**\n     * Constant for the default value delimiter of a variable.\n     */\n    public static final StrMatcher DEFAULT_VALUE_DELIMITER = StrMatcher.stringMatcher(\":-\");\n\n    /**\n     * Stores the escape character.\n     */\n    private char escapeChar;\n\n    /**\n     * Stores the variable prefix.\n     */\n    private StrMatcher prefixMatcher;\n\n    /**\n     * Stores the variable suffix.\n     */\n    private StrMatcher suffixMatcher;\n\n    /**\n     * Stores the default variable value delimiter.\n     */\n    private StrMatcher valueDelimiterMatcher;\n\n    /**\n     * Variable resolution is delegated to an implementor of VariableResolver.\n     */\n    private StrLookup<?> variableResolver;\n\n    /**\n     * The flag whether substitution in variable names is enabled.\n     */\n    private boolean enableSubstitutionInVariables;\n\n    /**\n     * Whether escapes should be preserved.  Default is false;\n     */\n    private boolean preserveEscapes = false;\n\n    /**\n     * The flag whether substitution in variable values is disabled.\n     */\n    private boolean disableSubstitutionInValues;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables in the given source object with\n     * their matching values from the map.\n     *\n     * @param <V> the type of the values in the map\n     * @param source  the source text containing the variables to substitute, null returns null\n     * @param valueMap  the map with the values, may be null\n     * @return The result of the replace operation\n     */\n    public static <V> String replace(final Object source, final Map<String, V> valueMap) {\n        return new StrSubstitutor(valueMap).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with\n     * their matching values from the map. This method allows to specify a\n     * custom variable prefix and suffix\n     *\n     * @param <V> the type of the values in the map\n     * @param source  the source text containing the variables to substitute, null returns null\n     * @param valueMap  the map with the values, may be null\n     * @param prefix  the prefix of variables, not null\n     * @param suffix  the suffix of variables, not null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public static <V> String replace(final Object source,\n                                     final Map<String, V> valueMap,\n                                     final String prefix,\n                                     final String suffix) {\n        return new StrSubstitutor(valueMap, prefix, suffix).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching\n     * values from the properties.\n     *\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueProperties the properties with values, may be null\n     * @return The result of the replace operation\n     */\n    public static String replace(final Object source, final Properties valueProperties) {\n        if (valueProperties == null) {\n            return source.toString();\n        }\n        final Map<String, String> valueMap = new HashMap<>();\n        final Enumeration<?> propNames = valueProperties.propertyNames();\n        while (propNames.hasMoreElements()) {\n            final String propName = (String) propNames.nextElement();\n            final String propValue = valueProperties.getProperty(propName);\n            valueMap.put(propName, propValue);\n        }\n        return StrSubstitutor.replace(source, valueMap);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with\n     * their matching values from the system properties.\n     *\n     * @param source  the source text containing the variables to substitute, null returns null\n     * @return The result of the replace operation\n     */\n    public static String replaceSystemProperties(final Object source) {\n        return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new instance with defaults for variable prefix and suffix\n     * and the escaping character.\n     */\n    public StrSubstitutor() {\n        this((StrLookup<?>) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses defaults for variable\n     * prefix and suffix and the escaping character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap  the map with the variables' values, may be null\n     */\n    public <V> StrSubstitutor(final Map<String, V> valueMap) {\n        this(StrLookup.mapLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses a default escaping character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap  the map with the variables' values, may be null\n     * @param prefix  the prefix for variables, not null\n     * @param suffix  the suffix for variables, not null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix) {\n        this(StrLookup.mapLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap  the map with the variables' values, may be null\n     * @param prefix  the prefix for variables, not null\n     * @param suffix  the suffix for variables, not null\n     * @param escape  the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n                              final char escape) {\n        this(StrLookup.mapLookup(valueMap), prefix, suffix, escape);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap  the map with the variables' values, may be null\n     * @param prefix  the prefix for variables, not null\n     * @param suffix  the suffix for variables, not null\n     * @param escape  the escape character\n     * @param valueDelimiter  the variable default value delimiter, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n                              final char escape, final String valueDelimiter) {\n        this(StrLookup.mapLookup(valueMap), prefix, suffix, escape, valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver  the variable resolver, may be null\n     */\n    public StrSubstitutor(final StrLookup<?> variableResolver) {\n        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver  the variable resolver, may be null\n     * @param prefix  the prefix for variables, not null\n     * @param suffix  the suffix for variables, not null\n     * @param escape  the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix,\n                          final char escape) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver  the variable resolver, may be null\n     * @param prefix  the prefix for variables, not null\n     * @param suffix  the suffix for variables, not null\n     * @param escape  the escape character\n     * @param valueDelimiter  the variable default value delimiter string, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix,\n                          final char escape, final String valueDelimiter) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiter(valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver  the variable resolver, may be null\n     * @param prefixMatcher  the prefix for variables, not null\n     * @param suffixMatcher  the suffix for variables, not null\n     * @param escape  the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StrSubstitutor(\n            final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher,\n            final char escape) {\n        this(variableResolver, prefixMatcher, suffixMatcher, escape, DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver  the variable resolver, may be null\n     * @param prefixMatcher  the prefix for variables, not null\n     * @param suffixMatcher  the suffix for variables, not null\n     * @param escape  the escape character\n     * @param valueDelimiterMatcher  the variable default value delimiter matcher, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StrSubstitutor(\n            final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher,\n            final char escape, final StrMatcher valueDelimiterMatcher) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefixMatcher(prefixMatcher);\n        this.setVariableSuffixMatcher(suffixMatcher);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(valueDelimiterMatcher);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source string as a template.\n     *\n     * @param source  the string to replace in, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final String source) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(source);\n        if (!substitute(buf, 0, source.length())) {\n            return source;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source string as a template.\n     * <p>\n     * Only the specified portion of the string will be processed.\n     * The rest of the string is not processed, and is not returned.\n     *\n     * @param source  the string to replace in, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     */\n    public String replace(final String source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return source.substring(offset, offset + length);\n        }\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source array as a template.\n     * The array is not altered by this method.\n     *\n     * @param source  the character array to replace in, not altered, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final char[] source) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(source.length).append(source);\n        substitute(buf, 0, source.length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source array as a template.\n     * The array is not altered by this method.\n     * <p>\n     * Only the specified portion of the array will be processed.\n     * The rest of the array is not processed, and is not returned.\n     *\n     * @param source  the character array to replace in, not altered, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     */\n    public String replace(final char[] source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source buffer as a template.\n     * The buffer is not altered by this method.\n     *\n     * @param source  the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final StringBuffer source) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(source.length()).append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source buffer as a template.\n     * The buffer is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed.\n     * The rest of the buffer is not processed, and is not returned.\n     *\n     * @param source  the buffer to use as a template, not changed, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     */\n    public String replace(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source as a template.\n     * The source is not altered by this method.\n     *\n     * @param source  the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final CharSequence source) {\n        if (source == null) {\n            return null;\n        }\n        return replace(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source as a template.\n     * The source is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed.\n     * The rest of the buffer is not processed, and is not returned.\n     *\n     * @param source  the buffer to use as a template, not changed, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     */\n    public String replace(final CharSequence source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source builder as a template.\n     * The builder is not altered by this method.\n     *\n     * @param source  the builder to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final StrBuilder source) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(source.length()).append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source builder as a template.\n     * The builder is not altered by this method.\n     * <p>\n     * Only the specified portion of the builder will be processed.\n     * The rest of the builder is not processed, and is not returned.\n     *\n     * @param source  the builder to use as a template, not changed, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     */\n    public String replace(final StrBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables in the given source object with\n     * their matching values from the resolver. The input source object is\n     * converted to a string using {@code toString} and is not altered.\n     *\n     * @param source  the source to replace in, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final Object source) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder().append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables within the given source buffer\n     * with their matching values from the resolver.\n     * The buffer is updated with the result.\n     *\n     * @param source  the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuffer source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer\n     * with their matching values from the resolver.\n     * The buffer is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed.\n     * The rest of the buffer is not processed, but it is not deleted.\n     *\n     * @param source  the buffer to replace in, updated, null returns zero\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the buffer to be processed, must be valid\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n  //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables within the given source buffer\n     * with their matching values from the resolver.\n     * The buffer is updated with the result.\n     *\n     * @param source  the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder\n     * with their matching values from the resolver.\n     * The builder is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed.\n     * The rest of the buffer is not processed, but it is not deleted.\n     *\n     * @param source  the buffer to replace in, updated, null returns zero\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the buffer to be processed, must be valid\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables within the given source\n     * builder with their matching values from the resolver.\n     *\n     * @param source  the builder to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StrBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source\n     * builder with their matching values from the resolver.\n     * <p>\n     * Only the specified portion of the builder will be processed.\n     * The rest of the builder is not processed, but it is not deleted.\n     *\n     * @param source  the builder to replace in, null returns zero\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    public boolean replaceIn(final StrBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, offset, length);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method that substitutes the variables.\n     * <p>\n     * Most users of this class do not need to call this method. This method will\n     * be called automatically by another (public) method.\n     * <p>\n     * Writers of subclasses can override this method if they need access to\n     * the substitution process at the start or end.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    protected boolean substitute(final StrBuilder buf, final int offset, final int length) {\n        return substitute(buf, offset, length, null) > 0;\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation. This is the main\n     * interpolation method, which resolves the values of all variable references\n     * contained in the passed in text.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @param priorVariables  the stack keeping track of the replaced variables, may be null\n     * @return The length change that occurs, unless priorVariables is null when the int\n     *  represents a boolean flag as to whether any change occurred.\n     */\n    private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n        final StrMatcher pfxMatcher = getVariablePrefixMatcher();\n        final StrMatcher suffMatcher = getVariableSuffixMatcher();\n        final char escape = getEscapeChar();\n        final StrMatcher valueDelimMatcher = getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n        final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues();\n\n        final boolean top = priorVariables == null;\n        boolean altered = false;\n        int lengthChange = 0;\n        char[] chars = buf.buffer;\n        int bufEnd = offset + length;\n        int pos = offset;\n        while (pos < bufEnd) {\n            final int startMatchLen = pfxMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen == 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos > offset && chars[pos - 1] == escape) {\n                    // escaped\n                    if (preserveEscapes) {\n                        pos++;\n                        continue;\n                    }\n                    buf.deleteCharAt(pos - 1);\n                    chars = buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered = true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos = pos;\n                    pos += startMatchLen;\n                    int endMatchLen = 0;\n                    int nestedVarCount = 0;\n                    while (pos < bufEnd) {\n                        if (substitutionInVariablesEnabled\n                                && pfxMatcher.isMatch(chars,\n                                        pos, offset, bufEnd) != 0) {\n                            // found a nested variable start\n                            endMatchLen = pfxMatcher.isMatch(chars,\n                                    pos, offset, bufEnd);\n                            nestedVarCount++;\n                            pos += endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen = suffMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen == 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount == 0) {\n                                String varNameExpr = new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (substitutionInVariablesEnabled) {\n                                    final StrBuilder bufName = new StrBuilder(varNameExpr);\n                                    substitute(bufName, 0, bufName.length());\n                                    varNameExpr = bufName.toString();\n                                }\n                                pos += endMatchLen;\n                                final int endPos = pos;\n\n                                String varName = varNameExpr;\n                                String varDefaultValue = null;\n\n                                if (valueDelimMatcher != null) {\n                                    final char[] varNameExprChars = varNameExpr.toCharArray();\n                                    int valueDelimiterMatchLen = 0;\n                                    for (int i = 0; i < varNameExprChars.length; i++) {\n                                        // if there's any nested variable when nested variable substitution disabled,\n                                        // then stop resolving name and default value.\n                                        if (!substitutionInVariablesEnabled\n                                                && pfxMatcher.isMatch(varNameExprChars,\n                                                                        i,\n                                                                        i,\n                                                                        varNameExprChars.length) != 0) {\n                                            break;\n                                        }\n                                        if (valueDelimMatcher.isMatch(varNameExprChars, i) != 0) {\n                                            valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i);\n                                            varName = varNameExpr.substring(0, i);\n                                            varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables == null) {\n                                    priorVariables = new ArrayList<>();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                String varValue = resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue == null) {\n                                    varValue = varDefaultValue;\n                                }\n                                if (varValue != null) {\n                                    final int varLen = varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered = true;\n                                    int change = 0;\n                                    if (!substitutionInValuesDisabled) { // recursive replace\n                                        change = substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    }\n                                    change = change\n                                        + varLen - (endPos - startPos);\n                                    pos += change;\n                                    bufEnd += change;\n                                    lengthChange += change;\n                                    chars = buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            }\n                            nestedVarCount--;\n                            pos += endMatchLen;\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }\n\n    /**\n     * Checks if the specified variable is already in the stack (list) of variables.\n     *\n     * @param varName  the variable name to check\n     * @param priorVariables  the list of prior variables\n     */\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\n        if (!priorVariables.contains(varName)) {\n            return;\n        }\n        final StrBuilder buf = new StrBuilder(256);\n        buf.append(\"Infinite loop in property interpolation of \");\n        buf.append(priorVariables.remove(0));\n        buf.append(\": \");\n        buf.appendWithSeparators(priorVariables, \"->\");\n        throw new IllegalStateException(buf.toString());\n    }\n\n    /**\n     * Internal method that resolves the value of a variable.\n     * <p>\n     * Most users of this class do not need to call this method. This method is\n     * called automatically by the substitution process.\n     * <p>\n     * Writers of subclasses can override this method if they need to alter\n     * how each substitution occurs. The method is passed the variable's name\n     * and must return the corresponding value. This implementation uses the\n     * {@link #getVariableResolver()} with the variable's name as the key.\n     *\n     * @param variableName  the name of the variable, not null\n     * @param buf  the buffer where the substitution is occurring, not null\n     * @param startPos  the start position of the variable including the prefix, valid\n     * @param endPos  the end position of the variable including the suffix, valid\n     * @return The variable's value or <b>null</b> if the variable is unknown\n     */\n    protected String resolveVariable(final String variableName,\n                                     final StrBuilder buf,\n                                     final int startPos,\n                                     final int endPos) {\n        final StrLookup<?> resolver = getVariableResolver();\n        if (resolver == null) {\n            return null;\n        }\n        return resolver.lookup(variableName);\n    }\n\n    // Escape\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the escape character.\n     *\n     * @return The character used for escaping variable references\n     */\n    public char getEscapeChar() {\n        return this.escapeChar;\n    }\n\n    /**\n     * Sets the escape character.\n     * If this character is placed before a variable reference in the source\n     * text, this variable will be ignored.\n     *\n     * @param escapeCharacter  the escape character (0 for disabling escaping)\n     */\n    public void setEscapeChar(final char escapeCharacter) {\n        this.escapeChar = escapeCharacter;\n    }\n\n    // Prefix\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the\n     * start of a variable. This prefix is expressed in terms of a matcher\n     * allowing advanced prefix matches.\n     *\n     * @return The prefix matcher in use\n     */\n    public StrMatcher getVariablePrefixMatcher() {\n        return prefixMatcher;\n    }\n\n    /**\n     * Sets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the\n     * start of a variable. This prefix is expressed in terms of a matcher\n     * allowing advanced prefix matches.\n     *\n     * @param prefixMatcher  the prefix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix matcher is null\n     */\n    public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher) {\n        Validate.isTrue(prefixMatcher != null, \"Variable prefix matcher must not be null!\");\n        this.prefixMatcher = prefixMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the\n     * start of a variable. This method allows a single character prefix to\n     * be easily set.\n     *\n     * @param prefix  the prefix character to use\n     * @return this, to enable chaining\n     */\n    public StrSubstitutor setVariablePrefix(final char prefix) {\n        return setVariablePrefixMatcher(StrMatcher.charMatcher(prefix));\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the\n     * start of a variable. This method allows a string prefix to be easily set.\n     *\n     * @param prefix  the prefix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix is null\n     */\n    public StrSubstitutor setVariablePrefix(final String prefix) {\n        Validate.isTrue(prefix != null, \"Variable prefix must not be null!\");\n        return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));\n    }\n\n    // Suffix\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the\n     * end of a variable. This suffix is expressed in terms of a matcher\n     * allowing advanced suffix matches.\n     *\n     * @return The suffix matcher in use\n     */\n    public StrMatcher getVariableSuffixMatcher() {\n        return suffixMatcher;\n    }\n\n    /**\n     * Sets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the\n     * end of a variable. This suffix is expressed in terms of a matcher\n     * allowing advanced suffix matches.\n     *\n     * @param suffixMatcher  the suffix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix matcher is null\n     */\n    public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) {\n        Validate.isTrue(suffixMatcher != null, \"Variable suffix matcher must not be null!\");\n        this.suffixMatcher = suffixMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the\n     * end of a variable. This method allows a single character suffix to\n     * be easily set.\n     *\n     * @param suffix  the suffix character to use\n     * @return this, to enable chaining\n     */\n    public StrSubstitutor setVariableSuffix(final char suffix) {\n        return setVariableSuffixMatcher(StrMatcher.charMatcher(suffix));\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the\n     * end of a variable. This method allows a string suffix to be easily set.\n     *\n     * @param suffix  the suffix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix is null\n     */\n    public StrSubstitutor setVariableSuffix(final String suffix) {\n        Validate.isTrue(suffix != null, \"Variable suffix must not be null!\");\n        return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));\n    }\n\n    // Variable Default Value Delimiter\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the variable default value delimiter matcher currently in use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the\n     * variable name and the variable default value. This delimiter is expressed in terms of a matcher\n     * allowing advanced variable default value delimiter matches.\n     * <p>\n     * If it returns null, then the variable default value resolution is disabled.\n     *\n     * @return The variable default value delimiter matcher in use, may be null\n     */\n    public StrMatcher getValueDelimiterMatcher() {\n        return valueDelimiterMatcher;\n    }\n\n    /**\n     * Sets the variable default value delimiter matcher to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the\n     * variable name and the variable default value. This delimiter is expressed in terms of a matcher\n     * allowing advanced variable default value delimiter matches.\n     * <p>\n     * If the {@code valueDelimiterMatcher} is null, then the variable default value resolution\n     * becomes disabled.\n     *\n     * @param valueDelimiterMatcher  variable default value delimiter matcher to use, may be null\n     * @return this, to enable chaining\n     */\n    public StrSubstitutor setValueDelimiterMatcher(final StrMatcher valueDelimiterMatcher) {\n        this.valueDelimiterMatcher = valueDelimiterMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the\n     * variable name and the variable default value. This method allows a single character\n     * variable default value delimiter to be easily set.\n     *\n     * @param valueDelimiter  the variable default value delimiter character to use\n     * @return this, to enable chaining\n     */\n    public StrSubstitutor setValueDelimiter(final char valueDelimiter) {\n        return setValueDelimiterMatcher(StrMatcher.charMatcher(valueDelimiter));\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the\n     * variable name and the variable default value. This method allows a string\n     * variable default value delimiter to be easily set.\n     * <p>\n     * If the {@code valueDelimiter} is null or empty string, then the variable default\n     * value resolution becomes disabled.\n     *\n     * @param valueDelimiter  the variable default value delimiter string to use, may be null or empty\n     * @return this, to enable chaining\n     */\n    public StrSubstitutor setValueDelimiter(final String valueDelimiter) {\n        if (valueDelimiter == null || valueDelimiter.length() == 0) {\n            setValueDelimiterMatcher(null);\n            return this;\n        }\n        return setValueDelimiterMatcher(StrMatcher.stringMatcher(valueDelimiter));\n    }\n\n    // Resolver\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the VariableResolver that is used to lookup variables.\n     *\n     * @return The VariableResolver\n     */\n    public StrLookup<?> getVariableResolver() {\n        return this.variableResolver;\n    }\n\n    /**\n     * Sets the VariableResolver that is used to lookup variables.\n     *\n     * @param variableResolver  the VariableResolver\n     */\n    public void setVariableResolver(final StrLookup<?> variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    // Substitution support in variable names\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a flag whether substitution is done in variable names.\n     *\n     * @return The substitution in variable names flag\n     */\n    public boolean isEnableSubstitutionInVariables() {\n        return enableSubstitutionInVariables;\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable names. If set to\n     * <b>true</b>, the names of variables can contain other variables which are\n     * processed first before the original variable is evaluated, e.g.\n     * {@code ${jre-${java.version}}}. The default value is <b>false</b>.\n     *\n     * @param enableSubstitutionInVariables the new value of the flag\n     */\n    public void setEnableSubstitutionInVariables(\n            final boolean enableSubstitutionInVariables) {\n        this.enableSubstitutionInVariables = enableSubstitutionInVariables;\n    }\n\n    /**\n     * Returns a flag whether substitution is disabled in variable values.If set to\n     * <b>true</b>, the values of variables can contain other variables will not be\n     * processed and substituted original variable is evaluated, e.g.\n     * <pre>\n     * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n     * valuesMap.put(&quot;name&quot;, &quot;Douglas ${surname}&quot;);\n     * valuesMap.put(&quot;surname&quot;, &quot;Crockford&quot;);\n     * String templateString = &quot;Hi ${name}&quot;;\n     * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n     * String resolvedString = sub.replace(templateString);\n     * </pre>\n     * yielding:\n     * <pre>\n     *      Hi Douglas ${surname}\n     * </pre>\n     *\n     * @return The substitution in variable values flag\n     *\n     * @since 1.2\n     */\n    public boolean isDisableSubstitutionInValues() {\n        return disableSubstitutionInValues;\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable values (recursive).\n     *\n     * @param disableSubstitutionInValues true if substitution in variable value are disabled\n     *\n     * @since 1.2\n     */\n    public void setDisableSubstitutionInValues(final boolean disableSubstitutionInValues) {\n        this.disableSubstitutionInValues = disableSubstitutionInValues;\n    }\n\n    /**\n     * Returns the flag controlling whether escapes are preserved during\n     * substitution.\n     *\n     * @return The preserve escape flag\n     */\n    public boolean isPreserveEscapes() {\n        return preserveEscapes;\n    }\n\n    /**\n     * Sets a flag controlling whether escapes are preserved during\n     * substitution.  If set to <b>true</b>, the escape character is retained\n     * during substitution (e.g. {@code $${this-is-escaped}} remains\n     * {@code $${this-is-escaped}}).  If set to <b>false</b>, the escape\n     * character is removed during substitution (e.g.\n     * {@code $${this-is-escaped}} becomes\n     * {@code ${this-is-escaped}}).  The default value is <b>false</b>\n     *\n     * @param preserveEscapes true if escapes are to be preserved\n     */\n    public void setPreserveEscapes(final boolean preserveEscapes) {\n        this.preserveEscapes = preserveEscapes;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/StrSubstitutor.java b/src/main/java/org/apache/commons/text/StrSubstitutor.java\nindex 362c02385d..021d2e1dec 100644\n--- a/src/main/java/org/apache/commons/text/StrSubstitutor.java\n+++ b/src/main/java/org/apache/commons/text/StrSubstitutor.java\n@@ -179,7 +179,7 @@ public class StrSubstitutor {\n     /**\n      * Whether escapes should be preserved.  Default is false;\n      */\n-    private boolean preserveEscapes = false;\n+    private boolean preserveEscapes;\n \n     /**\n      * The flag whether substitution in variable values is disabled.\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/StrTokenizer.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.junit.jupiter.api.Test;\n\n@Deprecated\npublic class StrTokenizerTest2 {\n\n    @Test\n    public void testCheckTokenizedWithNullChars() {\n        StrTokenizer tokenizer = new StrTokenizer();\n        tokenizer.checkTokenized();\n        assertEquals(0, tokenizer.size());\n        assertEquals(ArrayUtils.EMPTY_STRING_ARRAY, tokenizer.getTokenArray());\n    }\n\n    @Test\n    public void testCheckTokenizedWithEmptyChars() {\n        StrTokenizer tokenizer = new StrTokenizer(ArrayUtils.EMPTY_CHAR_ARRAY);\n        tokenizer.checkTokenized();\n        assertEquals(0, tokenizer.size());\n        assertEquals(ArrayUtils.EMPTY_STRING_ARRAY, tokenizer.getTokenArray());\n    }\n\n    @Test\n    public void testCheckTokenizedWithNonEmptyChars() {\n        StrTokenizer tokenizer = new StrTokenizer(\"a b c\".toCharArray());\n        tokenizer.checkTokenized();\n        assertEquals(3, tokenizer.size());\n        assertEquals(new String[]{\"a\", \"b\", \"c\"}, tokenizer.getTokenArray());\n    }\n\n    @Test\n    public void testConstructorDefaultValues() {\n        StrTokenizer tokenizer = new StrTokenizer();\n        assertFalse(tokenizer.isEmptyTokenAsNull());\n        assertTrue(tokenizer.isIgnoreEmptyTokens());\n    }\n\n    @Test\n    public void testConstructorWithEmptyTokenAsNull() {\n        StrTokenizer tokenizer = new StrTokenizer();\n        tokenizer.setEmptyTokenAsNull(true);\n        assertTrue(tokenizer.isEmptyTokenAsNull());\n    }\n\n    @Test\n    public void testConstructorWithIgnoreEmptyTokens() {\n        StrTokenizer tokenizer = new StrTokenizer();\n        tokenizer.setIgnoreEmptyTokens(false);\n        assertFalse(tokenizer.isIgnoreEmptyTokens());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * Tokenizes a string based on delimiters (separators)\n * and supporting quoting and ignored character concepts.\n * <p>\n * This class can split a String into many smaller strings. It aims\n * to do a similar job to {@link java.util.StringTokenizer StringTokenizer},\n * however it offers much more control and flexibility including implementing\n * the {@code ListIterator} interface. By default, it is set up\n * like {@code StringTokenizer}.\n * <p>\n * The input String is split into a number of <i>tokens</i>.\n * Each token is separated from the next String by a <i>delimiter</i>.\n * One or more delimiter characters must be specified.\n * <p>\n * Each token may be surrounded by quotes.\n * The <i>quote</i> matcher specifies the quote character(s).\n * A quote may be escaped within a quoted section by duplicating itself.\n * <p>\n * Between each token and the delimiter are potentially characters that need trimming.\n * The <i>trimmer</i> matcher specifies these characters.\n * One usage might be to trim whitespace characters.\n * <p>\n * At any point outside the quotes there might potentially be invalid characters.\n * The <i>ignored</i> matcher specifies these characters to be removed.\n * One usage might be to remove new line characters.\n * <p>\n * Empty tokens may be removed or returned as null.\n * <pre>\n * \"a,b,c\"         - Three tokens \"a\",\"b\",\"c\"   (comma delimiter)\n * \" a, b , c \"    - Three tokens \"a\",\"b\",\"c\"   (default CSV processing trims whitespace)\n * \"a, \", b ,\", c\" - Three tokens \"a, \" , \" b \", \", c\" (quoted text untouched)\n * </pre>\n *\n * <table>\n *  <caption>StrTokenizer properties and options</caption>\n *  <tr>\n *   <th>Property</th><th>Type</th><th>Default</th>\n *  </tr>\n *  <tr>\n *   <td>delim</td><td>CharSetMatcher</td><td>{ \\t\\n\\r\\f}</td>\n *  </tr>\n *  <tr>\n *   <td>quote</td><td>NoneMatcher</td><td>{}</td>\n *  </tr>\n *  <tr>\n *   <td>ignore</td><td>NoneMatcher</td><td>{}</td>\n *  </tr>\n *  <tr>\n *   <td>emptyTokenAsNull</td><td>boolean</td><td>false</td>\n *  </tr>\n *  <tr>\n *   <td>ignoreEmptyTokens</td><td>boolean</td><td>true</td>\n *  </tr>\n * </table>\n *\n * @since 1.0\n * @deprecated Deprecated as of 1.3, use {@link StringTokenizer} instead. This class will be removed in 2.0.\n */\n@Deprecated\npublic class StrTokenizer implements ListIterator<String>, Cloneable {\n\n    /** Comma separated values tokenizer internal variable. */\n    private static final StrTokenizer CSV_TOKENIZER_PROTOTYPE;\n    /** Tab separated values tokenizer internal variable. */\n    private static final StrTokenizer TSV_TOKENIZER_PROTOTYPE;\n    static {\n        CSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n        CSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.commaMatcher());\n        CSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());\n        CSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());\n        CSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n        CSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n\n        TSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n        TSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.tabMatcher());\n        TSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());\n        TSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());\n        TSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n        TSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n    }\n\n    /** The text to work on. */\n    private char[] chars;\n    /** The parsed tokens. */\n    private String[] tokens;\n    /** The current iteration position. */\n    private int tokenPos;\n\n    /** The delimiter matcher. */\n    private StrMatcher delimMatcher = StrMatcher.splitMatcher();\n    /** The quote matcher. */\n    private StrMatcher quoteMatcher = StrMatcher.noneMatcher();\n    /** The ignored matcher. */\n    private StrMatcher ignoredMatcher = StrMatcher.noneMatcher();\n    /** The trimmer matcher. */\n    private StrMatcher trimmerMatcher = StrMatcher.noneMatcher();\n\n    /** Whether to return empty tokens as null. */\n    private boolean emptyAsNull = false;\n    /** Whether to ignore empty tokens. */\n    private boolean ignoreEmptyTokens = true;\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns a clone of {@code CSV_TOKENIZER_PROTOTYPE}.\n     *\n     * @return a clone of {@code CSV_TOKENIZER_PROTOTYPE}.\n     */\n    private static StrTokenizer getCSVClone() {\n        return (StrTokenizer) CSV_TOKENIZER_PROTOTYPE.clone();\n    }\n\n    /**\n     * Gets a new tokenizer instance which parses Comma Separated Value strings\n     * initializing it with the given input.  The default for CSV processing\n     * will be trim whitespace from both ends (which can be overridden with\n     * the setTrimmer method).\n     * <p>\n     * You must call a \"reset\" method to set the string which you want to parse.\n     * @return a new tokenizer instance which parses Comma Separated Value strings\n     */\n    public static StrTokenizer getCSVInstance() {\n        return getCSVClone();\n    }\n\n    /**\n     * Gets a new tokenizer instance which parses Comma Separated Value strings\n     * initializing it with the given input.  The default for CSV processing\n     * will be trim whitespace from both ends (which can be overridden with\n     * the setTrimmer method).\n     *\n     * @param input  the text to parse\n     * @return a new tokenizer instance which parses Comma Separated Value strings\n     */\n    public static StrTokenizer getCSVInstance(final String input) {\n        final StrTokenizer tok = getCSVClone();\n        tok.reset(input);\n        return tok;\n    }\n\n    /**\n     * Gets a new tokenizer instance which parses Comma Separated Value strings\n     * initializing it with the given input.  The default for CSV processing\n     * will be trim whitespace from both ends (which can be overridden with\n     * the setTrimmer method).\n     *\n     * @param input  the text to parse\n     * @return a new tokenizer instance which parses Comma Separated Value strings\n     */\n    public static StrTokenizer getCSVInstance(final char[] input) {\n        final StrTokenizer tok = getCSVClone();\n        tok.reset(input);\n        return tok;\n    }\n\n    /**\n     * Returns a clone of {@code TSV_TOKENIZER_PROTOTYPE}.\n     *\n     * @return a clone of {@code TSV_TOKENIZER_PROTOTYPE}.\n     */\n    private static StrTokenizer getTSVClone() {\n        return (StrTokenizer) TSV_TOKENIZER_PROTOTYPE.clone();\n    }\n\n\n    /**\n     * Gets a new tokenizer instance which parses Tab Separated Value strings.\n     * The default for CSV processing will be trim whitespace from both ends\n     * (which can be overridden with the setTrimmer method).\n     * <p>\n     * You must call a \"reset\" method to set the string which you want to parse.\n     * @return a new tokenizer instance which parses Tab Separated Value strings.\n     */\n    public static StrTokenizer getTSVInstance() {\n        return getTSVClone();\n    }\n\n    /**\n     * Gets a new tokenizer instance which parses Tab Separated Value strings.\n     * The default for CSV processing will be trim whitespace from both ends\n     * (which can be overridden with the setTrimmer method).\n     * @param input  the string to parse\n     * @return a new tokenizer instance which parses Tab Separated Value strings.\n     */\n    public static StrTokenizer getTSVInstance(final String input) {\n        final StrTokenizer tok = getTSVClone();\n        tok.reset(input);\n        return tok;\n    }\n\n    /**\n     * Gets a new tokenizer instance which parses Tab Separated Value strings.\n     * The default for CSV processing will be trim whitespace from both ends\n     * (which can be overridden with the setTrimmer method).\n     * @param input  the string to parse\n     * @return a new tokenizer instance which parses Tab Separated Value strings.\n     */\n    public static StrTokenizer getTSVInstance(final char[] input) {\n        final StrTokenizer tok = getTSVClone();\n        tok.reset(input);\n        return tok;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a tokenizer splitting on space, tab, newline and form feed\n     * as per StringTokenizer, but with no text to tokenize.\n     * <p>\n     * This constructor is normally used with {@link #reset(String)}.\n     */\n    public StrTokenizer() {\n        this.chars = null;\n    }\n\n    /**\n     * Constructs a tokenizer splitting on space, tab, newline and form feed\n     * as per StringTokenizer.\n     *\n     * @param input  the string which is to be parsed\n     */\n    public StrTokenizer(final String input) {\n        if (input != null) {\n            chars = input.toCharArray();\n        } else {\n            chars = null;\n        }\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified delimiter character.\n     *\n     * @param input  the string which is to be parsed\n     * @param delim  the field delimiter character\n     */\n    public StrTokenizer(final String input, final char delim) {\n        this(input);\n        setDelimiterChar(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified delimiter string.\n     *\n     * @param input  the string which is to be parsed\n     * @param delim  the field delimiter string\n     */\n    public StrTokenizer(final String input, final String delim) {\n        this(input);\n        setDelimiterString(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting using the specified delimiter matcher.\n     *\n     * @param input  the string which is to be parsed\n     * @param delim  the field delimiter matcher\n     */\n    public StrTokenizer(final String input, final StrMatcher delim) {\n        this(input);\n        setDelimiterMatcher(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified delimiter character\n     * and handling quotes using the specified quote character.\n     *\n     * @param input  the string which is to be parsed\n     * @param delim  the field delimiter character\n     * @param quote  the field quoted string character\n     */\n    public StrTokenizer(final String input, final char delim, final char quote) {\n        this(input, delim);\n        setQuoteChar(quote);\n    }\n\n    /**\n     * Constructs a tokenizer splitting using the specified delimiter matcher\n     * and handling quotes using the specified quote matcher.\n     *\n     * @param input  the string which is to be parsed\n     * @param delim  the field delimiter matcher\n     * @param quote  the field quoted string matcher\n     */\n    public StrTokenizer(final String input, final StrMatcher delim, final StrMatcher quote) {\n        this(input, delim);\n        setQuoteMatcher(quote);\n    }\n\n    /**\n     * Constructs a tokenizer splitting on space, tab, newline and form feed\n     * as per StringTokenizer.\n     *\n     * @param input  the string which is to be parsed, not cloned\n     */\n    public StrTokenizer(final char[] input) {\n        if (input == null) {\n            this.chars = null;\n        } else {\n            this.chars = input.clone();\n        }\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified character.\n     *\n     * @param input  the string which is to be parsed, not cloned\n     * @param delim the field delimiter character\n     */\n    public StrTokenizer(final char[] input, final char delim) {\n        this(input);\n        setDelimiterChar(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified string.\n     *\n     * @param input  the string which is to be parsed, not cloned\n     * @param delim the field delimiter string\n     */\n    public StrTokenizer(final char[] input, final String delim) {\n        this(input);\n        setDelimiterString(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting using the specified delimiter matcher.\n     *\n     * @param input  the string which is to be parsed, not cloned\n     * @param delim  the field delimiter matcher\n     */\n    public StrTokenizer(final char[] input, final StrMatcher delim) {\n        this(input);\n        setDelimiterMatcher(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified delimiter character\n     * and handling quotes using the specified quote character.\n     *\n     * @param input  the string which is to be parsed, not cloned\n     * @param delim  the field delimiter character\n     * @param quote  the field quoted string character\n     */\n    public StrTokenizer(final char[] input, final char delim, final char quote) {\n        this(input, delim);\n        setQuoteChar(quote);\n    }\n\n    /**\n     * Constructs a tokenizer splitting using the specified delimiter matcher\n     * and handling quotes using the specified quote matcher.\n     *\n     * @param input  the string which is to be parsed, not cloned\n     * @param delim  the field delimiter character\n     * @param quote  the field quoted string character\n     */\n    public StrTokenizer(final char[] input, final StrMatcher delim, final StrMatcher quote) {\n        this(input, delim);\n        setQuoteMatcher(quote);\n    }\n\n    // API\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of tokens found in the String.\n     *\n     * @return The number of matched tokens\n     */\n    public int size() {\n        checkTokenized();\n        return tokens.length;\n    }\n\n    /**\n     * Gets the next token from the String.\n     * Equivalent to {@link #next()} except it returns null rather than\n     * throwing {@link NoSuchElementException} when no tokens remain.\n     *\n     * @return The next sequential token, or null when no more tokens are found\n     */\n    public String nextToken() {\n        if (hasNext()) {\n            return tokens[tokenPos++];\n        }\n        return null;\n    }\n\n    /**\n     * Gets the previous token from the String.\n     *\n     * @return The previous sequential token, or null when no more tokens are found\n     */\n    public String previousToken() {\n        if (hasPrevious()) {\n            return tokens[--tokenPos];\n        }\n        return null;\n    }\n\n    /**\n     * Gets a copy of the full token list as an independent modifiable array.\n     *\n     * @return The tokens as a String array\n     */\n    public String[] getTokenArray() {\n        checkTokenized();\n        return tokens.clone();\n    }\n\n    /**\n     * Gets a copy of the full token list as an independent modifiable list.\n     *\n     * @return The tokens as a String array\n     */\n    public List<String> getTokenList() {\n        checkTokenized();\n        final List<String> list = new ArrayList<>(tokens.length);\n        Collections.addAll(list, tokens);\n\n        return list;\n    }\n\n    /**\n     * Resets this tokenizer, forgetting all parsing and iteration already completed.\n     * <p>\n     * This method allows the same tokenizer to be reused for the same String.\n     *\n     * @return this, to enable chaining\n     */\n    public StrTokenizer reset() {\n        tokenPos = 0;\n        tokens = null;\n        return this;\n    }\n\n    /**\n     * Reset this tokenizer, giving it a new input string to parse.\n     * In this manner you can re-use a tokenizer with the same settings\n     * on multiple input lines.\n     *\n     * @param input  the new string to tokenize, null sets no text to parse\n     * @return this, to enable chaining\n     */\n    public StrTokenizer reset(final String input) {\n        reset();\n        if (input != null) {\n            this.chars = input.toCharArray();\n        } else {\n            this.chars = null;\n        }\n        return this;\n    }\n\n    /**\n     * Reset this tokenizer, giving it a new input string to parse.\n     * In this manner you can re-use a tokenizer with the same settings\n     * on multiple input lines.\n     *\n     * @param input  the new character array to tokenize, not cloned, null sets no text to parse\n     * @return this, to enable chaining\n     */\n    public StrTokenizer reset(final char[] input) {\n        reset();\n        if (input != null) {\n            this.chars = input.clone();\n        } else {\n            this.chars = null;\n        }\n        return this;\n    }\n\n    // ListIterator\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether there are any more tokens.\n     *\n     * @return true if there are more tokens\n     */\n    @Override\n    public boolean hasNext() {\n        checkTokenized();\n        return tokenPos < tokens.length;\n    }\n\n    /**\n     * Gets the next token.\n     *\n     * @return The next String token\n     * @throws NoSuchElementException if there are no more elements\n     */\n    @Override\n    public String next() {\n        if (hasNext()) {\n            return tokens[tokenPos++];\n        }\n        throw new NoSuchElementException();\n    }\n\n    /**\n     * Gets the index of the next token to return.\n     *\n     * @return The next token index\n     */\n    @Override\n    public int nextIndex() {\n        return tokenPos;\n    }\n\n    /**\n     * Checks whether there are any previous tokens that can be iterated to.\n     *\n     * @return true if there are previous tokens\n     */\n    @Override\n    public boolean hasPrevious() {\n        checkTokenized();\n        return tokenPos > 0;\n    }\n\n    /**\n     * Gets the token previous to the last returned token.\n     *\n     * @return The previous token\n     */\n    @Override\n    public String previous() {\n        if (hasPrevious()) {\n            return tokens[--tokenPos];\n        }\n        throw new NoSuchElementException();\n    }\n\n    /**\n     * Gets the index of the previous token.\n     *\n     * @return The previous token index\n     */\n    @Override\n    public int previousIndex() {\n        return tokenPos - 1;\n    }\n\n    /**\n     * Unsupported ListIterator operation.\n     *\n     * @throws UnsupportedOperationException always\n     */\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove() is unsupported\");\n    }\n\n    /**\n     * Unsupported ListIterator operation.\n     * @param obj this parameter ignored.\n     * @throws UnsupportedOperationException always\n     */\n    @Override\n    public void set(final String obj) {\n        throw new UnsupportedOperationException(\"set() is unsupported\");\n    }\n\n    /**\n     * Unsupported ListIterator operation.\n     * @param obj this parameter ignored.\n     * @throws UnsupportedOperationException always\n     */\n    @Override\n    public void add(final String obj) {\n        throw new UnsupportedOperationException(\"add() is unsupported\");\n    }\n\n    // Implementation\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if tokenization has been done, and if not then do it.\n     */\n    private void checkTokenized() {\n        if (tokens == null) {\n            if (chars == null) {\n                // still call tokenize as subclass may do some work\n                final List<String> split = tokenize(null, 0, 0);\n                tokens = split.toArray(new String[split.size()]);\n            } else {\n                final List<String> split = tokenize(chars, 0, chars.length);\n                tokens = split.toArray(new String[split.size()]);\n            }\n        }\n    }\n\n    /**\n     * Internal method to performs the tokenization.\n     * <p>\n     * Most users of this class do not need to call this method. This method\n     * will be called automatically by other (public) methods when required.\n     * <p>\n     * This method exists to allow subclasses to add code before or after the\n     * tokenization. For example, a subclass could alter the character array,\n     * offset or count to be parsed, or call the tokenizer multiple times on\n     * multiple strings. It is also be possible to filter the results.\n     * <p>\n     * {@code StrTokenizer} will always pass a zero offset and a count\n     * equal to the length of the array to this method, however a subclass\n     * may pass other values, or even an entirely different array.\n     *\n     * @param srcChars  the character array being tokenized, may be null\n     * @param offset  the start position within the character array, must be valid\n     * @param count  the number of characters to tokenize, must be valid\n     * @return The modifiable list of String tokens, unmodifiable if null array or zero count\n     */\n    protected List<String> tokenize(final char[] srcChars, final int offset, final int count) {\n        if (srcChars == null || count == 0) {\n            return Collections.emptyList();\n        }\n        final StrBuilder buf = new StrBuilder();\n        final List<String> tokenList = new ArrayList<>();\n        int pos = offset;\n\n        // loop around the entire buffer\n        while (pos >= 0 && pos < count) {\n            // find next token\n            pos = readNextToken(srcChars, pos, count, buf, tokenList);\n\n            // handle case where end of string is a delimiter\n            if (pos >= count) {\n                addToken(tokenList, StringUtils.EMPTY);\n            }\n        }\n        return tokenList;\n    }\n\n    /**\n     * Adds a token to a list, paying attention to the parameters we've set.\n     *\n     * @param list  the list to add to\n     * @param tok  the token to add\n     */\n    private void addToken(final List<String> list, String tok) {\n        if (tok == null || tok.length() == 0) {\n            if (isIgnoreEmptyTokens()) {\n                return;\n            }\n            if (isEmptyTokenAsNull()) {\n                tok = null;\n            }\n        }\n        list.add(tok);\n    }\n\n    /**\n     * Reads character by character through the String to get the next token.\n     *\n     * @param srcChars  the character array being tokenized\n     * @param start  the first character of field\n     * @param len  the length of the character array being tokenized\n     * @param workArea  a temporary work area\n     * @param tokenList  the list of parsed tokens\n     * @return The starting position of the next field (the character\n     *  immediately after the delimiter), or -1 if end of string found\n     */\n    private int readNextToken(final char[] srcChars,\n                              int start,\n                              final int len,\n                              final StrBuilder workArea,\n                              final List<String> tokenList) {\n        // skip all leading whitespace, unless it is the\n        // field delimiter or the quote character\n        while (start < len) {\n            final int removeLen = Math.max(\n                    getIgnoredMatcher().isMatch(srcChars, start, start, len),\n                    getTrimmerMatcher().isMatch(srcChars, start, start, len));\n            if (removeLen == 0\n                    || getDelimiterMatcher().isMatch(srcChars, start, start, len) > 0\n                    || getQuoteMatcher().isMatch(srcChars, start, start, len) > 0) {\n                break;\n            }\n            start += removeLen;\n        }\n\n        // handle reaching end\n        if (start >= len) {\n            addToken(tokenList, StringUtils.EMPTY);\n            return -1;\n        }\n\n        // handle empty token\n        final int delimLen = getDelimiterMatcher().isMatch(srcChars, start, start, len);\n        if (delimLen > 0) {\n            addToken(tokenList, StringUtils.EMPTY);\n            return start + delimLen;\n        }\n\n        // handle found token\n        final int quoteLen = getQuoteMatcher().isMatch(srcChars, start, start, len);\n        if (quoteLen > 0) {\n            return readWithQuotes(srcChars, start + quoteLen, len, workArea, tokenList, start, quoteLen);\n        }\n        return readWithQuotes(srcChars, start, len, workArea, tokenList, 0, 0);\n    }\n\n    /**\n     * Reads a possibly quoted string token.\n     *\n     * @param srcChars  the character array being tokenized\n     * @param start  the first character of field\n     * @param len  the length of the character array being tokenized\n     * @param workArea  a temporary work area\n     * @param tokenList  the list of parsed tokens\n     * @param quoteStart  the start position of the matched quote, 0 if no quoting\n     * @param quoteLen  the length of the matched quote, 0 if no quoting\n     * @return The starting position of the next field (the character\n     *  immediately after the delimiter, or if end of string found,\n     *  then the length of string\n     */\n    private int readWithQuotes(final char[] srcChars, final int start, final int len, final StrBuilder workArea,\n                               final List<String> tokenList, final int quoteStart, final int quoteLen) {\n        // Loop until we've found the end of the quoted\n        // string or the end of the input\n        workArea.clear();\n        int pos = start;\n        boolean quoting = quoteLen > 0;\n        int trimStart = 0;\n\n        while (pos < len) {\n            // quoting mode can occur several times throughout a string\n            // we must switch between quoting and non-quoting until we\n            // encounter a non-quoted delimiter, or end of string\n            if (quoting) {\n                // In quoting mode\n\n                // If we've found a quote character, see if it's\n                // followed by a second quote.  If so, then we need\n                // to actually put the quote character into the token\n                // rather than end the token.\n                if (isQuote(srcChars, pos, len, quoteStart, quoteLen)) {\n                    if (isQuote(srcChars, pos + quoteLen, len, quoteStart, quoteLen)) {\n                        // matched pair of quotes, thus an escaped quote\n                        workArea.append(srcChars, pos, quoteLen);\n                        pos += quoteLen * 2;\n                        trimStart = workArea.size();\n                        continue;\n                    }\n\n                    // end of quoting\n                    quoting = false;\n                    pos += quoteLen;\n                    continue;\n                }\n\n                // copy regular character from inside quotes\n                workArea.append(srcChars[pos++]);\n                trimStart = workArea.size();\n\n            } else {\n                // Not in quoting mode\n\n                // check for delimiter, and thus end of token\n                final int delimLen = getDelimiterMatcher().isMatch(srcChars, pos, start, len);\n                if (delimLen > 0) {\n                    // return condition when end of token found\n                    addToken(tokenList, workArea.substring(0, trimStart));\n                    return pos + delimLen;\n                }\n\n                // check for quote, and thus back into quoting mode\n                if (quoteLen > 0 && isQuote(srcChars, pos, len, quoteStart, quoteLen)) {\n                    quoting = true;\n                    pos += quoteLen;\n                    continue;\n                }\n\n                // check for ignored (outside quotes), and ignore\n                final int ignoredLen = getIgnoredMatcher().isMatch(srcChars, pos, start, len);\n                if (ignoredLen > 0) {\n                    pos += ignoredLen;\n                    continue;\n                }\n\n                // check for trimmed character\n                // don't yet know if its at the end, so copy to workArea\n                // use trimStart to keep track of trim at the end\n                final int trimmedLen = getTrimmerMatcher().isMatch(srcChars, pos, start, len);\n                if (trimmedLen > 0) {\n                    workArea.append(srcChars, pos, trimmedLen);\n                    pos += trimmedLen;\n                    continue;\n                }\n\n                // copy regular character from outside quotes\n                workArea.append(srcChars[pos++]);\n                trimStart = workArea.size();\n            }\n        }\n\n        // return condition when end of string found\n        addToken(tokenList, workArea.substring(0, trimStart));\n        return -1;\n    }\n\n    /**\n     * Checks if the characters at the index specified match the quote\n     * already matched in readNextToken().\n     *\n     * @param srcChars  the character array being tokenized\n     * @param pos  the position to check for a quote\n     * @param len  the length of the character array being tokenized\n     * @param quoteStart  the start position of the matched quote, 0 if no quoting\n     * @param quoteLen  the length of the matched quote, 0 if no quoting\n     * @return true if a quote is matched\n     */\n    private boolean isQuote(final char[] srcChars,\n                            final int pos,\n                            final int len,\n                            final int quoteStart,\n                            final int quoteLen) {\n        for (int i = 0; i < quoteLen; i++) {\n            if (pos + i >= len || srcChars[pos + i] != srcChars[quoteStart + i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Delimiter\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the field delimiter matcher.\n     *\n     * @return The delimiter matcher in use\n     */\n    public StrMatcher getDelimiterMatcher() {\n        return this.delimMatcher;\n    }\n\n    /**\n     * Sets the field delimiter matcher.\n     * <p>\n     * The delimiter is used to separate one token from another.\n     *\n     * @param delim  the delimiter matcher to use\n     * @return this, to enable chaining\n     */\n    public StrTokenizer setDelimiterMatcher(final StrMatcher delim) {\n        if (delim == null) {\n            this.delimMatcher = StrMatcher.noneMatcher();\n        } else {\n            this.delimMatcher = delim;\n        }\n        return this;\n    }\n\n    /**\n     * Sets the field delimiter character.\n     *\n     * @param delim  the delimiter character to use\n     * @return this, to enable chaining\n     */\n    public StrTokenizer setDelimiterChar(final char delim) {\n        return setDelimiterMatcher(StrMatcher.charMatcher(delim));\n    }\n\n    /**\n     * Sets the field delimiter string.\n     *\n     * @param delim  the delimiter string to use\n     * @return this, to enable chaining\n     */\n    public StrTokenizer setDelimiterString(final String delim) {\n        return setDelimiterMatcher(StrMatcher.stringMatcher(delim));\n    }\n\n    // Quote\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the quote matcher currently in use.\n     * <p>\n     * The quote character is used to wrap data between the tokens.\n     * This enables delimiters to be entered as data.\n     * The default value is '\"' (double quote).\n     *\n     * @return The quote matcher in use\n     */\n    public StrMatcher getQuoteMatcher() {\n        return quoteMatcher;\n    }\n\n    /**\n     * Set the quote matcher to use.\n     * <p>\n     * The quote character is used to wrap data between the tokens.\n     * This enables delimiters to be entered as data.\n     *\n     * @param quote  the quote matcher to use, null ignored\n     * @return this, to enable chaining\n     */\n    public StrTokenizer setQuoteMatcher(final StrMatcher quote) {\n        if (quote != null) {\n            this.quoteMatcher = quote;\n        }\n        return this;\n    }\n\n    /**\n     * Sets the quote character to use.\n     * <p>\n     * The quote character is used to wrap data between the tokens.\n     * This enables delimiters to be entered as data.\n     *\n     * @param quote  the quote character to use\n     * @return this, to enable chaining\n     */\n    public StrTokenizer setQuoteChar(final char quote) {\n        return setQuoteMatcher(StrMatcher.charMatcher(quote));\n    }\n\n    // Ignored\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the ignored character matcher.\n     * <p>\n     * These characters are ignored when parsing the String, unless they are\n     * within a quoted region.\n     * The default value is not to ignore anything.\n     *\n     * @return The ignored matcher in use\n     */\n    public StrMatcher getIgnoredMatcher() {\n        return ignoredMatcher;\n    }\n\n    /**\n     * Set the matcher for characters to ignore.\n     * <p>\n     * These characters are ignored when parsing the String, unless they are\n     * within a quoted region.\n     *\n     * @param ignored  the ignored matcher to use, null ignored\n     * @return this, to enable chaining\n     */\n    public StrTokenizer setIgnoredMatcher(final StrMatcher ignored) {\n        if (ignored != null) {\n            this.ignoredMatcher = ignored;\n        }\n        return this;\n    }\n\n    /**\n     * Set the character to ignore.\n     * <p>\n     * This character is ignored when parsing the String, unless it is\n     * within a quoted region.\n     *\n     * @param ignored  the ignored character to use\n     * @return this, to enable chaining\n     */\n    public StrTokenizer setIgnoredChar(final char ignored) {\n        return setIgnoredMatcher(StrMatcher.charMatcher(ignored));\n    }\n\n    // Trimmer\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the trimmer character matcher.\n     * <p>\n     * These characters are trimmed off on each side of the delimiter\n     * until the token or quote is found.\n     * The default value is not to trim anything.\n     *\n     * @return The trimmer matcher in use\n     */\n    public StrMatcher getTrimmerMatcher() {\n        return trimmerMatcher;\n    }\n\n    /**\n     * Sets the matcher for characters to trim.\n     * <p>\n     * These characters are trimmed off on each side of the delimiter\n     * until the token or quote is found.\n     *\n     * @param trimmer  the trimmer matcher to use, null ignored\n     * @return this, to enable chaining\n     */\n    public StrTokenizer setTrimmerMatcher(final StrMatcher trimmer) {\n        if (trimmer != null) {\n            this.trimmerMatcher = trimmer;\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets whether the tokenizer currently returns empty tokens as null.\n     * The default for this property is false.\n     *\n     * @return true if empty tokens are returned as null\n     */\n    public boolean isEmptyTokenAsNull() {\n        return this.emptyAsNull;\n    }\n\n    /**\n     * Sets whether the tokenizer should return empty tokens as null.\n     * The default for this property is false.\n     *\n     * @param emptyAsNull  whether empty tokens are returned as null\n     * @return this, to enable chaining\n     */\n    public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {\n        this.emptyAsNull = emptyAsNull;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets whether the tokenizer currently ignores empty tokens.\n     * The default for this property is true.\n     *\n     * @return true if empty tokens are not returned\n     */\n    public boolean isIgnoreEmptyTokens() {\n        return ignoreEmptyTokens;\n    }\n\n    /**\n     * Sets whether the tokenizer should ignore and not return empty tokens.\n     * The default for this property is true.\n     *\n     * @param ignoreEmptyTokens  whether empty tokens are not returned\n     * @return this, to enable chaining\n     */\n    public StrTokenizer setIgnoreEmptyTokens(final boolean ignoreEmptyTokens) {\n        this.ignoreEmptyTokens = ignoreEmptyTokens;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the String content that the tokenizer is parsing.\n     *\n     * @return The string content being parsed\n     */\n    public String getContent() {\n        if (chars == null) {\n            return null;\n        }\n        return new String(chars);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new instance of this Tokenizer. The new instance is reset so\n     * that it will be at the start of the token list.\n     * If a {@link CloneNotSupportedException} is caught, return {@code null}.\n     *\n     * @return a new instance of this Tokenizer which has been reset.\n     */\n    @Override\n    public Object clone() {\n        try {\n            return cloneReset();\n        } catch (final CloneNotSupportedException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Creates a new instance of this Tokenizer. The new instance is reset so that\n     * it will be at the start of the token list.\n     *\n     * @return a new instance of this Tokenizer which has been reset.\n     * @throws CloneNotSupportedException if there is a problem cloning\n     */\n    Object cloneReset() throws CloneNotSupportedException {\n        // this method exists to enable 100% test coverage\n        final StrTokenizer cloned = (StrTokenizer) super.clone();\n        if (cloned.chars != null) {\n            cloned.chars = cloned.chars.clone();\n        }\n        cloned.reset();\n        return cloned;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the String content that the tokenizer is parsing.\n     *\n     * @return The string content being parsed\n     */\n    @Override\n    public String toString() {\n        if (tokens == null) {\n            return \"StrTokenizer[not tokenized yet]\";\n        }\n        return \"StrTokenizer\" + getTokenList();\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/StrTokenizer.java b/src/main/java/org/apache/commons/text/StrTokenizer.java\nindex 318aac55f1..27147f3c2c 100644\n--- a/src/main/java/org/apache/commons/text/StrTokenizer.java\n+++ b/src/main/java/org/apache/commons/text/StrTokenizer.java\n@@ -22,6 +22,7 @@\n import java.util.ListIterator;\n import java.util.NoSuchElementException;\n \n+import org.apache.commons.lang3.ArrayUtils;\n import org.apache.commons.lang3.StringUtils;\n \n /**\n@@ -124,7 +125,7 @@ public class StrTokenizer implements ListIterator<String>, Cloneable {\n     private StrMatcher trimmerMatcher = StrMatcher.noneMatcher();\n \n     /** Whether to return empty tokens as null. */\n-    private boolean emptyAsNull = false;\n+    private boolean emptyAsNull;\n     /** Whether to ignore empty tokens. */\n     private boolean ignoreEmptyTokens = true;\n \n@@ -608,10 +609,10 @@ private void checkTokenized() {\n             if (chars == null) {\n                 // still call tokenize as subclass may do some work\n                 final List<String> split = tokenize(null, 0, 0);\n-                tokens = split.toArray(new String[split.size()]);\n+                tokens = split.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n             } else {\n                 final List<String> split = tokenize(chars, 0, chars.length);\n-                tokens = split.toArray(new String[split.size()]);\n+                tokens = split.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n             }\n         }\n     }\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/StringTokenizer.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\nimport org.junit.jupiter.api.Test;\n\npublic class StringTokenizerTest2 {\n\n    @Test\n    public void testCheckTokenizedWithNullChars() {\n        StringTokenizer tokenizer = new StringTokenizer();\n        tokenizer.checkTokenized();\n        assertEquals(0, tokenizer.size());\n        assertEquals(ArrayUtils.EMPTY_STRING_ARRAY, tokenizer.getTokenArray());\n    }\n\n    @Test\n    public void testCheckTokenizedWithEmptyChars() {\n        StringTokenizer tokenizer = new StringTokenizer(\"\");\n        tokenizer.checkTokenized();\n        assertEquals(1, tokenizer.size());\n        assertEquals(ArrayUtils.EMPTY_STRING_ARRAY, tokenizer.getTokenArray());\n    }\n\n    @Test\n    public void testCheckTokenizedWithNonEmptyChars() {\n        StringTokenizer tokenizer = new StringTokenizer(\"a b c\");\n        tokenizer.checkTokenized();\n        assertEquals(3, tokenizer.size());\n        assertEquals(new String[]{\"a\", \"b\", \"c\"}, tokenizer.getTokenArray());\n    }\n\n    @Test\n    public void testCheckTokenizedWithEmptyTokenAsNull() {\n        StringTokenizer tokenizer = new StringTokenizer(\"a b c\");\n        tokenizer.setEmptyTokenAsNull(true);\n        tokenizer.checkTokenized();\n        assertEquals(3, tokenizer.size());\n        assertEquals(new String[]{\"a\", \"b\", \"c\"}, tokenizer.getTokenArray());\n    }\n\n    @Test\n    public void testCheckTokenizedWithIgnoreEmptyTokens() {\n        StringTokenizer tokenizer = new StringTokenizer(\"a b c\");\n        tokenizer.setIgnoreEmptyTokens(true);\n        tokenizer.checkTokenized();\n        assertEquals(3, tokenizer.size());\n        assertEquals(new String[]{\"a\", \"b\", \"c\"}, tokenizer.getTokenArray());\n    }\n\n    @Test\n    public void testTokenizeWithNullSrcChars() {\n        StringTokenizer tokenizer = new StringTokenizer();\n        List<String> tokens = tokenizer.tokenize(null, 0, 0);\n        assertEquals(Collections.emptyList(), tokens);\n    }\n\n    @Test\n    public void testTokenizeWithEmptySrcChars() {\n        StringTokenizer tokenizer = new StringTokenizer(\"\");\n        List<String> tokens = tokenizer.tokenize(\"\".toCharArray(), 0, 0);\n        assertEquals(Collections.emptyList(), tokens);\n    }\n\n    @Test\n    public void testTokenizeWithNonEmptySrcChars() {\n        StringTokenizer tokenizer = new StringTokenizer(\"a b c\");\n        List<String> tokens = tokenizer.tokenize(\"a b c\".toCharArray(), 0, 5);\n        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), tokens);\n    }\n\n    @Test\n    public void testTokenizeWithEmptyTokenAsNull() {\n        StringTokenizer tokenizer = new StringTokenizer(\"a b c\");\n        tokenizer.setEmptyTokenAsNull(true);\n        List<String> tokens = tokenizer.tokenize(\"a b c\".toCharArray(), 0, 5);\n        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), tokens);\n    }\n\n    @Test\n    public void testTokenizeWithIgnoreEmptyTokens() {\n        StringTokenizer tokenizer = new StringTokenizer(\"a b c\");\n        tokenizer.setIgnoreEmptyTokens(true);\n        List<String> tokens = tokenizer.tokenize(\"a b c\".toCharArray(), 0, 5);\n        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), tokens);\n    }\n\n    @Test\n    public void testCloneReset() throws CloneNotSupportedException {\n        StringTokenizer tokenizer = new StringTokenizer(\"a b c\");\n        StringTokenizer clonedTokenizer = (StringTokenizer) tokenizer.cloneReset();\n        assertEquals(tokenizer.getTokenArray(), clonedTokenizer.getTokenArray());\n    }\n\n    @Test\n    public void testCloneResetWithNullChars() throws CloneNotSupportedException {\n        StringTokenizer tokenizer = new StringTokenizer();\n        StringTokenizer clonedTokenizer = (StringTokenizer) tokenizer.cloneReset();\n        assertNull(clonedTokenizer.getTokenArray());\n    }\n\n    @Test\n    public void testCloneResetWithEmptyChars() throws CloneNotSupportedException {\n        StringTokenizer tokenizer = new StringTokenizer(\"\");\n        StringTokenizer clonedTokenizer = (StringTokenizer) tokenizer.cloneReset();\n        assertEquals(tokenizer.getTokenArray(), clonedTokenizer.getTokenArray());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\n\n/**\n * Tokenizes a string based on delimiters (separators) and supporting quoting and ignored character concepts.\n * <p>\n * This class can split a String into many smaller strings. It aims to do a similar job to\n * {@link java.util.StringTokenizer StringTokenizer}, however it offers much more control and flexibility including\n * implementing the {@code ListIterator} interface. By default, it is set up like {@code StringTokenizer}.\n * <p>\n * The input String is split into a number of <i>tokens</i>. Each token is separated from the next String by a\n * <i>delimiter</i>. One or more delimiter characters must be specified.\n * <p>\n * Each token may be surrounded by quotes. The <i>quote</i> matcher specifies the quote character(s). A quote may be\n * escaped within a quoted section by duplicating itself.\n * <p>\n * Between each token and the delimiter are potentially characters that need trimming. The <i>trimmer</i> matcher\n * specifies these characters. One usage might be to trim whitespace characters.\n * <p>\n * At any point outside the quotes there might potentially be invalid characters. The <i>ignored</i> matcher specifies\n * these characters to be removed. One usage might be to remove new line characters.\n * <p>\n * Empty tokens may be removed or returned as null.\n *\n * <pre>\n * \"a,b,c\"         - Three tokens \"a\",\"b\",\"c\"   (comma delimiter)\n * \" a, b , c \"    - Three tokens \"a\",\"b\",\"c\"   (default CSV processing trims whitespace)\n * \"a, \", b ,\", c\" - Three tokens \"a, \" , \" b \", \", c\" (quoted text untouched)\n * </pre>\n *\n * <table>\n * <caption>StringTokenizer properties and options</caption>\n * <tr>\n * <th>Property</th>\n * <th>Type</th>\n * <th>Default</th>\n * </tr>\n * <tr>\n * <td>delim</td>\n * <td>CharSetMatcher</td>\n * <td>{ \\t\\n\\r\\f}</td>\n * </tr>\n * <tr>\n * <td>quote</td>\n * <td>NoneMatcher</td>\n * <td>{}</td>\n * </tr>\n * <tr>\n * <td>ignore</td>\n * <td>NoneMatcher</td>\n * <td>{}</td>\n * </tr>\n * <tr>\n * <td>emptyTokenAsNull</td>\n * <td>boolean</td>\n * <td>false</td>\n * </tr>\n * <tr>\n * <td>ignoreEmptyTokens</td>\n * <td>boolean</td>\n * <td>true</td>\n * </tr>\n * </table>\n *\n * @since 1.3\n */\npublic class StringTokenizer implements ListIterator<String>, Cloneable {\n\n    /** Comma separated values tokenizer internal variable. */\n    private static final StringTokenizer CSV_TOKENIZER_PROTOTYPE;\n    /** Tab separated values tokenizer internal variable. */\n    private static final StringTokenizer TSV_TOKENIZER_PROTOTYPE;\n    static {\n        CSV_TOKENIZER_PROTOTYPE = new StringTokenizer();\n        CSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StringMatcherFactory.INSTANCE.commaMatcher());\n        CSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StringMatcherFactory.INSTANCE.doubleQuoteMatcher());\n        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StringMatcherFactory.INSTANCE.noneMatcher());\n        CSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StringMatcherFactory.INSTANCE.trimMatcher());\n        CSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n        CSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n\n        TSV_TOKENIZER_PROTOTYPE = new StringTokenizer();\n        TSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StringMatcherFactory.INSTANCE.tabMatcher());\n        TSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StringMatcherFactory.INSTANCE.doubleQuoteMatcher());\n        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StringMatcherFactory.INSTANCE.noneMatcher());\n        TSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StringMatcherFactory.INSTANCE.trimMatcher());\n        TSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n        TSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n    }\n\n    /** The text to work on. */\n    private char[] chars;\n    /** The parsed tokens. */\n    private String[] tokens;\n    /** The current iteration position. */\n    private int tokenPos;\n\n    /** The delimiter matcher. */\n    private StringMatcher delimMatcher = StringMatcherFactory.INSTANCE.splitMatcher();\n    /** The quote matcher. */\n    private StringMatcher quoteMatcher = StringMatcherFactory.INSTANCE.noneMatcher();\n    /** The ignored matcher. */\n    private StringMatcher ignoredMatcher = StringMatcherFactory.INSTANCE.noneMatcher();\n    /** The trimmer matcher. */\n    private StringMatcher trimmerMatcher = StringMatcherFactory.INSTANCE.noneMatcher();\n\n    /** Whether to return empty tokens as null. */\n    private boolean emptyAsNull = false;\n    /** Whether to ignore empty tokens. */\n    private boolean ignoreEmptyTokens = true;\n\n    // -----------------------------------------------------------------------\n\n    /**\n     * Returns a clone of {@code CSV_TOKENIZER_PROTOTYPE}.\n     *\n     * @return a clone of {@code CSV_TOKENIZER_PROTOTYPE}.\n     */\n    private static StringTokenizer getCSVClone() {\n        return (StringTokenizer) CSV_TOKENIZER_PROTOTYPE.clone();\n    }\n\n    /**\n     * Gets a new tokenizer instance which parses Comma Separated Value strings initializing it with the given input.\n     * The default for CSV processing will be trim whitespace from both ends (which can be overridden with the\n     * setTrimmer method).\n     * <p>\n     * You must call a \"reset\" method to set the string which you want to parse.\n     *\n     * @return a new tokenizer instance which parses Comma Separated Value strings\n     */\n    public static StringTokenizer getCSVInstance() {\n        return getCSVClone();\n    }\n\n    /**\n     * Gets a new tokenizer instance which parses Comma Separated Value strings initializing it with the given input.\n     * The default for CSV processing will be trim whitespace from both ends (which can be overridden with the\n     * setTrimmer method).\n     *\n     * @param input\n     *            the text to parse\n     * @return a new tokenizer instance which parses Comma Separated Value strings\n     */\n    public static StringTokenizer getCSVInstance(final String input) {\n        final StringTokenizer tok = getCSVClone();\n        tok.reset(input);\n        return tok;\n    }\n\n    /**\n     * Gets a new tokenizer instance which parses Comma Separated Value strings initializing it with the given input.\n     * The default for CSV processing will be trim whitespace from both ends (which can be overridden with the\n     * setTrimmer method).\n     *\n     * @param input\n     *            the text to parse\n     * @return a new tokenizer instance which parses Comma Separated Value strings\n     */\n    public static StringTokenizer getCSVInstance(final char[] input) {\n        final StringTokenizer tok = getCSVClone();\n        tok.reset(input);\n        return tok;\n    }\n\n    /**\n     * Returns a clone of {@code TSV_TOKENIZER_PROTOTYPE}.\n     *\n     * @return a clone of {@code TSV_TOKENIZER_PROTOTYPE}.\n     */\n    private static StringTokenizer getTSVClone() {\n        return (StringTokenizer) TSV_TOKENIZER_PROTOTYPE.clone();\n    }\n\n    /**\n     * Gets a new tokenizer instance which parses Tab Separated Value strings. The default for CSV processing will be\n     * trim whitespace from both ends (which can be overridden with the setTrimmer method).\n     * <p>\n     * You must call a \"reset\" method to set the string which you want to parse.\n     *\n     * @return a new tokenizer instance which parses Tab Separated Value strings.\n     */\n    public static StringTokenizer getTSVInstance() {\n        return getTSVClone();\n    }\n\n    /**\n     * Gets a new tokenizer instance which parses Tab Separated Value strings. The default for CSV processing will be\n     * trim whitespace from both ends (which can be overridden with the setTrimmer method).\n     *\n     * @param input\n     *            the string to parse\n     * @return a new tokenizer instance which parses Tab Separated Value strings.\n     */\n    public static StringTokenizer getTSVInstance(final String input) {\n        final StringTokenizer tok = getTSVClone();\n        tok.reset(input);\n        return tok;\n    }\n\n    /**\n     * Gets a new tokenizer instance which parses Tab Separated Value strings. The default for CSV processing will be\n     * trim whitespace from both ends (which can be overridden with the setTrimmer method).\n     *\n     * @param input\n     *            the string to parse\n     * @return a new tokenizer instance which parses Tab Separated Value strings.\n     */\n    public static StringTokenizer getTSVInstance(final char[] input) {\n        final StringTokenizer tok = getTSVClone();\n        tok.reset(input);\n        return tok;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Constructs a tokenizer splitting on space, tab, newline and form feed as per StringTokenizer, but with no text to\n     * tokenize.\n     * <p>\n     * This constructor is normally used with {@link #reset(String)}.\n     */\n    public StringTokenizer() {\n        this.chars = null;\n    }\n\n    /**\n     * Constructs a tokenizer splitting on space, tab, newline and form feed as per StringTokenizer.\n     *\n     * @param input\n     *            the string which is to be parsed\n     */\n    public StringTokenizer(final String input) {\n        if (input != null) {\n            chars = input.toCharArray();\n        } else {\n            chars = null;\n        }\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified delimiter character.\n     *\n     * @param input\n     *            the string which is to be parsed\n     * @param delim\n     *            the field delimiter character\n     */\n    public StringTokenizer(final String input, final char delim) {\n        this(input);\n        setDelimiterChar(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified delimiter string.\n     *\n     * @param input\n     *            the string which is to be parsed\n     * @param delim\n     *            the field delimiter string\n     */\n    public StringTokenizer(final String input, final String delim) {\n        this(input);\n        setDelimiterString(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting using the specified delimiter matcher.\n     *\n     * @param input\n     *            the string which is to be parsed\n     * @param delim\n     *            the field delimiter matcher\n     */\n    public StringTokenizer(final String input, final StringMatcher delim) {\n        this(input);\n        setDelimiterMatcher(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified delimiter character and handling quotes using the specified\n     * quote character.\n     *\n     * @param input\n     *            the string which is to be parsed\n     * @param delim\n     *            the field delimiter character\n     * @param quote\n     *            the field quoted string character\n     */\n    public StringTokenizer(final String input, final char delim, final char quote) {\n        this(input, delim);\n        setQuoteChar(quote);\n    }\n\n    /**\n     * Constructs a tokenizer splitting using the specified delimiter matcher and handling quotes using the specified\n     * quote matcher.\n     *\n     * @param input\n     *            the string which is to be parsed\n     * @param delim\n     *            the field delimiter matcher\n     * @param quote\n     *            the field quoted string matcher\n     */\n    public StringTokenizer(final String input, final StringMatcher delim, final StringMatcher quote) {\n        this(input, delim);\n        setQuoteMatcher(quote);\n    }\n\n    /**\n     * Constructs a tokenizer splitting on space, tab, newline and form feed as per StringTokenizer.\n     *\n     * @param input\n     *            the string which is to be parsed, not cloned\n     */\n    public StringTokenizer(final char[] input) {\n        if (input == null) {\n            this.chars = null;\n        } else {\n            this.chars = input.clone();\n        }\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified character.\n     *\n     * @param input\n     *            the string which is to be parsed, not cloned\n     * @param delim\n     *            the field delimiter character\n     */\n    public StringTokenizer(final char[] input, final char delim) {\n        this(input);\n        setDelimiterChar(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified string.\n     *\n     * @param input\n     *            the string which is to be parsed, not cloned\n     * @param delim\n     *            the field delimiter string\n     */\n    public StringTokenizer(final char[] input, final String delim) {\n        this(input);\n        setDelimiterString(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting using the specified delimiter matcher.\n     *\n     * @param input\n     *            the string which is to be parsed, not cloned\n     * @param delim\n     *            the field delimiter matcher\n     */\n    public StringTokenizer(final char[] input, final StringMatcher delim) {\n        this(input);\n        setDelimiterMatcher(delim);\n    }\n\n    /**\n     * Constructs a tokenizer splitting on the specified delimiter character and handling quotes using the specified\n     * quote character.\n     *\n     * @param input\n     *            the string which is to be parsed, not cloned\n     * @param delim\n     *            the field delimiter character\n     * @param quote\n     *            the field quoted string character\n     */\n    public StringTokenizer(final char[] input, final char delim, final char quote) {\n        this(input, delim);\n        setQuoteChar(quote);\n    }\n\n    /**\n     * Constructs a tokenizer splitting using the specified delimiter matcher and handling quotes using the specified\n     * quote matcher.\n     *\n     * @param input\n     *            the string which is to be parsed, not cloned\n     * @param delim\n     *            the field delimiter character\n     * @param quote\n     *            the field quoted string character\n     */\n    public StringTokenizer(final char[] input, final StringMatcher delim, final StringMatcher quote) {\n        this(input, delim);\n        setQuoteMatcher(quote);\n    }\n\n    // API\n    // -----------------------------------------------------------------------\n    /**\n     * Gets the number of tokens found in the String.\n     *\n     * @return The number of matched tokens\n     */\n    public int size() {\n        checkTokenized();\n        return tokens.length;\n    }\n\n    /**\n     * Gets the next token from the String. Equivalent to {@link #next()} except it returns null rather than throwing\n     * {@link NoSuchElementException} when no tokens remain.\n     *\n     * @return The next sequential token, or null when no more tokens are found\n     */\n    public String nextToken() {\n        if (hasNext()) {\n            return tokens[tokenPos++];\n        }\n        return null;\n    }\n\n    /**\n     * Gets the previous token from the String.\n     *\n     * @return The previous sequential token, or null when no more tokens are found\n     */\n    public String previousToken() {\n        if (hasPrevious()) {\n            return tokens[--tokenPos];\n        }\n        return null;\n    }\n\n    /**\n     * Gets a copy of the full token list as an independent modifiable array.\n     *\n     * @return The tokens as a String array\n     */\n    public String[] getTokenArray() {\n        checkTokenized();\n        return tokens.clone();\n    }\n\n    /**\n     * Gets a copy of the full token list as an independent modifiable list.\n     *\n     * @return The tokens as a String array\n     */\n    public List<String> getTokenList() {\n        checkTokenized();\n        final List<String> list = new ArrayList<>(tokens.length);\n        Collections.addAll(list, tokens);\n\n        return list;\n    }\n\n    /**\n     * Resets this tokenizer, forgetting all parsing and iteration already completed.\n     * <p>\n     * This method allows the same tokenizer to be reused for the same String.\n     *\n     * @return this, to enable chaining\n     */\n    public StringTokenizer reset() {\n        tokenPos = 0;\n        tokens = null;\n        return this;\n    }\n\n    /**\n     * Reset this tokenizer, giving it a new input string to parse. In this manner you can re-use a tokenizer with the\n     * same settings on multiple input lines.\n     *\n     * @param input\n     *            the new string to tokenize, null sets no text to parse\n     * @return this, to enable chaining\n     */\n    public StringTokenizer reset(final String input) {\n        reset();\n        if (input != null) {\n            this.chars = input.toCharArray();\n        } else {\n            this.chars = null;\n        }\n        return this;\n    }\n\n    /**\n     * Reset this tokenizer, giving it a new input string to parse. In this manner you can re-use a tokenizer with the\n     * same settings on multiple input lines.\n     *\n     * @param input\n     *            the new character array to tokenize, not cloned, null sets no text to parse\n     * @return this, to enable chaining\n     */\n    public StringTokenizer reset(final char[] input) {\n        reset();\n        if (input != null) {\n            this.chars = input.clone();\n        } else {\n            this.chars = null;\n        }\n        return this;\n    }\n\n    // ListIterator\n    // -----------------------------------------------------------------------\n    /**\n     * Checks whether there are any more tokens.\n     *\n     * @return true if there are more tokens\n     */\n    @Override\n    public boolean hasNext() {\n        checkTokenized();\n        return tokenPos < tokens.length;\n    }\n\n    /**\n     * Gets the next token.\n     *\n     * @return The next String token\n     * @throws NoSuchElementException\n     *             if there are no more elements\n     */\n    @Override\n    public String next() {\n        if (hasNext()) {\n            return tokens[tokenPos++];\n        }\n        throw new NoSuchElementException();\n    }\n\n    /**\n     * Gets the index of the next token to return.\n     *\n     * @return The next token index\n     */\n    @Override\n    public int nextIndex() {\n        return tokenPos;\n    }\n\n    /**\n     * Checks whether there are any previous tokens that can be iterated to.\n     *\n     * @return true if there are previous tokens\n     */\n    @Override\n    public boolean hasPrevious() {\n        checkTokenized();\n        return tokenPos > 0;\n    }\n\n    /**\n     * Gets the token previous to the last returned token.\n     *\n     * @return The previous token\n     */\n    @Override\n    public String previous() {\n        if (hasPrevious()) {\n            return tokens[--tokenPos];\n        }\n        throw new NoSuchElementException();\n    }\n\n    /**\n     * Gets the index of the previous token.\n     *\n     * @return The previous token index\n     */\n    @Override\n    public int previousIndex() {\n        return tokenPos - 1;\n    }\n\n    /**\n     * Unsupported ListIterator operation.\n     *\n     * @throws UnsupportedOperationException\n     *             always\n     */\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove() is unsupported\");\n    }\n\n    /**\n     * Unsupported ListIterator operation.\n     *\n     * @param obj\n     *            this parameter ignored.\n     * @throws UnsupportedOperationException\n     *             always\n     */\n    @Override\n    public void set(final String obj) {\n        throw new UnsupportedOperationException(\"set() is unsupported\");\n    }\n\n    /**\n     * Unsupported ListIterator operation.\n     *\n     * @param obj\n     *            this parameter ignored.\n     * @throws UnsupportedOperationException\n     *             always\n     */\n    @Override\n    public void add(final String obj) {\n        throw new UnsupportedOperationException(\"add() is unsupported\");\n    }\n\n    // Implementation\n    // -----------------------------------------------------------------------\n    /**\n     * Checks if tokenization has been done, and if not then do it.\n     */\n    private void checkTokenized() {\n        if (tokens == null) {\n            if (chars == null) {\n                // still call tokenize as subclass may do some work\n                final List<String> split = tokenize(null, 0, 0);\n                tokens = split.toArray(new String[split.size()]);\n            } else {\n                final List<String> split = tokenize(chars, 0, chars.length);\n                tokens = split.toArray(new String[split.size()]);\n            }\n        }\n    }\n\n    /**\n     * Internal method to performs the tokenization.\n     * <p>\n     * Most users of this class do not need to call this method. This method will be called automatically by other\n     * (public) methods when required.\n     * <p>\n     * This method exists to allow subclasses to add code before or after the tokenization. For example, a subclass\n     * could alter the character array, offset or count to be parsed, or call the tokenizer multiple times on multiple\n     * strings. It is also be possible to filter the results.\n     * <p>\n     * {@code StrTokenizer} will always pass a zero offset and a count equal to the length of the array to this\n     * method, however a subclass may pass other values, or even an entirely different array.\n     *\n     * @param srcChars\n     *            the character array being tokenized, may be null\n     * @param offset\n     *            the start position within the character array, must be valid\n     * @param count\n     *            the number of characters to tokenize, must be valid\n     * @return The modifiable list of String tokens, unmodifiable if null array or zero count\n     */\n    protected List<String> tokenize(final char[] srcChars, final int offset, final int count) {\n        if (srcChars == null || count == 0) {\n            return Collections.emptyList();\n        }\n        final TextStringBuilder buf = new TextStringBuilder();\n        final List<String> tokenList = new ArrayList<>();\n        int pos = offset;\n\n        // loop around the entire buffer\n        while (pos >= 0 && pos < count) {\n            // find next token\n            pos = readNextToken(srcChars, pos, count, buf, tokenList);\n\n            // handle case where end of string is a delimiter\n            if (pos >= count) {\n                addToken(tokenList, StringUtils.EMPTY);\n            }\n        }\n        return tokenList;\n    }\n\n    /**\n     * Adds a token to a list, paying attention to the parameters we've set.\n     *\n     * @param list\n     *            the list to add to\n     * @param tok\n     *            the token to add\n     */\n    private void addToken(final List<String> list, String tok) {\n        if (tok == null || tok.length() == 0) {\n            if (isIgnoreEmptyTokens()) {\n                return;\n            }\n            if (isEmptyTokenAsNull()) {\n                tok = null;\n            }\n        }\n        list.add(tok);\n    }\n\n    /**\n     * Reads character by character through the String to get the next token.\n     *\n     * @param srcChars\n     *            the character array being tokenized\n     * @param start\n     *            the first character of field\n     * @param len\n     *            the length of the character array being tokenized\n     * @param workArea\n     *            a temporary work area\n     * @param tokenList\n     *            the list of parsed tokens\n     * @return The starting position of the next field (the character immediately after the delimiter), or -1 if end of\n     *         string found\n     */\n    private int readNextToken(final char[] srcChars, int start, final int len, final TextStringBuilder workArea,\n            final List<String> tokenList) {\n        // skip all leading whitespace, unless it is the\n        // field delimiter or the quote character\n        while (start < len) {\n            final int removeLen = Math.max(getIgnoredMatcher().isMatch(srcChars, start, start, len),\n                    getTrimmerMatcher().isMatch(srcChars, start, start, len));\n            if (removeLen == 0 || getDelimiterMatcher().isMatch(srcChars, start, start, len) > 0\n                    || getQuoteMatcher().isMatch(srcChars, start, start, len) > 0) {\n                break;\n            }\n            start += removeLen;\n        }\n\n        // handle reaching end\n        if (start >= len) {\n            addToken(tokenList, StringUtils.EMPTY);\n            return -1;\n        }\n\n        // handle empty token\n        final int delimLen = getDelimiterMatcher().isMatch(srcChars, start, start, len);\n        if (delimLen > 0) {\n            addToken(tokenList, StringUtils.EMPTY);\n            return start + delimLen;\n        }\n\n        // handle found token\n        final int quoteLen = getQuoteMatcher().isMatch(srcChars, start, start, len);\n        if (quoteLen > 0) {\n            return readWithQuotes(srcChars, start + quoteLen, len, workArea, tokenList, start, quoteLen);\n        }\n        return readWithQuotes(srcChars, start, len, workArea, tokenList, 0, 0);\n    }\n\n    /**\n     * Reads a possibly quoted string token.\n     *\n     * @param srcChars\n     *            the character array being tokenized\n     * @param start\n     *            the first character of field\n     * @param len\n     *            the length of the character array being tokenized\n     * @param workArea\n     *            a temporary work area\n     * @param tokenList\n     *            the list of parsed tokens\n     * @param quoteStart\n     *            the start position of the matched quote, 0 if no quoting\n     * @param quoteLen\n     *            the length of the matched quote, 0 if no quoting\n     * @return The starting position of the next field (the character immediately after the delimiter, or if end of\n     *         string found, then the length of string\n     */\n    private int readWithQuotes(final char[] srcChars, final int start, final int len, final TextStringBuilder workArea,\n            final List<String> tokenList, final int quoteStart, final int quoteLen) {\n        // Loop until we've found the end of the quoted\n        // string or the end of the input\n        workArea.clear();\n        int pos = start;\n        boolean quoting = quoteLen > 0;\n        int trimStart = 0;\n\n        while (pos < len) {\n            // quoting mode can occur several times throughout a string\n            // we must switch between quoting and non-quoting until we\n            // encounter a non-quoted delimiter, or end of string\n            if (quoting) {\n                // In quoting mode\n\n                // If we've found a quote character, see if it's\n                // followed by a second quote. If so, then we need\n                // to actually put the quote character into the token\n                // rather than end the token.\n                if (isQuote(srcChars, pos, len, quoteStart, quoteLen)) {\n                    if (isQuote(srcChars, pos + quoteLen, len, quoteStart, quoteLen)) {\n                        // matched pair of quotes, thus an escaped quote\n                        workArea.append(srcChars, pos, quoteLen);\n                        pos += quoteLen * 2;\n                        trimStart = workArea.size();\n                        continue;\n                    }\n\n                    // end of quoting\n                    quoting = false;\n                    pos += quoteLen;\n                    continue;\n                }\n\n                // copy regular character from inside quotes\n                workArea.append(srcChars[pos++]);\n                trimStart = workArea.size();\n\n            } else {\n                // Not in quoting mode\n\n                // check for delimiter, and thus end of token\n                final int delimLen = getDelimiterMatcher().isMatch(srcChars, pos, start, len);\n                if (delimLen > 0) {\n                    // return condition when end of token found\n                    addToken(tokenList, workArea.substring(0, trimStart));\n                    return pos + delimLen;\n                }\n\n                // check for quote, and thus back into quoting mode\n                if (quoteLen > 0 && isQuote(srcChars, pos, len, quoteStart, quoteLen)) {\n                    quoting = true;\n                    pos += quoteLen;\n                    continue;\n                }\n\n                // check for ignored (outside quotes), and ignore\n                final int ignoredLen = getIgnoredMatcher().isMatch(srcChars, pos, start, len);\n                if (ignoredLen > 0) {\n                    pos += ignoredLen;\n                    continue;\n                }\n\n                // check for trimmed character\n                // don't yet know if its at the end, so copy to workArea\n                // use trimStart to keep track of trim at the end\n                final int trimmedLen = getTrimmerMatcher().isMatch(srcChars, pos, start, len);\n                if (trimmedLen > 0) {\n                    workArea.append(srcChars, pos, trimmedLen);\n                    pos += trimmedLen;\n                    continue;\n                }\n\n                // copy regular character from outside quotes\n                workArea.append(srcChars[pos++]);\n                trimStart = workArea.size();\n            }\n        }\n\n        // return condition when end of string found\n        addToken(tokenList, workArea.substring(0, trimStart));\n        return -1;\n    }\n\n    /**\n     * Checks if the characters at the index specified match the quote already matched in readNextToken().\n     *\n     * @param srcChars\n     *            the character array being tokenized\n     * @param pos\n     *            the position to check for a quote\n     * @param len\n     *            the length of the character array being tokenized\n     * @param quoteStart\n     *            the start position of the matched quote, 0 if no quoting\n     * @param quoteLen\n     *            the length of the matched quote, 0 if no quoting\n     * @return true if a quote is matched\n     */\n    private boolean isQuote(final char[] srcChars, final int pos, final int len, final int quoteStart,\n            final int quoteLen) {\n        for (int i = 0; i < quoteLen; i++) {\n            if (pos + i >= len || srcChars[pos + i] != srcChars[quoteStart + i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Delimiter\n    // -----------------------------------------------------------------------\n    /**\n     * Gets the field delimiter matcher.\n     *\n     * @return The delimiter matcher in use\n     */\n    public StringMatcher getDelimiterMatcher() {\n        return this.delimMatcher;\n    }\n\n    /**\n     * Sets the field delimiter matcher.\n     * <p>\n     * The delimiter is used to separate one token from another.\n     *\n     * @param delim\n     *            the delimiter matcher to use\n     * @return this, to enable chaining\n     */\n    public StringTokenizer setDelimiterMatcher(final StringMatcher delim) {\n        if (delim == null) {\n            this.delimMatcher = StringMatcherFactory.INSTANCE.noneMatcher();\n        } else {\n            this.delimMatcher = delim;\n        }\n        return this;\n    }\n\n    /**\n     * Sets the field delimiter character.\n     *\n     * @param delim\n     *            the delimiter character to use\n     * @return this, to enable chaining\n     */\n    public StringTokenizer setDelimiterChar(final char delim) {\n        return setDelimiterMatcher(StringMatcherFactory.INSTANCE.charMatcher(delim));\n    }\n\n    /**\n     * Sets the field delimiter string.\n     *\n     * @param delim\n     *            the delimiter string to use\n     * @return this, to enable chaining\n     */\n    public StringTokenizer setDelimiterString(final String delim) {\n        return setDelimiterMatcher(StringMatcherFactory.INSTANCE.stringMatcher(delim));\n    }\n\n    // Quote\n    // -----------------------------------------------------------------------\n    /**\n     * Gets the quote matcher currently in use.\n     * <p>\n     * The quote character is used to wrap data between the tokens. This enables delimiters to be entered as data. The\n     * default value is '\"' (double quote).\n     *\n     * @return The quote matcher in use\n     */\n    public StringMatcher getQuoteMatcher() {\n        return quoteMatcher;\n    }\n\n    /**\n     * Set the quote matcher to use.\n     * <p>\n     * The quote character is used to wrap data between the tokens. This enables delimiters to be entered as data.\n     *\n     * @param quote\n     *            the quote matcher to use, null ignored\n     * @return this, to enable chaining\n     */\n    public StringTokenizer setQuoteMatcher(final StringMatcher quote) {\n        if (quote != null) {\n            this.quoteMatcher = quote;\n        }\n        return this;\n    }\n\n    /**\n     * Sets the quote character to use.\n     * <p>\n     * The quote character is used to wrap data between the tokens. This enables delimiters to be entered as data.\n     *\n     * @param quote\n     *            the quote character to use\n     * @return this, to enable chaining\n     */\n    public StringTokenizer setQuoteChar(final char quote) {\n        return setQuoteMatcher(StringMatcherFactory.INSTANCE.charMatcher(quote));\n    }\n\n    // Ignored\n    // -----------------------------------------------------------------------\n    /**\n     * Gets the ignored character matcher.\n     * <p>\n     * These characters are ignored when parsing the String, unless they are within a quoted region. The default value\n     * is not to ignore anything.\n     *\n     * @return The ignored matcher in use\n     */\n    public StringMatcher getIgnoredMatcher() {\n        return ignoredMatcher;\n    }\n\n    /**\n     * Set the matcher for characters to ignore.\n     * <p>\n     * These characters are ignored when parsing the String, unless they are within a quoted region.\n     *\n     * @param ignored\n     *            the ignored matcher to use, null ignored\n     * @return this, to enable chaining\n     */\n    public StringTokenizer setIgnoredMatcher(final StringMatcher ignored) {\n        if (ignored != null) {\n            this.ignoredMatcher = ignored;\n        }\n        return this;\n    }\n\n    /**\n     * Set the character to ignore.\n     * <p>\n     * This character is ignored when parsing the String, unless it is within a quoted region.\n     *\n     * @param ignored\n     *            the ignored character to use\n     * @return this, to enable chaining\n     */\n    public StringTokenizer setIgnoredChar(final char ignored) {\n        return setIgnoredMatcher(StringMatcherFactory.INSTANCE.charMatcher(ignored));\n    }\n\n    // Trimmer\n    // -----------------------------------------------------------------------\n    /**\n     * Gets the trimmer character matcher.\n     * <p>\n     * These characters are trimmed off on each side of the delimiter until the token or quote is found. The default\n     * value is not to trim anything.\n     *\n     * @return The trimmer matcher in use\n     */\n    public StringMatcher getTrimmerMatcher() {\n        return trimmerMatcher;\n    }\n\n    /**\n     * Sets the matcher for characters to trim.\n     * <p>\n     * These characters are trimmed off on each side of the delimiter until the token or quote is found.\n     *\n     * @param trimmer\n     *            the trimmer matcher to use, null ignored\n     * @return this, to enable chaining\n     */\n    public StringTokenizer setTrimmerMatcher(final StringMatcher trimmer) {\n        if (trimmer != null) {\n            this.trimmerMatcher = trimmer;\n        }\n        return this;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets whether the tokenizer currently returns empty tokens as null. The default for this property is false.\n     *\n     * @return true if empty tokens are returned as null\n     */\n    public boolean isEmptyTokenAsNull() {\n        return this.emptyAsNull;\n    }\n\n    /**\n     * Sets whether the tokenizer should return empty tokens as null. The default for this property is false.\n     *\n     * @param emptyAsNull\n     *            whether empty tokens are returned as null\n     * @return this, to enable chaining\n     */\n    public StringTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {\n        this.emptyAsNull = emptyAsNull;\n        return this;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets whether the tokenizer currently ignores empty tokens. The default for this property is true.\n     *\n     * @return true if empty tokens are not returned\n     */\n    public boolean isIgnoreEmptyTokens() {\n        return ignoreEmptyTokens;\n    }\n\n    /**\n     * Sets whether the tokenizer should ignore and not return empty tokens. The default for this property is true.\n     *\n     * @param ignoreEmptyTokens\n     *            whether empty tokens are not returned\n     * @return this, to enable chaining\n     */\n    public StringTokenizer setIgnoreEmptyTokens(final boolean ignoreEmptyTokens) {\n        this.ignoreEmptyTokens = ignoreEmptyTokens;\n        return this;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets the String content that the tokenizer is parsing.\n     *\n     * @return The string content being parsed\n     */\n    public String getContent() {\n        if (chars == null) {\n            return null;\n        }\n        return new String(chars);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Creates a new instance of this Tokenizer. The new instance is reset so that it will be at the start of the token\n     * list. If a {@link CloneNotSupportedException} is caught, return {@code null}.\n     *\n     * @return a new instance of this Tokenizer which has been reset.\n     */\n    @Override\n    public Object clone() {\n        try {\n            return cloneReset();\n        } catch (final CloneNotSupportedException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Creates a new instance of this Tokenizer. The new instance is reset so that it will be at the start of the token\n     * list.\n     *\n     * @return a new instance of this Tokenizer which has been reset.\n     * @throws CloneNotSupportedException\n     *             if there is a problem cloning\n     */\n    Object cloneReset() throws CloneNotSupportedException {\n        // this method exists to enable 100% test coverage\n        final StringTokenizer cloned = (StringTokenizer) super.clone();\n        if (cloned.chars != null) {\n            cloned.chars = cloned.chars.clone();\n        }\n        cloned.reset();\n        return cloned;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets the String content that the tokenizer is parsing.\n     *\n     * @return The string content being parsed\n     */\n    @Override\n    public String toString() {\n        if (tokens == null) {\n            return \"StringTokenizer[not tokenized yet]\";\n        }\n        return \"StringTokenizer\" + getTokenList();\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/StringTokenizer.java b/src/main/java/org/apache/commons/text/StringTokenizer.java\nindex 4c68606d53..e8520e26fe 100644\n--- a/src/main/java/org/apache/commons/text/StringTokenizer.java\n+++ b/src/main/java/org/apache/commons/text/StringTokenizer.java\n@@ -22,6 +22,7 @@\n import java.util.ListIterator;\n import java.util.NoSuchElementException;\n \n+import org.apache.commons.lang3.ArrayUtils;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.text.matcher.StringMatcher;\n import org.apache.commons.text.matcher.StringMatcherFactory;\n@@ -130,7 +131,7 @@ public class StringTokenizer implements ListIterator<String>, Cloneable {\n     private StringMatcher trimmerMatcher = StringMatcherFactory.INSTANCE.noneMatcher();\n \n     /** Whether to return empty tokens as null. */\n-    private boolean emptyAsNull = false;\n+    private boolean emptyAsNull;\n     /** Whether to ignore empty tokens. */\n     private boolean ignoreEmptyTokens = true;\n \n@@ -646,10 +647,10 @@ private void checkTokenized() {\n             if (chars == null) {\n                 // still call tokenize as subclass may do some work\n                 final List<String> split = tokenize(null, 0, 0);\n-                tokens = split.toArray(new String[split.size()]);\n+                tokens = split.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n             } else {\n                 final List<String> split = tokenize(chars, 0, chars.length);\n-                tokens = split.toArray(new String[split.size()]);\n+                tokens = split.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n             }\n         }\n     }\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/diff/ReplacementsFinderTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 192,
    "title": "Minor Improvements",
    "state": "closed",
    "created_at": "2020-12-20T07:18:48Z",
    "merge_commit_sha": "4d2a8b5102cf34a05bd26270aa4a8207a50e61c3",
    "base_sha": "fa366c88e3f70c367dd736b6fe2e38b7b66eddb3",
    "head_sha": "2aaf264b0c999f14bdbfe7e37382a0d7a00e58d6",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/AlphabetConverter.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AlphabetConverterTest2 {\n\n    private static Character[] lowerCaseEnglish = {' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};\n    private static Character[] englishAndNumbers = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c',\n            'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\n            'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n            'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' '};\n    private static Character[] lowerCaseEnglishAndNumbers = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a',\n            'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n            'w', 'x', 'y', 'z', ' '};\n    private static Character[] numbers = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n    private static Character[] binary = {'0', '1'};\n    private static Character[] hebrew = {'_', ' ', '\\u05e7', '\\u05e8', '\\u05d0', '\\u05d8', '\\u05d5', '\\u05df', '\\u05dd',\n            '\\u05e4', '\\u05e9', '\\u05d3', '\\u05d2', '\\u05db', '\\u05e2', '\\u05d9', '\\u05d7', '\\u05dc', '\\u05da',\n            '\\u05e3', '\\u05d6', '\\u05e1', '\\u05d1', '\\u05d4', '\\u05e0', '\\u05de', '\\u05e6', '\\u05ea', '\\u05e5'};\n    private static Character[] empty = {};\n    private static Integer[] unicode = {32, 35395, 35397, 36302, 36291, 35203, 35201, 35215, 35219, 35268, 97, 98, 99,\n            100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 1001, 1002, 1003, 1004, 1005};\n    private static Integer[] lowerCaseEnglishCodepoints = {32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,\n            108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122};\n    private static Integer[] doNotEncodeCodepoints = {32, 97, 98, 99};\n\n    @Test\n    public void testCreateConverterWithFinalEncodedLetterLength() {\n        // Test to ensure that the encodedLetterLength is correctly set as final\n        final AlphabetConverter ac = AlphabetConverter.createConverter(lowerCaseEnglishCodepoints, lowerCaseEnglishCodepoints, doNotEncodeCodepoints);\n        assertThat(ac.getEncodedCharLength()).isEqualTo(1);\n    }\n\n    @Test\n    public void testCreateConverterWithFinalEncodedLetterLengthAndEncoding() {\n        // Test to ensure that the encodedLetterLength is correctly set as final with different encoding\n        final AlphabetConverter ac = AlphabetConverter.createConverter(lowerCaseEnglishCodepoints, numbers, doNotEncodeCodepoints);\n        assertThat(ac.getEncodedCharLength()).isEqualTo(2);\n    }\n\n    @Test\n    public void testCreateConverterWithFinalEncodedLetterLengthAndEmptyDoNotEncode() {\n        // Test to ensure that the encodedLetterLength is correctly set as final with empty doNotEncode\n        final AlphabetConverter ac = AlphabetConverter.createConverter(lowerCaseEnglishCodepoints, numbers, empty);\n        assertThat(ac.getEncodedCharLength()).isEqualTo(2);\n    }\n\n    @Test\n    public void testCreateConverterWithFinalEncodedLetterLengthAndEmptyEncoding() {\n        // Test to ensure that the encodedLetterLength is correctly set as final with empty encoding\n        assertThatThrownBy(() -> {\n            AlphabetConverter.createConverter(lowerCaseEnglishCodepoints, empty, doNotEncodeCodepoints);\n        }).isInstanceOf(IllegalArgumentException.class).hasMessage(\n                \"Must have at least two encoding characters (excluding those in the 'do not encode' list), but has 0\");\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * <p>\n * Convert from one alphabet to another, with the possibility of leaving certain\n * characters unencoded.\n * </p>\n *\n * <p>\n * The target and do not encode languages must be in the Unicode BMP, but the\n * source language does not.\n * </p>\n *\n * <p>\n * The encoding will all be of a fixed length, except for the 'do not encode'\n * chars, which will be of length 1\n * </p>\n *\n * <h2>Sample usage</h2>\n *\n * <pre>\n * Character[] originals;   // a, b, c, d\n * Character[] encoding;    // 0, 1, d\n * Character[] doNotEncode; // d\n *\n * AlphabetConverter ac = AlphabetConverter.createConverterFromChars(originals,\n * encoding, doNotEncode);\n *\n * ac.encode(\"a\");    // 00\n * ac.encode(\"b\");    // 01\n * ac.encode(\"c\");    // 0d\n * ac.encode(\"d\");    // d\n * ac.encode(\"abcd\"); // 00010dd\n * </pre>\n *\n * <p>\n * #ThreadSafe# AlphabetConverter class methods are thread-safe as they do not\n * change internal state.\n * </p>\n *\n * @since 1.0\n *\n */\npublic final class AlphabetConverter {\n\n    /**\n     * Original string to be encoded.\n     */\n    private final Map<Integer, String> originalToEncoded;\n    /**\n     * Encoding alphabet.\n     */\n    private final Map<String, String> encodedToOriginal;\n    /**\n     * Length of the encoded letter.\n     */\n    private final int encodedLetterLength;\n    /**\n     * Arrow constant, used for converting the object into a string.\n     */\n    private static final String ARROW = \" -> \";\n\n    /**\n     * Hidden constructor for alphabet converter. Used by static helper methods.\n     *\n     * @param originalToEncoded original string to be encoded\n     * @param encodedToOriginal encoding alphabet\n     * @param encodedLetterLength length of the encoded letter\n     */\n    private AlphabetConverter(final Map<Integer, String> originalToEncoded,\n                              final Map<String, String> encodedToOriginal,\n                              final int encodedLetterLength) {\n\n        this.originalToEncoded = originalToEncoded;\n        this.encodedToOriginal = encodedToOriginal;\n        this.encodedLetterLength = encodedLetterLength;\n    }\n\n    /**\n     * Encode a given string.\n     *\n     * @param original the string to be encoded\n     * @return The encoded string, {@code null} if the given string is null\n     * @throws UnsupportedEncodingException if chars that are not supported are\n     *                                      encountered\n     */\n    public String encode(final String original)\n            throws UnsupportedEncodingException {\n        if (original == null) {\n            return null;\n        }\n\n        final StringBuilder sb = new StringBuilder();\n\n        for (int i = 0; i < original.length();) {\n            final int codepoint = original.codePointAt(i);\n\n            final String nextLetter = originalToEncoded.get(codepoint);\n\n            if (nextLetter == null) {\n                throw new UnsupportedEncodingException(\n                        \"Couldn't find encoding for '\"\n                                + codePointToString(codepoint)\n                                + \"' in \"\n                                + original\n                );\n            }\n\n            sb.append(nextLetter);\n\n            i += Character.charCount(codepoint);\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Decode a given string.\n     *\n     * @param encoded a string that has been encoded using this\n     *                AlphabetConverter\n     * @return The decoded string, {@code null} if the given string is null\n     * @throws UnsupportedEncodingException if unexpected characters that\n     *                                      cannot be handled are encountered\n     */\n    public String decode(final String encoded)\n            throws UnsupportedEncodingException {\n        if (encoded == null) {\n            return null;\n        }\n\n        final StringBuilder result = new StringBuilder();\n\n        for (int j = 0; j < encoded.length();) {\n            final int i = encoded.codePointAt(j);\n            final String s = codePointToString(i);\n\n            if (s.equals(originalToEncoded.get(i))) {\n                result.append(s);\n                j++; // because we do not encode in Unicode extended the\n                     // length of each encoded char is 1\n            } else {\n                if (j + encodedLetterLength > encoded.length()) {\n                    throw new UnsupportedEncodingException(\"Unexpected end \"\n                            + \"of string while decoding \" + encoded);\n                }\n                final String nextGroup = encoded.substring(j,\n                        j + encodedLetterLength);\n                final String next = encodedToOriginal.get(nextGroup);\n                if (next == null) {\n                    throw new UnsupportedEncodingException(\n                            \"Unexpected string without decoding (\"\n                                    + nextGroup + \") in \" + encoded);\n                }\n                result.append(next);\n                j += encodedLetterLength;\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Get the length of characters in the encoded alphabet that are necessary\n     * for each character in the original\n     * alphabet.\n     *\n     * @return The length of the encoded char\n     */\n    public int getEncodedCharLength() {\n        return encodedLetterLength;\n    }\n\n    /**\n     * Get the mapping from integer code point of source language to encoded\n     * string. Use to reconstruct converter from\n     * serialized map.\n     *\n     * @return The original map\n     */\n    public Map<Integer, String> getOriginalToEncoded() {\n        return Collections.unmodifiableMap(originalToEncoded);\n    }\n\n    /**\n     * Recursive method used when creating encoder/decoder.\n     *\n     * @param level at which point it should add a single encoding\n     * @param currentEncoding current encoding\n     * @param encoding letters encoding\n     * @param originals original values\n     * @param doNotEncodeMap map of values that should not be encoded\n     */\n    @SuppressWarnings(\"PMD\")\n    private void addSingleEncoding(final int level,\n                                   final String currentEncoding,\n                                   final Collection<Integer> encoding,\n                                   final Iterator<Integer> originals,\n                                   final Map<Integer, String> doNotEncodeMap) {\n\n        if (level > 0) {\n            for (final int encodingLetter : encoding) {\n                if (originals.hasNext()) {\n\n                    // this skips the doNotEncode chars if they are in the\n                    // leftmost place\n                    if (level != encodedLetterLength\n                            || !doNotEncodeMap.containsKey(encodingLetter)) {\n                        addSingleEncoding(level - 1,\n                                currentEncoding\n                                        + codePointToString(encodingLetter),\n                                encoding,\n                                originals,\n                                doNotEncodeMap\n                        );\n                    }\n                } else {\n                    return; // done encoding all the original alphabet\n                }\n            }\n        } else {\n            Integer next = originals.next();\n\n            while (doNotEncodeMap.containsKey(next)) {\n                final String originalLetterAsString = codePointToString(next);\n\n                originalToEncoded.put(next, originalLetterAsString);\n                encodedToOriginal.put(originalLetterAsString,\n                        originalLetterAsString);\n\n                if (!originals.hasNext()) {\n                    return;\n                }\n\n                next = originals.next();\n            }\n\n            final String originalLetterAsString = codePointToString(next);\n\n            originalToEncoded.put(next, currentEncoding);\n            encodedToOriginal.put(currentEncoding, originalLetterAsString);\n        }\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n\n        for (final Entry<Integer, String> entry\n                : originalToEncoded.entrySet()) {\n            sb.append(codePointToString(entry.getKey()))\n                    .append(ARROW)\n                    .append(entry.getValue()).append(System.lineSeparator());\n        }\n\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof AlphabetConverter)) {\n            return false;\n        }\n        final AlphabetConverter other = (AlphabetConverter) obj;\n        return originalToEncoded.equals(other.originalToEncoded)\n                && encodedToOriginal.equals(other.encodedToOriginal)\n                && encodedLetterLength == other.encodedLetterLength;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(originalToEncoded,\n                encodedToOriginal,\n                encodedLetterLength);\n    }\n\n    // -- static methods\n\n    /**\n     * Create a new converter from a map.\n     *\n     * @param originalToEncoded a map returned from getOriginalToEncoded()\n     * @return The reconstructed AlphabetConverter\n     * @see AlphabetConverter#getOriginalToEncoded()\n     */\n    public static AlphabetConverter createConverterFromMap(\n            final Map<Integer, String> originalToEncoded) {\n        final Map<Integer, String> unmodifiableOriginalToEncoded =\n                Collections.unmodifiableMap(originalToEncoded);\n        final Map<String, String> encodedToOriginal = new LinkedHashMap<>();\n\n        int encodedLetterLength = 1;\n\n        for (final Entry<Integer, String> e\n                : unmodifiableOriginalToEncoded.entrySet()) {\n            final String originalAsString = codePointToString(e.getKey());\n            encodedToOriginal.put(e.getValue(), originalAsString);\n\n            if (e.getValue().length() > encodedLetterLength) {\n                encodedLetterLength = e.getValue().length();\n            }\n        }\n\n        return new AlphabetConverter(unmodifiableOriginalToEncoded,\n                encodedToOriginal,\n                encodedLetterLength);\n    }\n\n    /**\n     * Create an alphabet converter, for converting from the original alphabet,\n     * to the encoded alphabet, while leaving the characters in\n     * <em>doNotEncode</em> as they are (if possible).\n     *\n     * <p>Duplicate letters in either original or encoding will be ignored.</p>\n     *\n     * @param original an array of chars representing the original alphabet\n     * @param encoding an array of chars representing the alphabet to be used\n     *                 for encoding\n     * @param doNotEncode an array of chars to be encoded using the original\n     *                    alphabet - every char here must appear in\n     *                    both the previous params\n     * @return The AlphabetConverter\n     * @throws IllegalArgumentException if an AlphabetConverter cannot be\n     *                                  constructed\n     */\n    public static AlphabetConverter createConverterFromChars(\n            final Character[] original,\n            final Character[] encoding,\n            final Character[] doNotEncode) {\n        return AlphabetConverter.createConverter(\n                convertCharsToIntegers(original),\n                convertCharsToIntegers(encoding),\n                convertCharsToIntegers(doNotEncode));\n    }\n\n    /**\n     * Convert characters to integers.\n     *\n     * @param chars array of characters\n     * @return an equivalent array of integers\n     */\n    private static Integer[] convertCharsToIntegers(final Character[] chars) {\n        if (ArrayUtils.isEmpty(chars)) {\n            return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] integers = new Integer[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            integers[i] = (int) chars[i];\n        }\n        return integers;\n    }\n\n    /**\n     * Create an alphabet converter, for converting from the original alphabet,\n     * to the encoded alphabet, while leaving\n     * the characters in <em>doNotEncode</em> as they are (if possible).\n     *\n     * <p>Duplicate letters in either original or encoding will be ignored.</p>\n     *\n     * @param original an array of ints representing the original alphabet in\n     *                 codepoints\n     * @param encoding an array of ints representing the alphabet to be used for\n     *                 encoding, in codepoints\n     * @param doNotEncode an array of ints representing the chars to be encoded\n     *                    using the original alphabet - every char\n     *                    here must appear in both the previous params\n     * @return The AlphabetConverter\n     * @throws IllegalArgumentException if an AlphabetConverter cannot be\n     *                                   constructed\n     */\n    public static AlphabetConverter createConverter(\n            final Integer[] original,\n            final Integer[] encoding,\n            final Integer[] doNotEncode) {\n        final Set<Integer> originalCopy = new LinkedHashSet<>(Arrays.asList(original));\n        final Set<Integer> encodingCopy = new LinkedHashSet<>(Arrays.asList(encoding));\n        final Set<Integer> doNotEncodeCopy = new LinkedHashSet<>(Arrays.asList(doNotEncode));\n\n        final Map<Integer, String> originalToEncoded = new LinkedHashMap<>();\n        final Map<String, String> encodedToOriginal = new LinkedHashMap<>();\n        final Map<Integer, String> doNotEncodeMap = new HashMap<>();\n\n        int encodedLetterLength;\n\n        for (final int i : doNotEncodeCopy) {\n            if (!originalCopy.contains(i)) {\n                throw new IllegalArgumentException(\n                        \"Can not use 'do not encode' list because original \"\n                                + \"alphabet does not contain '\"\n                                + codePointToString(i) + \"'\");\n            }\n\n            if (!encodingCopy.contains(i)) {\n                throw new IllegalArgumentException(\n                        \"Can not use 'do not encode' list because encoding alphabet does not contain '\"\n                                + codePointToString(i) + \"'\");\n            }\n\n            doNotEncodeMap.put(i, codePointToString(i));\n        }\n\n        if (encodingCopy.size() >= originalCopy.size()) {\n            encodedLetterLength = 1;\n\n            final Iterator<Integer> it = encodingCopy.iterator();\n\n            for (final int originalLetter : originalCopy) {\n                final String originalLetterAsString =\n                        codePointToString(originalLetter);\n\n                if (doNotEncodeMap.containsKey(originalLetter)) {\n                    originalToEncoded.put(originalLetter,\n                            originalLetterAsString);\n                    encodedToOriginal.put(originalLetterAsString,\n                            originalLetterAsString);\n                } else {\n                    Integer next = it.next();\n\n                    while (doNotEncodeCopy.contains(next)) {\n                        next = it.next();\n                    }\n\n                    final String encodedLetter = codePointToString(next);\n\n                    originalToEncoded.put(originalLetter, encodedLetter);\n                    encodedToOriginal.put(encodedLetter,\n                            originalLetterAsString);\n                }\n            }\n\n            return new AlphabetConverter(originalToEncoded,\n                    encodedToOriginal,\n                    encodedLetterLength);\n\n        } else if (encodingCopy.size() - doNotEncodeCopy.size() < 2) {\n            throw new IllegalArgumentException(\n                    \"Must have at least two encoding characters (excluding \"\n                            + \"those in the 'do not encode' list), but has \"\n                            + (encodingCopy.size() - doNotEncodeCopy.size()));\n        } else {\n            // we start with one which is our minimum, and because we do the\n            // first division outside the loop\n            int lettersSoFar = 1;\n\n            // the first division takes into account that the doNotEncode\n            // letters can't be in the leftmost place\n            int lettersLeft = (originalCopy.size() - doNotEncodeCopy.size())\n                    / (encodingCopy.size() - doNotEncodeCopy.size());\n\n            while (lettersLeft / encodingCopy.size() >= 1) {\n                lettersLeft = lettersLeft / encodingCopy.size();\n                lettersSoFar++;\n            }\n\n            encodedLetterLength = lettersSoFar + 1;\n\n            final AlphabetConverter ac =\n                    new AlphabetConverter(originalToEncoded,\n                            encodedToOriginal,\n                            encodedLetterLength);\n\n            ac.addSingleEncoding(encodedLetterLength,\n                    StringUtils.EMPTY,\n                    encodingCopy,\n                    originalCopy.iterator(),\n                    doNotEncodeMap);\n\n            return ac;\n        }\n    }\n\n    /**\n     * Create new String that contains just the given code point.\n     *\n     * @param i code point\n     * @return a new string with the new code point\n     * @see \"http://www.oracle.com/us/technologies/java/supplementary-142654.html\"\n     */\n    private static String codePointToString(final int i) {\n        if (Character.charCount(i) == 1) {\n            return String.valueOf((char) i);\n        }\n        return new String(Character.toChars(i));\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/AlphabetConverter.java b/src/main/java/org/apache/commons/text/AlphabetConverter.java\nindex be769395b0..e6ac7537ea 100644\n--- a/src/main/java/org/apache/commons/text/AlphabetConverter.java\n+++ b/src/main/java/org/apache/commons/text/AlphabetConverter.java\n@@ -418,7 +418,7 @@ public static AlphabetConverter createConverter(\n         final Map<String, String> encodedToOriginal = new LinkedHashMap<>();\n         final Map<Integer, String> doNotEncodeMap = new HashMap<>();\n \n-        int encodedLetterLength;\n+        final int encodedLetterLength;\n \n         for (final int i : doNotEncodeCopy) {\n             if (!originalCopy.contains(i)) {\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/RandomStringGenerator.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatNullPointerException;\nimport static org.assertj.core.api.Assertions.fail;\n\nimport org.junit.jupiter.api.Test;\n\npublic class RandomStringGeneratorTest2 {\n\n    private static final CharacterPredicate A_FILTER = codePoint -> codePoint == 'a';\n    private static final CharacterPredicate B_FILTER = codePoint -> codePoint == 'b';\n\n    private static int codePointLength(final String s) {\n        return s.codePointCount(0, s.length());\n    }\n\n    /**\n     * Test to ensure the final keyword does not affect the functionality of codePoint generation.\n     */\n    @Test\n    public void testGenerateWithFinalCodePoint() {\n        final RandomStringGenerator generator = new RandomStringGenerator.Builder().withinRange('a', 'z').build();\n        final String str = generator.generate(100);\n        assertThat(codePointLength(str)).isEqualTo(100);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\n\n/**\n * <p>\n * Generates random Unicode strings containing the specified number of code points.\n * Instances are created using a builder class, which allows the\n * callers to define the properties of the generator. See the documentation for the\n * {@link Builder} class to see available properties.\n * </p>\n * <pre>\n * // Generates a 20 code point string, using only the letters a-z\n * RandomStringGenerator generator = new RandomStringGenerator.Builder()\n *     .withinRange('a', 'z').build();\n * String randomLetters = generator.generate(20);\n * </pre>\n * <pre>\n * // Using Apache Commons RNG for randomness\n * UniformRandomProvider rng = RandomSource.create(...);\n * // Generates a 20 code point string, using only the letters a-z\n * RandomStringGenerator generator = new RandomStringGenerator.Builder()\n *     .withinRange('a', 'z')\n *     .usingRandom(rng::nextInt) // uses Java 8 syntax\n *     .build();\n * String randomLetters = generator.generate(20);\n * </pre>\n * <p>\n * {@code RandomStringGenerator} instances are thread-safe when using the\n * default random number generator (RNG). If a custom RNG is set by calling the method\n * {@link Builder#usingRandom(TextRandomProvider) Builder.usingRandom(TextRandomProvider)}, thread-safety\n * must be ensured externally.\n * </p>\n * @since 1.1\n */\npublic final class RandomStringGenerator {\n\n    /**\n     * The smallest allowed code point (inclusive).\n     */\n    private final int minimumCodePoint;\n\n    /**\n     * The largest allowed code point (inclusive).\n     */\n    private final int maximumCodePoint;\n\n    /**\n     * Filters for code points.\n     */\n    private final Set<CharacterPredicate> inclusivePredicates;\n\n    /**\n     * The source of randomness for this generator.\n     */\n    private final TextRandomProvider random;\n\n    /**\n     * The source of provided characters.\n     */\n    private final List<Character> characterList;\n\n    /**\n     * Constructs the generator.\n     *\n     * @param minimumCodePoint\n     *            smallest allowed code point (inclusive)\n     * @param maximumCodePoint\n     *            largest allowed code point (inclusive)\n     * @param inclusivePredicates\n     *            filters for code points\n     * @param random\n     *            source of randomness\n     * @param characterList list of predefined set of characters.\n     */\n    private RandomStringGenerator(final int minimumCodePoint, final int maximumCodePoint,\n                                  final Set<CharacterPredicate> inclusivePredicates, final TextRandomProvider random,\n                                  final List<Character> characterList) {\n        this.minimumCodePoint = minimumCodePoint;\n        this.maximumCodePoint = maximumCodePoint;\n        this.inclusivePredicates = inclusivePredicates;\n        this.random = random;\n        this.characterList = characterList;\n    }\n\n    /**\n     * Generates a random number within a range, using a {@link ThreadLocalRandom} instance\n     * or the user-supplied source of randomness.\n     *\n     * @param minInclusive\n     *            the minimum value allowed\n     * @param maxInclusive\n     *            the maximum value allowed\n     * @return The random number.\n     */\n    private int generateRandomNumber(final int minInclusive, final int maxInclusive) {\n        if (random != null) {\n            return random.nextInt(maxInclusive - minInclusive + 1) + minInclusive;\n        }\n        return ThreadLocalRandom.current().nextInt(minInclusive, maxInclusive + 1);\n    }\n\n    /**\n     * Generates a random number within a range, using a {@link ThreadLocalRandom} instance\n     * or the user-supplied source of randomness.\n     *\n     * @param characterList predefined char list.\n     * @return The random number.\n     */\n    private int generateRandomNumber(final List<Character> characterList) {\n        final int listSize = characterList.size();\n        if (random != null) {\n            return String.valueOf(characterList.get(random.nextInt(listSize))).codePointAt(0);\n        }\n        return String.valueOf(characterList.get(ThreadLocalRandom.current().nextInt(0, listSize))).codePointAt(0);\n    }\n\n    /**\n     * <p>\n     * Generates a random string, containing the specified number of code points.\n     * </p>\n     * <p>Code points are randomly selected between the minimum and maximum values defined\n     * in the generator.\n     * Surrogate and private use characters are not returned, although the\n     * resulting string may contain pairs of surrogates that together encode a\n     * supplementary character.\n     * </p>\n     * <p>\n     * Note: the number of {@code char} code units generated will exceed\n     * {@code length} if the string contains supplementary characters. See the\n     * {@link Character} documentation to understand how Java stores Unicode\n     * values.\n     * </p>\n     *\n     * @param length\n     *            the number of code points to generate\n     * @return The generated string\n     * @throws IllegalArgumentException\n     *             if {@code length < 0}\n     */\n    public String generate(final int length) {\n        if (length == 0) {\n            return StringUtils.EMPTY;\n        }\n        Validate.isTrue(length > 0, \"Length %d is smaller than zero.\", length);\n\n        final StringBuilder builder = new StringBuilder(length);\n        long remaining = length;\n\n        do {\n            int codePoint;\n            if (characterList != null && !characterList.isEmpty()) {\n                codePoint = generateRandomNumber(characterList);\n            } else {\n                codePoint = generateRandomNumber(minimumCodePoint, maximumCodePoint);\n            }\n            switch (Character.getType(codePoint)) {\n            case Character.UNASSIGNED:\n            case Character.PRIVATE_USE:\n            case Character.SURROGATE:\n                continue;\n            default:\n            }\n\n            if (inclusivePredicates != null) {\n                boolean matchedFilter = false;\n                for (final CharacterPredicate predicate : inclusivePredicates) {\n                    if (predicate.test(codePoint)) {\n                        matchedFilter = true;\n                        break;\n                    }\n                }\n                if (!matchedFilter) {\n                    continue;\n                }\n            }\n\n            builder.appendCodePoint(codePoint);\n            remaining--;\n\n        } while (remaining != 0);\n\n        return builder.toString();\n    }\n\n    /**\n     * Generates a random string, containing between the minimum (inclusive) and the maximum (inclusive)\n     * number of code points.\n     *\n     * @param minLengthInclusive\n     *            the minimum (inclusive) number of code points to generate\n     * @param maxLengthInclusive\n     *            the maximum (inclusive) number of code points to generate\n     * @return The generated string\n     * @throws IllegalArgumentException\n     *             if {@code minLengthInclusive < 0}, or {@code maxLengthInclusive < minLengthInclusive}\n     * @see RandomStringGenerator#generate(int)\n     * @since 1.2\n     */\n    public String generate(final int minLengthInclusive, final int maxLengthInclusive) {\n        Validate.isTrue(minLengthInclusive >= 0, \"Minimum length %d is smaller than zero.\", minLengthInclusive);\n        Validate.isTrue(minLengthInclusive <= maxLengthInclusive,\n                \"Maximum length %d is smaller than minimum length %d.\", maxLengthInclusive, minLengthInclusive);\n        return generate(generateRandomNumber(minLengthInclusive, maxLengthInclusive));\n    }\n\n    /**\n     * <p>A builder for generating {@code RandomStringGenerator} instances.</p>\n     * <p>The behavior of a generator is controlled by properties set by this\n     * builder. Each property has a default value, which can be overridden by\n     * calling the methods defined in this class, prior to calling {@link #build()}.</p>\n     *\n     * <p>All the property setting methods return the {@code Builder} instance to allow for method chaining.</p>\n     *\n     * <p>The minimum and maximum code point values are defined using {@link #withinRange(int, int)}. The\n     * default values are {@code 0} and {@link Character#MAX_CODE_POINT} respectively.</p>\n     *\n     * <p>The source of randomness can be set using {@link #usingRandom(TextRandomProvider)},\n     * otherwise {@link ThreadLocalRandom} is used.</p>\n     *\n     * <p>The type of code points returned can be filtered using {@link #filteredBy(CharacterPredicate...)},\n     * which defines a collection of tests that are applied to the randomly generated code points.\n     * The code points will only be included in the result if they pass at least one of the tests.\n     * Some commonly used predicates are provided by the {@link CharacterPredicates} enum.</p>\n     *\n     * <p>This class is not thread safe.</p>\n     * @since 1.1\n     */\n    public static class Builder implements org.apache.commons.text.Builder<RandomStringGenerator> {\n\n        /**\n         * The default maximum code point allowed: {@link Character#MAX_CODE_POINT}\n         * ({@value}).\n         */\n        public static final int DEFAULT_MAXIMUM_CODE_POINT = Character.MAX_CODE_POINT;\n\n        /**\n         * The default string length produced by this builder: {@value}.\n         */\n        public static final int DEFAULT_LENGTH = 0;\n\n        /**\n         * The default minimum code point allowed: {@value}.\n         */\n        public static final int DEFAULT_MINIMUM_CODE_POINT = 0;\n\n        /**\n         * The minimum code point allowed.\n         */\n        private int minimumCodePoint = DEFAULT_MINIMUM_CODE_POINT;\n\n        /**\n         * The maximum code point allowed.\n         */\n        private int maximumCodePoint = DEFAULT_MAXIMUM_CODE_POINT;\n\n        /**\n         * Filters for code points.\n         */\n        private Set<CharacterPredicate> inclusivePredicates;\n\n        /**\n         * The source of randomness.\n         */\n        private TextRandomProvider random;\n\n        /**\n         * The source of provided characters.\n         */\n        private List<Character> characterList;\n\n        /**\n         * <p>\n         * Specifies the minimum and maximum code points allowed in the\n         * generated string.\n         * </p>\n         *\n         * @param minimumCodePoint\n         *            the smallest code point allowed (inclusive)\n         * @param maximumCodePoint\n         *            the largest code point allowed (inclusive)\n         * @return {@code this}, to allow method chaining\n         * @throws IllegalArgumentException\n         *             if {@code maximumCodePoint >}\n         *             {@link Character#MAX_CODE_POINT}\n         * @throws IllegalArgumentException\n         *             if {@code minimumCodePoint < 0}\n         * @throws IllegalArgumentException\n         *             if {@code minimumCodePoint > maximumCodePoint}\n         */\n        public Builder withinRange(final int minimumCodePoint, final int maximumCodePoint) {\n            Validate.isTrue(minimumCodePoint <= maximumCodePoint,\n                    \"Minimum code point %d is larger than maximum code point %d\", minimumCodePoint, maximumCodePoint);\n            Validate.isTrue(minimumCodePoint >= 0, \"Minimum code point %d is negative\", minimumCodePoint);\n            Validate.isTrue(maximumCodePoint <= Character.MAX_CODE_POINT,\n                    \"Value %d is larger than Character.MAX_CODE_POINT.\", maximumCodePoint);\n\n            this.minimumCodePoint = minimumCodePoint;\n            this.maximumCodePoint = maximumCodePoint;\n            return this;\n        }\n\n        /**\n         * <p>\n         * Specifies the array of minimum and maximum char allowed in the\n         * generated string.\n         * </p>\n         *\n         * For example:\n         * <pre>\n         * {@code\n         *     char [][] pairs = {{'0','9'}};\n         *     char [][] pairs = {{'a','z'}};\n         *     char [][] pairs = {{'a','z'},{'0','9'}};\n         * }\n         * </pre>\n         *\n         * @param pairs array of characters array, expected is to pass min, max pairs through this arg.\n         * @return {@code this}, to allow method chaining.\n         */\n        public Builder withinRange(final char[]... pairs) {\n            characterList = new ArrayList<>();\n            for (final char[] pair :  pairs) {\n                Validate.isTrue(pair.length == 2,\n                      \"Each pair must contain minimum and maximum code point\");\n                final int minimumCodePoint = pair[0];\n                final int maximumCodePoint = pair[1];\n                Validate.isTrue(minimumCodePoint <= maximumCodePoint,\n                    \"Minimum code point %d is larger than maximum code point %d\", minimumCodePoint, maximumCodePoint);\n\n                for (int index = minimumCodePoint; index <= maximumCodePoint; index++) {\n                    characterList.add((char) index);\n                }\n            }\n            return this;\n\n        }\n\n        /**\n         * <p>\n         * Limits the characters in the generated string to those that match at\n         * least one of the predicates supplied.\n         * </p>\n         *\n         * <p>\n         * Passing {@code null} or an empty array to this method will revert to the\n         * default behavior of allowing any character. Multiple calls to this\n         * method will replace the previously stored predicates.\n         * </p>\n         *\n         * @param predicates\n         *            the predicates, may be {@code null} or empty\n         * @return {@code this}, to allow method chaining\n         */\n        public Builder filteredBy(final CharacterPredicate... predicates) {\n            if (ArrayUtils.isEmpty(predicates)) {\n                inclusivePredicates = null;\n                return this;\n            }\n\n            if (inclusivePredicates == null) {\n                inclusivePredicates = new HashSet<>();\n            } else {\n                inclusivePredicates.clear();\n            }\n\n            Collections.addAll(inclusivePredicates, predicates);\n\n            return this;\n        }\n\n        /**\n         * <p>\n         * Overrides the default source of randomness.  It is highly\n         * recommended that a random number generator library like\n         * <a href=\"https://commons.apache.org/proper/commons-rng/\">Apache Commons RNG</a>\n         * be used to provide the random number generation.\n         * </p>\n         *\n         * <p>\n         * When using Java 8 or later, {@link TextRandomProvider} is a\n         * functional interface and need not be explicitly implemented:\n         * </p>\n         * <pre>\n         * {@code\n         *     UniformRandomProvider rng = RandomSource.create(...);\n         *     RandomStringGenerator gen = new RandomStringGenerator.Builder()\n         *         .usingRandom(rng::nextInt)\n         *         // additional builder calls as needed\n         *         .build();\n         * }\n         * </pre>\n         *\n         * <p>\n         * Passing {@code null} to this method will revert to the default source of\n         * randomness.\n         * </p>\n         *\n         * @param random\n         *            the source of randomness, may be {@code null}\n         * @return {@code this}, to allow method chaining\n         */\n        public Builder usingRandom(final TextRandomProvider random) {\n            this.random = random;\n            return this;\n        }\n\n        /**\n         * <p>\n         * Limits the characters in the generated string to those who match at\n         * supplied list of Character.\n         * </p>\n         *\n         * <p>\n         * Passing {@code null} or an empty array to this method will revert to the\n         * default behavior of allowing any character. Multiple calls to this\n         * method will replace the previously stored Character.\n         * </p>\n         *\n         * @param chars set of predefined Characters for random string generation\n         *            the Character can be, may be {@code null} or empty\n         * @return {@code this}, to allow method chaining\n         * @since 1.2\n         */\n        public Builder selectFrom(final char... chars) {\n            characterList = new ArrayList<>();\n            for (final char c : chars) {\n                characterList.add(c);\n            }\n            return this;\n        }\n\n        /**\n         * <p>Builds the {@code RandomStringGenerator} using the properties specified.</p>\n         * @return The configured {@code RandomStringGenerator}\n         */\n        @Override\n        public RandomStringGenerator build() {\n            return new RandomStringGenerator(minimumCodePoint, maximumCodePoint, inclusivePredicates,\n                    random, characterList);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/RandomStringGenerator.java b/src/main/java/org/apache/commons/text/RandomStringGenerator.java\nindex d8e38e4614..3a36e5d3b9 100644\n--- a/src/main/java/org/apache/commons/text/RandomStringGenerator.java\n+++ b/src/main/java/org/apache/commons/text/RandomStringGenerator.java\n@@ -173,7 +173,7 @@ public String generate(final int length) {\n         long remaining = length;\n \n         do {\n-            int codePoint;\n+            final int codePoint;\n             if (characterList != null && !characterList.isEmpty()) {\n                 codePoint = generateRandomNumber(characterList);\n             } else {\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/CosineSimilarity.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.within;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class CosineSimilarityTest2 {\n\n    @Test\n    public void testCosineSimilarityWithPositiveValues() {\n        final CosineSimilarity cosineSimilarity = new CosineSimilarity();\n        final Map<CharSequence, Integer> leftVector = new HashMap<>();\n        leftVector.put(\"a\", 1);\n        leftVector.put(\"b\", 2);\n        final Map<CharSequence, Integer> rightVector = new HashMap<>();\n        rightVector.put(\"a\", 2);\n        rightVector.put(\"b\", 3);\n        assertThat(cosineSimilarity.cosineSimilarity(leftVector, rightVector)).isCloseTo(0.9926, within(0.0001));\n    }\n\n    @Test\n    public void testCosineSimilarityWithNegativeValues() {\n        final CosineSimilarity cosineSimilarity = new CosineSimilarity();\n        final Map<CharSequence, Integer> leftVector = new HashMap<>();\n        leftVector.put(\"a\", -1);\n        leftVector.put(\"b\", -2);\n        final Map<CharSequence, Integer> rightVector = new HashMap<>();\n        rightVector.put(\"a\", -2);\n        rightVector.put(\"b\", -3);\n        assertThat(cosineSimilarity.cosineSimilarity(leftVector, rightVector)).isCloseTo(0.9926, within(0.0001));\n    }\n\n    @Test\n    public void testCosineSimilarityWithMixedValues() {\n        final CosineSimilarity cosineSimilarity = new CosineSimilarity();\n        final Map<CharSequence, Integer> leftVector = new HashMap<>();\n        leftVector.put(\"a\", 1);\n        leftVector.put(\"b\", -2);\n        final Map<CharSequence, Integer> rightVector = new HashMap<>();\n        rightVector.put(\"a\", -2);\n        rightVector.put(\"b\", 3);\n        assertThat(cosineSimilarity.cosineSimilarity(leftVector, rightVector)).isCloseTo(-0.8, within(0.0001));\n    }\n\n    @Test\n    public void testCosineSimilarityWithZeroValues() {\n        final CosineSimilarity cosineSimilarity = new CosineSimilarity();\n        final Map<CharSequence, Integer> leftVector = new HashMap<>();\n        leftVector.put(\"a\", 0);\n        leftVector.put(\"b\", 0);\n        final Map<CharSequence, Integer> rightVector = new HashMap<>();\n        rightVector.put(\"a\", 0);\n        rightVector.put(\"b\", 0);\n        assertThat(cosineSimilarity.cosineSimilarity(leftVector, rightVector)).isEqualTo(0.0, within(0.01));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Measures the Cosine similarity of two vectors of an inner product space and\n * compares the angle between them.\n *\n * <p>\n * For further explanation about the Cosine Similarity, refer to\n * http://en.wikipedia.org/wiki/Cosine_similarity.\n * </p>\n *\n * @since 1.0\n */\npublic class CosineSimilarity {\n\n    /**\n     * Calculates the cosine similarity for two given vectors.\n     *\n     * @param leftVector left vector\n     * @param rightVector right vector\n     * @return cosine similarity between the two vectors\n     */\n    public Double cosineSimilarity(final Map<CharSequence, Integer> leftVector,\n                                   final Map<CharSequence, Integer> rightVector) {\n        if (leftVector == null || rightVector == null) {\n            throw new IllegalArgumentException(\"Vectors must not be null\");\n        }\n\n        final Set<CharSequence> intersection = getIntersection(leftVector, rightVector);\n\n        final double dotProduct = dot(leftVector, rightVector, intersection);\n        double d1 = 0.0d;\n        for (final Integer value : leftVector.values()) {\n            d1 += Math.pow(value, 2);\n        }\n        double d2 = 0.0d;\n        for (final Integer value : rightVector.values()) {\n            d2 += Math.pow(value, 2);\n        }\n        double cosineSimilarity;\n        if (d1 <= 0.0 || d2 <= 0.0) {\n            cosineSimilarity = 0.0;\n        } else {\n            cosineSimilarity = dotProduct / (Math.sqrt(d1) * Math.sqrt(d2));\n        }\n        return cosineSimilarity;\n    }\n\n    /**\n     * Returns a set with strings common to the two given maps.\n     *\n     * @param leftVector left vector map\n     * @param rightVector right vector map\n     * @return common strings\n     */\n    private Set<CharSequence> getIntersection(final Map<CharSequence, Integer> leftVector,\n            final Map<CharSequence, Integer> rightVector) {\n        final Set<CharSequence> intersection = new HashSet<>(leftVector.keySet());\n        intersection.retainAll(rightVector.keySet());\n        return intersection;\n    }\n\n    /**\n     * Computes the dot product of two vectors. It ignores remaining elements. It means\n     * that if a vector is longer than other, then a smaller part of it will be used to compute\n     * the dot product.\n     *\n     * @param leftVector left vector\n     * @param rightVector right vector\n     * @param intersection common elements\n     * @return The dot product\n     */\n    private double dot(final Map<CharSequence, Integer> leftVector, final Map<CharSequence, Integer> rightVector,\n            final Set<CharSequence> intersection) {\n        long dotProduct = 0;\n        for (final CharSequence key : intersection) {\n            dotProduct += leftVector.get(key) * (long) rightVector.get(key);\n        }\n        return dotProduct;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/CosineSimilarity.java b/src/main/java/org/apache/commons/text/similarity/CosineSimilarity.java\nindex 21550f2eec..57eb25f5db 100644\n--- a/src/main/java/org/apache/commons/text/similarity/CosineSimilarity.java\n+++ b/src/main/java/org/apache/commons/text/similarity/CosineSimilarity.java\n@@ -57,7 +57,7 @@ public Double cosineSimilarity(final Map<CharSequence, Integer> leftVector,\n         for (final Integer value : rightVector.values()) {\n             d2 += Math.pow(value, 2);\n         }\n-        double cosineSimilarity;\n+        final double cosineSimilarity;\n         if (d1 <= 0.0 || d2 <= 0.0) {\n             cosineSimilarity = 0.0;\n         } else {\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/IntersectionSimilarity.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\n\npublic class IntersectionSimilarityTest2 {\n\n    @Test\n    public void testIntersectionUsingSetCharacter() {\n        final IntersectionSimilarity<Character> similarity =\n            new IntersectionSimilarity<>(IntersectionSimilarityTest2::toCharacterSet);\n        assertIntersection(similarity, \"\", \"\", 0, 0, 0);\n        assertIntersection(similarity, \"a\", \"\", 1, 0, 0);\n        assertIntersection(similarity, \"a\", \"a\", 1, 1, 1);\n        assertIntersection(similarity, \"a\", \"b\", 1, 1, 0);\n        assertIntersection(similarity, \"aa\", \"ab\", 1, 2, 1);\n        assertIntersection(similarity, \"ab\", \"ab\", 2, 2, 2);\n        assertIntersection(similarity, \"aaba\", \"abaa\", 2, 2, 2);\n        assertIntersection(similarity, \"aaaa\", \"aa\", 1, 1, 1);\n        assertIntersection(similarity, \"aa\", \"aaaa\", 1, 1, 1);\n        assertIntersection(similarity, \"aaaa\", \"aaa\", 1, 1, 1);\n        assertIntersection(similarity, \"aabab\", \"ababa\", 2, 2, 2);\n        assertIntersection(similarity, \"the same\", \"the same\", 7, 7, 7);\n        assertIntersection(similarity, \"abcdefghijklm\", \"ab_defg ijklm\", 13, 13, 11);\n    }\n\n    private static Set<Character> toCharacterSet(final CharSequence sequence) {\n        final int length = sequence.length();\n        final Set<Character> set = new HashSet<>(length);\n        for (int i = 0; i < length; i++) {\n            set.add(sequence.charAt(i));\n        }\n        return set;\n    }\n\n    private static <T> void assertIntersection(final IntersectionSimilarity<T> similarity,\n                                               final CharSequence cs1, final CharSequence cs2, final int sizeA, final int sizeB, final int intersection) {\n        final IntersectionResult result = similarity.apply(cs1, cs2);\n        assertEquals(sizeA, result.getSizeA(), \"Size A error\");\n        assertEquals(sizeB, result.getSizeB(), \"Size B error\");\n        assertEquals(intersection, result.getIntersection(), \"Intersection error\");\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.function.Function;\n\n/**\n * Measures the intersection of two sets created from a pair of character sequences.\n *\n * <p>It is assumed that the type {@code T} correctly conforms to the requirements for storage\n * within a {@link Set} or {@link HashMap}. Ideally the type is immutable and implements\n * {@link Object#equals(Object)} and {@link Object#hashCode()}.</p>\n *\n * @param <T> the type of the elements extracted from the character sequence\n * @since 1.7\n * @see Set\n * @see HashMap\n */\npublic class IntersectionSimilarity<T> implements SimilarityScore<IntersectionResult> {\n    /** The converter used to create the elements from the characters. */\n    private final Function<CharSequence, Collection<T>> converter;\n\n    // The following is adapted from commons-collections for a Bag.\n    // A Bag is a collection that can store the count of the number\n    // of copies of each element.\n\n    /**\n     * Mutable counter class for storing the count of elements.\n     */\n    private static class BagCount {\n        /** The count. This is initialised to 1 upon construction. */\n        int count = 1;\n    }\n\n    /**\n     * A minimal implementation of a Bag that can store elements and a count.\n     *\n     * <p>For the intended purpose the Bag does not have to be a {@link Collection}. It does not\n     * even have to know its own size.\n     */\n    private class TinyBag {\n        /** The backing map. */\n        private final Map<T, BagCount> map;\n\n        /**\n         * Create a new tiny bag.\n         *\n         * @param initialCapacity the initial capacity\n         */\n        TinyBag(final int initialCapacity) {\n            map = new HashMap<>(initialCapacity);\n        }\n\n        /**\n         * Adds a new element to the bag, incrementing its count in the underlying map.\n         *\n         * @param object the object to add\n         */\n        void add(final T object) {\n            final BagCount mut = map.get(object);\n            if (mut == null) {\n                map.put(object, new BagCount());\n            } else {\n                mut.count++;\n            }\n        }\n\n        /**\n         * Returns the number of occurrence of the given element in this bag by\n         * looking up its count in the underlying map.\n         *\n         * @param object the object to search for\n         * @return The number of occurrences of the object, zero if not found\n         */\n        int getCount(final Object object) {\n            final BagCount count = map.get(object);\n            if (count != null) {\n                return count.count;\n            }\n            return 0;\n        }\n\n        /**\n         * Returns a Set view of the mappings contained in this bag.\n         *\n         * @return The Set view\n         */\n        Set<Entry<T, BagCount>> entrySet() {\n            return map.entrySet();\n        }\n\n        /**\n         * Get the number of unique elements in the bag.\n         *\n         * @return The unique element size\n         */\n        int uniqueElementSize() {\n            return map.size();\n        }\n    }\n\n    /**\n     * Create a new intersection similarity using the provided converter.\n     *\n     * <p>If the converter returns a {@link Set} then the intersection result will\n     * not include duplicates. Any other {@link Collection} is used to produce a result\n     * that will include duplicates in the intersect and union.\n     *\n     * @param converter the converter used to create the elements from the characters\n     * @throws IllegalArgumentException if the converter is null\n     */\n    public IntersectionSimilarity(final Function<CharSequence, Collection<T>> converter) {\n        if (converter == null) {\n            throw new IllegalArgumentException(\"Converter must not be null\");\n        }\n        this.converter = converter;\n    }\n\n    /**\n     * Calculates the intersection of two character sequences passed as input.\n     *\n     * @param left first character sequence\n     * @param right second character sequence\n     * @return The intersection result\n     * @throws IllegalArgumentException if either input sequence is {@code null}\n     */\n    @Override\n    public IntersectionResult apply(final CharSequence left, final CharSequence right) {\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"Input cannot be null\");\n        }\n\n        // Create the elements from the sequences\n        final Collection<T> objectsA = converter.apply(left);\n        final Collection<T> objectsB = converter.apply(right);\n        final int sizeA = objectsA.size();\n        final int sizeB = objectsB.size();\n\n        // Short-cut if either collection is empty\n        if (Math.min(sizeA, sizeB) == 0) {\n            // No intersection\n            return new IntersectionResult(sizeA, sizeB, 0);\n        }\n\n        // Intersection = count the number of shared elements\n        int intersection;\n        if (objectsA instanceof Set && objectsB instanceof Set) {\n            // If a Set then the elements will only have a count of 1.\n            // Iterate over the smaller set.\n            intersection = (sizeA < sizeB)\n                    ? getIntersection((Set<T>) objectsA, (Set<T>) objectsB)\n                    : getIntersection((Set<T>) objectsB, (Set<T>) objectsA);\n        } else  {\n            // Create a bag for each collection\n            final TinyBag bagA = toBag(objectsA);\n            final TinyBag bagB = toBag(objectsB);\n            // Iterate over the smaller number of unique elements\n            intersection = (bagA.uniqueElementSize() < bagB.uniqueElementSize())\n                    ? getIntersection(bagA, bagB)\n                    : getIntersection(bagB, bagA);\n        }\n\n        return new IntersectionResult(sizeA, sizeB, intersection);\n    }\n\n    /**\n     * Convert the collection to a bag. The bag will contain the count of each element\n     * in the collection.\n     *\n     * @param objects the objects\n     * @return The bag\n     */\n    private TinyBag toBag(final Collection<T> objects) {\n        final TinyBag bag = new TinyBag(objects.size());\n        for (final T t : objects) {\n            bag.add(t);\n        }\n        return bag;\n    }\n\n    /**\n     * Compute the intersection between two sets. This is the count of all the elements\n     * that are within both sets.\n     *\n     * @param <T> the type of the elements in the set\n     * @param setA the set A\n     * @param setB the set B\n     * @return The intersection\n     */\n    private static <T> int getIntersection(final Set<T> setA, final Set<T> setB) {\n        int intersection = 0;\n        for (final T element : setA) {\n            if (setB.contains(element)) {\n                intersection++;\n            }\n        }\n        return intersection;\n    }\n\n    /**\n     * Compute the intersection between two bags. This is the sum of the minimum\n     * count of each element that is within both sets.\n     *\n     * @param bagA the bag A\n     * @param bagB the bag B\n     * @return The intersection\n     */\n    private int getIntersection(final TinyBag bagA, final TinyBag bagB) {\n        int intersection = 0;\n        for (final Entry<T, BagCount> entry : bagA.entrySet()) {\n            final T element = entry.getKey();\n            final int count = entry.getValue().count;\n            // The intersection of this entry in both bags is the minimum count\n            intersection += Math.min(count, bagB.getCount(element));\n        }\n        return intersection;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/IntersectionSimilarity.java b/src/main/java/org/apache/commons/text/similarity/IntersectionSimilarity.java\nindex d08bfbf270..a64f01c1f5 100644\n--- a/src/main/java/org/apache/commons/text/similarity/IntersectionSimilarity.java\n+++ b/src/main/java/org/apache/commons/text/similarity/IntersectionSimilarity.java\n@@ -162,7 +162,7 @@ public IntersectionResult apply(final CharSequence left, final CharSequence righ\n         }\n \n         // Intersection = count the number of shared elements\n-        int intersection;\n+        final int intersection;\n         if (objectsA instanceof Set && objectsB instanceof Set) {\n             // If a Set then the elements will only have a count of 1.\n             // Iterate over the smaller set.\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class JaroWinklerDistanceTest2 {\n\n    private static JaroWinklerDistance distance;\n\n    @BeforeAll\n    public static void setUp() {\n        distance = new JaroWinklerDistance();\n    }\n\n    @Test\n    public void testMatchesMethod() {\n        // Testing the matches method directly to ensure it handles the changes correctly\n        int[] result1 = JaroWinklerDistance.matches(\"frog\", \"fog\");\n        assertEquals(3, result1[0]); // matches\n        assertEquals(0, result1[1]); // half transpositions\n        assertEquals(2, result1[2]); // prefix\n\n        int[] result2 = JaroWinklerDistance.matches(\"elephant\", \"hippo\");\n        assertEquals(3, result2[0]); // matches\n        assertEquals(1, result2[1]); // half transpositions\n        assertEquals(0, result2[2]); // prefix\n\n        int[] result3 = JaroWinklerDistance.matches(\"ABC Corporation\", \"ABC Corp\");\n        assertEquals(8, result3[0]); // matches\n        assertEquals(0, result3[1]); // half transpositions\n        assertEquals(4, result3[2]); // prefix\n\n        int[] result4 = JaroWinklerDistance.matches(\"D N H Enterprises Inc\", \"D & H Enterprises, Inc.\");\n        assertEquals(17, result4[0]); // matches\n        assertEquals(0, result4[1]); // half transpositions\n        assertEquals(0, result4[2]); // prefix\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.Arrays;\n\n/**\n * Measures the Jaro-Winkler distance of two character sequences.\n * It is the complementary of Jaro-Winkler similarity.\n *\n * @since 1.0\n */\npublic class JaroWinklerDistance implements EditDistance<Double> {\n\n    /**\n     * @deprecated Deprecated as of 1.7. This constant will be removed in 2.0.\n     */\n    @Deprecated\n    public static final int INDEX_NOT_FOUND = -1;\n\n    /**\n     * Computes the Jaro Winkler Distance between two character sequences.\n     *\n     * <pre>\n     * distance.apply(null, null)          = IllegalArgumentException\n     * distance.apply(\"foo\", null)         = IllegalArgumentException\n     * distance.apply(null, \"foo\")         = IllegalArgumentException\n     * distance.apply(\"\", \"\")              = 0.0\n     * distance.apply(\"foo\", \"foo\")        = 0.0\n     * distance.apply(\"foo\", \"foo \")       = 0.06\n     * distance.apply(\"foo\", \"foo  \")      = 0.09\n     * distance.apply(\"foo\", \" foo \")      = 0.13\n     * distance.apply(\"foo\", \"  foo\")      = 0.49\n     * distance.apply(\"\", \"a\")             = 1.0\n     * distance.apply(\"aaapppp\", \"\")       = 1.0\n     * distance.apply(\"frog\", \"fog\")       = 0.07\n     * distance.apply(\"fly\", \"ant\")        = 1.0\n     * distance.apply(\"elephant\", \"hippo\") = 0.56\n     * distance.apply(\"hippo\", \"elephant\") = 0.56\n     * distance.apply(\"hippo\", \"zzzzzzzz\") = 1.0\n     * distance.apply(\"hello\", \"hallo\")    = 0.12\n     * distance.apply(\"ABC Corporation\", \"ABC Corp\") = 0.09\n     * distance.apply(\"D N H Enterprises Inc\", \"D &amp; H Enterprises, Inc.\") = 0.05\n     * distance.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\") = 0.08\n     * distance.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\") = 0.12\n     * </pre>\n     *\n     * @param left the first CharSequence, must not be null\n     * @param right the second CharSequence, must not be null\n     * @return result distance\n     * @throws IllegalArgumentException if either CharSequence input is {@code null}\n     */\n    @Override\n    public Double apply(final CharSequence left, final CharSequence right) {\n\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n\n        // TODO: replace the rest of the code by this in 2.0, see TEXT-104\n        //\n        // JaroWinklerSimilarity similarity = new JaroWinklerSimilarity();\n        // return 1 - similarity.apply(left, right);\n\n        final double defaultScalingFactor = 0.1;\n        final int[] mtp = matches(left, right);\n        final double m = mtp[0];\n        if (m == 0) {\n            return 0D;\n        }\n        final double j = ((m / left.length() + m / right.length() + (m - (double) mtp[1] / 2) / m)) / 3;\n        final double jw = j < 0.7D ? j : j + defaultScalingFactor * mtp[2] * (1D - j);\n        return jw;\n    }\n\n    // TODO: remove this method in 2.0, see TEXT-104\n    /**\n     * This method returns the Jaro-Winkler string matches, half transpositions, prefix array.\n     *\n     * @param first the first string to be matched\n     * @param second the second string to be matched\n     * @return mtp array containing: matches, half transpositions, and prefix\n     * @deprecated Deprecated as of 1.7. This method will be removed in 2.0, and moved to a Jaro Winkler similarity\n     *             class.\n     */\n    @Deprecated\n    protected static int[] matches(final CharSequence first, final CharSequence second) {\n        CharSequence max, min;\n        if (first.length() > second.length()) {\n            max = first;\n            min = second;\n        } else {\n            max = second;\n            min = first;\n        }\n        final int range = Math.max(max.length() / 2 - 1, 0);\n        final int[] matchIndexes = new int[min.length()];\n        Arrays.fill(matchIndexes, -1);\n        final boolean[] matchFlags = new boolean[max.length()];\n        int matches = 0;\n        for (int mi = 0; mi < min.length(); mi++) {\n            final char c1 = min.charAt(mi);\n            for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max.length()); xi < xn; xi++) {\n                if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n                    matchIndexes[mi] = xi;\n                    matchFlags[xi] = true;\n                    matches++;\n                    break;\n                }\n            }\n        }\n        final char[] ms1 = new char[matches];\n        final char[] ms2 = new char[matches];\n        for (int i = 0, si = 0; i < min.length(); i++) {\n            if (matchIndexes[i] != -1) {\n                ms1[si] = min.charAt(i);\n                si++;\n            }\n        }\n        for (int i = 0, si = 0; i < max.length(); i++) {\n            if (matchFlags[i]) {\n                ms2[si] = max.charAt(i);\n                si++;\n            }\n        }\n        int halfTranspositions = 0;\n        for (int mi = 0; mi < ms1.length; mi++) {\n            if (ms1[mi] != ms2[mi]) {\n                halfTranspositions++;\n            }\n        }\n        int prefix = 0;\n        for (int mi = 0; mi < Math.min(4, min.length()); mi++) {\n            if (first.charAt(mi) == second.charAt(mi)) {\n                prefix++;\n            } else {\n                break;\n            }\n        }\n        return new int[] {matches, halfTranspositions, prefix};\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java b/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\nindex 044a36c8eb..ab1b7ea5ca 100644\n--- a/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\n+++ b/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\n@@ -99,7 +99,8 @@ public Double apply(final CharSequence left, final CharSequence right) {\n      */\n     @Deprecated\n     protected static int[] matches(final CharSequence first, final CharSequence second) {\n-        CharSequence max, min;\n+        final CharSequence max;\n+        final CharSequence min;\n         if (first.length() > second.length()) {\n             max = first;\n             min = second;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class JaroWinklerSimilarityTest2 {\n\n    private static JaroWinklerSimilarity similarity;\n\n    @BeforeAll\n    public static void setUp() {\n        similarity = new JaroWinklerSimilarity();\n    }\n\n    @Test\n    public void testMatchesMethodWithDifferentLengths() {\n        // Test when first string is longer than the second\n        int[] result1 = JaroWinklerSimilarity.matches(\"longerString\", \"short\");\n        assertEquals(3, result1[0]); // matches\n        assertEquals(0, result1[1]); // half transpositions\n        assertEquals(0, result1[2]); // prefix\n\n        // Test when second string is longer than the first\n        int[] result2 = JaroWinklerSimilarity.matches(\"short\", \"longerString\");\n        assertEquals(3, result2[0]); // matches\n        assertEquals(0, result2[1]); // half transpositions\n        assertEquals(0, result2[2]); // prefix\n    }\n\n    @Test\n    public void testMatchesMethodWithEqualLengths() {\n        // Test when both strings have equal length\n        int[] result = JaroWinklerSimilarity.matches(\"same\", \"same\");\n        assertEquals(4, result[0]); // matches\n        assertEquals(0, result[1]); // half transpositions\n        assertEquals(4, result[2]); // prefix\n    }\n\n    @Test\n    public void testMatchesMethodWithNoMatches() {\n        // Test when there are no matches\n        int[] result = JaroWinklerSimilarity.matches(\"abcd\", \"efgh\");\n        assertEquals(0, result[0]); // matches\n        assertEquals(0, result[1]); // half transpositions\n        assertEquals(0, result[2]); // prefix\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * A similarity algorithm indicating the percentage of matched characters between two character sequences.\n *\n * <p>\n * The Jaro measure is the weighted sum of percentage of matched characters\n * from each file and transposed characters. Winkler increased this measure\n * for matching initial characters.\n * </p>\n *\n * <p>\n * This implementation is based on the Jaro Winkler similarity algorithm\n * from <a href=\"http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\">\n * http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a>.\n * </p>\n *\n * <p>\n * This code has been adapted from Apache Commons Lang 3.3.\n * </p>\n *\n * @since 1.7\n */\npublic class JaroWinklerSimilarity implements SimilarityScore<Double> {\n\n    /**\n     * Computes the Jaro Winkler Similarity between two character sequences.\n     *\n     * <pre>\n     * sim.apply(null, null)          = IllegalArgumentException\n     * sim.apply(\"foo\", null)         = IllegalArgumentException\n     * sim.apply(null, \"foo\")         = IllegalArgumentException\n     * sim.apply(\"\", \"\")              = 1.0\n     * sim.apply(\"foo\", \"foo\")        = 1.0\n     * sim.apply(\"foo\", \"foo \")       = 0.94\n     * sim.apply(\"foo\", \"foo  \")      = 0.91\n     * sim.apply(\"foo\", \" foo \")      = 0.87\n     * sim.apply(\"foo\", \"  foo\")      = 0.51\n     * sim.apply(\"\", \"a\")             = 0.0\n     * sim.apply(\"aaapppp\", \"\")       = 0.0\n     * sim.apply(\"frog\", \"fog\")       = 0.93\n     * sim.apply(\"fly\", \"ant\")        = 0.0\n     * sim.apply(\"elephant\", \"hippo\") = 0.44\n     * sim.apply(\"hippo\", \"elephant\") = 0.44\n     * sim.apply(\"hippo\", \"zzzzzzzz\") = 0.0\n     * sim.apply(\"hello\", \"hallo\")    = 0.88\n     * sim.apply(\"ABC Corporation\", \"ABC Corp\") = 0.91\n     * sim.apply(\"D N H Enterprises Inc\", \"D &amp; H Enterprises, Inc.\") = 0.95\n     * sim.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\") = 0.92\n     * sim.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\") = 0.88\n     * </pre>\n     *\n     * @param left the first CharSequence, must not be null\n     * @param right the second CharSequence, must not be null\n     * @return result similarity\n     * @throws IllegalArgumentException if either CharSequence input is {@code null}\n     */\n    @Override\n    public Double apply(final CharSequence left, final CharSequence right) {\n        final double defaultScalingFactor = 0.1;\n\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n\n        if (StringUtils.equals(left, right)) {\n            return 1d;\n        }\n\n        final int[] mtp = matches(left, right);\n        final double m = mtp[0];\n        if (m == 0) {\n            return 0d;\n        }\n        final double j = ((m / left.length() + m / right.length() + (m - (double) mtp[1] / 2) / m)) / 3;\n        final double jw = j < 0.7d ? j : j + defaultScalingFactor * mtp[2] * (1d - j);\n        return jw;\n    }\n\n    /**\n     * This method returns the Jaro-Winkler string matches, half transpositions, prefix array.\n     *\n     * @param first the first string to be matched\n     * @param second the second string to be matched\n     * @return mtp array containing: matches, half transpositions, and prefix\n     */\n    protected static int[] matches(final CharSequence first, final CharSequence second) {\n        CharSequence max, min;\n        if (first.length() > second.length()) {\n            max = first;\n            min = second;\n        } else {\n            max = second;\n            min = first;\n        }\n        final int range = Math.max(max.length() / 2 - 1, 0);\n        final int[] matchIndexes = new int[min.length()];\n        Arrays.fill(matchIndexes, -1);\n        final boolean[] matchFlags = new boolean[max.length()];\n        int matches = 0;\n        for (int mi = 0; mi < min.length(); mi++) {\n            final char c1 = min.charAt(mi);\n            for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max.length()); xi < xn; xi++) {\n                if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n                    matchIndexes[mi] = xi;\n                    matchFlags[xi] = true;\n                    matches++;\n                    break;\n                }\n            }\n        }\n        final char[] ms1 = new char[matches];\n        final char[] ms2 = new char[matches];\n        for (int i = 0, si = 0; i < min.length(); i++) {\n            if (matchIndexes[i] != -1) {\n                ms1[si] = min.charAt(i);\n                si++;\n            }\n        }\n        for (int i = 0, si = 0; i < max.length(); i++) {\n            if (matchFlags[i]) {\n                ms2[si] = max.charAt(i);\n                si++;\n            }\n        }\n        int halfTranspositions = 0;\n        for (int mi = 0; mi < ms1.length; mi++) {\n            if (ms1[mi] != ms2[mi]) {\n                halfTranspositions++;\n            }\n        }\n        int prefix = 0;\n        for (int mi = 0; mi < Math.min(4, min.length()); mi++) {\n            if (first.charAt(mi) == second.charAt(mi)) {\n                prefix++;\n            } else {\n                break;\n            }\n        }\n        return new int[] {matches, halfTranspositions, prefix};\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java b/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java\nindex fa7d754621..7ff5869271 100644\n--- a/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java\n+++ b/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java\n@@ -105,7 +105,8 @@ public Double apply(final CharSequence left, final CharSequence right) {\n      * @return mtp array containing: matches, half transpositions, and prefix\n      */\n     protected static int[] matches(final CharSequence first, final CharSequence second) {\n-        CharSequence max, min;\n+        final CharSequence max;\n+        final CharSequence min;\n         if (first.length() > second.length()) {\n             max = first;\n             min = second;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/translate/NumericEntityUnescaper.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.translate;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.fail;\nimport org.junit.jupiter.api.Test;\n\npublic class NumericEntityUnescaperTest2 {\n\n    @Test\n    public void testSemiColonRequiredOption() {\n        NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonRequired);\n        String input = \"Test &#1234 not test\";\n        String expected = \"Test &#1234 not test\";\n        String result = neu.translate(input);\n        assertThat(result).as(\"Failed to ignore unfinished entities with semiColonRequired option\").isEqualTo(expected);\n    }\n\n    @Test\n    public void testErrorIfNoSemiColonOption() {\n        NumericEntityUnescaper neu = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon);\n        String input = \"Test &#1234 not test\";\n        try {\n            neu.translate(input);\n            fail(\"IllegalArgumentException expected\");\n        } catch (IllegalArgumentException iae) {\n            // Expected exception\n        }\n    }\n\n    @Test\n    public void testFinalEntityValue() {\n        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n        String input = \"&#x1F600;\";\n        String expected = \"\\uD83D\\uDE00\";\n        String result = neu.translate(input);\n        assertThat(result).as(\"Failed to unescape numeric entities with final entity value\").isEqualTo(expected);\n    }\n\n    @Test\n    public void testEnumSetInitialization() {\n        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n        assertThat(neu.isSet(NumericEntityUnescaper.OPTION.semiColonRequired)).isTrue();\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.translate;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Arrays;\nimport java.util.EnumSet;\n\n/**\n * Translate XML numeric entities of the form &amp;#[xX]?\\d+;? to\n * the specific codepoint.\n *\n * Note that the semi-colon is optional.\n *\n * @since 1.0\n */\npublic class NumericEntityUnescaper extends CharSequenceTranslator {\n\n    /** Enumerates NumericEntityUnescaper options for unescaping. */\n    public enum OPTION {\n\n        /**\n         * Require a semicolon.\n         */\n        semiColonRequired,\n\n        /**\n         * Do not require a semicolon.\n         */\n        semiColonOptional,\n\n        /**\n         * Throw an exception if a semi-colon is missing.\n         */\n        errorIfNoSemiColon\n    }\n\n    /** EnumSet of OPTIONS, given from the constructor. */\n    private final EnumSet<OPTION> options;\n\n    /**\n     * Create a UnicodeUnescaper.\n     *\n     * The constructor takes a list of options, only one type of which is currently\n     * available (whether to allow, error or ignore the semi-colon on the end of a\n     * numeric entity to being missing).\n     *\n     * For example, to support numeric entities without a ';':\n     *    new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional)\n     * and to throw an IllegalArgumentException when they're missing:\n     *    new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon)\n     *\n     * Note that the default behavior is to ignore them.\n     *\n     * @param options to apply to this unescaper\n     */\n    public NumericEntityUnescaper(final OPTION... options) {\n        if (options.length > 0) {\n            this.options = EnumSet.copyOf(Arrays.asList(options));\n        } else {\n            this.options = EnumSet.copyOf(Arrays.asList(OPTION.semiColonRequired));\n        }\n    }\n\n    /**\n     * Whether the passed in option is currently set.\n     *\n     * @param option to check state of\n     * @return whether the option is set\n     */\n    public boolean isSet(final OPTION option) {\n        return options != null && options.contains(option);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n        final int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            final char firstChar = input.charAt(start);\n            if (firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n                if (start == seqEnd) {\n                    return 0;\n                }\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9'\n                                    || input.charAt(end) >= 'a' && input.charAt(end) <= 'f'\n                                    || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {\n                end++;\n            }\n\n            final boolean semiNext = end != seqEnd && input.charAt(end) == ';';\n\n            if (!semiNext) {\n                if (isSet(OPTION.semiColonRequired)) {\n                    return 0;\n                }\n                if (isSet(OPTION.errorIfNoSemiColon)) {\n                    throw new IllegalArgumentException(\"Semi-colon required at end of numeric entity\");\n                }\n            }\n\n            int entityValue;\n            try {\n                if (isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch (final NumberFormatException nfe) {\n                return 0;\n            }\n\n            if (entityValue > 0xFFFF) {\n                final char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n            return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n        }\n        return 0;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/translate/NumericEntityUnescaper.java b/src/main/java/org/apache/commons/text/translate/NumericEntityUnescaper.java\nindex d41e5b54b2..77896fafe0 100644\n--- a/src/main/java/org/apache/commons/text/translate/NumericEntityUnescaper.java\n+++ b/src/main/java/org/apache/commons/text/translate/NumericEntityUnescaper.java\n@@ -19,6 +19,7 @@\n import java.io.IOException;\n import java.io.Writer;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.EnumSet;\n \n /**\n@@ -73,7 +74,7 @@ public NumericEntityUnescaper(final OPTION... options) {\n         if (options.length > 0) {\n             this.options = EnumSet.copyOf(Arrays.asList(options));\n         } else {\n-            this.options = EnumSet.copyOf(Arrays.asList(OPTION.semiColonRequired));\n+            this.options = EnumSet.copyOf(Collections.singletonList(OPTION.semiColonRequired));\n         }\n     }\n \n@@ -128,7 +129,7 @@ public int translate(final CharSequence input, final int index, final Writer out\n                 }\n             }\n \n-            int entityValue;\n+            final int entityValue;\n             try {\n                 if (isHex) {\n                     entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/AlphabetConverterTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/StringEscapeUtilsTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/similarity/IntersectionSimilarityTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 142,
    "title": "[TEXT-158]: empty strings must have similarity of 1, and distance of 0 (i.e. identical)",
    "state": "closed",
    "created_at": "2020-07-30T05:25:24Z",
    "merge_commit_sha": "74afb2d933e3af8a375ed52f2379e68720453197",
    "base_sha": "ac09fd74ed1c71de634f58f5ec89e66d729e0ffc",
    "head_sha": "38727e31d978350b76edba1683a081a114fe345f",
    "user_login": "kinow",
    "changed_files": [
      {
        "filename": "src/changes/changes.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/JaccardSimilarity.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class JaccardSimilarityTest2 {\n    private static JaccardSimilarity classBeingTested;\n\n    @BeforeAll\n    public static void setUp() {\n        classBeingTested = new JaccardSimilarity();\n    }\n\n    @Test\n    public void testGettingJaccardSimilarityBothEmptyStrings() {\n        // Test case for the new condition where both strings are empty\n        assertEquals(1.0, classBeingTested.apply(\"\", \"\"));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Measures the Jaccard similarity (aka Jaccard index) of two sets of character\n * sequence. Jaccard similarity is the size of the intersection divided by the\n * size of the union of the two sets.\n *\n * <p>\n * For further explanation about Jaccard Similarity, refer\n * https://en.wikipedia.org/wiki/Jaccard_index\n * </p>\n *\n * @since 1.0\n */\npublic class JaccardSimilarity implements SimilarityScore<Double> {\n\n    /**\n     * Calculates Jaccard Similarity of two set character sequence passed as\n     * input.\n     *\n     * @param left first character sequence\n     * @param right second character sequence\n     * @return index\n     * @throws IllegalArgumentException\n     *             if either String input {@code null}\n     */\n    @Override\n    public Double apply(final CharSequence left, final CharSequence right) {\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"Input cannot be null\");\n        }\n        return calculateJaccardSimilarity(left, right);\n    }\n\n    /**\n     * Calculates Jaccard Similarity of two character sequences passed as\n     * input. Does the calculation by identifying the union (characters in at\n     * least one of the two sets) of the two sets and intersection (characters\n     * which are present in set one which are present in set two)\n     *\n     * @param left first character sequence\n     * @param right second character sequence\n     * @return index\n     */\n    private Double calculateJaccardSimilarity(final CharSequence left, final CharSequence right) {\n        final int leftLength = left.length();\n        final int rightLength = right.length();\n        if (leftLength == 0 || rightLength == 0) {\n            return 0d;\n        }\n        final Set<Character> leftSet = new HashSet<>();\n        for (int i = 0; i < leftLength; i++) {\n            leftSet.add(left.charAt(i));\n        }\n        final Set<Character> rightSet = new HashSet<>();\n        for (int i = 0; i < rightLength; i++) {\n            rightSet.add(right.charAt(i));\n        }\n        final Set<Character> unionSet = new HashSet<>(leftSet);\n        unionSet.addAll(rightSet);\n        final int intersectionSize = leftSet.size() + rightSet.size() - unionSet.size();\n        return 1.0d * intersectionSize / unionSet.size();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/JaccardSimilarity.java b/src/main/java/org/apache/commons/text/similarity/JaccardSimilarity.java\nindex d1478cbca8..4f29139260 100644\n--- a/src/main/java/org/apache/commons/text/similarity/JaccardSimilarity.java\n+++ b/src/main/java/org/apache/commons/text/similarity/JaccardSimilarity.java\n@@ -64,6 +64,9 @@ public Double apply(final CharSequence left, final CharSequence right) {\n     private Double calculateJaccardSimilarity(final CharSequence left, final CharSequence right) {\n         final int leftLength = left.length();\n         final int rightLength = right.length();\n+        if (leftLength == 0 && rightLength == 0) {\n+            return 1d;\n+        }\n         if (leftLength == 0 || rightLength == 0) {\n             return 0d;\n         }\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/similarity/JaccardDistanceTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/similarity/JaccardSimilarityTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 137,
    "title": "[TEXT-182] Fix typos",
    "state": "closed",
    "created_at": "2020-07-21T05:47:16Z",
    "merge_commit_sha": "2559593ad0cf37b43a6f4631c747d9b67dae8d5f",
    "base_sha": "d36a5faf0560fce4f0d23ded7db8c915c68def91",
    "head_sha": "2b0611a784bb5fe851c9707419927e1308282096",
    "user_login": "XenoAmess",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/CaseUtils.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport org.junit.jupiter.api.Test;\n\npublic class CaseUtilsTest2 {\n\n    @Test\n    public void testToCamelCaseWithTitleCaseCorrection() {\n        // Test to ensure the title case correction in the Javadoc is reflected in the functionality\n        assertThat(CaseUtils.toCamelCase(\"word\", true)).isEqualTo(\"Word\");\n        assertThat(CaseUtils.toCamelCase(\"word\", false)).isEqualTo(\"word\");\n        assertThat(CaseUtils.toCamelCase(\"word word\", true, ' ')).isEqualTo(\"WordWord\");\n        assertThat(CaseUtils.toCamelCase(\"word word\", false, ' ')).isEqualTo(\"wordWord\");\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * <p>Case manipulation operations on Strings that contain words.</p>\n *\n * <p>This class tries to handle {@code null} input gracefully.\n * An exception will not be thrown for a {@code null} input.\n * Each method documents its behavior in more detail.</p>\n *\n * @since 1.2\n */\npublic class CaseUtils {\n\n    /**\n     * <p>{@code CaseUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code CaseUtils.toCamelCase(\"foo bar\", true, new char[]{'-'});}.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public CaseUtils() {\n        super();\n    }\n\n    /**\n     * <p>Converts all the delimiter separated words in a String into camelCase,\n     * that is each word is made up of a titlecase character and then a series of\n     * lowercase characters.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first non-delimiter character after a delimiter will be capitalized. The first String\n     * character may or may not be capitalized and it's determined by the user input for capitalizeFirstLetter\n     * variable.</p>\n     *\n     * <p>A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case and cannot perform locale-sensitive mappings.</p>\n     *\n     * <pre>\n     * CaseUtils.toCamelCase(null, false)                                 = null\n     * CaseUtils.toCamelCase(\"\", false, *)                                = \"\"\n     * CaseUtils.toCamelCase(*, false, null)                              = *\n     * CaseUtils.toCamelCase(*, true, new char[0])                        = *\n     * CaseUtils.toCamelCase(\"To.Camel.Case\", false, new char[]{'.'})     = \"toCamelCase\"\n     * CaseUtils.toCamelCase(\" to @ Camel case\", true, new char[]{'@'})   = \"ToCamelCase\"\n     * CaseUtils.toCamelCase(\" @to @ Camel case\", false, new char[]{'@'}) = \"toCamelCase\"\n     * </pre>\n     *\n     * @param str  the String to be converted to camelCase, may be null\n     * @param capitalizeFirstLetter boolean that determines if the first character of first word should be title case.\n     * @param delimiters  set of characters to determine capitalization, null and/or empty array means whitespace\n     * @return camelCase of String, {@code null} if null String input\n     */\n    public static String toCamelCase(String str, final boolean capitalizeFirstLetter, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        str = str.toLowerCase();\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        boolean capitalizeNext = false;\n        if (capitalizeFirstLetter) {\n            capitalizeNext = true;\n        }\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                capitalizeNext = true;\n                if (outOffset == 0) {\n                    capitalizeNext = false;\n                }\n                index += Character.charCount(codePoint);\n            } else if (capitalizeNext || outOffset == 0 && capitalizeFirstLetter) {\n                final int titleCaseCodePoint = Character.toTitleCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                capitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        if (outOffset != 0) {\n            return new String(newCodePoints, 0, outOffset);\n        }\n        return str;\n    }\n\n    /**\n     * <p>Converts an array of delimiters to a hash set of code points. Code point of space(32) is added\n     * as the default value. The generated hash set provides O(1) lookup time.</p>\n     *\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return Set<Integer>\n     */\n    private static Set<Integer> generateDelimiterSet(final char[] delimiters) {\n        final Set<Integer> delimiterHashSet = new HashSet<>();\n        delimiterHashSet.add(Character.codePointAt(new char[]{' '}, 0));\n        if (ArrayUtils.isEmpty(delimiters)) {\n            return delimiterHashSet;\n        }\n\n        for (int index = 0; index < delimiters.length; index++) {\n            delimiterHashSet.add(Character.codePointAt(delimiters, index));\n        }\n        return delimiterHashSet;\n    }\n}\n",
        "diff": " a/src/main/java/org/apache/commons/text/CaseUtils.java b/src/main/java/org/apache/commons/text/CaseUtils.java\nindex 641f64cd8d..cbdae7ee01 100644\n--- a/src/main/java/org/apache/commons/text/CaseUtils.java\n+++ b/src/main/java/org/apache/commons/text/CaseUtils.java\n@@ -47,7 +47,7 @@ public CaseUtils() {\n \n     /**\n      * <p>Converts all the delimiter separated words in a String into camelCase,\n-     * that is each word is made up of a titlecase character and then a series of\n+     * that is each word is made up of a title case character and then a series of\n      * lowercase characters.</p>\n      *\n      * <p>The delimiters represent a set of characters understood to separate words.\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/ExtendedMessageFormat.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.MessageFormat;\nimport java.text.NumberFormat;\nimport java.text.ParsePosition;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class ExtendedMessageFormatTest2 {\n\n    private static class LowerCaseFormat extends Format {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n            return toAppendTo.append(((String) obj).toLowerCase(Locale.ROOT));\n        }\n\n        @Override\n        public Object parseObject(final String source, final ParsePosition pos) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class LowerCaseFormatFactory implements FormatFactory {\n        private static final Format LOWER_INSTANCE = new LowerCaseFormat();\n\n        @Override\n        public Format getFormat(final String name, final String arguments, final Locale locale) {\n            return LOWER_INSTANCE;\n        }\n    }\n\n    private static class UpperCaseFormat extends Format {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n            return toAppendTo.append(((String) obj).toUpperCase(Locale.ROOT));\n        }\n\n        @Override\n        public Object parseObject(final String source, final ParsePosition pos) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class UpperCaseFormatFactory implements FormatFactory {\n        private static final Format UPPER_INSTANCE = new UpperCaseFormat();\n\n        @Override\n        public Format getFormat(final String name, final String arguments, final Locale locale) {\n            return UPPER_INSTANCE;\n        }\n    }\n\n    private final Map<String, FormatFactory> registry = new HashMap<>();\n\n    @BeforeEach\n    public void setUp() {\n        registry.put(\"lower\", new LowerCaseFormatFactory());\n        registry.put(\"upper\", new UpperCaseFormatFactory());\n    }\n\n    @Test\n    public void testCorrectSpellingOfSquigglyBrace() {\n        final String pattern = \"Pattern with squiggly braces: {0,upper}\";\n        final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n        assertEquals(\"Pattern with squiggly braces: FOO\", emf.format(new Object[] {\"foo\"}));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.text.Format;\nimport java.text.MessageFormat;\nimport java.text.ParsePosition;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Locale.Category;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport org.apache.commons.text.matcher.StringMatcherFactory;\n\n/**\n * Extends {@code java.text.MessageFormat} to allow pluggable/additional formatting\n * options for embedded format elements.  Client code should specify a registry\n * of {@code FormatFactory} instances associated with {@code String}\n * format names.  This registry will be consulted when the format elements are\n * parsed from the message pattern.  In this way custom patterns can be specified,\n * and the formats supported by {@code java.text.MessageFormat} can be overridden\n * at the format and/or format style level (see MessageFormat).  A \"format element\"\n * embedded in the message pattern is specified (<b>()?</b> signifies optionality):<br>\n * {@code {}<i>argument-number</i><b>(</b>{@code ,}<i>format-name</i><b>\n * (</b>{@code ,}<i>format-style</i><b>)?)?</b>{@code }}\n *\n * <p>\n * <i>format-name</i> and <i>format-style</i> values are trimmed of surrounding whitespace\n * in the manner of {@code java.text.MessageFormat}.  If <i>format-name</i> denotes\n * {@code FormatFactory formatFactoryInstance} in {@code registry}, a {@code Format}\n * matching <i>format-name</i> and <i>format-style</i> is requested from\n * {@code formatFactoryInstance}.  If this is successful, the {@code Format}\n * found is used for this format element.\n * </p>\n *\n * <p><b>NOTICE:</b> The various subformat mutator methods are considered unnecessary; they exist on the parent\n * class to allow the type of customization which it is the job of this class to provide in\n * a configurable fashion.  These methods have thus been disabled and will throw\n * {@code UnsupportedOperationException} if called.\n * </p>\n *\n * <p>Limitations inherited from {@code java.text.MessageFormat}:</p>\n * <ul>\n * <li>When using \"choice\" subformats, support for nested formatting instructions is limited\n *     to that provided by the base class.</li>\n * <li>Thread-safety of {@code Format}s, including {@code MessageFormat} and thus\n *     {@code ExtendedMessageFormat}, is not guaranteed.</li>\n * </ul>\n *\n * @since 1.0\n */\npublic class ExtendedMessageFormat extends MessageFormat {\n\n    /**\n     * Serializable Object.\n     */\n    private static final long serialVersionUID = -2362048321261811743L;\n\n    /**\n     * Our initial seed value for calculating hashes.\n     */\n    private static final int HASH_SEED = 31;\n\n    /**\n     * The empty string.\n     */\n    private static final String DUMMY_PATTERN = \"\";\n\n    /**\n     * A comma.\n     */\n    private static final char START_FMT = ',';\n\n    /**\n     * A right side squigly brace.\n     */\n    private static final char END_FE = '}';\n\n    /**\n     * A left side squigly brace.\n     */\n    private static final char START_FE = '{';\n\n    /**\n     * A properly escaped character representing a single quote.\n     */\n    private static final char QUOTE = '\\'';\n\n    /**\n     * To pattern string.\n     */\n    private String toPattern;\n\n    /**\n     * Our registry of FormatFactory's.\n     */\n    private final Map<String, ? extends FormatFactory> registry;\n\n    /**\n     * Create a new ExtendedMessageFormat for the default locale.\n     *\n     * @param pattern  the pattern to use, not null\n     * @throws IllegalArgumentException in case of a bad pattern.\n     */\n    public ExtendedMessageFormat(final String pattern) {\n        this(pattern, Locale.getDefault(Category.FORMAT));\n    }\n\n    /**\n     * Create a new ExtendedMessageFormat.\n     *\n     * @param pattern  the pattern to use, not null\n     * @param locale  the locale to use, not null\n     * @throws IllegalArgumentException in case of a bad pattern.\n     */\n    public ExtendedMessageFormat(final String pattern, final Locale locale) {\n        this(pattern, locale, null);\n    }\n\n    /**\n     * Create a new ExtendedMessageFormat for the default locale.\n     *\n     * @param pattern  the pattern to use, not null\n     * @param registry  the registry of format factories, may be null\n     * @throws IllegalArgumentException in case of a bad pattern.\n     */\n    public ExtendedMessageFormat(final String pattern,\n                                 final Map<String, ? extends FormatFactory> registry) {\n        this(pattern, Locale.getDefault(Category.FORMAT), registry);\n    }\n\n    /**\n     * Create a new ExtendedMessageFormat.\n     *\n     * @param pattern  the pattern to use, not null\n     * @param locale  the locale to use, not null\n     * @param registry  the registry of format factories, may be null\n     * @throws IllegalArgumentException in case of a bad pattern.\n     */\n    public ExtendedMessageFormat(final String pattern,\n                                 final Locale locale,\n                                 final Map<String, ? extends FormatFactory> registry) {\n        super(DUMMY_PATTERN);\n        setLocale(locale);\n        this.registry = registry;\n        applyPattern(pattern);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toPattern() {\n        return toPattern;\n    }\n\n    /**\n     * Apply the specified pattern.\n     *\n     * @param pattern String\n     */\n    @Override\n    public final void applyPattern(final String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        final ArrayList<Format> foundFormats = new ArrayList<>();\n        final ArrayList<String> foundDescriptions = new ArrayList<>();\n        final StringBuilder stripCustom = new StringBuilder(pattern.length());\n\n        final ParsePosition pos = new ParsePosition(0);\n        final char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                final int start = pos.getIndex();\n                final int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                if (foundFormats.size() != fmtCount) {\n                    throw new IllegalArgumentException(\"The validated expression is false\");\n                }\n                if (foundDescriptions.size() != fmtCount) {\n                    throw new IllegalArgumentException(\"The validated expression is false\");\n                }\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                //$FALL-THROUGH$\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            final Format[] origFormats = getFormats();\n            // only loop over what we know we have, as MessageFormat on Java 1.3\n            // seems to provide an extra format element:\n            int i = 0;\n            for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n                final Format f = it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param formatElementIndex format element index\n     * @param newFormat the new format\n     * @throws UnsupportedOperationException always thrown since this isn't\n     *                                       supported by ExtendMessageFormat\n     */\n    @Override\n    public void setFormat(final int formatElementIndex, final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param argumentIndex argument index\n     * @param newFormat the new format\n     * @throws UnsupportedOperationException always thrown since this isn't\n     *                                       supported by ExtendMessageFormat\n     */\n    @Override\n    public void setFormatByArgumentIndex(final int argumentIndex,\n                                         final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param newFormats new formats\n     * @throws UnsupportedOperationException always thrown since this isn't\n     *                                       supported by ExtendMessageFormat\n     */\n    @Override\n    public void setFormats(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Throws UnsupportedOperationException - see class Javadoc for details.\n     *\n     * @param newFormats new formats\n     * @throws UnsupportedOperationException always thrown since this isn't\n     *                                       supported by ExtendMessageFormat\n     */\n    @Override\n    public void setFormatsByArgumentIndex(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Check if this extended message format is equal to another object.\n     *\n     * @param obj the object to compare to\n     * @return true if this object equals the other, otherwise false\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!Objects.equals(getClass(), obj.getClass())) {\n          return false;\n        }\n        final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj;\n        if (!Objects.equals(toPattern, rhs.toPattern)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        return Objects.equals(registry, rhs.registry);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = HASH_SEED * result + Objects.hashCode(registry);\n        result = HASH_SEED * result + Objects.hashCode(toPattern);\n        return result;\n    }\n\n    /**\n     * Get a custom format from a format description.\n     *\n     * @param desc String\n     * @return Format\n     */\n    private Format getFormat(final String desc) {\n        if (registry != null) {\n            String name = desc;\n            String args = null;\n            final int i = desc.indexOf(START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            final FormatFactory factory = registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Read the argument index from the current format element.\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @return argument index\n     */\n    private int readArgumentIndex(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final StringBuilder result = new StringBuilder();\n        boolean error = false;\n        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if (c != START_FMT && c != END_FE) {\n                    error = true;\n                    continue;\n                }\n            }\n            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n                try {\n                    return Integer.parseInt(result.toString());\n                } catch (final NumberFormatException e) { // NOPMD\n                    // we've already ensured only digits, so unless something\n                    // outlandishly large was specified we should be okay.\n                }\n            }\n            error = !Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new IllegalArgumentException(\n                    \"Invalid format argument index at position \" + start + \": \"\n                            + pattern.substring(start, pos.getIndex()));\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    /**\n     * Parse the format component of a format element.\n     *\n     * @param pattern string to parse\n     * @param pos current parse position\n     * @return Format description String\n     */\n    private String parseFormatDescription(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        int depth = 1;\n        while (pos.getIndex() < pattern.length()) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                next(pos);\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    return pattern.substring(text, pos.getIndex());\n                }\n                next(pos);\n                break;\n            case QUOTE:\n                getQuotedString(pattern, pos);\n                break;\n            default:\n                next(pos);\n                break;\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }\n\n    /**\n     * Insert formats back into the pattern for toPattern() support.\n     *\n     * @param pattern source\n     * @param customPatterns The custom patterns to re-insert, if any\n     * @return full pattern\n     */\n    private String insertFormats(final String pattern, final ArrayList<String> customPatterns) {\n        if (!containsElements(customPatterns)) {\n            return pattern;\n        }\n        final StringBuilder sb = new StringBuilder(pattern.length() * 2);\n        final ParsePosition pos = new ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            final char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, sb);\n                break;\n            case START_FE:\n                depth++;\n                sb.append(START_FE).append(readArgumentIndex(pattern, next(pos)));\n                // do not look for custom patterns when they are embedded, e.g. in a choice\n                if (depth == 1) {\n                    fe++;\n                    final String customPattern = customPatterns.get(fe);\n                    if (customPattern != null) {\n                        sb.append(START_FMT).append(customPattern);\n                    }\n                }\n                break;\n            case END_FE:\n                depth--;\n                //$FALL-THROUGH$\n            default:\n                sb.append(c);\n                next(pos);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Consume whitespace from the current parse position.\n     *\n     * @param pattern String to read\n     * @param pos current position\n     */\n    private void seekNonWs(final String pattern, final ParsePosition pos) {\n        int len = 0;\n        final char[] buffer = pattern.toCharArray();\n        do {\n            len = StringMatcherFactory.INSTANCE.splitMatcher().isMatch(buffer, pos.getIndex(), 0, buffer.length);\n            pos.setIndex(pos.getIndex() + len);\n        } while (len > 0 && pos.getIndex() < pattern.length());\n    }\n\n    /**\n     * Convenience method to advance parse position by 1.\n     *\n     * @param pos ParsePosition\n     * @return {@code pos}\n     */\n    private ParsePosition next(final ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }\n\n    /**\n     * Consume a quoted string, adding it to {@code appendTo} if\n     * specified.\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuilder to append\n     * @return {@code appendTo}\n     */\n    private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos,\n            final StringBuilder appendTo) {\n        assert pattern.toCharArray()[pos.getIndex()] == QUOTE\n                : \"Quoted string must start with quote character\";\n\n        // handle quote character at the beginning of the string\n        if (appendTo != null) {\n            appendTo.append(QUOTE);\n        }\n        next(pos);\n\n        final int start = pos.getIndex();\n        final char[] c = pattern.toCharArray();\n        final int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n\n    /**\n     * Consume quoted string only.\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position\n     */\n    private void getQuotedString(final String pattern, final ParsePosition pos) {\n        appendQuotedString(pattern, pos, null);\n    }\n\n    /**\n     * Learn whether the specified Collection contains non-null elements.\n     * @param coll to check\n     * @return {@code true} if some Object was found, {@code false} otherwise.\n     */\n    private boolean containsElements(final Collection<?> coll) {\n        if (coll == null || coll.isEmpty()) {\n            return false;\n        }\n        for (final Object name : coll) {\n            if (name != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/ExtendedMessageFormat.java b/src/main/java/org/apache/commons/text/ExtendedMessageFormat.java\nindex e4b5b6ada3..28c1604487 100644\n--- a/src/main/java/org/apache/commons/text/ExtendedMessageFormat.java\n+++ b/src/main/java/org/apache/commons/text/ExtendedMessageFormat.java\n@@ -89,12 +89,12 @@ public class ExtendedMessageFormat extends MessageFormat {\n     private static final char START_FMT = ',';\n \n     /**\n-     * A right side squigly brace.\n+     * A right side squiggly brace.\n      */\n     private static final char END_FE = '}';\n \n     /**\n-     * A left side squigly brace.\n+     * A left side squiggly brace.\n      */\n     private static final char START_FE = '{';\n \n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/StrSubstitutor.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class StrSubstitutorTest2 {\n\n    @Test\n    public void testValueDelimiterMatcherDocumentation() {\n        final StrSubstitutor sub = new StrSubstitutor();\n        sub.setValueDelimiter(\":-\");\n        assertEquals(\":-\", sub.getValueDelimiterMatcher().toString());\n    }\n\n    @Test\n    public void testValueDelimiterMatcherDocumentationWithChar() {\n        final StrSubstitutor sub = new StrSubstitutor();\n        sub.setValueDelimiter(':');\n        assertEquals(\":\", sub.getValueDelimiterMatcher().toString());\n    }\n\n    @Test\n    public void testValueDelimiterMatcherDocumentationWithNull() {\n        final StrSubstitutor sub = new StrSubstitutor();\n        sub.setValueDelimiter((String) null);\n        assertEquals(null, sub.getValueDelimiterMatcher());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.lang3.Validate;\n\n/**\n * Substitutes variables within a string by values.\n * <p>\n * This class takes a piece of text and substitutes all the variables within it.\n * The default definition of a variable is {@code ${variableName}}.\n * The prefix and suffix can be changed via constructors and set methods.\n * <p>\n * Variable values are typically resolved from a map, but could also be resolved\n * from system properties, or by supplying a custom variable resolver.\n * <p>\n * The simplest example is to use this class to replace Java System properties. For example:\n * <pre>\n * StrSubstitutor.replaceSystemProperties(\n *      \"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n * </pre>\n * <p>\n * Typical usage of this class follows the following pattern: First an instance is created\n * and initialized with the map that contains the values for the available variables.\n * If a prefix and/or suffix for variables should be used other than the default ones,\n * the appropriate settings can be performed. After that the {@code replace()}\n * method can be called passing in the source text for interpolation. In the returned\n * text all variable references (as long as their values are known) will be resolved.\n * The following example demonstrates this:\n * <pre>\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n * String resolvedString = sub.replace(templateString);\n * </pre>\n * yielding:\n * <pre>\n *      The quick brown fox jumped over the lazy dog.\n * </pre>\n * <p>\n * Also, this class allows to set a default value for unresolved variables.\n * The default value for a variable can be appended to the variable name after the variable\n * default value delimiter. The default value of the variable default value delimiter is ':-',\n * as in bash and other *nix shells, as those are arguably where the default ${} delimiter set originated.\n * The variable default value delimiter can be manually set by calling {@link #setValueDelimiterMatcher(StrMatcher)},\n * {@link #setValueDelimiter(char)} or {@link #setValueDelimiter(String)}.\n * The following shows an example with variable default value settings:\n * <pre>\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target}. ${undefined.number:-1234567890}.&quot;;\n * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n * String resolvedString = sub.replace(templateString);\n * </pre>\n * yielding:\n * <pre>\n *      The quick brown fox jumped over the lazy dog. 1234567890.\n * </pre>\n * <p>\n * In addition to this usage pattern there are some static convenience methods that\n * cover the most common use cases. These methods can be used without the need of\n * manually creating an instance. However if multiple replace operations are to be\n * performed, creating and reusing an instance of this class will be more efficient.\n * <p>\n * Variable replacement works in a recursive way. Thus, if a variable value contains\n * a variable then that variable will also be replaced. Cyclic replacements are\n * detected and will cause an exception to be thrown.\n * <p>\n * Sometimes the interpolation's result must contain a variable prefix. As an example\n * take the following source text:\n * <pre>\n *   The variable ${${name}} must be used.\n * </pre>\n * Here only the variable's name referred to in the text should be replaced resulting\n * in the text (assuming that the value of the {@code name} variable is {@code x}):\n * <pre>\n *   The variable ${x} must be used.\n * </pre>\n * To achieve this effect there are two possibilities: Either set a different prefix\n * and suffix for variables which do not conflict with the result text you want to\n * produce. The other possibility is to use the escape character, by default '$'.\n * If this character is placed before a variable reference, this reference is ignored\n * and won't be replaced. For example:\n * <pre>\n *   The variable $${${name}} must be used.\n * </pre>\n * <p>\n * In some complex scenarios you might even want to perform substitution in the\n * names of variables, for instance\n * <pre>\n * ${jre-${java.specification.version}}\n * </pre>\n * {@code StrSubstitutor} supports this recursive substitution in variable\n * names, but it has to be enabled explicitly by setting the\n * {@link #setEnableSubstitutionInVariables(boolean) enableSubstitutionInVariables}\n * property to <b>true</b>.\n * <p>This class is <b>not</b> thread safe.</p>\n *\n * @since 1.0\n * @deprecated Deprecated as of 1.3, use {@link StringSubstitutor} instead. This class will be removed in 2.0.\n */\n@Deprecated\npublic class StrSubstitutor {\n\n    /**\n     * Constant for the default escape character.\n     */\n    public static final char DEFAULT_ESCAPE = '$';\n\n    /**\n     * Constant for the default variable prefix.\n     */\n    public static final StrMatcher DEFAULT_PREFIX = StrMatcher.stringMatcher(\"${\");\n\n    /**\n     * Constant for the default variable suffix.\n     */\n    public static final StrMatcher DEFAULT_SUFFIX = StrMatcher.stringMatcher(\"}\");\n\n    /**\n     * Constant for the default value delimiter of a variable.\n     */\n    public static final StrMatcher DEFAULT_VALUE_DELIMITER = StrMatcher.stringMatcher(\":-\");\n\n    /**\n     * Stores the escape character.\n     */\n    private char escapeChar;\n\n    /**\n     * Stores the variable prefix.\n     */\n    private StrMatcher prefixMatcher;\n\n    /**\n     * Stores the variable suffix.\n     */\n    private StrMatcher suffixMatcher;\n\n    /**\n     * Stores the default variable value delimiter.\n     */\n    private StrMatcher valueDelimiterMatcher;\n\n    /**\n     * Variable resolution is delegated to an implementor of VariableResolver.\n     */\n    private StrLookup<?> variableResolver;\n\n    /**\n     * The flag whether substitution in variable names is enabled.\n     */\n    private boolean enableSubstitutionInVariables;\n\n    /**\n     * Whether escapes should be preserved.  Default is false;\n     */\n    private boolean preserveEscapes = false;\n\n    /**\n     * The flag whether substitution in variable values is disabled.\n     */\n    private boolean disableSubstitutionInValues;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables in the given source object with\n     * their matching values from the map.\n     *\n     * @param <V> the type of the values in the map\n     * @param source  the source text containing the variables to substitute, null returns null\n     * @param valueMap  the map with the values, may be null\n     * @return The result of the replace operation\n     */\n    public static <V> String replace(final Object source, final Map<String, V> valueMap) {\n        return new StrSubstitutor(valueMap).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with\n     * their matching values from the map. This method allows to specify a\n     * custom variable prefix and suffix\n     *\n     * @param <V> the type of the values in the map\n     * @param source  the source text containing the variables to substitute, null returns null\n     * @param valueMap  the map with the values, may be null\n     * @param prefix  the prefix of variables, not null\n     * @param suffix  the suffix of variables, not null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public static <V> String replace(final Object source,\n                                     final Map<String, V> valueMap,\n                                     final String prefix,\n                                     final String suffix) {\n        return new StrSubstitutor(valueMap, prefix, suffix).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching\n     * values from the properties.\n     *\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueProperties the properties with values, may be null\n     * @return The result of the replace operation\n     */\n    public static String replace(final Object source, final Properties valueProperties) {\n        if (valueProperties == null) {\n            return source.toString();\n        }\n        final Map<String, String> valueMap = new HashMap<>();\n        final Enumeration<?> propNames = valueProperties.propertyNames();\n        while (propNames.hasMoreElements()) {\n            final String propName = (String) propNames.nextElement();\n            final String propValue = valueProperties.getProperty(propName);\n            valueMap.put(propName, propValue);\n        }\n        return StrSubstitutor.replace(source, valueMap);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with\n     * their matching values from the system properties.\n     *\n     * @param source  the source text containing the variables to substitute, null returns null\n     * @return The result of the replace operation\n     */\n    public static String replaceSystemProperties(final Object source) {\n        return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new instance with defaults for variable prefix and suffix\n     * and the escaping character.\n     */\n    public StrSubstitutor() {\n        this((StrLookup<?>) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses defaults for variable\n     * prefix and suffix and the escaping character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap  the map with the variables' values, may be null\n     */\n    public <V> StrSubstitutor(final Map<String, V> valueMap) {\n        this(StrLookup.mapLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses a default escaping character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap  the map with the variables' values, may be null\n     * @param prefix  the prefix for variables, not null\n     * @param suffix  the suffix for variables, not null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix) {\n        this(StrLookup.mapLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap  the map with the variables' values, may be null\n     * @param prefix  the prefix for variables, not null\n     * @param suffix  the suffix for variables, not null\n     * @param escape  the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n                              final char escape) {\n        this(StrLookup.mapLookup(valueMap), prefix, suffix, escape);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap  the map with the variables' values, may be null\n     * @param prefix  the prefix for variables, not null\n     * @param suffix  the suffix for variables, not null\n     * @param escape  the escape character\n     * @param valueDelimiter  the variable default value delimiter, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n                              final char escape, final String valueDelimiter) {\n        this(StrLookup.mapLookup(valueMap), prefix, suffix, escape, valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver  the variable resolver, may be null\n     */\n    public StrSubstitutor(final StrLookup<?> variableResolver) {\n        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver  the variable resolver, may be null\n     * @param prefix  the prefix for variables, not null\n     * @param suffix  the suffix for variables, not null\n     * @param escape  the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix,\n                          final char escape) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver  the variable resolver, may be null\n     * @param prefix  the prefix for variables, not null\n     * @param suffix  the suffix for variables, not null\n     * @param escape  the escape character\n     * @param valueDelimiter  the variable default value delimiter string, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix,\n                          final char escape, final String valueDelimiter) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiter(valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver  the variable resolver, may be null\n     * @param prefixMatcher  the prefix for variables, not null\n     * @param suffixMatcher  the suffix for variables, not null\n     * @param escape  the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StrSubstitutor(\n            final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher,\n            final char escape) {\n        this(variableResolver, prefixMatcher, suffixMatcher, escape, DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver  the variable resolver, may be null\n     * @param prefixMatcher  the prefix for variables, not null\n     * @param suffixMatcher  the suffix for variables, not null\n     * @param escape  the escape character\n     * @param valueDelimiterMatcher  the variable default value delimiter matcher, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StrSubstitutor(\n            final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher,\n            final char escape, final StrMatcher valueDelimiterMatcher) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefixMatcher(prefixMatcher);\n        this.setVariableSuffixMatcher(suffixMatcher);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(valueDelimiterMatcher);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source string as a template.\n     *\n     * @param source  the string to replace in, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final String source) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(source);\n        if (!substitute(buf, 0, source.length())) {\n            return source;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source string as a template.\n     * <p>\n     * Only the specified portion of the string will be processed.\n     * The rest of the string is not processed, and is not returned.\n     *\n     * @param source  the string to replace in, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     */\n    public String replace(final String source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return source.substring(offset, offset + length);\n        }\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source array as a template.\n     * The array is not altered by this method.\n     *\n     * @param source  the character array to replace in, not altered, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final char[] source) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(source.length).append(source);\n        substitute(buf, 0, source.length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source array as a template.\n     * The array is not altered by this method.\n     * <p>\n     * Only the specified portion of the array will be processed.\n     * The rest of the array is not processed, and is not returned.\n     *\n     * @param source  the character array to replace in, not altered, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     */\n    public String replace(final char[] source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source buffer as a template.\n     * The buffer is not altered by this method.\n     *\n     * @param source  the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final StringBuffer source) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(source.length()).append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source buffer as a template.\n     * The buffer is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed.\n     * The rest of the buffer is not processed, and is not returned.\n     *\n     * @param source  the buffer to use as a template, not changed, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     */\n    public String replace(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source as a template.\n     * The source is not altered by this method.\n     *\n     * @param source  the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final CharSequence source) {\n        if (source == null) {\n            return null;\n        }\n        return replace(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source as a template.\n     * The source is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed.\n     * The rest of the buffer is not processed, and is not returned.\n     *\n     * @param source  the buffer to use as a template, not changed, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     */\n    public String replace(final CharSequence source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source builder as a template.\n     * The builder is not altered by this method.\n     *\n     * @param source  the builder to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final StrBuilder source) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(source.length()).append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source builder as a template.\n     * The builder is not altered by this method.\n     * <p>\n     * Only the specified portion of the builder will be processed.\n     * The rest of the builder is not processed, and is not returned.\n     *\n     * @param source  the builder to use as a template, not changed, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     */\n    public String replace(final StrBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables in the given source object with\n     * their matching values from the resolver. The input source object is\n     * converted to a string using {@code toString} and is not altered.\n     *\n     * @param source  the source to replace in, null returns null\n     * @return The result of the replace operation\n     */\n    public String replace(final Object source) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder().append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables within the given source buffer\n     * with their matching values from the resolver.\n     * The buffer is updated with the result.\n     *\n     * @param source  the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuffer source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer\n     * with their matching values from the resolver.\n     * The buffer is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed.\n     * The rest of the buffer is not processed, but it is not deleted.\n     *\n     * @param source  the buffer to replace in, updated, null returns zero\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the buffer to be processed, must be valid\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n  //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables within the given source buffer\n     * with their matching values from the resolver.\n     * The buffer is updated with the result.\n     *\n     * @param source  the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder\n     * with their matching values from the resolver.\n     * The builder is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed.\n     * The rest of the buffer is not processed, but it is not deleted.\n     *\n     * @param source  the buffer to replace in, updated, null returns zero\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the buffer to be processed, must be valid\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all the occurrences of variables within the given source\n     * builder with their matching values from the resolver.\n     *\n     * @param source  the builder to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StrBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source\n     * builder with their matching values from the resolver.\n     * <p>\n     * Only the specified portion of the builder will be processed.\n     * The rest of the builder is not processed, but it is not deleted.\n     *\n     * @param source  the builder to replace in, null returns zero\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    public boolean replaceIn(final StrBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, offset, length);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method that substitutes the variables.\n     * <p>\n     * Most users of this class do not need to call this method. This method will\n     * be called automatically by another (public) method.\n     * <p>\n     * Writers of subclasses can override this method if they need access to\n     * the substitution process at the start or end.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    protected boolean substitute(final StrBuilder buf, final int offset, final int length) {\n        return substitute(buf, offset, length, null) > 0;\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation. This is the main\n     * interpolation method, which resolves the values of all variable references\n     * contained in the passed in text.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @param priorVariables  the stack keeping track of the replaced variables, may be null\n     * @return The length change that occurs, unless priorVariables is null when the int\n     *  represents a boolean flag as to whether any change occurred.\n     */\n    private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n        final StrMatcher pfxMatcher = getVariablePrefixMatcher();\n        final StrMatcher suffMatcher = getVariableSuffixMatcher();\n        final char escape = getEscapeChar();\n        final StrMatcher valueDelimMatcher = getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n        final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues();\n\n        final boolean top = priorVariables == null;\n        boolean altered = false;\n        int lengthChange = 0;\n        char[] chars = buf.buffer;\n        int bufEnd = offset + length;\n        int pos = offset;\n        while (pos < bufEnd) {\n            final int startMatchLen = pfxMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen == 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos > offset && chars[pos - 1] == escape) {\n                    // escaped\n                    if (preserveEscapes) {\n                        pos++;\n                        continue;\n                    }\n                    buf.deleteCharAt(pos - 1);\n                    chars = buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered = true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos = pos;\n                    pos += startMatchLen;\n                    int endMatchLen = 0;\n                    int nestedVarCount = 0;\n                    while (pos < bufEnd) {\n                        if (substitutionInVariablesEnabled\n                                && pfxMatcher.isMatch(chars,\n                                        pos, offset, bufEnd) != 0) {\n                            // found a nested variable start\n                            endMatchLen = pfxMatcher.isMatch(chars,\n                                    pos, offset, bufEnd);\n                            nestedVarCount++;\n                            pos += endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen = suffMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen == 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount == 0) {\n                                String varNameExpr = new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (substitutionInVariablesEnabled) {\n                                    final StrBuilder bufName = new StrBuilder(varNameExpr);\n                                    substitute(bufName, 0, bufName.length());\n                                    varNameExpr = bufName.toString();\n                                }\n                                pos += endMatchLen;\n                                final int endPos = pos;\n\n                                String varName = varNameExpr;\n                                String varDefaultValue = null;\n\n                                if (valueDelimMatcher != null) {\n                                    final char[] varNameExprChars = varNameExpr.toCharArray();\n                                    int valueDelimiterMatchLen = 0;\n                                    for (int i = 0; i < varNameExprChars.length; i++) {\n                                        // if there's any nested variable when nested variable substitution disabled,\n                                        // then stop resolving name and default value.\n                                        if (!substitutionInVariablesEnabled\n                                                && pfxMatcher.isMatch(varNameExprChars,\n                                                                        i,\n                                                                        i,\n                                                                        varNameExprChars.length) != 0) {\n                                            break;\n                                        }\n                                        if (valueDelimMatcher.isMatch(varNameExprChars, i) != 0) {\n                                            valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i);\n                                            varName = varNameExpr.substring(0, i);\n                                            varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables == null) {\n                                    priorVariables = new ArrayList<>();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                String varValue = resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue == null) {\n                                    varValue = varDefaultValue;\n                                }\n                                if (varValue != null) {\n                                    final int varLen = varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered = true;\n                                    int change = 0;\n                                    if (!substitutionInValuesDisabled) { // recursive replace\n                                        change = substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    }\n                                    change = change\n                                        + varLen - (endPos - startPos);\n                                    pos += change;\n                                    bufEnd += change;\n                                    lengthChange += change;\n                                    chars = buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            }\n                            nestedVarCount--;\n                            pos += endMatchLen;\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }\n\n    /**\n     * Checks if the specified variable is already in the stack (list) of variables.\n     *\n     * @param varName  the variable name to check\n     * @param priorVariables  the list of prior variables\n     */\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\n        if (!priorVariables.contains(varName)) {\n            return;\n        }\n        final StrBuilder buf = new StrBuilder(256);\n        buf.append(\"Infinite loop in property interpolation of \");\n        buf.append(priorVariables.remove(0));\n        buf.append(\": \");\n        buf.appendWithSeparators(priorVariables, \"->\");\n        throw new IllegalStateException(buf.toString());\n    }\n\n    /**\n     * Internal method that resolves the value of a variable.\n     * <p>\n     * Most users of this class do not need to call this method. This method is\n     * called automatically by the substitution process.\n     * <p>\n     * Writers of subclasses can override this method if they need to alter\n     * how each substitution occurs. The method is passed the variable's name\n     * and must return the corresponding value. This implementation uses the\n     * {@link #getVariableResolver()} with the variable's name as the key.\n     *\n     * @param variableName  the name of the variable, not null\n     * @param buf  the buffer where the substitution is occurring, not null\n     * @param startPos  the start position of the variable including the prefix, valid\n     * @param endPos  the end position of the variable including the suffix, valid\n     * @return The variable's value or <b>null</b> if the variable is unknown\n     */\n    protected String resolveVariable(final String variableName,\n                                     final StrBuilder buf,\n                                     final int startPos,\n                                     final int endPos) {\n        final StrLookup<?> resolver = getVariableResolver();\n        if (resolver == null) {\n            return null;\n        }\n        return resolver.lookup(variableName);\n    }\n\n    // Escape\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the escape character.\n     *\n     * @return The character used for escaping variable references\n     */\n    public char getEscapeChar() {\n        return this.escapeChar;\n    }\n\n    /**\n     * Sets the escape character.\n     * If this character is placed before a variable reference in the source\n     * text, this variable will be ignored.\n     *\n     * @param escapeCharacter  the escape character (0 for disabling escaping)\n     */\n    public void setEscapeChar(final char escapeCharacter) {\n        this.escapeChar = escapeCharacter;\n    }\n\n    // Prefix\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the\n     * start of a variable. This prefix is expressed in terms of a matcher\n     * allowing advanced prefix matches.\n     *\n     * @return The prefix matcher in use\n     */\n    public StrMatcher getVariablePrefixMatcher() {\n        return prefixMatcher;\n    }\n\n    /**\n     * Sets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the\n     * start of a variable. This prefix is expressed in terms of a matcher\n     * allowing advanced prefix matches.\n     *\n     * @param prefixMatcher  the prefix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix matcher is null\n     */\n    public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher) {\n        Validate.isTrue(prefixMatcher != null, \"Variable prefix matcher must not be null!\");\n        this.prefixMatcher = prefixMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the\n     * start of a variable. This method allows a single character prefix to\n     * be easily set.\n     *\n     * @param prefix  the prefix character to use\n     * @return this, to enable chaining\n     */\n    public StrSubstitutor setVariablePrefix(final char prefix) {\n        return setVariablePrefixMatcher(StrMatcher.charMatcher(prefix));\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the\n     * start of a variable. This method allows a string prefix to be easily set.\n     *\n     * @param prefix  the prefix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix is null\n     */\n    public StrSubstitutor setVariablePrefix(final String prefix) {\n        Validate.isTrue(prefix != null, \"Variable prefix must not be null!\");\n        return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));\n    }\n\n    // Suffix\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the\n     * end of a variable. This suffix is expressed in terms of a matcher\n     * allowing advanced suffix matches.\n     *\n     * @return The suffix matcher in use\n     */\n    public StrMatcher getVariableSuffixMatcher() {\n        return suffixMatcher;\n    }\n\n    /**\n     * Sets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the\n     * end of a variable. This suffix is expressed in terms of a matcher\n     * allowing advanced suffix matches.\n     *\n     * @param suffixMatcher  the suffix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix matcher is null\n     */\n    public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) {\n        Validate.isTrue(suffixMatcher != null, \"Variable suffix matcher must not be null!\");\n        this.suffixMatcher = suffixMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the\n     * end of a variable. This method allows a single character suffix to\n     * be easily set.\n     *\n     * @param suffix  the suffix character to use\n     * @return this, to enable chaining\n     */\n    public StrSubstitutor setVariableSuffix(final char suffix) {\n        return setVariableSuffixMatcher(StrMatcher.charMatcher(suffix));\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the\n     * end of a variable. This method allows a string suffix to be easily set.\n     *\n     * @param suffix  the suffix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix is null\n     */\n    public StrSubstitutor setVariableSuffix(final String suffix) {\n        Validate.isTrue(suffix != null, \"Variable suffix must not be null!\");\n        return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));\n    }\n\n    // Variable Default Value Delimiter\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the variable default value delimiter matcher currently in use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimite the\n     * variable name and the variable default value. This delimiter is expressed in terms of a matcher\n     * allowing advanced variable default value delimiter matches.\n     * <p>\n     * If it returns null, then the variable default value resolution is disabled.\n     *\n     * @return The variable default value delimiter matcher in use, may be null\n     */\n    public StrMatcher getValueDelimiterMatcher() {\n        return valueDelimiterMatcher;\n    }\n\n    /**\n     * Sets the variable default value delimiter matcher to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimite the\n     * variable name and the variable default value. This delimiter is expressed in terms of a matcher\n     * allowing advanced variable default value delimiter matches.\n     * <p>\n     * If the {@code valueDelimiterMatcher} is null, then the variable default value resolution\n     * becomes disabled.\n     *\n     * @param valueDelimiterMatcher  variable default value delimiter matcher to use, may be null\n     * @return this, to enable chaining\n     */\n    public StrSubstitutor setValueDelimiterMatcher(final StrMatcher valueDelimiterMatcher) {\n        this.valueDelimiterMatcher = valueDelimiterMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimite the\n     * variable name and the variable default value. This method allows a single character\n     * variable default value delimiter to be easily set.\n     *\n     * @param valueDelimiter  the variable default value delimiter character to use\n     * @return this, to enable chaining\n     */\n    public StrSubstitutor setValueDelimiter(final char valueDelimiter) {\n        return setValueDelimiterMatcher(StrMatcher.charMatcher(valueDelimiter));\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimite the\n     * variable name and the variable default value. This method allows a string\n     * variable default value delimiter to be easily set.\n     * <p>\n     * If the {@code valueDelimiter} is null or empty string, then the variable default\n     * value resolution becomes disabled.\n     *\n     * @param valueDelimiter  the variable default value delimiter string to use, may be null or empty\n     * @return this, to enable chaining\n     */\n    public StrSubstitutor setValueDelimiter(final String valueDelimiter) {\n        if (valueDelimiter == null || valueDelimiter.length() == 0) {\n            setValueDelimiterMatcher(null);\n            return this;\n        }\n        return setValueDelimiterMatcher(StrMatcher.stringMatcher(valueDelimiter));\n    }\n\n    // Resolver\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the VariableResolver that is used to lookup variables.\n     *\n     * @return The VariableResolver\n     */\n    public StrLookup<?> getVariableResolver() {\n        return this.variableResolver;\n    }\n\n    /**\n     * Sets the VariableResolver that is used to lookup variables.\n     *\n     * @param variableResolver  the VariableResolver\n     */\n    public void setVariableResolver(final StrLookup<?> variableResolver) {\n        this.variableResolver = variableResolver;\n    }\n\n    // Substitution support in variable names\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a flag whether substitution is done in variable names.\n     *\n     * @return The substitution in variable names flag\n     */\n    public boolean isEnableSubstitutionInVariables() {\n        return enableSubstitutionInVariables;\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable names. If set to\n     * <b>true</b>, the names of variables can contain other variables which are\n     * processed first before the original variable is evaluated, e.g.\n     * {@code ${jre-${java.version}}}. The default value is <b>false</b>.\n     *\n     * @param enableSubstitutionInVariables the new value of the flag\n     */\n    public void setEnableSubstitutionInVariables(\n            final boolean enableSubstitutionInVariables) {\n        this.enableSubstitutionInVariables = enableSubstitutionInVariables;\n    }\n\n    /**\n     * Returns a flag whether substitution is disabled in variable values.If set to\n     * <b>true</b>, the values of variables can contain other variables will not be\n     * processed and substituted original variable is evaluated, e.g.\n     * <pre>\n     * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n     * valuesMap.put(&quot;name&quot;, &quot;Douglas ${surname}&quot;);\n     * valuesMap.put(&quot;surname&quot;, &quot;Crockford&quot;);\n     * String templateString = &quot;Hi ${name}&quot;;\n     * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n     * String resolvedString = sub.replace(templateString);\n     * </pre>\n     * yielding:\n     * <pre>\n     *      Hi Douglas ${surname}\n     * </pre>\n     *\n     * @return The substitution in variable values flag\n     *\n     * @since 1.2\n     */\n    public boolean isDisableSubstitutionInValues() {\n        return disableSubstitutionInValues;\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable values (recursive).\n     *\n     * @param disableSubstitutionInValues true if substitution in variable value are disabled\n     *\n     * @since 1.2\n     */\n    public void setDisableSubstitutionInValues(final boolean disableSubstitutionInValues) {\n        this.disableSubstitutionInValues = disableSubstitutionInValues;\n    }\n\n    /**\n     * Returns the flag controlling whether escapes are preserved during\n     * substitution.\n     *\n     * @return The preserve escape flag\n     */\n    public boolean isPreserveEscapes() {\n        return preserveEscapes;\n    }\n\n    /**\n     * Sets a flag controlling whether escapes are preserved during\n     * substitution.  If set to <b>true</b>, the escape character is retained\n     * during substitution (e.g. {@code $${this-is-escaped}} remains\n     * {@code $${this-is-escaped}}).  If set to <b>false</b>, the escape\n     * character is removed during substitution (e.g.\n     * {@code $${this-is-escaped}} becomes\n     * {@code ${this-is-escaped}}).  The default value is <b>false</b>\n     *\n     * @param preserveEscapes true if escapes are to be preserved\n     */\n    public void setPreserveEscapes(final boolean preserveEscapes) {\n        this.preserveEscapes = preserveEscapes;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/StrSubstitutor.java b/src/main/java/org/apache/commons/text/StrSubstitutor.java\nindex 5216a07972..362c02385d 100644\n--- a/src/main/java/org/apache/commons/text/StrSubstitutor.java\n+++ b/src/main/java/org/apache/commons/text/StrSubstitutor.java\n@@ -1103,7 +1103,7 @@ public StrSubstitutor setVariableSuffix(final String suffix) {\n     /**\n      * Gets the variable default value delimiter matcher currently in use.\n      * <p>\n-     * The variable default value delimiter is the character or characters that delimite the\n+     * The variable default value delimiter is the character or characters that delimit the\n      * variable name and the variable default value. This delimiter is expressed in terms of a matcher\n      * allowing advanced variable default value delimiter matches.\n      * <p>\n@@ -1118,7 +1118,7 @@ public StrMatcher getValueDelimiterMatcher() {\n     /**\n      * Sets the variable default value delimiter matcher to use.\n      * <p>\n-     * The variable default value delimiter is the character or characters that delimite the\n+     * The variable default value delimiter is the character or characters that delimit the\n      * variable name and the variable default value. This delimiter is expressed in terms of a matcher\n      * allowing advanced variable default value delimiter matches.\n      * <p>\n@@ -1136,7 +1136,7 @@ public StrSubstitutor setValueDelimiterMatcher(final StrMatcher valueDelimiterMa\n     /**\n      * Sets the variable default value delimiter to use.\n      * <p>\n-     * The variable default value delimiter is the character or characters that delimite the\n+     * The variable default value delimiter is the character or characters that delimit the\n      * variable name and the variable default value. This method allows a single character\n      * variable default value delimiter to be easily set.\n      *\n@@ -1150,7 +1150,7 @@ public StrSubstitutor setValueDelimiter(final char valueDelimiter) {\n     /**\n      * Sets the variable default value delimiter to use.\n      * <p>\n-     * The variable default value delimiter is the character or characters that delimite the\n+     * The variable default value delimiter is the character or characters that delimit the\n      * variable name and the variable default value. This method allows a string\n      * variable default value delimiter to be easily set.\n      * <p>\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/StringSubstitutor.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatNullPointerException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.commons.text.lookup.StringLookup;\nimport org.apache.commons.text.lookup.StringLookupFactory;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\n\n@TestMethodOrder(MethodOrderer.Alphanumeric.class)\npublic class StringSubstitutorTest2 {\n\n    private static final String ACTUAL_ANIMAL = \"quick brown fox\";\n    private static final String ACTUAL_TARGET = \"lazy dog\";\n    private static final String CLASSIC_RESULT = \"The quick brown fox jumps over the lazy dog.\";\n    private static final String CLASSIC_TEMPLATE = \"The ${animal} jumps over the ${target}.\";\n    private static final String EMPTY_EXPR = \"${}\";\n\n    protected Map<String, String> values;\n\n    private void assertEqualsCharSeq(final CharSequence expected, final CharSequence actual) {\n        assertEquals(expected, actual, () -> String.format(\"expected.length()=%,d, actual.length()=%,d\",\n                StringUtils.length(expected), StringUtils.length(actual)));\n    }\n\n    protected void doNotReplace(final String replaceTemplate) throws IOException {\n        doTestNoReplace(new StringSubstitutor(values), replaceTemplate);\n    }\n\n    protected void doReplace(final String expectedResult, final String replaceTemplate, final boolean substring)\n            throws IOException {\n        doTestReplace(new StringSubstitutor(values), expectedResult, replaceTemplate, substring);\n    }\n\n    protected void doTestNoReplace(final StringSubstitutor substitutor, final String replaceTemplate)\n            throws IOException {\n        if (replaceTemplate == null) {\n            assertNull(replace(substitutor, (String) null));\n            assertNull(substitutor.replace((String) null, 0, 100));\n            assertNull(substitutor.replace((char[]) null));\n            assertNull(substitutor.replace((char[]) null, 0, 100));\n            assertNull(substitutor.replace((StringBuffer) null));\n            assertNull(substitutor.replace((StringBuffer) null, 0, 100));\n            assertNull(substitutor.replace((TextStringBuilder) null));\n            assertNull(substitutor.replace((TextStringBuilder) null, 0, 100));\n            assertNull(substitutor.replace((Object) null));\n            assertFalse(substitutor.replaceIn((StringBuffer) null));\n            assertFalse(substitutor.replaceIn((StringBuffer) null, 0, 100));\n            assertFalse(substitutor.replaceIn((TextStringBuilder) null));\n            assertFalse(substitutor.replaceIn((TextStringBuilder) null, 0, 100));\n        } else {\n            assertEquals(replaceTemplate, replace(substitutor, replaceTemplate));\n            final TextStringBuilder builder = new TextStringBuilder(replaceTemplate);\n            assertFalse(substitutor.replaceIn(builder));\n            assertEquals(replaceTemplate, builder.toString());\n        }\n    }\n\n    protected void doTestReplace(final StringSubstitutor sub, final String expectedResult, final String replaceTemplate,\n            final boolean substring) throws IOException {\n        final String expectedShortResult = substring ? expectedResult.substring(1, expectedResult.length() - 1)\n                : expectedResult;\n        final String actual = replace(sub, replaceTemplate);\n        assertEquals(expectedResult, actual,\n                () -> String.format(\"Index of difference: %,d\", StringUtils.indexOfDifference(expectedResult, actual)));\n        if (substring) {\n            assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2));\n        }\n        final char[] chars = replaceTemplate.toCharArray();\n        assertEquals(expectedResult, sub.replace(chars));\n        if (substring) {\n            assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2));\n        }\n        StringBuffer buf = new StringBuffer(replaceTemplate);\n        assertEquals(expectedResult, sub.replace(buf));\n        if (substring) {\n            assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2));\n        }\n        StringBuilder builder = new StringBuilder(replaceTemplate);\n        assertEquals(expectedResult, sub.replace(builder));\n        if (substring) {\n            assertEquals(expectedShortResult, sub.replace(builder, 1, builder.length() - 2));\n        }\n        TextStringBuilder bld = new TextStringBuilder(replaceTemplate);\n        assertEquals(expectedResult, sub.replace(bld));\n        if (substring) {\n            assertEquals(expectedShortResult, sub.replace(bld, 1, bld.length() - 2));\n        }\n        final MutableObject<String> obj = new MutableObject<>(replaceTemplate);\n        assertEquals(expectedResult, sub.replace(obj));\n        buf = new StringBuffer(replaceTemplate);\n        assertTrue(sub.replaceIn(buf), replaceTemplate);\n        assertEquals(expectedResult, buf.toString());\n        if (substring) {\n            buf = new StringBuffer(replaceTemplate);\n            assertTrue(sub.replaceIn(buf, 1, buf.length() - 2));\n            assertEquals(expectedResult, buf.toString());\n        }\n        builder = new StringBuilder(replaceTemplate);\n        assertTrue(sub.replaceIn(builder));\n        assertEquals(expectedResult, builder.toString());\n        if (substring) {\n            builder = new StringBuilder(replaceTemplate);\n            assertTrue(sub.replaceIn(builder, 1, builder.length() - 2));\n            assertEquals(expectedResult, builder.toString());\n        }\n        bld = new TextStringBuilder(replaceTemplate);\n        assertTrue(sub.replaceIn(bld));\n        assertEquals(expectedResult, bld.toString());\n        if (substring) {\n            bld = new TextStringBuilder(replaceTemplate);\n            assertTrue(sub.replaceIn(bld, 1, bld.length() - 2));\n            assertEquals(expectedResult, bld.toString());\n        }\n    }\n\n    protected String replace(final StringSubstitutor stringSubstitutor, final String template) throws IOException {\n        return stringSubstitutor.replace(template);\n    }\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        values = new HashMap<>();\n        values.put(\"a\", \"1\");\n        values.put(\"aa\", \"11\");\n        values.put(\"aaa\", \"111\");\n        values.put(\"b\", \"2\");\n        values.put(\"bb\", \"22\");\n        values.put(\"bbb\", \"222\");\n        values.put(\"a2b\", \"b\");\n        values.put(\"animal\", ACTUAL_ANIMAL);\n        values.put(\"target\", ACTUAL_TARGET);\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception {\n        values = null;\n    }\n\n    @Test\n    public void testTypoFixInJavadoc() {\n        // This test ensures that the typo fix in the Javadoc comments does not affect functionality.\n        final StringSubstitutor sub = new StringSubstitutor(values);\n        assertEqualsCharSeq(CLASSIC_RESULT, replace(sub, CLASSIC_TEMPLATE));\n    }\n\n    @Test\n    public void testOuterLoopLabel() throws IOException {\n        // This test ensures that the change from 'outter' to 'outer' in the loop label does not affect functionality.\n        doReplace(CLASSIC_RESULT, CLASSIC_TEMPLATE, true);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\n\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.text.lookup.StringLookup;\nimport org.apache.commons.text.lookup.StringLookupFactory;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\n\n/**\n * Substitutes variables within a string by values.\n * <p>\n * This class takes a piece of text and substitutes all the variables within it. The default definition of a variable is\n * {@code ${variableName}}. The prefix and suffix can be changed via constructors and set methods.\n * </p>\n * <p>\n * Variable values are typically resolved from a map, but could also be resolved from system properties, or by supplying\n * a custom variable resolver.\n * </p>\n * <h2>Using System Properties</h2>\n * <p>\n * The simplest example is to use this class to replace Java System properties. For example:\n * </p>\n *\n * <pre>\n * StringSubstitutor\n *     .replaceSystemProperties(\"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n * </pre>\n *\n * <h2>Using a Custom Map</h2>\n * <p>\n * Typical usage of this class follows the following pattern:\n * </p>\n * <ul>\n * <li>Create and initialize a StringSubstitutor with the map that contains the values for the variables you want to\n * make available.</li>\n * <li>Optionally set attributes like variable prefix, variable suffix, default value delimiter, and so on.</li>\n * <li>Call the {@code replace()} method with in the source text for interpolation.</li>\n * <li>The returned text contains all variable references (as long as their values are known) as resolved.</li>\n * </ul>\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * // Build map\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n *\n * // Build StringSubstitutor\n * StringSubstitutor sub = new StringSubstitutor(valuesMap);\n *\n * // Replace\n * String resolvedString = sub.replace(templateString);\n * </pre>\n *\n * <p>\n * yielding:\n * </p>\n *\n * <pre>\n * \"The quick brown fox jumped over the lazy dog.\"\n * </pre>\n *\n * <h2>Providing Default Values</h2>\n * <p>\n * You can set a default value for unresolved variables. The default value for a variable can be appended to the\n * variable name after the variable default value delimiter. The default value of the variable default value delimiter\n * is \":-\", as in bash and other *nix shells.\n * </p>\n * <p>\n * You can set the variable value delimiter with {@link #setValueDelimiterMatcher(StringMatcher)},\n * {@link #setValueDelimiter(char)} or {@link #setValueDelimiter(String)}.\n * </p>\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * // Build map\n * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n * String templateString = &quot;The ${animal} jumped over the ${target} ${undefined.number:-1234567890} times.&quot;;\n *\n * // Build StringSubstitutor\n * StringSubstitutor sub = new StringSubstitutor(valuesMap);\n *\n * // Replace\n * String resolvedString = sub.replace(templateString);\n * </pre>\n *\n * <p>\n * yielding:\n * </p>\n *\n * <pre>\n * \"The quick brown fox jumped over the lazy dog 1234567890 times.\"\n * </pre>\n *\n * <p>\n * {@code StringSubstitutor} supports throwing exceptions for unresolved variables, you enable this by setting calling\n * {@link #setEnableUndefinedVariableException(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Reusing Instances</h2>\n * <p>\n * Static shortcut methods cover the most common use cases. If multiple replace operations are to be performed, creating\n * and reusing an instance of this class will be more efficient.\n * </p>\n *\n * <h2>Using Interpolation</h2>\n * <p>\n * The default interpolator let's you use string lookups like:\n * </p>\n *\n * <pre>\n * final StringSubstitutor interpolator = StringSubstitutor.createInterpolator();\n * interpolator.setEnableSubstitutionInVariables(true); // Allows for nested $'s.\n * final String text = interpolator.replace(\"Base64 Decoder:        ${base64Decoder:SGVsbG9Xb3JsZCE=}\\n\"\n *     + \"Base64 Encoder:        ${base64Encoder:HelloWorld!}\\n\"\n *     + \"Java Constant:         ${const:java.awt.event.KeyEvent.VK_ESCAPE}\\n\"\n *     + \"Date:                  ${date:yyyy-MM-dd}\\n\" + \"DNS:                   ${dns:address|apache.org}\\n\"\n *     + \"Environment Variable:  ${env:USERNAME}\\n\"\n *     + \"File Content:          ${file:UTF-8:src/test/resources/document.properties}\\n\"\n *     + \"Java:                  ${java:version}\\n\" + \"Localhost:             ${localhost:canonical-name}\\n\"\n *     + \"Properties File:       ${properties:src/test/resources/document.properties::mykey}\\n\"\n *     + \"Resource Bundle:       ${resourceBundle:org.example.testResourceBundleLookup:mykey}\\n\"\n *     + \"Script:                ${script:javascript:3 + 4}\\n\" + \"System Property:       ${sys:user.dir}\\n\"\n *     + \"URL Decoder:           ${urlDecoder:Hello%20World%21}\\n\"\n *     + \"URL Encoder:           ${urlEncoder:Hello World!}\\n\"\n *     + \"URL Content (HTTP):    ${url:UTF-8:http://www.apache.org}\\n\"\n *     + \"URL Content (HTTPS):   ${url:UTF-8:https://www.apache.org}\\n\"\n *     + \"URL Content (File):    ${url:UTF-8:file:///${sys:user.dir}/src/test/resources/document.properties}\\n\"\n *     + \"XML XPath:             ${xml:src/test/resources/document.xml:/root/path/to/node}\\n\");\n * </pre>\n * <p>\n * For documentation of each lookup, see {@link StringLookupFactory}.\n * </p>\n *\n * <h2>Using Recursive Variable Replacement</h2>\n * <p>\n * Variable replacement can work recursively by calling {@link #setEnableSubstitutionInVariables(boolean)} with\n * {@code true}. If a variable value contains a variable then that variable will also be replaced. Cyclic replacements\n * are detected and will throw an exception.\n * </p>\n * <p>\n * You can get the replace result to contain a variable prefix. For example:\n * </p>\n *\n * <pre>\n * \"The variable ${${name}} must be used.\"\n * </pre>\n *\n * <p>\n * If the value of the \"name\" variable is \"x\", then only the variable \"name\" is replaced resulting in:\n * </p>\n *\n * <pre>\n * \"The variable ${x} must be used.\"\n * </pre>\n *\n * <p>\n * To achieve this effect there are two possibilities: Either set a different prefix and suffix for variables which do\n * not conflict with the result text you want to produce. The other possibility is to use the escape character, by\n * default '$'. If this character is placed before a variable reference, this reference is ignored and won't be\n * replaced. For example:\n * </p>\n *\n * <pre>\n * \"The variable $${${name}} must be used.\"\n * </pre>\n * <p>\n * In some complex scenarios you might even want to perform substitution in the names of variables, for instance\n * </p>\n *\n * <pre>\n * ${jre-${java.specification.version}}\n * </pre>\n *\n * <p>\n * {@code StringSubstitutor} supports this recursive substitution in variable names, but it has to be enabled explicitly\n * by calling {@link #setEnableSubstitutionInVariables(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Thread Safety</h2>\n * <p>\n * This class is <b>not</b> thread safe.\n * </p>\n *\n * @since 1.3\n */\npublic class StringSubstitutor {\n\n    /**\n     * The low-level result of a substitution.\n     *\n     * @since 1.9\n     */\n    private static final class Result {\n\n        /** Whether the buffer is altered. */\n        public final boolean altered;\n\n        /** The length of change. */\n        public final int lengthChange;\n\n        private Result(final boolean altered, final int lengthChange) {\n            super();\n            this.altered = altered;\n            this.lengthChange = lengthChange;\n        }\n\n        @Override\n        public String toString() {\n            return \"Result [altered=\" + altered + \", lengthChange=\" + lengthChange + \"]\";\n        }\n    }\n\n    /**\n     * Constant for the default escape character.\n     */\n    public static final char DEFAULT_ESCAPE = '$';\n\n    /**\n     * The default variable default separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_DEFAULT = \":-\";\n\n    /**\n     * The default variable end separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_END = \"}\";\n\n    /**\n     * The default variable start separator.\n     *\n     * @since 1.5.\n     */\n    public static final String DEFAULT_VAR_START = \"${\";\n\n    /**\n     * Constant for the default variable prefix.\n     */\n    public static final StringMatcher DEFAULT_PREFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_START);\n\n    /**\n     * Constant for the default variable suffix.\n     */\n    public static final StringMatcher DEFAULT_SUFFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_END);\n\n    /**\n     * Constant for the default value delimiter of a variable.\n     */\n    public static final StringMatcher DEFAULT_VALUE_DELIMITER = StringMatcherFactory.INSTANCE\n        .stringMatcher(DEFAULT_VAR_DEFAULT);\n\n    /**\n     * Creates a new instance using the interpolator string lookup\n     * {@link StringLookupFactory#interpolatorStringLookup()}.\n     * <p>\n     * This StringSubstitutor lets you perform substituions like:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\n     *   \"OS name: ${sys:os.name}, \" + \"3 + 4 = ${script:javascript:3 + 4}\");\n     * </pre>\n     *\n     * @return a new instance using the interpolator string lookup.\n     * @see StringLookupFactory#interpolatorStringLookup()\n     * @since 1.8\n     */\n    public static StringSubstitutor createInterpolator() {\n        return new StringSubstitutor(StringLookupFactory.INSTANCE.interpolatorStringLookup());\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the map.\n     *\n     * @param <V> the type of the values in the map\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueMap the map with the values, may be null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static <V> String replace(final Object source, final Map<String, V> valueMap) {\n        return new StringSubstitutor(valueMap).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the map.\n     * This method allows to specify a custom variable prefix and suffix\n     *\n     * @param <V> the type of the values in the map\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueMap the map with the values, may be null\n     * @param prefix the prefix of variables, not null\n     * @param suffix the suffix of variables, not null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static <V> String replace(final Object source, final Map<String, V> valueMap, final String prefix,\n        final String suffix) {\n        return new StringSubstitutor(valueMap, prefix, suffix).replace(source);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the\n     * properties.\n     *\n     * @param source the source text containing the variables to substitute, null returns null\n     * @param valueProperties the properties with values, may be null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static String replace(final Object source, final Properties valueProperties) {\n        if (valueProperties == null) {\n            return source.toString();\n        }\n        final Map<String, String> valueMap = new HashMap<>();\n        final Enumeration<?> propNames = valueProperties.propertyNames();\n        while (propNames.hasMoreElements()) {\n            final String propName = (String) propNames.nextElement();\n            final String propValue = valueProperties.getProperty(propName);\n            valueMap.put(propName, propValue);\n        }\n        return StringSubstitutor.replace(source, valueMap);\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the system\n     * properties.\n     *\n     * @param source the source text containing the variables to substitute, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public static String replaceSystemProperties(final Object source) {\n        return new StringSubstitutor(StringLookupFactory.INSTANCE.systemPropertyStringLookup()).replace(source);\n    }\n\n    /**\n     * The flag whether substitution in variable values is disabled.\n     */\n    private boolean disableSubstitutionInValues;\n\n    /**\n     * The flag whether substitution in variable names is enabled.\n     */\n    private boolean enableSubstitutionInVariables;\n\n    /**\n     * The flag whether exception should be thrown on undefined variable.\n     */\n    private boolean enableUndefinedVariableException;\n\n    /**\n     * Stores the escape character.\n     */\n    private char escapeChar;\n\n    /**\n     * Stores the variable prefix.\n     */\n    private StringMatcher prefixMatcher;\n\n    /**\n     * Whether escapes should be preserved. Default is false;\n     */\n    private boolean preserveEscapes;\n\n    /**\n     * Stores the variable suffix.\n     */\n    private StringMatcher suffixMatcher;\n\n    /**\n     * Stores the default variable value delimiter.\n     */\n    private StringMatcher valueDelimiterMatcher;\n\n    /**\n     * Variable resolution is delegated to an implementor of {@link StringLookup}.\n     */\n    private StringLookup variableResolver;\n\n    /**\n     * Creates a new instance with defaults for variable prefix and suffix and the escaping character.\n     */\n    public StringSubstitutor() {\n        this((StringLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses defaults for variable prefix and suffix and the escaping\n     * character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it. Uses a default escaping character.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n        final char escape) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param <V> the type of the values in the map\n     * @param valueMap the map with the variables' values, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiter the variable default value delimiter, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\n        final char escape, final String valueDelimiter) {\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape, valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     */\n    public StringSubstitutor(final StringLookup variableResolver) {\n        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,\n        final char escape) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefix the prefix for variables, not null\n     * @param suffix the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiter the variable default value delimiter string, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,\n        final char escape, final String valueDelimiter) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefix(prefix);\n        this.setVariableSuffix(suffix);\n        this.setEscapeChar(escape);\n        this.setValueDelimiter(valueDelimiter);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefixMatcher the prefix for variables, not null\n     * @param suffixMatcher the suffix for variables, not null\n     * @param escape the escape character\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,\n        final StringMatcher suffixMatcher, final char escape) {\n        this(variableResolver, prefixMatcher, suffixMatcher, escape, DEFAULT_VALUE_DELIMITER);\n    }\n\n    /**\n     * Creates a new instance and initializes it.\n     *\n     * @param variableResolver the variable resolver, may be null\n     * @param prefixMatcher the prefix for variables, not null\n     * @param suffixMatcher the suffix for variables, not null\n     * @param escape the escape character\n     * @param valueDelimiterMatcher the variable default value delimiter matcher, may be null\n     * @throws IllegalArgumentException if the prefix or suffix is null\n     */\n    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,\n        final StringMatcher suffixMatcher, final char escape, final StringMatcher valueDelimiterMatcher) {\n        this.setVariableResolver(variableResolver);\n        this.setVariablePrefixMatcher(prefixMatcher);\n        this.setVariableSuffixMatcher(suffixMatcher);\n        this.setEscapeChar(escape);\n        this.setValueDelimiterMatcher(valueDelimiterMatcher);\n    }\n\n    /**\n     * Creates a new instance based on the given StringSubstitutor.\n     *\n     * @param other The StringSubstitutor is use as the source.\n     * @since 1.9\n     */\n    public StringSubstitutor(final StringSubstitutor other) {\n        disableSubstitutionInValues = other.isDisableSubstitutionInValues();\n        enableSubstitutionInVariables = other.isEnableSubstitutionInVariables();\n        enableUndefinedVariableException = other.isEnableUndefinedVariableException();\n        escapeChar = other.getEscapeChar();\n        prefixMatcher = other.getVariablePrefixMatcher();\n        preserveEscapes = other.isPreserveEscapes();\n        suffixMatcher = other.getVariableSuffixMatcher();\n        valueDelimiterMatcher = other.getValueDelimiterMatcher();\n        variableResolver = other.getStringLookup();\n    }\n\n    /**\n     * Checks if the specified variable is already in the stack (list) of variables.\n     *\n     * @param varName the variable name to check\n     * @param priorVariables the list of prior variables\n     */\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\n        if (!priorVariables.contains(varName)) {\n            return;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(256);\n        buf.append(\"Infinite loop in property interpolation of \");\n        buf.append(priorVariables.remove(0));\n        buf.append(\": \");\n        buf.appendWithSeparators(priorVariables, \"->\");\n        throw new IllegalStateException(buf.toString());\n    }\n\n    // Escape\n    /**\n     * Returns the escape character.\n     *\n     * @return The character used for escaping variable references\n     */\n    public char getEscapeChar() {\n        return this.escapeChar;\n    }\n\n    /**\n     * Gets the StringLookup that is used to lookup variables.\n     *\n     * @return The StringLookup\n     */\n    public StringLookup getStringLookup() {\n        return this.variableResolver;\n    }\n\n    /**\n     * Gets the variable default value delimiter matcher currently in use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimite the variable name and the\n     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\n     * value delimiter matches.\n     * </p>\n     * <p>\n     * If it returns null, then the variable default value resolution is disabled.\n     *\n     * @return The variable default value delimiter matcher in use, may be null\n     */\n    public StringMatcher getValueDelimiterMatcher() {\n        return valueDelimiterMatcher;\n    }\n\n    /**\n     * Gets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This prefix is\n     * expressed in terms of a matcher allowing advanced prefix matches.\n     * </p>\n     *\n     * @return The prefix matcher in use\n     */\n    public StringMatcher getVariablePrefixMatcher() {\n        return prefixMatcher;\n    }\n\n    /**\n     * Gets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed\n     * in terms of a matcher allowing advanced suffix matches.\n     * </p>\n     *\n     * @return The suffix matcher in use\n     */\n    public StringMatcher getVariableSuffixMatcher() {\n        return suffixMatcher;\n    }\n\n    /**\n     * Returns a flag whether substitution is disabled in variable values.If set to <b>true</b>, the values of variables\n     * can contain other variables will not be processed and substituted original variable is evaluated, e.g.\n     *\n     * <pre>\n     * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n     * valuesMap.put(&quot;name&quot;, &quot;Douglas ${surname}&quot;);\n     * valuesMap.put(&quot;surname&quot;, &quot;Crockford&quot;);\n     * String templateString = &quot;Hi ${name}&quot;;\n     * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n     * String resolvedString = sub.replace(templateString);\n     * </pre>\n     *\n     * yielding:\n     *\n     * <pre>\n     *      Hi Douglas ${surname}\n     * </pre>\n     *\n     * @return The substitution in variable values flag\n     */\n    public boolean isDisableSubstitutionInValues() {\n        return disableSubstitutionInValues;\n    }\n\n    /**\n     * Returns a flag whether substitution is done in variable names.\n     *\n     * @return The substitution in variable names flag\n     */\n    public boolean isEnableSubstitutionInVariables() {\n        return enableSubstitutionInVariables;\n    }\n\n    /**\n     * Returns a flag whether exception can be thrown upon undefined variable.\n     *\n     * @return The fail on undefined variable flag\n     */\n    public boolean isEnableUndefinedVariableException() {\n        return enableUndefinedVariableException;\n    }\n\n    /**\n     * Returns the flag controlling whether escapes are preserved during substitution.\n     *\n     * @return The preserve escape flag\n     */\n    public boolean isPreserveEscapes() {\n        return preserveEscapes;\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * array as a template. The array is not altered by this method.\n     *\n     * @param source the character array to replace in, not altered, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final char[] source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source.length).append(source);\n        substitute(buf, 0, source.length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * array as a template. The array is not altered by this method.\n     * <p>\n     * Only the specified portion of the array will be processed. The rest of the array is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the character array to replace in, not altered, null returns null\n     * @param offset the start offset within the array, must be valid\n     * @param length the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final char[] source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as\n     * a template. The source is not altered by this method.\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final CharSequence source) {\n        if (source == null) {\n            return null;\n        }\n        return replace(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as\n     * a template. The source is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @param offset the start offset within the array, must be valid\n     * @param length the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final CharSequence source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source.toString(), offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables in the given source object with their matching values from the\n     * resolver. The input source object is converted to a string using {@code toString} and is not altered.\n     *\n     * @param source the source to replace in, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\n     */\n    public String replace(final Object source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder().append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * string as a template.\n     *\n     * @param source the string to replace in, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final String source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source);\n        if (!substitute(buf, 0, source.length())) {\n            return source;\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * string as a template.\n     * <p>\n     * Only the specified portion of the string will be processed. The rest of the string is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the string to replace in, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final String source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return source.substring(offset, offset + length);\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * buffer as a template. The buffer is not altered by this method.\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final StringBuffer source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(source.length()).append(source);\n        substitute(buf, 0, buf.length());\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * buffer as a template. The buffer is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the buffer to use as a template, not changed, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * builder as a template. The builder is not altered by this method.\n     *\n     * @param source the builder to use as a template, not changed, null returns null\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final TextStringBuilder source) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder builder = new TextStringBuilder(source.length()).append(source);\n        substitute(builder, 0, builder.length());\n        return builder.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\n     * builder as a template. The builder is not altered by this method.\n     * <p>\n     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, and is not\n     * returned.\n     * </p>\n     *\n     * @param source the builder to use as a template, not changed, null returns null\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return The result of the replace operation\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public String replace(final TextStringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuffer source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\n     * resolver. The buffer is updated with the result.\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @return true if altered\n     */\n    public boolean replaceIn(final StringBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return replaceIn(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver. The builder is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the buffer to replace in, updated, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final StringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver.\n     *\n     * @param source the builder to replace in, updated, null returns zero\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final TextStringBuilder source) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, 0, source.length());\n    }\n\n    /**\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\n     * resolver.\n     * <p>\n     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, but it is\n     * not deleted.\n     * </p>\n     *\n     * @param source the builder to replace in, null returns zero\n     * @param offset the start offset within the source, must be valid\n     * @param length the length within the source to be processed, must be valid\n     * @return true if altered\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     */\n    public boolean replaceIn(final TextStringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        return substitute(source, offset, length);\n    }\n\n    /**\n     * Internal method that resolves the value of a variable.\n     * <p>\n     * Most users of this class do not need to call this method. This method is called automatically by the substitution\n     * process.\n     * </p>\n     * <p>\n     * Writers of subclasses can override this method if they need to alter how each substitution occurs. The method is\n     * passed the variable's name and must return the corresponding value. This implementation uses the\n     * {@link #getStringLookup()} with the variable's name as the key.\n     * </p>\n     *\n     * @param variableName the name of the variable, not null\n     * @param buf the buffer where the substitution is occurring, not null\n     * @param startPos the start position of the variable including the prefix, valid\n     * @param endPos the end position of the variable including the suffix, valid\n     * @return The variable's value or <b>null</b> if the variable is unknown\n     */\n    protected String resolveVariable(final String variableName, final TextStringBuilder buf, final int startPos,\n        final int endPos) {\n        final StringLookup resolver = getStringLookup();\n        if (resolver == null) {\n            return null;\n        }\n        return resolver.lookup(variableName);\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable values (recursive).\n     *\n     * @param disableSubstitutionInValues true if substitution in variable value are disabled\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setDisableSubstitutionInValues(final boolean disableSubstitutionInValues) {\n        this.disableSubstitutionInValues = disableSubstitutionInValues;\n        return this;\n    }\n\n    /**\n     * Sets a flag whether substitution is done in variable names. If set to <b>true</b>, the names of variables can\n     * contain other variables which are processed first before the original variable is evaluated, e.g.\n     * {@code ${jre-${java.version}}}. The default value is <b>false</b>.\n     *\n     * @param enableSubstitutionInVariables the new value of the flag\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {\n        this.enableSubstitutionInVariables = enableSubstitutionInVariables;\n        return this;\n    }\n\n    /**\n     * Sets a flag whether exception should be thrown if any variable is undefined.\n     *\n     * @param failOnUndefinedVariable true if exception should be thrown on undefined variable\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEnableUndefinedVariableException(final boolean failOnUndefinedVariable) {\n        this.enableUndefinedVariableException = failOnUndefinedVariable;\n        return this;\n    }\n\n    /**\n     * Sets the escape character. If this character is placed before a variable reference in the source text, this\n     * variable will be ignored.\n     *\n     * @param escapeCharacter the escape character (0 for disabling escaping)\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setEscapeChar(final char escapeCharacter) {\n        this.escapeChar = escapeCharacter;\n        return this;\n    }\n\n    /**\n     * Sets a flag controlling whether escapes are preserved during substitution. If set to <b>true</b>, the escape\n     * character is retained during substitution (e.g. {@code $${this-is-escaped}} remains {@code $${this-is-escaped}}).\n     * If set to <b>false</b>, the escape character is removed during substitution (e.g. {@code $${this-is-escaped}}\n     * becomes {@code ${this-is-escaped}}). The default value is <b>false</b>\n     *\n     * @param preserveEscapes true if escapes are to be preserved\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setPreserveEscapes(final boolean preserveEscapes) {\n        this.preserveEscapes = preserveEscapes;\n        return this;\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimite the variable name and the\n     * variable default value. This method allows a single character variable default value delimiter to be easily set.\n     * </p>\n     *\n     * @param valueDelimiter the variable default value delimiter character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiter(final char valueDelimiter) {\n        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.charMatcher(valueDelimiter));\n    }\n\n    /**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimite the variable name and the\n     * variable default value. This method allows a string variable default value delimiter to be easily set.\n     * </p>\n     * <p>\n     * If the {@code valueDelimiter} is null or empty string, then the variable default value resolution becomes\n     * disabled.\n     * </p>\n     *\n     * @param valueDelimiter the variable default value delimiter string to use, may be null or empty\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiter(final String valueDelimiter) {\n        if (valueDelimiter == null || valueDelimiter.length() == 0) {\n            setValueDelimiterMatcher(null);\n            return this;\n        }\n        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.stringMatcher(valueDelimiter));\n    }\n\n    /**\n     * Sets the variable default value delimiter matcher to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimite the variable name and the\n     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\n     * value delimiter matches.\n     * </p>\n     * <p>\n     * If the {@code valueDelimiterMatcher} is null, then the variable default value resolution becomes disabled.\n     * </p>\n     *\n     * @param valueDelimiterMatcher variable default value delimiter matcher to use, may be null\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setValueDelimiterMatcher(final StringMatcher valueDelimiterMatcher) {\n        this.valueDelimiterMatcher = valueDelimiterMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This method allows a\n     * single character prefix to be easily set.\n     * </p>\n     *\n     * @param prefix the prefix character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariablePrefix(final char prefix) {\n        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.charMatcher(prefix));\n    }\n\n    /**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This method allows a\n     * string prefix to be easily set.\n     * </p>\n     *\n     * @param prefix the prefix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix is null\n     */\n    public StringSubstitutor setVariablePrefix(final String prefix) {\n        Validate.isTrue(prefix != null, \"Variable prefix must not be null!\");\n        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(prefix));\n    }\n\n    /**\n     * Sets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the start of a variable. This prefix is\n     * expressed in terms of a matcher allowing advanced prefix matches.\n     * </p>\n     *\n     * @param prefixMatcher the prefix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix matcher is null\n     */\n    public StringSubstitutor setVariablePrefixMatcher(final StringMatcher prefixMatcher) {\n        Validate.isTrue(prefixMatcher != null, \"Variable prefix matcher must not be null!\");\n        this.prefixMatcher = prefixMatcher;\n        return this;\n    }\n\n    /**\n     * Sets the VariableResolver that is used to lookup variables.\n     *\n     * @param variableResolver the VariableResolver\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariableResolver(final StringLookup variableResolver) {\n        this.variableResolver = variableResolver;\n        return this;\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This method allows a\n     * single character suffix to be easily set.\n     * </p>\n     *\n     * @param suffix the suffix character to use\n     * @return this, to enable chaining\n     */\n    public StringSubstitutor setVariableSuffix(final char suffix) {\n        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.charMatcher(suffix));\n    }\n\n    /**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This method allows a\n     * string suffix to be easily set.\n     * </p>\n     *\n     * @param suffix the suffix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix is null\n     */\n    public StringSubstitutor setVariableSuffix(final String suffix) {\n        Validate.isTrue(suffix != null, \"Variable suffix must not be null!\");\n        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(suffix));\n    }\n\n    /**\n     * Sets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed\n     * in terms of a matcher allowing advanced suffix matches.\n     * </p>\n     *\n     * @param suffixMatcher the suffix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix matcher is null\n     */\n    public StringSubstitutor setVariableSuffixMatcher(final StringMatcher suffixMatcher) {\n        Validate.isTrue(suffixMatcher != null, \"Variable suffix matcher must not be null!\");\n        this.suffixMatcher = suffixMatcher;\n        return this;\n    }\n\n    /**\n     * Internal method that substitutes the variables.\n     * <p>\n     * Most users of this class do not need to call this method. This method will be called automatically by another\n     * (public) method.\n     * </p>\n     * <p>\n     * Writers of subclasses can override this method if they need access to the substitution process at the start or\n     * end.\n     * </p>\n     *\n     * @param builder the string builder to substitute into, not null\n     * @param offset the start offset within the builder, must be valid\n     * @param length the length within the builder to be processed, must be valid\n     * @return true if altered\n     */\n    protected boolean substitute(final TextStringBuilder builder, final int offset, final int length) {\n        return substitute(builder, offset, length, null).altered;\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation. This is the main interpolation method, which resolves the\n     * values of all variable references contained in the passed in text.\n     *\n     * @param builder the string builder to substitute into, not null\n     * @param offset the start offset within the builder, must be valid\n     * @param length the length within the builder to be processed, must be valid\n     * @param priorVariables the stack keeping track of the replaced variables, may be null\n     * @return The result.\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\n     * @since 1.9\n     */\n    private Result substitute(final TextStringBuilder builder, final int offset, final int length,\n        List<String> priorVariables) {\n        Objects.requireNonNull(builder, \"builder\");\n        final StringMatcher prefixMatcher = getVariablePrefixMatcher();\n        final StringMatcher suffixMatcher = getVariableSuffixMatcher();\n        final char escapeCh = getEscapeChar();\n        final StringMatcher valueDelimMatcher = getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n        final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues();\n        final boolean undefinedVariableException = isEnableUndefinedVariableException();\n        final boolean preserveEscapes = isPreserveEscapes();\n\n        boolean altered = false;\n        int lengthChange = 0;\n        int bufEnd = offset + length;\n        int pos = offset;\n        int escPos = -1;\n        outter: while (pos < bufEnd) {\n            final int startMatchLen = prefixMatcher.isMatch(builder, pos, offset, bufEnd);\n            if (startMatchLen == 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos > offset && builder.charAt(pos - 1) == escapeCh) {\n                    // escape detected\n                    if (preserveEscapes) {\n                        // keep escape\n                        pos++;\n                        continue;\n                    }\n                    // mark esc ch for deletion if we find a complete variable\n                    escPos = pos - 1;\n                }\n                // find suffix\n                int startPos = pos;\n                pos += startMatchLen;\n                int endMatchLen = 0;\n                int nestedVarCount = 0;\n                while (pos < bufEnd) {\n                    if (substitutionInVariablesEnabled && prefixMatcher.isMatch(builder, pos, offset, bufEnd) != 0) {\n                        // found a nested variable start\n                        endMatchLen = prefixMatcher.isMatch(builder, pos, offset, bufEnd);\n                        nestedVarCount++;\n                        pos += endMatchLen;\n                        continue;\n                    }\n\n                    endMatchLen = suffixMatcher.isMatch(builder, pos, offset, bufEnd);\n                    if (endMatchLen == 0) {\n                        pos++;\n                    } else {\n                        // found variable end marker\n                        if (nestedVarCount == 0) {\n                            if (escPos >= 0) {\n                                // delete escape\n                                builder.deleteCharAt(escPos);\n                                escPos = -1;\n                                lengthChange--;\n                                altered = true;\n                                bufEnd--;\n                                pos = startPos + 1;\n                                startPos--;\n                                continue outter;\n                            }\n                            // get var name\n                            String varNameExpr = builder.toString(startPos + startMatchLen,\n                                pos - startPos - startMatchLen);\n                            if (substitutionInVariablesEnabled) {\n                                final TextStringBuilder bufName = new TextStringBuilder(varNameExpr);\n                                substitute(bufName, 0, bufName.length());\n                                varNameExpr = bufName.toString();\n                            }\n                            pos += endMatchLen;\n                            final int endPos = pos;\n\n                            String varName = varNameExpr;\n                            String varDefaultValue = null;\n\n                            if (valueDelimMatcher != null) {\n                                final char[] varNameExprChars = varNameExpr.toCharArray();\n                                int valueDelimiterMatchLen = 0;\n                                for (int i = 0; i < varNameExprChars.length; i++) {\n                                    // if there's any nested variable when nested variable substitution disabled,\n                                    // then stop resolving name and default value.\n                                    if (!substitutionInVariablesEnabled && prefixMatcher.isMatch(varNameExprChars, i, i,\n                                        varNameExprChars.length) != 0) {\n                                        break;\n                                    }\n                                    if (valueDelimMatcher.isMatch(varNameExprChars, i, 0,\n                                        varNameExprChars.length) != 0) {\n                                        valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i, 0,\n                                            varNameExprChars.length);\n                                        varName = varNameExpr.substring(0, i);\n                                        varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                        break;\n                                    }\n                                }\n                            }\n\n                            // on the first call initialize priorVariables\n                            if (priorVariables == null) {\n                                priorVariables = new ArrayList<>();\n                                priorVariables.add(builder.toString(offset, length));\n                            }\n\n                            // handle cyclic substitution\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n\n                            // resolve the variable\n                            String varValue = resolveVariable(varName, builder, startPos, endPos);\n                            if (varValue == null) {\n                                varValue = varDefaultValue;\n                            }\n                            if (varValue != null) {\n                                final int varLen = varValue.length();\n                                builder.replace(startPos, endPos, varValue);\n                                altered = true;\n                                int change = 0;\n                                if (!substitutionInValuesDisabled) { // recursive replace\n                                    change = substitute(builder, startPos, varLen, priorVariables).lengthChange;\n                                }\n                                change = change + varLen - (endPos - startPos);\n                                pos += change;\n                                bufEnd += change;\n                                lengthChange += change;\n                            } else if (undefinedVariableException) {\n                                throw new IllegalArgumentException(\n                                    String.format(\"Cannot resolve variable '%s' (enableSubstitutionInVariables=%s).\",\n                                        varName, substitutionInVariablesEnabled));\n                            }\n\n                            // remove variable from the cyclic stack\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                        nestedVarCount--;\n                        pos += endMatchLen;\n                    }\n                }\n            }\n        }\n        return new Result(altered, lengthChange);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/StringSubstitutor.java b/src/main/java/org/apache/commons/text/StringSubstitutor.java\nindex 0400c43b46..098d7bb717 100644\n--- a/src/main/java/org/apache/commons/text/StringSubstitutor.java\n+++ b/src/main/java/org/apache/commons/text/StringSubstitutor.java\n@@ -614,7 +614,7 @@ public StringLookup getStringLookup() {\n     /**\n      * Gets the variable default value delimiter matcher currently in use.\n      * <p>\n-     * The variable default value delimiter is the character or characters that delimite the variable name and the\n+     * The variable default value delimiter is the character or characters that delimit the variable name and the\n      * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\n      * value delimiter matches.\n      * </p>\n@@ -1131,7 +1131,7 @@ public StringSubstitutor setPreserveEscapes(final boolean preserveEscapes) {\n     /**\n      * Sets the variable default value delimiter to use.\n      * <p>\n-     * The variable default value delimiter is the character or characters that delimite the variable name and the\n+     * The variable default value delimiter is the character or characters that delimit the variable name and the\n      * variable default value. This method allows a single character variable default value delimiter to be easily set.\n      * </p>\n      *\n@@ -1145,7 +1145,7 @@ public StringSubstitutor setValueDelimiter(final char valueDelimiter) {\n     /**\n      * Sets the variable default value delimiter to use.\n      * <p>\n-     * The variable default value delimiter is the character or characters that delimite the variable name and the\n+     * The variable default value delimiter is the character or characters that delimit the variable name and the\n      * variable default value. This method allows a string variable default value delimiter to be easily set.\n      * </p>\n      * <p>\n@@ -1167,7 +1167,7 @@ public StringSubstitutor setValueDelimiter(final String valueDelimiter) {\n     /**\n      * Sets the variable default value delimiter matcher to use.\n      * <p>\n-     * The variable default value delimiter is the character or characters that delimite the variable name and the\n+     * The variable default value delimiter is the character or characters that delimit the variable name and the\n      * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\n      * value delimiter matches.\n      * </p>\n@@ -1337,7 +1337,7 @@ private Result substitute(final TextStringBuilder builder, final int offset, fin\n         int bufEnd = offset + length;\n         int pos = offset;\n         int escPos = -1;\n-        outter: while (pos < bufEnd) {\n+        outer: while (pos < bufEnd) {\n             final int startMatchLen = prefixMatcher.isMatch(builder, pos, offset, bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n@@ -1382,7 +1382,7 @@ private Result substitute(final TextStringBuilder builder, final int offset, fin\n                                 bufEnd--;\n                                 pos = startPos + 1;\n                                 startPos--;\n-                                continue outter;\n+                                continue outer;\n                             }\n                             // get var name\n                             String varNameExpr = builder.toString(startPos + startMatchLen,\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/io/StringSubstitutorReader.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.io;\n\nimport org.apache.commons.text.StringSubstitutor;\nimport org.apache.commons.text.TextStringBuilder;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class StringSubstitutorReaderTest {\n\n    private StringSubstitutor stringSubstitutor;\n    private StringSubstitutorReader stringSubstitutorReader;\n\n    @BeforeEach\n    public void setUp() {\n        stringSubstitutor = new StringSubstitutor();\n        stringSubstitutorReader = new StringSubstitutorReader(new StringReader(\"test input\"), stringSubstitutor);\n    }\n\n    @Test\n    public void testBufferOrDrainOnEos() throws IOException {\n        char[] target = new char[10];\n        int targetIndex = 0;\n        int requestReadCount = 5;\n\n        // Simulate end of stream\n        stringSubstitutorReader.eos = true;\n\n        // Test the bufferOrDrainOnEos method\n        int result = stringSubstitutorReader.bufferOrDrainOnEos(requestReadCount, target, targetIndex, target.length);\n\n        // Verify the result\n        assertEquals(StringSubstitutorReader.EOS, result);\n    }\n\n    @Test\n    public void testBufferOrDrainOnEosWithNonEos() throws IOException {\n        char[] target = new char[10];\n        int targetIndex = 0;\n        int requestReadCount = 5;\n\n        // Simulate non-end of stream\n        stringSubstitutorReader.eos = false;\n\n        // Test the bufferOrDrainOnEos method\n        int result = stringSubstitutorReader.bufferOrDrainOnEos(requestReadCount, target, targetIndex, target.length);\n\n        // Verify the result\n        assertEquals(requestReadCount, result);\n    }\n\n    @Test\n    public void testBufferOrDrainOnEosWithException() {\n        char[] target = new char[10];\n        int targetIndex = 0;\n        int requestReadCount = 5;\n\n        // Simulate an IOException\n        StringSubstitutorReader faultyReader = new StringSubstitutorReader(new StringReader(\"faulty input\") {\n            @Override\n            public int read(char[] cbuf, int off, int len) throws IOException {\n                throw new IOException(\"Simulated IOException\");\n            }\n        }, stringSubstitutor);\n\n        // Test the bufferOrDrainOnEos method and expect an IOException\n        assertThrows(IOException.class, () -> {\n            faultyReader.bufferOrDrainOnEos(requestReadCount, target, targetIndex, target.length);\n        });\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.text.io;\n\nimport java.io.FilterReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.util.Objects;\n\nimport org.apache.commons.text.StringSubstitutor;\nimport org.apache.commons.text.TextStringBuilder;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\n\n/**\n * A {@link Reader} that performs string substitution on a source {@code Reader} using a {@link StringSubstitutor}.\n *\n * <p>\n * Using this Reader avoids reading a whole file into memory as a {@code String} to perform string substitution, for\n * example, when a Servlet filters a file to a client.\n * </p>\n * <p>\n * This class is not thread-safe.\n * </p>\n *\n * @since 1.9\n */\npublic class StringSubstitutorReader extends FilterReader {\n\n    /** The end-of-stream character marker. */\n    private static final int EOS = -1;\n\n    /** Our internal buffer. */\n    private final TextStringBuilder buffer = new TextStringBuilder();\n\n    /** End-of-Stream flag. */\n    private boolean eos;\n\n    /** Matches escaped variable starts. */\n    private final StringMatcher prefixEscapeMatcher;\n\n    /** Internal buffer for {@link #read()} method. */\n    private final char[] read1CharBuffer = {0};\n\n    /** The underlying StringSubstitutor. */\n    private final StringSubstitutor stringSubstitutor;\n\n    /** We don't always want to drain the whole buffer. */\n    private int toDrain;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param reader the underlying reader containing the template text known to the given {@code StringSubstitutor}.\n     * @param stringSubstitutor How to replace as we read.\n     * @throws NullPointerException if {@code reader} is {@code null}.\n     * @throws NullPointerException if {@code stringSubstitutor} is {@code null}.\n     */\n    public StringSubstitutorReader(final Reader reader, final StringSubstitutor stringSubstitutor) {\n        super(reader);\n        this.stringSubstitutor = Objects.requireNonNull(stringSubstitutor);\n        this.prefixEscapeMatcher = StringMatcherFactory.INSTANCE.charMatcher(stringSubstitutor.getEscapeChar())\n            .andThen(stringSubstitutor.getVariablePrefixMatcher());\n    }\n\n    /**\n     * Buffers the requested number of characters if available.\n     */\n    private int buffer(final int requestReadCount) throws IOException {\n        final int actualReadCount = buffer.readFrom(super.in, requestReadCount);\n        eos = actualReadCount == EOS;\n        return actualReadCount;\n    }\n\n    /**\n     * Reads a requested number of chars from the underlying reader into the buffer. On EOS, set the state is DRANING,\n     * drain, and return a drain count, otherwise, returns the actual read count.\n     */\n    private int bufferOrDrainOnEos(final int requestReadCount, final char[] target, final int targetIndex,\n        final int targetLength) throws IOException {\n        final int actualReadCount = buffer(requestReadCount);\n        return drainOnEos(actualReadCount, target, targetIndex, targetLength);\n    }\n\n    /**\n     * Drains characters from our buffer to the given {@code target}.\n     */\n    private int drain(final char[] target, final int targetIndex, final int targetLength) {\n        final int actualLen = Math.min(buffer.length(), targetLength);\n        final int drainCount = buffer.drainChars(0, actualLen, target, targetIndex);\n        toDrain -= drainCount;\n        if (buffer.isEmpty() || toDrain == 0) {\n            // nothing or everything drained.\n            toDrain = 0;\n        }\n        return drainCount;\n    }\n\n    /**\n     * Drains from the buffer to the target only if we are at EOS per the input count. If input count is EOS, drain and\n     * returns the drain count, otherwise return the input count. If draining, the state is set to DRAINING.\n     */\n    private int drainOnEos(final int readCountOrEos, final char[] target, final int targetIndex,\n        final int targetLength) {\n        if (readCountOrEos == EOS) {\n            // At EOS, drain.\n            if (buffer.isNotEmpty()) {\n                toDrain = buffer.size();\n                return drain(target, targetIndex, targetLength);\n            }\n            return EOS;\n        }\n        return readCountOrEos;\n    }\n\n    /**\n     * Tests if our buffer matches the given string matcher at the given position in the buffer.\n     */\n    private boolean isBufferMatchAt(final StringMatcher stringMatcher, final int pos) {\n        return stringMatcher.isMatch(buffer, pos) == stringMatcher.size();\n    }\n\n    /**\n     * Tests if we are draining.\n     */\n    private boolean isDraining() {\n        return toDrain > 0;\n    }\n\n    /**\n     * Reads a single character.\n     *\n     * @return a character as an {@code int} or {@code -1} for end-of-stream.\n     * @throws IOException If an I/O error occurs\n     */\n    @Override\n    public int read() throws IOException {\n        int count = 0;\n        // ask until we get a char or EOS\n        do {\n            count = read(read1CharBuffer, 0, 1);\n            if (count == EOS) {\n                return EOS;\n            }\n            // keep on buffering\n        } while (count < 1);\n        return read1CharBuffer[0];\n    }\n\n    /**\n     * Reads characters into a portion of an array.\n     *\n     * @param target Target buffer.\n     * @param targetIndexIn Index in the target at which to start storing characters.\n     * @param targetLengthIn Maximum number of characters to read.\n     *\n     * @return The number of characters read, or -1 on end of stream.\n     * @throws IOException If an I/O error occurs\n     */\n    @Override\n    public int read(final char[] target, final int targetIndexIn, final int targetLengthIn) throws IOException {\n        // The whole thing is inefficient because we must look for a balanced suffix to match the starting prefix\n        // Trying to substitute an incomplete expression can perform replacements when it should not.\n        // At a high level:\n        // - if draining, drain until empty or target length hit\n        // - copy to target until we find a variable start\n        // - buffer until a balanced suffix is read, then substitute.\n        if (eos && buffer.isEmpty()) {\n            return EOS;\n        }\n        if (targetLengthIn <= 0) {\n            // short-circuit: ask nothing, give nothing\n            return 0;\n        }\n        // drain check\n        int targetIndex = targetIndexIn;\n        int targetLength = targetLengthIn;\n        if (isDraining()) {\n            // drain as much as possible\n            final int drainCount = drain(target, targetIndex, Math.min(toDrain, targetLength));\n            if (drainCount == targetLength) {\n                // drained length requested, target is full, can only do more in the next invocation\n                return targetLength;\n            }\n            // drained less than requested, target not full.\n            targetIndex += drainCount;\n            targetLength -= drainCount;\n        }\n        // BUFFER from the underlying reader\n        final int minReadLenPrefix = prefixEscapeMatcher.size();\n        // READ enough to test for an [optionally escaped] variable start\n        int readCount = buffer(readCount(minReadLenPrefix, 0));\n        if (buffer.length() < minReadLenPrefix && targetLength < minReadLenPrefix) {\n            // read less than minReadLenPrefix, no variable possible\n            final int drainCount = drain(target, targetIndex, targetLength);\n            targetIndex += drainCount;\n            final int targetSize = targetIndex - targetIndexIn;\n            return eos && targetSize <= 0 ? EOS : targetSize;\n        }\n        if (eos) {\n            // EOS\n            stringSubstitutor.replaceIn(buffer);\n            toDrain = buffer.size();\n            final int drainCount = drain(target, targetIndex, targetLength);\n            targetIndex += drainCount;\n            final int targetSize = targetIndex - targetIndexIn;\n            return eos && targetSize <= 0 ? EOS : targetSize;\n        }\n        // PREFIX\n        // buffer and drain until we find a variable start, escaped or plain.\n        int balance = 0;\n        final StringMatcher prefixMatcher = stringSubstitutor.getVariablePrefixMatcher();\n        int pos = 0;\n        while (targetLength > 0) {\n            if (isBufferMatchAt(prefixMatcher, 0)) {\n                balance = 1;\n                pos = prefixMatcher.size();\n                break;\n            } else if (isBufferMatchAt(prefixEscapeMatcher, 0)) {\n                balance = 1;\n                pos = prefixEscapeMatcher.size();\n                break;\n            }\n            // drain first char\n            final int drainCount = drain(target, targetIndex, 1);\n            targetIndex += drainCount;\n            targetLength -= drainCount;\n            if (buffer.size() < minReadLenPrefix) {\n                readCount = bufferOrDrainOnEos(minReadLenPrefix, target, targetIndex, targetLength);\n                if (eos || isDraining()) {\n                    // if draining, readCount is a drain count\n                    if (readCount != EOS) {\n                        targetIndex += readCount;\n                        targetLength -= readCount;\n                    }\n                    final int actual = targetIndex - targetIndexIn;\n                    return actual > 0 ? actual : EOS;\n                }\n            }\n        }\n        // we found a variable start\n        if (targetLength <= 0) {\n            // no more room in target\n            return targetLengthIn;\n        }\n        // SUFFIX\n        // buffer more to find a balanced suffix\n        final StringMatcher suffixMatcher = stringSubstitutor.getVariableSuffixMatcher();\n        final int minReadLenSuffix = Math.max(minReadLenPrefix, suffixMatcher.size());\n        readCount = buffer(readCount(minReadLenSuffix, pos));\n        if (eos) {\n            // EOS\n            stringSubstitutor.replaceIn(buffer);\n            toDrain = buffer.size();\n            final int drainCount = drain(target, targetIndex, targetLength);\n            return targetIndex + drainCount - targetIndexIn;\n        }\n        // buffer and break out when we find the end or a balanced suffix\n        while (true) {\n            if (isBufferMatchAt(suffixMatcher, pos)) {\n                balance--;\n                pos++;\n                if (balance == 0) {\n                    break;\n                }\n            } else if (isBufferMatchAt(prefixMatcher, pos)) {\n                balance++;\n                pos += prefixMatcher.size();\n            } else if (isBufferMatchAt(prefixEscapeMatcher, pos)) {\n                balance++;\n                pos += prefixEscapeMatcher.size();\n            } else {\n                pos++;\n            }\n            readCount = buffer(readCount(minReadLenSuffix, pos));\n            if (readCount == EOS && pos >= buffer.size()) {\n                break;\n            }\n        }\n        // substitute\n        final int endPos = pos + 1;\n        final int leftover = Math.max(0, buffer.size() - pos);\n        stringSubstitutor.replaceIn(buffer, 0, Math.min(buffer.size(), endPos));\n        pos = buffer.size() - leftover;\n        final int drainLen = Math.min(targetLength, pos);\n        // only drain up to what we've substituted\n        toDrain = pos;\n        drain(target, targetIndex, drainLen);\n        return targetIndex - targetIndexIn + drainLen;\n    }\n\n    /**\n     * Returns how many chars to attempt reading to have room in the buffer for {@code count} chars starting at position\n     * {@code pos}.\n     */\n    private int readCount(final int count, final int pos) {\n        final int avail = buffer.size() - pos;\n        return avail >= count ? 0 : count - avail;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/io/StringSubstitutorReader.java b/src/main/java/org/apache/commons/text/io/StringSubstitutorReader.java\nindex 35307d5695..fbe151b0b7 100644\n--- a/src/main/java/org/apache/commons/text/io/StringSubstitutorReader.java\n+++ b/src/main/java/org/apache/commons/text/io/StringSubstitutorReader.java\n@@ -88,7 +88,7 @@ private int buffer(final int requestReadCount) throws IOException {\n     }\n \n     /**\n-     * Reads a requested number of chars from the underlying reader into the buffer. On EOS, set the state is DRANING,\n+     * Reads a requested number of chars from the underlying reader into the buffer. On EOS, set the state is DRAINING,\n      * drain, and return a drain count, otherwise, returns the actual read count.\n      */\n     private int bufferOrDrainOnEos(final int requestReadCount, final char[] target, final int targetIndex,\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/ConstantStringLookup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Assertions;\n\npublic class ConstantStringLookupTest2 {\n\n    private ConstantStringLookup stringLookup;\n\n    @AfterEach\n    public void afterEach() {\n        ConstantStringLookup.clear();\n    }\n\n    @BeforeEach\n    public void beforeEach() {\n        stringLookup = ConstantStringLookup.INSTANCE;\n    }\n\n    @Test\n    public void testFieldSeparatorConstant() {\n        // Ensure the FIELD_SEPARATOR constant is correctly defined\n        Assertions.assertEquals('.', getFieldSeparator(), \"FIELD_SEPARATOR constant has incorrect value\");\n    }\n\n    private char getFieldSeparator() {\n        try {\n            java.lang.reflect.Field field = ConstantStringLookup.class.getDeclaredField(\"FIELD_SEPARATOR\");\n            field.setAccessible(true);\n            return field.getChar(null);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to access FIELD_SEPARATOR field\", e);\n        }\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\n\npackage org.apache.commons.text.lookup;\n\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.commons.lang3.ClassUtils;\nimport org.apache.commons.text.StringSubstitutor;\n\n/**\n * <p>\n * Looks up the value of a fully-qualified static final value.\n * </p>\n * <p>\n * Sometimes it is necessary in a configuration file to refer to a constant defined in a class. This can be done with\n * this lookup implementation. Variable names must be in the format {@code apackage.AClass.AFIELD}. The\n * {@code lookup(String)} method will split the passed in string at the last dot, separating the fully qualified class\n * name and the name of the constant (i.e. <b>static final</b>) member field. Then the class is loaded and the field's\n * value is obtained using reflection.\n * </p>\n * <p>\n * Once retrieved values are cached for fast access. This class is thread-safe. It can be used as a standard (i.e.\n * global) lookup object and serve multiple clients concurrently.\n * </p>\n * <p>\n * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n * </p>\n *\n * <pre>\n * StringLookupFactory.INSTANCE.constantStringLookup().lookup(\"java.awt.event.KeyEvent.VK_ESCAPE\");\n * </pre>\n * <p>\n * Using a {@link StringSubstitutor}:\n * </p>\n *\n * <pre>\n * StringSubstitutor.createInterpolator().replace(\"... ${const:java.awt.event.KeyEvent.VK_ESCAPE} ...\"));\n * </pre>\n * <p>\n * The above examples convert {@code java.awt.event.KeyEvent.VK_ESCAPE} to {@code \"27\"}.\n * </p>\n * <p>\n * This class was adapted from Apache Commons Configuration.\n * </p>\n *\n * @since 1.5\n */\nclass ConstantStringLookup extends AbstractStringLookup {\n\n    /** An internally used cache for already retrieved values. */\n    private static final ConcurrentHashMap<String, String> CONSTANT_CACHE = new ConcurrentHashMap<>();\n\n    /** Constant for the field separator. */\n    private static final char FIELD_SEPRATOR = '.';\n\n    /**\n     * Defines the singleton for this class.\n     */\n    static final ConstantStringLookup INSTANCE = new ConstantStringLookup();\n\n    /**\n     * Clears the shared cache with the so far resolved constants.\n     */\n    static void clear() {\n        CONSTANT_CACHE.clear();\n    }\n\n    /**\n     * Loads the class with the specified name. If an application has special needs regarding the class loaders to be\n     * used, it can hook in here. This implementation delegates to the {@code getClass()} method of Commons Lang's\n     * <code><a href=\"https://commons.apache.org/lang/api-release/org/apache/commons/lang/ClassUtils.html\">\n     * ClassUtils</a></code>.\n     *\n     * @param className the name of the class to be loaded\n     * @return The corresponding class object\n     * @throws ClassNotFoundException if the class cannot be loaded\n     */\n    protected Class<?> fetchClass(final String className) throws ClassNotFoundException {\n        return ClassUtils.getClass(className);\n    }\n\n    /**\n     * Tries to resolve the specified variable. The passed in variable name is interpreted as the name of a <b>static\n     * final</b> member field of a class. If the value has already been obtained, it can be retrieved from an internal\n     * cache. Otherwise this method will invoke the {@code resolveField()} method and pass in the name of the class and\n     * the field.\n     *\n     * @param key the name of the variable to be resolved\n     * @return The value of this variable or <b>null</b> if it cannot be resolved\n     */\n    @Override\n    public synchronized String lookup(final String key) {\n        if (key == null) {\n            return null;\n        }\n        String result;\n        result = CONSTANT_CACHE.get(key);\n        if (result != null) {\n            return result;\n        }\n        final int fieldPos = key.lastIndexOf(FIELD_SEPRATOR);\n        if (fieldPos < 0) {\n            return null;\n        }\n        try {\n            final Object value = resolveField(key.substring(0, fieldPos), key.substring(fieldPos + 1));\n            if (value != null) {\n                final String string = Objects.toString(value, null);\n                CONSTANT_CACHE.put(key, string);\n                result = string;\n            }\n        } catch (final Exception ex) {\n            // TODO it would be nice to log\n            return null;\n        }\n        return result;\n    }\n\n    /**\n     * Determines the value of the specified constant member field of a class. This implementation will call\n     * {@code fetchClass()} to obtain the {@code java.lang.Class} object for the target class. Then it will use\n     * reflection to obtain the field's value. For this to work the field must be accessable.\n     *\n     * @param className the name of the class\n     * @param fieldName the name of the member field of that class to read\n     * @return The field's value\n     * @throws Exception if an error occurs\n     */\n    protected Object resolveField(final String className, final String fieldName) throws Exception {\n        final Class<?> clazz = fetchClass(className);\n        if (clazz == null) {\n            return null;\n        }\n        return clazz.getField(fieldName).get(null);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/ConstantStringLookup.java b/src/main/java/org/apache/commons/text/lookup/ConstantStringLookup.java\nindex 05d211a242..e46bf7eaf3 100644\n--- a/src/main/java/org/apache/commons/text/lookup/ConstantStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/ConstantStringLookup.java\n@@ -67,7 +67,7 @@ class ConstantStringLookup extends AbstractStringLookup {\n     private static ConcurrentHashMap<String, String> constantCache = new ConcurrentHashMap<>();\n \n     /** Constant for the field separator. */\n-    private static final char FIELD_SEPRATOR = '.';\n+    private static final char FIELD_SEPARATOR = '.';\n \n     /**\n      * Defines the singleton for this class.\n@@ -114,7 +114,7 @@ public synchronized String lookup(final String key) {\n         if (result != null) {\n             return result;\n         }\n-        final int fieldPos = key.lastIndexOf(FIELD_SEPRATOR);\n+        final int fieldPos = key.lastIndexOf(FIELD_SEPARATOR);\n         if (fieldPos < 0) {\n             return null;\n         }\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/DateStringLookup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DateStringLookupTest2 {\n    @Test\n    public void testBadFormat() {\n        assertThrows(IllegalArgumentException.class,\n            () -> DateStringLookup.INSTANCE.lookup(\"this-is-a-bad-format-dontcha-know\"));\n    }\n\n    @Test\n    public void testDefault() throws ParseException {\n        final String formatted = DateStringLookup.INSTANCE.lookup(null);\n        DateFormat.getInstance().parse(formatted); \n    }\n\n    @Test\n    public void testFormat() {\n        final String format = \"yyyy-MM-dd\";\n        final String value = DateStringLookup.INSTANCE.lookup(format);\n        assertNotNull(value, \"No Date\");\n        final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format);\n        final String today = simpleDateFormat.format(new Date());\n        assertEquals(value, today);\n    }\n\n    @Test\n    public void testToString() {\n        Assertions.assertFalse(DateStringLookup.INSTANCE.toString().isEmpty());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\npackage org.apache.commons.text.lookup;\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport org.apache.commons.lang3.time.FastDateFormat;\nimport org.apache.commons.text.StringSubstitutor;\n\n/**\n * Formats the current date with the format given in the key in a format compatible with\n * {@link java.text.SimpleDateFormat}.\n * <p>\n * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n * </p>\n *\n * <pre>\n * StringLookupFactory.INSTANCE.dateStringLookup().lookup(\"yyyy-MM-dd\");\n * </pre>\n * <p>\n * Using a {@link StringSubstitutor}:\n * </p>\n *\n * <pre>\n * StringSubstitutor.createInterpolator().replace(\"... ${date:yyyy-MM-dd} ...\"));\n * </pre>\n * <p>\n * The above examples convert {@code \"yyyy-MM-dd\"} to todays's date, for example, {@code \"2019-08-04\"}.\n * </p>\n */\nfinal class DateStringLookup extends AbstractStringLookup {\n\n    /**\n     * Defines the singleton for this class.\n     */\n    static final DateStringLookup INSTANCE = new DateStringLookup();\n\n    /**\n     * No need to build instances for now.\n     */\n    private DateStringLookup() {\n        // empty\n    }\n\n    /**\n     * Formats the given {@code date} long with the given {@code format}.\n     *\n     * @param date the date to format\n     * @param format the format string for {@link SimpleDateFormat}.\n     * @return The formatted date\n     */\n    private String formatDate(final long date, final String format) {\n        FastDateFormat dateFormat = null;\n        if (format != null) {\n            try {\n                dateFormat = FastDateFormat.getInstance(format);\n            } catch (final Exception ex) {\n                throw IllegalArgumentExceptions.format(ex, \"Invalid date format: [%s]\", format);\n            }\n        }\n        if (dateFormat == null) {\n            dateFormat = FastDateFormat.getInstance();\n        }\n        return dateFormat.format(new Date(date));\n    }\n\n    /**\n     * Formats the current date with the format given in the key in a format compatible with\n     * {@link java.text.SimpleDateFormat}.\n     *\n     * @param key the format to use. If null, the default {@link DateFormat} will be used.\n     * @return The value of the environment variable.\n     */\n    @Override\n    public String lookup(final String key) {\n        return formatDate(System.currentTimeMillis(), key);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/DateStringLookup.java b/src/main/java/org/apache/commons/text/lookup/DateStringLookup.java\nindex e7e192e71a..b3bcb9ccdf 100644\n--- a/src/main/java/org/apache/commons/text/lookup/DateStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/DateStringLookup.java\n@@ -41,7 +41,7 @@\n  * StringSubstitutor.createInterpolator().replace(\"... ${date:yyyy-MM-dd} ...\"));\n  * </pre>\n  * <p>\n- * The above examples convert {@code \"yyyy-MM-dd\"} to todays's date, for example, {@code \"2019-08-04\"}.\n+ * The above examples convert {@code \"yyyy-MM-dd\"} to today's date, for example, {@code \"2019-08-04\"}.\n  * </p>\n  */\n final class DateStringLookup extends AbstractStringLookup {\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/IllegalArgumentExceptions.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass IllegalArgumentExceptionsTest {\n\n    @Test\n    void testFormatWithMessage() {\n        String format = \"This is a %s test\";\n        String arg = \"simple\";\n        IllegalArgumentException exception = IllegalArgumentExceptions.format(format, arg);\n        assertEquals(\"This is a simple test\", exception.getMessage());\n    }\n\n    @Test\n    void testFormatWithThrowableAndMessage() {\n        String format = \"This is a %s test\";\n        String arg = \"complex\";\n        Throwable cause = new RuntimeException(\"Cause\");\n        IllegalArgumentException exception = IllegalArgumentExceptions.format(cause, format, arg);\n        assertEquals(\"This is a complex test\", exception.getMessage());\n        assertEquals(cause, exception.getCause());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\n\npackage org.apache.commons.text.lookup;\n\n/**\n * Shorthands creating {@link IllegalArgumentException} instances using formatted strings.\n *\n * @since 1.3\n */\nfinal class IllegalArgumentExceptions {\n\n    /**\n     * Creates an {@link IllegalArgumentException} with a message formated with {@link String#format(String,Object...)}.\n     *\n     * @param format See {@link String#format(String,Object...)}\n     * @param args See {@link String#format(String,Object...)}\n     * @return an {@link IllegalArgumentException} with a message formated with {@link String#format(String,Object...)}\n     */\n    static IllegalArgumentException format(final String format, final Object... args) {\n        return new IllegalArgumentException(String.format(format, args));\n    }\n\n    /**\n     * Creates an {@link IllegalArgumentException} with a message formated with {@link String#format(String,Object...)}.\n     *\n     * @param t the throwable cause\n     * @param format See {@link String#format(String,Object...)}\n     * @param args See {@link String#format(String,Object...)}\n     * @return an {@link IllegalArgumentException} with a message formated with {@link String#format(String,Object...)}\n     */\n    static IllegalArgumentException format(final Throwable t, final String format, final Object... args) {\n        return new IllegalArgumentException(String.format(format, args), t);\n    }\n\n    /**\n     * No need to build instances.\n     */\n    private IllegalArgumentExceptions() {\n        // empty\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/IllegalArgumentExceptions.java b/src/main/java/org/apache/commons/text/lookup/IllegalArgumentExceptions.java\nindex 6ebb0e383d..50b3926ca4 100644\n--- a/src/main/java/org/apache/commons/text/lookup/IllegalArgumentExceptions.java\n+++ b/src/main/java/org/apache/commons/text/lookup/IllegalArgumentExceptions.java\n@@ -25,23 +25,25 @@\n final class IllegalArgumentExceptions {\n \n     /**\n-     * Creates an {@link IllegalArgumentException} with a message formated with {@link String#format(String,Object...)}.\n+     * Creates an {@link IllegalArgumentException} with a message\n+     * formatted with {@link String#format(String,Object...)}.\n      *\n      * @param format See {@link String#format(String,Object...)}\n      * @param args See {@link String#format(String,Object...)}\n-     * @return an {@link IllegalArgumentException} with a message formated with {@link String#format(String,Object...)}\n+     * @return an {@link IllegalArgumentException} with a message formatted with {@link String#format(String,Object...)}\n      */\n     static IllegalArgumentException format(final String format, final Object... args) {\n         return new IllegalArgumentException(String.format(format, args));\n     }\n \n     /**\n-     * Creates an {@link IllegalArgumentException} with a message formated with {@link String#format(String,Object...)}.\n+     * Creates an {@link IllegalArgumentException} with a message\n+     * formatted with {@link String#format(String,Object...)}.\n      *\n      * @param t the throwable cause\n      * @param format See {@link String#format(String,Object...)}\n      * @param args See {@link String#format(String,Object...)}\n-     * @return an {@link IllegalArgumentException} with a message formated with {@link String#format(String,Object...)}\n+     * @return an {@link IllegalArgumentException} with a message formatted with {@link String#format(String,Object...)}\n      */\n     static IllegalArgumentException format(final Throwable t, final String format, final Object... args) {\n         return new IllegalArgumentException(String.format(format, args), t);\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class StringLookupFactoryTest2 {\n\n    /**\n     * Test to ensure the corrected spelling in the Javadoc comment does not affect functionality.\n     */\n    @Test\n    public void testBiFunctionStringLookupJavadocCorrection() {\n        final StringLookupFactory stringLookupFactory = StringLookupFactory.INSTANCE;\n        BiFunction<String, Integer, String> biFunction = (key, value) -> key + value;\n        BiStringLookup<Integer> biStringLookup = stringLookupFactory.biFunctionStringLookup(biFunction);\n        Assertions.assertNotNull(biStringLookup);\n        Assertions.assertEquals(\"test123\", biStringLookup.lookup(\"test\", 123));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\n\npackage org.apache.commons.text.lookup;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport org.apache.commons.text.StringSubstitutor;\n\n/**\n * Create instances of string lookups or access singleton string lookups implemented in this package.\n * <p>\n * The \"classic\" look up is {@link #mapStringLookup(Map)}.\n * </p>\n * <p>\n * The methods for variable interpolation (A.K.A. variable substitution) are:\n * </p>\n * <ul>\n * <li>{@link #interpolatorStringLookup()}.</li>\n * <li>{@link #interpolatorStringLookup(Map)}.</li>\n * <li>{@link #interpolatorStringLookup(StringLookup)}.</li>\n * <li>{@link #interpolatorStringLookup(Map, StringLookup, boolean)}.</li>\n * </ul>\n * <p>\n * The default lookups are:\n * </p>\n * <table>\n * <caption>Default String Lookups</caption>\n * <tr>\n * <th>Key</th>\n * <th>Interface</th>\n * <th>Factory Method</th>\n * <th>Since</th>\n * </tr>\n * <tr>\n * <td>{@value #KEY_BASE64_DECODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #base64DecoderStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_BASE64_ENCODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #base64EncoderStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_CONST}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #constantStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_DATE}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #dateStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_DNS}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #dnsStringLookup()}</td>\n * <td>1.8</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_ENV}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #environmentVariableStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_FILE}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #fileStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_JAVA}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #javaPlatformStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_LOCALHOST}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #localHostStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_PROPERTIES}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #propertiesStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_RESOURCE_BUNDLE}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #resourceBundleStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_SCRIPT}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #scriptStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_SYS}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #systemPropertyStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #urlStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL_DECODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #urlDecoderStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL_ENCODER}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #urlEncoderStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_XML}</td>\n * <td>{@link StringLookup}</td>\n * <td>{@link #xmlStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * </table>\n * <p>\n * We also provide functional lookups used as building blocks for other lookups.\n * <table>\n * <caption>Functional String Lookups</caption>\n * <tr>\n * <th>Interface</th>\n * <th>Factory Method</th>\n * <th>Since</th>\n * </tr>\n * <tr>\n * <td>{@link BiStringLookup}</td>\n * <td>{@link #biFunctionStringLookup(BiFunction)}</td>\n * <td>1.9</td>\n * </tr>\n * <tr>\n * <td>{@link StringLookup}</td>\n * <td>{@link #functionStringLookup(Function)}</td>\n * <td>1.9</td>\n * </tr>\n * </table>\n *\n * @since 1.3\n */\npublic final class StringLookupFactory {\n\n    /**\n     * Defines the singleton for this class.\n     */\n    public static final StringLookupFactory INSTANCE = new StringLookupFactory();\n\n    /**\n     * Decodes Base64 Strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64DecoderStringLookup().lookup(\"SGVsbG9Xb3JsZCE=\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Decoder:SGVsbG9Xb3JsZCE=} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"SGVsbG9Xb3JsZCE=\"} to {@code \"HelloWorld!\"}.\n     * </p>\n     */\n    static final FunctionStringLookup<String> INSTANCE_BASE64_DECODER = FunctionStringLookup\n        .on(key -> new String(Base64.getDecoder().decode(key), StandardCharsets.ISO_8859_1));\n\n    /**\n     * Encodes Base64 Strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64EncoderStringLookup().lookup(\"HelloWorld!\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Encoder:HelloWorld!} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"HelloWorld!\"} to {@code \"SGVsbG9Xb3JsZCE=\"}.\n     * </p>\n     * Defines the singleton for this class.\n     */\n    static final FunctionStringLookup<String> INSTANCE_BASE64_ENCODER = FunctionStringLookup\n        .on(key -> Base64.getEncoder().encodeToString(key.getBytes(StandardCharsets.ISO_8859_1)));\n\n    /**\n     * Looks up keys from environment variables.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.dateStringLookup().lookup(\"USER\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${env:USER} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert (on Linux) {@code \"USER\"} to the current user name. On Windows 10, you would use\n     * {@code \"USERNAME\"} to the same effect.\n     * </p>\n     */\n    static final FunctionStringLookup<String> INSTANCE_ENVIRONMENT_VARIABLES = FunctionStringLookup.on(System::getenv);\n\n    /**\n     * Defines the FunctionStringLookup singleton that always returns null.\n     */\n    static final FunctionStringLookup<String> INSTANCE_NULL = FunctionStringLookup.on(key -> null);\n\n    /**\n     * Defines the FunctionStringLookup singleton for looking up system properties.\n     */\n    static final FunctionStringLookup<String> INSTANCE_SYSTEM_PROPERTIES = FunctionStringLookup.on(System::getProperty);\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_BASE64_DECODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_BASE64_DECODER = \"base64Decoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_BASE64_ENCODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_BASE64_ENCODER = \"base64Encoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_CONST}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_CONST = \"const\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_DATE}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_DATE = \"date\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_DNS}.\n     *\n     * @since 1.8\n     */\n    public static final String KEY_DNS = \"dns\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_ENV}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_ENV = \"env\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_FILE}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_FILE = \"file\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_JAVA}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_JAVA = \"java\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_LOCALHOST}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_LOCALHOST = \"localhost\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_PROPERTIES}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_PROPERTIES = \"properties\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_RESOURCE_BUNDLE}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_RESOURCE_BUNDLE = \"resourceBundle\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_SCRIPT}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_SCRIPT = \"script\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_SYS}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_SYS = \"sys\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_URL}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL = \"url\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_URL_DECODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL_DECODER = \"urlDecoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_URL_ENCODER}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL_ENCODER = \"urlEncoder\";\n\n    /**\n     * Default lookup key for interpolation {@value #KEY_XML}.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_XML = \"xml\";\n\n    /**\n     * Clears any static resources.\n     *\n     * @since 1.5\n     */\n    public static void clear() {\n        ConstantStringLookup.clear();\n    }\n\n    /**\n     * No need to build instances for now.\n     */\n    private StringLookupFactory() {\n        // empty\n    }\n\n    /**\n     * Adds the {@link StringLookupFactory default lookups}.\n     *\n     * @param stringLookupMap the map of string lookups.\n     * @since 1.5\n     */\n    public void addDefaultStringLookups(final Map<String, StringLookup> stringLookupMap) {\n        if (stringLookupMap != null) {\n            // \"base64\" is deprecated in favor of KEY_BASE64_DECODER.\n            stringLookupMap.put(\"base64\", StringLookupFactory.INSTANCE_BASE64_DECODER);\n            for (final DefaultStringLookup stringLookup : DefaultStringLookup.values()) {\n                stringLookupMap.put(InterpolatorStringLookup.toKey(stringLookup.getKey()),\n                    stringLookup.getStringLookup());\n            }\n        }\n    }\n\n    /**\n     * Returns the Base64DecoderStringLookup singleton instance to decode Base64 strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64DecoderStringLookup().lookup(\"SGVsbG9Xb3JsZCE=\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Decoder:SGVsbG9Xb3JsZCE=} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"SGVsbG9Xb3JsZCE=\"} to {@code \"HelloWorld!\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup base64DecoderStringLookup() {\n        return StringLookupFactory.INSTANCE_BASE64_DECODER;\n    }\n\n    /**\n     * Returns the Base64EncoderStringLookup singleton instance to encode strings to Base64.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64EncoderStringLookup().lookup(\"HelloWorld!\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Encoder:HelloWorld!} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code } to {@code \"SGVsbG9Xb3JsZCE=\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup base64EncoderStringLookup() {\n        return StringLookupFactory.INSTANCE_BASE64_ENCODER;\n    }\n\n    /**\n     * Returns the Base64DecoderStringLookup singleton instance to decode Base64 strings.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.base64DecoderStringLookup().lookup(\"SGVsbG9Xb3JsZCE=\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${base64Decoder:SGVsbG9Xb3JsZCE=} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"SGVsbG9Xb3JsZCE=\"} to {@code \"HelloWorld!\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     * @since 1.5\n     * @deprecated Use {@link #base64DecoderStringLookup()}.\n     */\n    @Deprecated\n    public StringLookup base64StringLookup() {\n        return StringLookupFactory.INSTANCE_BASE64_DECODER;\n    }\n\n    /**\n     * Returns a new function-based lookup where the request for a lookup is answered by applying the function with a\n     * lookup key.\n     *\n     * @param <R> the function return type.\n     * @param <U> the funtion's second paremeter type.\n     * @param biFunction the function.\n     * @return a new MapStringLookup.\n     * @since 1.9\n     */\n    public <R, U> BiStringLookup<U> biFunctionStringLookup(final BiFunction<String, U, R> biFunction) {\n        return BiFunctionStringLookup.on(biFunction);\n    }\n\n    /**\n     * Returns the ConstantStringLookup singleton instance to look up the value of a fully-qualified static final value.\n     * <p>\n     * Sometimes it is necessary in a configuration file to refer to a constant defined in a class. This can be done\n     * with this lookup implementation. Variable names must be in the format {@code apackage.AClass.AFIELD}. The\n     * {@code lookup(String)} method will split the passed in string at the last dot, separating the fully qualified\n     * class name and the name of the constant (i.e. <b>static final</b>) member field. Then the class is loaded and the\n     * field's value is obtained using reflection.\n     * </p>\n     * <p>\n     * Once retrieved values are cached for fast access. This class is thread-safe. It can be used as a standard (i.e.\n     * global) lookup object and serve multiple clients concurrently.\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.constantStringLookup().lookup(\"java.awt.event.KeyEvent.VK_ESCAPE\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${const:java.awt.event.KeyEvent.VK_ESCAPE} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code java.awt.event.KeyEvent.VK_ESCAPE} to {@code \"27\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup constantStringLookup() {\n        return ConstantStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the DateStringLookup singleton instance to format the current date with the format given in the key in a\n     * format compatible with {@link java.text.SimpleDateFormat}.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.dateStringLookup().lookup(\"yyyy-MM-dd\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${date:yyyy-MM-dd} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"yyyy-MM-dd\"} to todays's date, for example, {@code \"2019-08-04\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     */\n    public StringLookup dateStringLookup() {\n        return DateStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the DnsStringLookup singleton instance where the lookup key is one of:\n     * <ul>\n     * <li><b>name</b>: for the local host name, for example {@code EXAMPLE} but also {@code EXAMPLE.apache.org}.</li>\n     * <li><b>canonical-name</b>: for the local canonical host name, for example {@code EXAMPLE.apache.org}.</li>\n     * <li><b>address</b>: for the local host address, for example {@code 192.168.56.1}.</li>\n     * </ul>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.dnsStringLookup().lookup(\"address|apache.org\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${dns:address|apache.org} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"address|apache.org\"} to {@code \"95.216.24.32} (or {@code \"40.79.78.1\"}).\n     * </p>\n     *\n     * @return the DateStringLookup singleton instance.\n     * @since 1.8\n     */\n    public StringLookup dnsStringLookup() {\n        return DnsStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the EnvironmentVariableStringLookup singleton instance where the lookup key is an environment variable\n     * name.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.dateStringLookup().lookup(\"USER\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${env:USER} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert (on Linux) {@code \"USER\"} to the current user name. On Windows 10, you would use\n     * {@code \"USERNAME\"} to the same effect.\n     * </p>\n     *\n     * @return The EnvironmentVariableStringLookup singleton instance.\n     */\n    public StringLookup environmentVariableStringLookup() {\n        return StringLookupFactory.INSTANCE_ENVIRONMENT_VARIABLES;\n    }\n\n    /**\n     * Returns the FileStringLookup singleton instance.\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.fileStringLookup().lookup(\"UTF-8:com/domain/document.properties\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${file:UTF-8:com/domain/document.properties} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"UTF-8:com/domain/document.properties\"} to the contents of the file.\n     * </p>\n     *\n     * @return The FileStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup fileStringLookup() {\n        return FileStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new function-based lookup where the request for a lookup is answered by applying the function with a\n     * lookup key.\n     *\n     * @param <R> the function return type.\n     * @param function the function.\n     * @return a new MapStringLookup.\n     * @since 1.9\n     */\n    public <R> StringLookup functionStringLookup(final Function<String, R> function) {\n        return FunctionStringLookup.on(function);\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n     * <p>\n     * The lookups available to an interpolator are defined in\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.interpolatorStringLookup().lookup(\"${sys:os.name}, ${env:USER}\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${sys:os.name}, ${env:USER} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"${sys:os.name}, ${env:USER}\"} to the OS name and Linux user name.\n     * </p>\n     *\n     * @return a new InterpolatorStringLookup.\n     */\n    public StringLookup interpolatorStringLookup() {\n        return InterpolatorStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n     * <p>\n     * If {@code addDefaultLookups} is true, the following lookups are used in addition to the ones provided in\n     * {@code stringLookupMap}:\n     * </p>\n     *\n     * @param stringLookupMap the map of string lookups.\n     * @param defaultStringLookup the default string lookup.\n     * @param addDefaultLookups whether to use lookups as described above.\n     * @return a new InterpolatorStringLookup.\n     * @since 1.4\n     */\n    public StringLookup interpolatorStringLookup(final Map<String, StringLookup> stringLookupMap,\n        final StringLookup defaultStringLookup, final boolean addDefaultLookups) {\n        return new InterpolatorStringLookup(stringLookupMap, defaultStringLookup, addDefaultLookups);\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n     *\n     * @param <V> the value type the default string lookup's map.\n     * @param map the default map for string lookups.\n     * @return a new InterpolatorStringLookup.\n     */\n    public <V> StringLookup interpolatorStringLookup(final Map<String, V> map) {\n        return new InterpolatorStringLookup(map);\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n     *\n     * @param defaultStringLookup the default string lookup.\n     * @return a new InterpolatorStringLookup.\n     */\n    public StringLookup interpolatorStringLookup(final StringLookup defaultStringLookup) {\n        return new InterpolatorStringLookup(defaultStringLookup);\n    }\n\n    /**\n     * Returns the JavaPlatformStringLookup singleton instance. Looks up keys related to Java: Java version, JRE\n     * version, VM version, and so on.\n     * <p>\n     * The lookup keys with examples are:\n     * </p>\n     * <ul>\n     * <li><b>version</b>: \"Java version 1.8.0_181\"</li>\n     * <li><b>runtime</b>: \"Java(TM) SE Runtime Environment (build 1.8.0_181-b13) from Oracle Corporation\"</li>\n     * <li><b>vm</b>: \"Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)\"</li>\n     * <li><b>os</b>: \"Windows 10 10.0, architecture: amd64-64\"</li>\n     * <li><b>hardware</b>: \"processors: 4, architecture: amd64-64, instruction sets: amd64\"</li>\n     * <li><b>locale</b>: \"default locale: en_US, platform encoding: iso-8859-1\"</li>\n     * </ul>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.javaPlatformStringLookup().lookup(\"version\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${java:version} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"version\"} to the current VM version, for example,\n     * {@code \"Java version 1.8.0_181\"}.\n     * </p>\n     *\n     * @return The JavaPlatformStringLookup singleton instance.\n     */\n    public StringLookup javaPlatformStringLookup() {\n        return JavaPlatformStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the LocalHostStringLookup singleton instance where the lookup key is one of:\n     * <ul>\n     * <li><b>name</b>: for the local host name, for example {@code EXAMPLE}.</li>\n     * <li><b>canonical-name</b>: for the local canonical host name, for example {@code EXAMPLE.apache.org}.</li>\n     * <li><b>address</b>: for the local host address, for example {@code 192.168.56.1}.</li>\n     * </ul>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.localHostStringLookup().lookup(\"canonical-name\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${localhost:canonical-name} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"canonical-name\"} to the current host name, for example,\n     * {@code \"EXAMPLE.apache.org\"}.\n     * </p>\n     *\n     * @return The DateStringLookup singleton instance.\n     */\n    public StringLookup localHostStringLookup() {\n        return LocalHostStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new map-based lookup where the request for a lookup is answered with the value for that key.\n     *\n     * @param <V> the map value type.\n     * @param map the map.\n     * @return a new MapStringLookup.\n     */\n    public <V> StringLookup mapStringLookup(final Map<String, V> map) {\n        return FunctionStringLookup.on(map);\n    }\n\n    /**\n     * Returns the NullStringLookup singleton instance which always returns null.\n     *\n     * @return The NullStringLookup singleton instance.\n     */\n    public StringLookup nullStringLookup() {\n        return StringLookupFactory.INSTANCE_NULL;\n    }\n\n    /**\n     * Returns the PropertiesStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"DocumentPath::MyKey\".\n     * </p>\n     * <p>\n     * Note the use of \"::\" instead of \":\" to allow for \"C:\" drive letters in paths.\n     * </p>\n     * <p>\n     * For example: \"com/domain/document.properties::MyKey\".\n     * </p>\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.propertiesStringLookup().lookup(\"com/domain/document.properties::MyKey\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${properties:com/domain/document.properties::MyKey} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"com/domain/document.properties::MyKey\"} to the key value in the properties\n     * file at the path \"com/domain/document.properties\".\n     * </p>\n     *\n     * @return The PropertiesStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup propertiesStringLookup() {\n        return PropertiesStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the ResourceBundleStringLookup singleton instance.\n     * <p>\n     * Looks up the value for a given key in the format \"BundleName:BundleKey\".\n     * </p>\n     * <p>\n     * For example: \"com.domain.messages:MyKey\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.resourceBundleStringLookup().lookup(\"com.domain.messages:MyKey\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${resourceBundle:com.domain.messages:MyKey} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"com.domain.messages:MyKey\"} to the key value in the resource bundle at\n     * {@code \"com.domain.messages\"}.\n     * </p>\n     *\n     * @return The ResourceBundleStringLookup singleton instance.\n     */\n    public StringLookup resourceBundleStringLookup() {\n        return ResourceBundleStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a ResourceBundleStringLookup instance for the given bundle name.\n     * <p>\n     * Looks up the value for a given key in the format \"MyKey\".\n     * </p>\n     * <p>\n     * For example: \"MyKey\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.resourceBundleStringLookup(\"com.domain.messages\").lookup(\"MyKey\");\n     * </pre>\n     * <p>\n     * The above example converts {@code \"MyKey\"} to the key value in the resource bundle at\n     * {@code \"com.domain.messages\"}.\n     * </p>\n     *\n     * @param bundleName Only lookup in this bundle.\n     * @return a ResourceBundleStringLookup instance for the given bundle name.\n     * @since 1.5\n     */\n    public StringLookup resourceBundleStringLookup(final String bundleName) {\n        return new ResourceBundleStringLookup(bundleName);\n    }\n\n    /**\n     * Returns the ScriptStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"ScriptEngineName:Script\".\n     * </p>\n     * <p>\n     * For example: \"javascript:3 + 4\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.scriptStringLookup().lookup(\"javascript:3 + 4\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${javascript:3 + 4} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"javascript:3 + 4\"} to {@code \"7\"}.\n     * </p>\n     *\n     * @return The ScriptStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup scriptStringLookup() {\n        return ScriptStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the SystemPropertyStringLookup singleton instance where the lookup key is a system property name.\n     *\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.systemPropertyStringLookup().lookup(\"os.name\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${sys:os.name} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"os.name\"} to the operating system name.\n     * </p>\n     *\n     * @return The SystemPropertyStringLookup singleton instance.\n     */\n    public StringLookup systemPropertyStringLookup() {\n        return StringLookupFactory.INSTANCE_SYSTEM_PROPERTIES;\n    }\n\n    /**\n     * Returns the UrlDecoderStringLookup singleton instance.\n     * <p>\n     * Decodes URL Strings using the UTF-8 encoding.\n     * </p>\n     * <p>\n     * For example: \"Hello%20World%21\" becomes \"Hello World!\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.urlDecoderStringLookup().lookup(\"Hello%20World%21\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${urlDecoder:Hello%20World%21} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"Hello%20World%21\"} to {@code \"Hello World!\"}.\n     * </p>\n     *\n     * @return The UrlStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup urlDecoderStringLookup() {\n        return UrlDecoderStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the UrlDecoderStringLookup singleton instance.\n     * <p>\n     * Decodes URL Strings using the UTF-8 encoding.\n     * </p>\n     * <p>\n     * For example: \"Hello World!\" becomes \"Hello+World%21\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.urlEncoderStringLookup().lookup(\"Hello World!\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${urlEncoder:Hello World!} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"Hello World!\"} to {@code \"Hello%20World%21\"}.\n     * </p>\n     *\n     * @return The UrlStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup urlEncoderStringLookup() {\n        return UrlEncoderStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the UrlStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"CharsetName:URL\".\n     * </p>\n     * <p>\n     * For example, using the HTTP scheme: \"UTF-8:http://www.google.com\"\n     * </p>\n     * <p>\n     * For example, using the file scheme:\n     * \"UTF-8:file:///C:/somehome/commons/commons-text/src/test/resources/document.properties\"\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.urlStringLookup().lookup(\"UTF-8:https://www.apache.org\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${url:UTF-8:https://www.apache.org} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"UTF-8:https://www.apache.org\"} to the contents of that page.\n     * </p>\n     *\n     * @return The UrlStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup urlStringLookup() {\n        return UrlStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the XmlStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"DocumentPath:XPath\".\n     * </p>\n     * <p>\n     * For example: \"com/domain/document.xml:/path/to/node\".\n     * </p>\n     * <p>\n     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n     * </p>\n     *\n     * <pre>\n     * StringLookupFactory.INSTANCE.xmlStringLookup().lookup(\"com/domain/document.xml:/path/to/node\");\n     * </pre>\n     * <p>\n     * Using a {@link StringSubstitutor}:\n     * </p>\n     *\n     * <pre>\n     * StringSubstitutor.createInterpolator().replace(\"... ${xml:com/domain/document.xml:/path/to/node} ...\"));\n     * </pre>\n     * <p>\n     * The above examples convert {@code \"com/domain/document.xml:/path/to/node\"} to the value of the XPath in the XML\n     * document.\n     * </p>\n     *\n     * @return The XmlStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup xmlStringLookup() {\n        return XmlStringLookup.INSTANCE;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\nindex 59db15ff9d..b38dd414e3 100644\n--- a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n+++ b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n@@ -503,7 +503,7 @@ public StringLookup base64StringLookup() {\n      * lookup key.\n      *\n      * @param <R> the function return type.\n-     * @param <U> the funtion's second paremeter type.\n+     * @param <U> the function's second parameter type.\n      * @param biFunction the function.\n      * @return a new MapStringLookup.\n      * @since 1.9\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/AlphabetConverterTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/ExtendedMessageFormatTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/StrLookupTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/StringSubstitutorTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/TextStringBuilderTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/diff/ReplacementsFinderTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/similarity/LongestCommonSubsequenceDistanceTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/translate/EntityArraysTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 136,
    "title": "[TEXT-183] Make ConstantStringLookup.constantCache final",
    "state": "closed",
    "created_at": "2020-07-21T05:40:22Z",
    "merge_commit_sha": "c1a006d3366f0ce946264cf37d262986b0d50320",
    "base_sha": "d36a5faf0560fce4f0d23ded7db8c915c68def91",
    "head_sha": "91f53d790a4353e8fa796e30fce57136204b31e3",
    "user_login": "XenoAmess",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/ConstantStringLookup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class ConstantStringLookupTest2 {\n\n    private ConstantStringLookup stringLookup;\n\n    @AfterEach\n    public void afterEach() {\n        ConstantStringLookup.clear();\n    }\n\n    @BeforeEach\n    public void beforeEach() {\n        stringLookup = ConstantStringLookup.INSTANCE;\n    }\n\n    /**\n     * Test to ensure that the CONSTANT_CACHE is correctly cleared.\n     */\n    @Test\n    public void testClearCache() {\n        // Populate the cache\n        stringLookup.lookup(variable(\"FIELD\"));\n        Assertions.assertNotNull(stringLookup.lookup(variable(\"FIELD\")), \"Cache should contain the value\");\n\n        // Clear the cache\n        ConstantStringLookup.clear();\n        Assertions.assertNull(stringLookup.lookup(variable(\"FIELD\")), \"Cache should be cleared\");\n    }\n\n    /**\n     * Test to ensure that the CONSTANT_CACHE is correctly used.\n     */\n    @Test\n    public void testCacheUsage() {\n        // First lookup should populate the cache\n        String firstLookup = stringLookup.lookup(variable(\"FIELD\"));\n        Assertions.assertNotNull(firstLookup, \"First lookup should return a value\");\n\n        // Second lookup should retrieve from cache\n        String secondLookup = stringLookup.lookup(variable(\"FIELD\"));\n        Assertions.assertEquals(firstLookup, secondLookup, \"Second lookup should return the cached value\");\n    }\n\n    private String variable(final String field) {\n        return getClass().getName() + '.' + field;\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\n\npackage org.apache.commons.text.lookup;\n\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.commons.lang3.ClassUtils;\nimport org.apache.commons.text.StringSubstitutor;\n\n/**\n * <p>\n * Looks up the value of a fully-qualified static final value.\n * </p>\n * <p>\n * Sometimes it is necessary in a configuration file to refer to a constant defined in a class. This can be done with\n * this lookup implementation. Variable names must be in the format {@code apackage.AClass.AFIELD}. The\n * {@code lookup(String)} method will split the passed in string at the last dot, separating the fully qualified class\n * name and the name of the constant (i.e. <b>static final</b>) member field. Then the class is loaded and the field's\n * value is obtained using reflection.\n * </p>\n * <p>\n * Once retrieved values are cached for fast access. This class is thread-safe. It can be used as a standard (i.e.\n * global) lookup object and serve multiple clients concurrently.\n * </p>\n * <p>\n * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n * </p>\n *\n * <pre>\n * StringLookupFactory.INSTANCE.constantStringLookup().lookup(\"java.awt.event.KeyEvent.VK_ESCAPE\");\n * </pre>\n * <p>\n * Using a {@link StringSubstitutor}:\n * </p>\n *\n * <pre>\n * StringSubstitutor.createInterpolator().replace(\"... ${const:java.awt.event.KeyEvent.VK_ESCAPE} ...\"));\n * </pre>\n * <p>\n * The above examples convert {@code java.awt.event.KeyEvent.VK_ESCAPE} to {@code \"27\"}.\n * </p>\n * <p>\n * This class was adapted from Apache Commons Configuration.\n * </p>\n *\n * @since 1.5\n */\nclass ConstantStringLookup extends AbstractStringLookup {\n\n    /** An internally used cache for already retrieved values. */\n    private static ConcurrentHashMap<String, String> constantCache = new ConcurrentHashMap<>();\n\n    /** Constant for the field separator. */\n    private static final char FIELD_SEPRATOR = '.';\n\n    /**\n     * Defines the singleton for this class.\n     */\n    static final ConstantStringLookup INSTANCE = new ConstantStringLookup();\n\n    /**\n     * Clears the shared cache with the so far resolved constants.\n     */\n    static void clear() {\n        constantCache.clear();\n    }\n\n    /**\n     * Loads the class with the specified name. If an application has special needs regarding the class loaders to be\n     * used, it can hook in here. This implementation delegates to the {@code getClass()} method of Commons Lang's\n     * <code><a href=\"https://commons.apache.org/lang/api-release/org/apache/commons/lang/ClassUtils.html\">\n     * ClassUtils</a></code>.\n     *\n     * @param className the name of the class to be loaded\n     * @return The corresponding class object\n     * @throws ClassNotFoundException if the class cannot be loaded\n     */\n    protected Class<?> fetchClass(final String className) throws ClassNotFoundException {\n        return ClassUtils.getClass(className);\n    }\n\n    /**\n     * Tries to resolve the specified variable. The passed in variable name is interpreted as the name of a <b>static\n     * final</b> member field of a class. If the value has already been obtained, it can be retrieved from an internal\n     * cache. Otherwise this method will invoke the {@code resolveField()} method and pass in the name of the class and\n     * the field.\n     *\n     * @param key the name of the variable to be resolved\n     * @return The value of this variable or <b>null</b> if it cannot be resolved\n     */\n    @Override\n    public synchronized String lookup(final String key) {\n        if (key == null) {\n            return null;\n        }\n        String result;\n        result = constantCache.get(key);\n        if (result != null) {\n            return result;\n        }\n        final int fieldPos = key.lastIndexOf(FIELD_SEPRATOR);\n        if (fieldPos < 0) {\n            return null;\n        }\n        try {\n            final Object value = resolveField(key.substring(0, fieldPos), key.substring(fieldPos + 1));\n            if (value != null) {\n                final String string = Objects.toString(value, null);\n                constantCache.put(key, string);\n                result = string;\n            }\n        } catch (final Exception ex) {\n            // TODO it would be nice to log\n            return null;\n        }\n        return result;\n    }\n\n    /**\n     * Determines the value of the specified constant member field of a class. This implementation will call\n     * {@code fetchClass()} to obtain the {@code java.lang.Class} object for the target class. Then it will use\n     * reflection to obtain the field's value. For this to work the field must be accessable.\n     *\n     * @param className the name of the class\n     * @param fieldName the name of the member field of that class to read\n     * @return The field's value\n     * @throws Exception if an error occurs\n     */\n    protected Object resolveField(final String className, final String fieldName) throws Exception {\n        final Class<?> clazz = fetchClass(className);\n        if (clazz == null) {\n            return null;\n        }\n        return clazz.getField(fieldName).get(null);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/ConstantStringLookup.java b/src/main/java/org/apache/commons/text/lookup/ConstantStringLookup.java\nindex 05d211a242..66f8298c40 100644\n--- a/src/main/java/org/apache/commons/text/lookup/ConstantStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/ConstantStringLookup.java\n@@ -64,7 +64,7 @@\n class ConstantStringLookup extends AbstractStringLookup {\n \n     /** An internally used cache for already retrieved values. */\n-    private static ConcurrentHashMap<String, String> constantCache = new ConcurrentHashMap<>();\n+    private static final ConcurrentHashMap<String, String> CONSTANT_CACHE = new ConcurrentHashMap<>();\n \n     /** Constant for the field separator. */\n     private static final char FIELD_SEPRATOR = '.';\n@@ -78,7 +78,7 @@ class ConstantStringLookup extends AbstractStringLookup {\n      * Clears the shared cache with the so far resolved constants.\n      */\n     static void clear() {\n-        constantCache.clear();\n+        CONSTANT_CACHE.clear();\n     }\n \n     /**\n@@ -110,7 +110,7 @@ public synchronized String lookup(final String key) {\n             return null;\n         }\n         String result;\n-        result = constantCache.get(key);\n+        result = CONSTANT_CACHE.get(key);\n         if (result != null) {\n             return result;\n         }\n@@ -122,7 +122,7 @@ public synchronized String lookup(final String key) {\n             final Object value = resolveField(key.substring(0, fieldPos), key.substring(fieldPos + 1));\n             if (value != null) {\n                 final String string = Objects.toString(value, null);\n-                constantCache.put(key, string);\n+                CONSTANT_CACHE.put(key, string);\n                 result = string;\n             }\n         } catch (final Exception ex) {\n"
      }
    ]
  },
  {
    "pr_number": 135,
    "title": "[TEXT-181] Fix Javadocs",
    "state": "closed",
    "created_at": "2020-07-21T05:39:53Z",
    "merge_commit_sha": "e9adb40fb58e8c0ccfb717fe7fdbed5093cd916e",
    "base_sha": "d36a5faf0560fce4f0d23ded7db8c915c68def91",
    "head_sha": "88d6408a765434be3a46418a9fe0c751e49db5b2",
    "user_login": "XenoAmess",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/TextStringBuilder.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.Locale;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.matcher.StringMatcher;\nimport org.apache.commons.text.matcher.StringMatcherFactory;\nimport org.junit.jupiter.api.Test;\n\npublic class TextStringBuilderTest2 {\n\n    @Test\n    public void testConstructorWithInvalidLength() {\n        char[] initialBuffer = new char[10];\n        assertThrows(IllegalArgumentException.class, () -> new TextStringBuilder(initialBuffer, -1));\n        assertThrows(IllegalArgumentException.class, () -> new TextStringBuilder(initialBuffer, 11));\n    }\n\n    @Test\n    public void testConstructorWithValidLength() {\n        char[] initialBuffer = new char[10];\n        TextStringBuilder tsb = new TextStringBuilder(initialBuffer, 5);\n        assertEquals(5, tsb.size());\n        assertEquals(10, tsb.capacity());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.Writer;\nimport java.nio.CharBuffer;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.matcher.StringMatcher;\n\n/**\n * Builds a string from constituent parts providing a more flexible and powerful API than StringBuffer.\n * <p>\n * The main differences from StringBuffer/StringBuilder are:\n * </p>\n * <ul>\n * <li>Not synchronized</li>\n * <li>Not final</li>\n * <li>Subclasses have direct access to character array</li>\n * <li>Additional methods\n * <ul>\n * <li>appendWithSeparators - adds an array of values, with a separator</li>\n * <li>appendPadding - adds a length padding characters</li>\n * <li>appendFixedLength - adds a fixed width field to the builder</li>\n * <li>toCharArray/getChars - simpler ways to get a range of the character array</li>\n * <li>delete - delete char or string</li>\n * <li>replace - search and replace for a char or string</li>\n * <li>leftString/rightString/midString - substring without exceptions</li>\n * <li>contains - whether the builder contains a char or string</li>\n * <li>size/clear/isEmpty - collections style API methods</li>\n * </ul>\n * </li>\n * <li>Views\n * <ul>\n * <li>asTokenizer - uses the internal buffer as the source of a StrTokenizer</li>\n * <li>asReader - uses the internal buffer as the source of a Reader</li>\n * <li>asWriter - allows a Writer to write directly to the internal buffer</li>\n * </ul>\n * </li>\n * </ul>\n * <p>\n * The aim has been to provide an API that mimics very closely what StringBuffer provides, but with additional methods.\n * It should be noted that some edge cases, with invalid indices or null input, have been altered - see individual\n * methods. The biggest of these changes is that by default, null will not output the text 'null'. This can be\n * controlled by a property, {@link #setNullText(String)}.\n * </p>\n * <p>\n * This class is called {@code TextStringBuilder} instead of {@code StringBuilder} to avoid clashing with\n * {@link java.lang.StringBuilder}.\n * </p>\n *\n * @since 1.3\n */\npublic class TextStringBuilder implements CharSequence, Appendable, Serializable, Builder<String> {\n\n    /**\n     * Inner class to allow StrBuilder to operate as a reader.\n     */\n    class TextStringBuilderReader extends Reader {\n\n        /** The last mark position. */\n        private int mark;\n\n        /** The current stream position. */\n        private int pos;\n\n        /**\n         * Default constructor.\n         */\n        TextStringBuilderReader() {\n            super();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void mark(final int readAheadLimit) {\n            mark = pos;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean markSupported() {\n            return true;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int read() {\n            if (!ready()) {\n                return -1;\n            }\n            return TextStringBuilder.this.charAt(pos++);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int read(final char[] b, final int off, int len) {\n            if (off < 0 || len < 0 || off > b.length || off + len > b.length || off + len < 0) {\n                throw new IndexOutOfBoundsException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            if (pos >= TextStringBuilder.this.size()) {\n                return -1;\n            }\n            if (pos + len > size()) {\n                len = TextStringBuilder.this.size() - pos;\n            }\n            TextStringBuilder.this.getChars(pos, pos + len, b, off);\n            pos += len;\n            return len;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean ready() {\n            return pos < TextStringBuilder.this.size();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void reset() {\n            pos = mark;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public long skip(long n) {\n            if (pos + n > TextStringBuilder.this.size()) {\n                n = TextStringBuilder.this.size() - pos;\n            }\n            if (n < 0) {\n                return 0;\n            }\n            pos += n;\n            return n;\n        }\n    }\n\n    /**\n     * Inner class to allow StrBuilder to operate as a tokenizer.\n     */\n    class TextStringBuilderTokenizer extends StringTokenizer {\n\n        /**\n         * Default constructor.\n         */\n        TextStringBuilderTokenizer() {\n            super();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public String getContent() {\n            final String str = super.getContent();\n            if (str == null) {\n                return TextStringBuilder.this.toString();\n            }\n            return str;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n            if (chars == null) {\n                return super.tokenize(TextStringBuilder.this.getBuffer(), 0, TextStringBuilder.this.size());\n            }\n            return super.tokenize(chars, offset, count);\n        }\n    }\n\n    /**\n     * Inner class to allow StrBuilder to operate as a writer.\n     */\n    class TextStringBuilderWriter extends Writer {\n\n        /**\n         * Default constructor.\n         */\n        TextStringBuilderWriter() {\n            super();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void flush() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final char[] cbuf) {\n            TextStringBuilder.this.append(cbuf);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final char[] cbuf, final int off, final int len) {\n            TextStringBuilder.this.append(cbuf, off, len);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final int c) {\n            TextStringBuilder.this.append((char) c);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final String str) {\n            TextStringBuilder.this.append(str);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void write(final String str, final int off, final int len) {\n            TextStringBuilder.this.append(str, off, len);\n        }\n    }\n\n    /**\n     * The extra capacity for new builders.\n     */\n    static final int CAPACITY = 32;\n\n    /**\n     * End-Of-Stream.\n     */\n    private static final int EOS = -1;\n\n    /**\n     * The size of the string {@code \"false\"}.\n     */\n    private static final int FALSE_STRING_SIZE = \"false\".length();\n\n    /**\n     * Required for serialization support.\n     *\n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * The size of the string {@code \"true\"}.\n     */\n    private static final int TRUE_STRING_SIZE = \"true\".length();\n\n    /**\n     * Constructs an instance from a reference to a character array. Changes to the input chars are reflected in this\n     * instance until the internal buffer needs to be reallocated. Using a reference to an array allows the instance to\n     * be initialized without copying the input array.\n     *\n     * @param initialBuffer The initial array that will back the new builder.\n     * @return A new instance.\n     * @since 1.9\n     */\n    public static TextStringBuilder wrap(final char[] initialBuffer) {\n        Objects.requireNonNull(initialBuffer, \"initialBuffer\");\n        return new TextStringBuilder(initialBuffer, initialBuffer.length);\n    }\n\n    /**\n     * Constructs an instance from a reference to a character array. Changes to the input chars are reflected in this\n     * instance until the internal buffer needs to be reallocated. Using a reference to an array allows the instance to\n     * be initialized without copying the input array.\n     *\n     * @param initialBuffer The initial array that will back the new builder.\n     * @param length The length of the subarray to be used; must be non-negative and no larger than\n     *        {@code initialBuffer.length}. The new builder's size will be set to {@code length}.\n     * @return A new instance.\n     * @since 1.9\n     */\n    public static TextStringBuilder wrap(final char[] initialBuffer, final int length) {\n        return new TextStringBuilder(initialBuffer, length);\n    }\n\n    /** Internal data storage. */\n    private char[] buffer;\n\n    /** The new line. */\n    private String newLine;\n\n    /** The null text. */\n    private String nullText;\n\n    /** Incremented when the buffer is reallocated. */\n    private int reallocations;\n\n    /** Current size of the buffer. */\n    private int size;\n\n    /**\n     * Constructor that creates an empty builder initial capacity 32 characters.\n     */\n    public TextStringBuilder() {\n        this(CAPACITY);\n    }\n\n    /**\n     * Constructs an instance from a reference to a character array.\n     *\n     * @param initialBuffer a reference to a character array, must not be null.\n     * @param length The length of the subarray to be used; must be non-negative and no larger than\n     *        {@code initialBuffer.length}. The new builder's size will be set to {@code length}.\n     * @throws NullPointerException If {@code initialBuffer} is null.\n     * @throws IllegalArgumentException if {@length} is bad.\n     */\n    private TextStringBuilder(final char[] initialBuffer, final int length) {\n        this.buffer = Objects.requireNonNull(initialBuffer, \"initialBuffer\");\n        if (length < 0 || length > initialBuffer.length) {\n            throw new IllegalArgumentException(\"initialBuffer.length=\" + initialBuffer.length + \", length=\" + length);\n        }\n        this.size = length;\n    }\n\n    /**\n     * Constructs an instance from a character sequence, allocating 32 extra characters for growth.\n     *\n     * @param seq the string to copy, null treated as blank string\n     * @since 1.9\n     */\n    public TextStringBuilder(final CharSequence seq) {\n        this(StringUtils.length(seq) + CAPACITY);\n        if (seq != null) {\n            append(seq);\n        }\n    }\n\n    /**\n     * Constructs an instance with the specified initial capacity.\n     *\n     * @param initialCapacity the initial capacity, zero or less will be converted to 32\n     */\n    public TextStringBuilder(final int initialCapacity) {\n        super();\n        buffer = new char[initialCapacity <= 0 ? CAPACITY : initialCapacity];\n    }\n\n    /**\n     * Constructs an instance from a string, allocating 32 extra characters for growth.\n     *\n     * @param str the string to copy, null treated as blank string\n     */\n    public TextStringBuilder(final String str) {\n        this(StringUtils.length(str) + CAPACITY);\n        if (str != null) {\n            append(str);\n        }\n    }\n\n    /**\n     * Appends a boolean value to the string builder.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final boolean value) {\n        if (value) {\n            ensureCapacity(size + TRUE_STRING_SIZE);\n            appendTrue(size);\n        } else {\n            ensureCapacity(size + FALSE_STRING_SIZE);\n            appendFalse(size);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char value to the string builder.\n     *\n     * @param ch the value to append\n     * @return this, to enable chaining\n     */\n    @Override\n    public TextStringBuilder append(final char ch) {\n        final int len = length();\n        ensureCapacity(len + 1);\n        buffer[size++] = ch;\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final char[] chars) {\n        if (chars == null) {\n            return appendNull();\n        }\n        final int strLen = chars.length;\n        if (strLen > 0) {\n            final int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(chars, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final char[] chars, final int startIndex, final int length) {\n        if (chars == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n        }\n        if (length < 0 || startIndex + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(chars, startIndex, buffer, len, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends the contents of a char buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the char buffer to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final CharBuffer str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends the contents of a char buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param buf the char buffer to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final CharBuffer buf, final int startIndex, final int length) {\n        if (buf == null) {\n            return appendNull();\n        }\n        if (buf.hasArray()) {\n            final int totalLength = buf.remaining();\n            if (startIndex < 0 || startIndex > totalLength) {\n                throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n            }\n            if (length < 0 || startIndex + length > totalLength) {\n                throw new StringIndexOutOfBoundsException(\"length must be valid\");\n            }\n            final int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(buf.array(), buf.arrayOffset() + buf.position() + startIndex, buffer, len, length);\n            size += length;\n        } else {\n            append(buf.toString(), startIndex, length);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a CharSequence to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param seq the CharSequence to append\n     * @return this, to enable chaining\n     */\n    @Override\n    public TextStringBuilder append(final CharSequence seq) {\n        if (seq == null) {\n            return appendNull();\n        }\n        if (seq instanceof TextStringBuilder) {\n            return append((TextStringBuilder) seq);\n        }\n        if (seq instanceof StringBuilder) {\n            return append((StringBuilder) seq);\n        }\n        if (seq instanceof StringBuffer) {\n            return append((StringBuffer) seq);\n        }\n        if (seq instanceof CharBuffer) {\n            return append((CharBuffer) seq);\n        }\n        return append(seq.toString());\n    }\n\n    /**\n     * Appends part of a CharSequence to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param seq the CharSequence to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid\n     * @return this, to enable chaining\n     */\n    @Override\n    public TextStringBuilder append(final CharSequence seq, final int startIndex, final int endIndex) {\n        if (seq == null) {\n            return appendNull();\n        }\n        if (endIndex <= 0) {\n            throw new StringIndexOutOfBoundsException(\"endIndex must be valid\");\n        }\n        if (startIndex >= endIndex) {\n            throw new StringIndexOutOfBoundsException(\"endIndex must be greater than startIndex\");\n        }\n        return append(seq.toString(), startIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Appends a double value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final double value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a float value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final float value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends an int value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final int value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a long value to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final long value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends an object to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param obj the object to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final Object obj) {\n        if (obj == null) {\n            return appendNull();\n        }\n        if (obj instanceof CharSequence) {\n            return append((CharSequence) obj);\n        }\n        return append(obj.toString());\n    }\n\n    /**\n     * Appends a string to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final String str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a string to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final String str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Calls {@link String#format(String, Object...)} and appends the result.\n     *\n     * @param format the format string\n     * @param objs the objects to use in the format string\n     * @return {@code this} to enable chaining\n     * @see String#format(String, Object...)\n     */\n    public TextStringBuilder append(final String format, final Object... objs) {\n        return append(String.format(format, objs));\n    }\n\n    /**\n     * Appends a string buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string buffer to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuffer str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a string buffer to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuffer str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a StringBuilder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the StringBuilder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuilder str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a StringBuilder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the StringBuilder to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final StringBuilder str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends another string builder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final TextStringBuilder str) {\n        return append(str, 0, StringUtils.length(str));\n    }\n\n    /**\n     * Appends part of a string builder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder append(final TextStringBuilder str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an iterable to the builder without any separators. Appending a null iterable will have no\n     * effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param iterable the iterable to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendAll(final Iterable<?> iterable) {\n        if (iterable != null) {\n            for (final Object o : iterable) {\n                append(o);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an iterator to the builder without any separators. Appending a null iterator will have no\n     * effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param it the iterator to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendAll(final Iterator<?> it) {\n        if (it != null) {\n            while (it.hasNext()) {\n                append(it.next());\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends each item in an array to the builder without any separators. Appending a null array will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param <T> the element type\n     * @param array the array to append\n     * @return this, to enable chaining\n     */\n    public <T> TextStringBuilder appendAll(@SuppressWarnings(\"unchecked\") final T... array) {\n        /*\n         * @SuppressWarnings used to hide warning about vararg usage. We cannot use @SafeVarargs, since this method is\n         * not final. Using @SuppressWarnings is fine, because it isn't inherited by subclasses, so each subclass must\n         * vouch for itself whether its use of 'array' is safe.\n         */\n        if (array != null && array.length > 0) {\n            for (final Object element : array) {\n                append(element);\n            }\n        }\n        return this;\n    }\n\n    /** Appends {@code \"false\"}. */\n    private void appendFalse(int index) {\n        buffer[index++] = 'f';\n        buffer[index++] = 'a';\n        buffer[index++] = 'l';\n        buffer[index++] = 's';\n        buffer[index] = 'e';\n        size += FALSE_STRING_SIZE;\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width. The {@code String.valueOf} of the\n     * {@code int} value is used. If the formatted value is larger than the length, the left hand side is lost.\n     *\n     * @param value the value to append\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {\n        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width. The {@code toString} of the object is\n     * used. If the object is larger than the length, the left hand side is lost. If the object is null, the null text\n     * value is used.\n     *\n     * @param obj the object to append, null uses null text\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = obj == null ? getNullText() : obj.toString();\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length. The {@code String.valueOf} of the\n     * {@code int} value is used. If the object is larger than the length, the right hand side is lost.\n     *\n     * @param value the value to append\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {\n        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length. The {@code toString} of the object is\n     * used. If the object is larger than the length, the right hand side is lost. If the object is null, null text\n     * value is used.\n     *\n     * @param obj the object to append, null uses null text\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = obj == null ? getNullText() : obj.toString();\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a boolean value followed by a new line to the string builder.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final boolean value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a char value followed by a new line to the string builder.\n     *\n     * @param ch the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final char ch) {\n        return append(ch).appendNewLine();\n    }\n\n    /**\n     * Appends a char array followed by a new line to the string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final char[] chars) {\n        return append(chars).appendNewLine();\n    }\n\n    /**\n     * Appends a char array followed by a new line to the string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param chars the char array to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final char[] chars, final int startIndex, final int length) {\n        return append(chars, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends a double value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final double value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a float value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final float value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends an int value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final int value) {\n        return append(value).appendNewLine();\n    }\n\n    /**\n     * Appends a long value followed by a new line to the string builder using {@code String.valueOf}.\n     *\n     * @param value the value to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final long value) {\n        return append(value).appendNewLine();\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Appends an object followed by a new line to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param obj the object to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final Object obj) {\n        return append(obj).appendNewLine();\n    }\n\n    /**\n     * Appends a string followed by a new line to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final String str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final String str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Calls {@link String#format(String, Object...)} and appends the result.\n     *\n     * @param format the format string\n     * @param objs the objects to use in the format string\n     * @return {@code this} to enable chaining\n     * @see String#format(String, Object...)\n     */\n    public TextStringBuilder appendln(final String format, final Object... objs) {\n        return append(format, objs).appendNewLine();\n    }\n\n    /**\n     * Appends a string buffer followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string buffer to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuffer str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string buffer followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuffer str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends a string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuilder str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final StringBuilder str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends another string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string builder to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final TextStringBuilder str) {\n        return append(str).appendNewLine();\n    }\n\n    /**\n     * Appends part of a string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendln(final TextStringBuilder str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }\n\n    /**\n     * Appends the new line string to this string builder.\n     * <p>\n     * The new line string can be altered using {@link #setNewLineText(String)}. This might be used to force the output\n     * to always use Unix line endings even when on Windows.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendNewLine() {\n        if (newLine == null) {\n            append(System.lineSeparator());\n            return this;\n        }\n        return append(newLine);\n    }\n\n    /**\n     * Appends the text representing {@code null} to this string builder.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendNull() {\n        if (nullText == null) {\n            return this;\n        }\n        return append(nullText);\n    }\n\n    /**\n     * Appends the pad character to the builder the specified number of times.\n     *\n     * @param length the length to append, negative means no append\n     * @param padChar the character to append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendPadding(final int length, final char padChar) {\n        if (length >= 0) {\n            ensureCapacity(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator if the builder is currently non-empty. The separator is appended using {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (Iterator it = list.iterator(); it.hasNext();) {\n     *     appendSeparator(',');\n     *     append(it.next());\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final char separator) {\n        if (isNotEmpty()) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Append one of both separators to the builder If the builder is currently empty it will append the\n     * defaultIfEmpty-separator Otherwise it will append the standard-separator\n     *\n     * The separator is appended using {@link #append(char)}.\n     *\n     * @param standard the separator if builder is not empty\n     * @param defaultIfEmpty the separator if builder is empty\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final char standard, final char defaultIfEmpty) {\n        if (isEmpty()) {\n            append(defaultIfEmpty);\n        } else {\n            append(standard);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero. The separator is appended using\n     * {@link #append(char)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (int i = 0; i &lt; list.size(); i++) {\n     *     appendSeparator(\",\", i);\n     *     append(list.get(i));\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use\n     * @param loopIndex the loop index\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final char separator, final int loopIndex) {\n        if (loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends a separator if the builder is currently non-empty. Appending a null separator will have no effect. The\n     * separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (Iterator it = list.iterator(); it.hasNext();) {\n     *     appendSeparator(\",\");\n     *     append(it.next());\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final String separator) {\n        return appendSeparator(separator, null);\n    }\n\n    /**\n     * Appends a separator to the builder if the loop index is greater than zero. Appending a null separator will have\n     * no effect. The separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is useful for adding a separator each time around the loop except the first.\n     * </p>\n     *\n     * <pre>\n     * for (int i = 0; i &lt; list.size(); i++) {\n     *     appendSeparator(\",\", i);\n     *     append(list.get(i));\n     * }\n     * </pre>\n     *\n     * <p>\n     * Note that for this simple example, you should use {@link #appendWithSeparators(Iterable, String)}.\n     * </p>\n     *\n     * @param separator the separator to use, null means no separator\n     * @param loopIndex the loop index\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final String separator, final int loopIndex) {\n        if (separator != null && loopIndex > 0) {\n            append(separator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends one of both separators to the StrBuilder. If the builder is currently empty it will append the\n     * defaultIfEmpty-separator Otherwise it will append the standard-separator\n     *\n     * Appending a null separator will have no effect. The separator is appended using {@link #append(String)}.\n     * <p>\n     * This method is for example useful for constructing queries\n     * </p>\n     *\n     * <pre>\n     * StrBuilder whereClause = new StrBuilder();\n     * if(searchCommand.getPriority() != null) {\n     *  whereClause.appendSeparator(\" and\", \" where\");\n     *  whereClause.append(\" priority = ?\")\n     * }\n     * if(searchCommand.getComponent() != null) {\n     *  whereClause.appendSeparator(\" and\", \" where\");\n     *  whereClause.append(\" component = ?\")\n     * }\n     * selectClause.append(whereClause)\n     * </pre>\n     *\n     * @param standard the separator if builder is not empty, null means no separator\n     * @param defaultIfEmpty the separator if builder is empty, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendSeparator(final String standard, final String defaultIfEmpty) {\n        final String str = isEmpty() ? defaultIfEmpty : standard;\n        if (str != null) {\n            append(str);\n        }\n        return this;\n    }\n\n    /**\n     * Appends current contents of this {@code StrBuilder} to the provided {@link Appendable}.\n     * <p>\n     * This method tries to avoid doing any extra copies of contents.\n     * </p>\n     *\n     * @param appendable the appendable to append data to\n     * @throws IOException if an I/O error occurs\n     *\n     * @see #readFrom(Readable)\n     */\n    public void appendTo(final Appendable appendable) throws IOException {\n        if (appendable instanceof Writer) {\n            ((Writer) appendable).write(buffer, 0, size);\n        } else if (appendable instanceof StringBuilder) {\n            ((StringBuilder) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof StringBuffer) {\n            ((StringBuffer) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof CharBuffer) {\n            ((CharBuffer) appendable).put(buffer, 0, size);\n        } else {\n            appendable.append(this);\n        }\n    }\n\n    /** Appends {@code \"true\"}. */\n    private void appendTrue(int index) {\n        buffer[index++] = 't';\n        buffer[index++] = 'r';\n        buffer[index++] = 'u';\n        buffer[index] = 'e';\n        size += TRUE_STRING_SIZE;\n    }\n\n    /**\n     * Appends an iterable placing separators between each value, but not before the first or after the last. Appending\n     * a null iterable will have no effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param iterable the iterable to append\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendWithSeparators(final Iterable<?> iterable, final String separator) {\n        if (iterable != null) {\n            final String sep = Objects.toString(separator, \"\");\n            final Iterator<?> it = iterable.iterator();\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(sep);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends an iterator placing separators between each value, but not before the first or after the last. Appending\n     * a null iterator will have no effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param it the iterator to append\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendWithSeparators(final Iterator<?> it, final String separator) {\n        if (it != null) {\n            final String sep = Objects.toString(separator, \"\");\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(sep);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends an array placing separators between each value, but not before the first or after the last. Appending a\n     * null array will have no effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param array the array to append\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder appendWithSeparators(final Object[] array, final String separator) {\n        if (array != null && array.length > 0) {\n            final String sep = Objects.toString(separator, \"\");\n            append(array[0]);\n            for (int i = 1; i < array.length; i++) {\n                append(sep);\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets the contents of this builder as a Reader.\n     * <p>\n     * This method allows the contents of the builder to be read using any standard method that expects a Reader.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder}, populate it with data, call {@code asReader}, and then read away.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the reader. This allows you to append to the\n     * builder after creating the reader, and the changes will be picked up. Note however, that no synchronization\n     * occurs, so you must perform all operations with the builder and the reader in one thread.\n     * </p>\n     * <p>\n     * The returned reader supports marking, and ignores the flush method.\n     * </p>\n     *\n     * @return a reader that reads from this builder\n     */\n    public Reader asReader() {\n        return new TextStringBuilderReader();\n    }\n\n    /**\n     * Creates a tokenizer that can tokenize the contents of this builder.\n     * <p>\n     * This method allows the contents of this builder to be tokenized. The tokenizer will be setup by default to\n     * tokenize on space, tab, newline and form feed (as per StringTokenizer). These values can be changed on the\n     * tokenizer class, before retrieving the tokens.\n     * </p>\n     * <p>\n     * The returned tokenizer is linked to this builder. You may intermix calls to the builder and tokenizer within\n     * certain limits, however there is no synchronization. Once the tokenizer has been used once, it must be\n     * {@link StringTokenizer#reset() reset} to pickup the latest changes in the builder. For example:\n     * </p>\n     *\n     * <pre>\n     * StrBuilder b = new StrBuilder();\n     * b.append(\"a b \");\n     * StrTokenizer t = b.asTokenizer();\n     * String[] tokens1 = t.getTokenArray(); // returns a,b\n     * b.append(\"c d \");\n     * String[] tokens2 = t.getTokenArray(); // returns a,b (c and d ignored)\n     * t.reset(); // reset causes builder changes to be picked up\n     * String[] tokens3 = t.getTokenArray(); // returns a,b,c,d\n     * </pre>\n     *\n     * <p>\n     * In addition to simply intermixing appends and tokenization, you can also call the set methods on the tokenizer to\n     * alter how it tokenizes. Just remember to call reset when you want to pickup builder changes.\n     * </p>\n     * <p>\n     * Calling {@link StringTokenizer#reset(String)} or {@link StringTokenizer#reset(char[])} with a non-null value will\n     * break the link with the builder.\n     * </p>\n     *\n     * @return a tokenizer that is linked to this builder\n     */\n    public StringTokenizer asTokenizer() {\n        return new TextStringBuilderTokenizer();\n    }\n\n    /**\n     * Gets this builder as a Writer that can be written to.\n     * <p>\n     * This method allows you to populate the contents of the builder using any standard method that takes a Writer.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder}, call {@code asWriter}, and populate away. The data is available at\n     * any time using the methods of the {@code StrBuilder}.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the writer. This allows you to intermix calls that\n     * append to the builder and write using the writer and the changes will be occur correctly. Note however, that no\n     * synchronization occurs, so you must perform all operations with the builder and the writer in one thread.\n     * </p>\n     * <p>\n     * The returned writer ignores the close and flush methods.\n     * </p>\n     *\n     * @return a writer that populates this builder\n     */\n    public Writer asWriter() {\n        return new TextStringBuilderWriter();\n    }\n\n    /**\n     * Implement the {@link Builder} interface.\n     *\n     * @return The builder as a String\n     * @see #toString()\n     */\n    @Override\n    public String build() {\n        return toString();\n    }\n\n    /**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return The capacity\n     */\n    public int capacity() {\n        return buffer.length;\n    }\n\n    /**\n     * Gets the character at the specified index.\n     *\n     * @see #setCharAt(int, char)\n     * @see #deleteCharAt(int)\n     * @param index the index to retrieve, must be valid\n     * @return The character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    @Override\n    public char charAt(final int index) {\n        validateIndex(index);\n        return buffer[index];\n    }\n\n    /**\n     * Gets the character at the specified index before deleting it.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index the index to retrieve, must be valid\n     * @return The character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 1.9\n     */\n    public char charAtDelete(final int index) {\n        validateIndex(index);\n        final char c = buffer[index];\n        deleteCharAt(index);\n        return c;\n    }\n\n    /**\n     * Clears the string builder (convenience Collections API style method).\n     * <p>\n     * This method does not reduce the size of the internal character buffer. To do that, call {@code clear()} followed\n     * by {@link #minimizeCapacity()}.\n     * </p>\n     * <p>\n     * This method is the same as {@link #setLength(int)} called with zero and is provided to match the API of\n     * Collections.\n     * </p>\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder clear() {\n        size = 0;\n        return this;\n    }\n\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch the character to find\n     * @return true if the builder contains the character\n     */\n    public boolean contains(final char ch) {\n        final char[] thisBuf = buffer;\n        for (int i = 0; i < this.size; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the string builder contains the specified string.\n     *\n     * @param str the string to find\n     * @return true if the builder contains the string\n     */\n    public boolean contains(final String str) {\n        return indexOf(str, 0) >= 0;\n    }\n\n    /**\n     * Checks if the string builder contains a string matched using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to search for\n     * the character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @return true if the matcher finds a match in the builder\n     */\n    public boolean contains(final StringMatcher matcher) {\n        return indexOf(matcher, 0) >= 0;\n    }\n\n    /**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder delete(final int startIndex, final int endIndex) {\n        final int actualEndIndex = validateRange(startIndex, endIndex);\n        final int len = actualEndIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, actualEndIndex, len);\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch the character to delete\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteAll(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                final int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                final int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteAll(final String str) {\n        final int len = str == null ? 0 : str.length();\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            while (index >= 0) {\n                deleteImpl(index, index + len, len);\n                index = indexOf(str, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes all parts of the builder that the matcher matches.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteAll(final StringMatcher matcher) {\n        return replace(matcher, null, 0, size, -1);\n    }\n\n    /**\n     * Deletes the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #setCharAt(int, char)\n     * @param index the index to delete\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder deleteCharAt(final int index) {\n        validateIndex(index);\n        deleteImpl(index, index + 1, 1);\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch the character to delete\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteFirst(final char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteFirst(final String str) {\n        final int len = str == null ? 0 : str.length();\n        if (len > 0) {\n            final int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the first match within the builder using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior. For example you could write a matcher to delete where\n     * the character 'a' is followed by a number.\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder deleteFirst(final StringMatcher matcher) {\n        return replace(matcher, null, 0, size, 1);\n    }\n\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex the start index, must be valid\n     * @param endIndex the end index (exclusive), must be valid\n     * @param len the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void deleteImpl(final int startIndex, final int endIndex, final int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    /**\n     * Drains (copies, then deletes) this character sequence into the specified array. This is equivalent to copying the\n     * characters from this sequence into the target and then deleting those character from this sequence.\n     *\n     * @param startIndex first index to copy, inclusive.\n     * @param endIndex last index to copy, exclusive.\n     * @param target the target array, must not be {@code null}.\n     * @param targetIndex the index to start copying in the target.\n     * @return How many characters where copied (then deleted). If this builder is empty, return {@code 0}.\n     * @since 1.9\n     */\n    public int drainChars(final int startIndex, final int endIndex, final char[] target, final int targetIndex) {\n        final int length = endIndex - startIndex;\n        if (isEmpty() || length == 0 || target.length == 0) {\n            return 0;\n        }\n        final int actualLen = Math.min(Math.min(size, length), target.length - targetIndex);\n        getChars(startIndex, actualLen, target, targetIndex);\n        delete(startIndex, actualLen);\n        return actualLen;\n    }\n\n    /**\n     * Checks whether this builder ends with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str the string to search for, null returns false\n     * @return true if the builder ends with the string\n     */\n    public boolean endsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        int pos = size - len;\n        for (int i = 0; i < len; i++, pos++) {\n            if (buffer[pos] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks the capacity and ensures that it is at least the size specified.\n     *\n     * @param capacity the capacity to ensure\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder ensureCapacity(final int capacity) {\n        if (capacity > buffer.length) {\n            reallocate(capacity * 2);\n        }\n        return this;\n    }\n\n    /**\n     * Checks the contents of this builder against another to see if they contain the same character content.\n     *\n     * @param obj the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        return obj instanceof TextStringBuilder && equals((TextStringBuilder) obj);\n    }\n\n    /**\n     * Checks the contents of this builder against another to see if they contain the same character content.\n     *\n     * @param other the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equals(final TextStringBuilder other) {\n        return other != null && Arrays.equals(buffer, other.buffer);\n    }\n\n    /**\n     * Checks the contents of this builder against another to see if they contain the same character content ignoring\n     * case.\n     *\n     * @param other the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equalsIgnoreCase(final TextStringBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        final char[] thisBuf = this.buffer;\n        final char[] otherBuf = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            final char c1 = thisBuf[i];\n            final char c2 = otherBuf[i];\n            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /** Gets a direct reference to internal storage, not for public consumption. */\n    char[] getBuffer() {\n        return buffer;\n    }\n\n    /**\n     * Copies this character array into the specified array.\n     *\n     * @param target the target array, null will cause an array to be created\n     * @return The input array, unless that was null or too small\n     */\n    public char[] getChars(char[] target) {\n        final int len = length();\n        if (target == null || target.length < len) {\n            target = new char[len];\n        }\n        System.arraycopy(buffer, 0, target, 0, len);\n        return target;\n    }\n\n    /**\n     * Copies this character array into the specified array.\n     *\n     * @param startIndex first index to copy, inclusive, must be valid.\n     * @param endIndex last index to copy, exclusive, must be valid.\n     * @param target the target array, must not be null or too small.\n     * @param targetIndex the index to start copying in target.\n     * @throws NullPointerException if the array is null.\n     * @throws IndexOutOfBoundsException if any index is invalid.\n     */\n    public void getChars(final int startIndex, final int endIndex, final char[] target, final int targetIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex < 0 || endIndex > length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        System.arraycopy(buffer, startIndex, target, targetIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Gets the text to be appended when a new line is added.\n     *\n     * @return The new line text, null means use system default\n     */\n    public String getNewLineText() {\n        return newLine;\n    }\n\n    /**\n     * Gets the text to be appended when null is added.\n     *\n     * @return The null text, null means no append\n     */\n    public String getNullText() {\n        return nullText;\n    }\n\n    /**\n     * Gets a suitable hash code for this builder.\n     *\n     * @return a hash code\n     */\n    @Override\n    public int hashCode() {\n        return Arrays.hashCode(buffer);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     *\n     * @param ch the character to find\n     * @return The first index of the character, or -1 if not found\n     */\n    public int indexOf(final char ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     *\n     * @param ch the character to find\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The first index of the character, or -1 if not found\n     */\n    public int indexOf(final char ch, int startIndex) {\n        startIndex = Math.max(0, startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        final char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     *\n     * @param str the string to find, null returns -1\n     * @return The first index of the string, or -1 if not found\n     */\n    public int indexOf(final String str) {\n        return indexOf(str, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified string starting searching from the given\n     * index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str the string to find, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The first index of the string, or -1 if not found\n     */\n    public int indexOf(final String str, int startIndex) {\n        startIndex = Math.max(0, startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        final int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        final char[] thisBuf = buffer;\n        final int len = size - strLen + 1;\n        outer: for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @return The first index matched, or -1 if not found\n     */\n    public int indexOf(final StringMatcher matcher) {\n        return indexOf(matcher, 0);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The first index matched, or -1 if not found\n     */\n    public int indexOf(final StringMatcher matcher, int startIndex) {\n        startIndex = Math.max(0, startIndex);\n        if (matcher == null || startIndex >= size) {\n            return -1;\n        }\n        final int len = size;\n        final char[] buf = buffer;\n        for (int i = startIndex; i < len; i++) {\n            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + TRUE_STRING_SIZE);\n            System.arraycopy(buffer, index, buffer, index + TRUE_STRING_SIZE, size - index);\n            appendTrue(index);\n        } else {\n            ensureCapacity(size + FALSE_STRING_SIZE);\n            System.arraycopy(buffer, index, buffer, index + FALSE_STRING_SIZE, size - index);\n            appendFalse(index);\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Inserts the character array into this builder. Inserting null will use the stored null text value.\n     *\n     * @param index the index to add at, must be valid\n     * @param chars the char array to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final char[] chars) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        final int len = chars.length;\n        if (len > 0) {\n            ensureCapacity(size + len);\n            System.arraycopy(buffer, index, buffer, index + len, size - index);\n            System.arraycopy(chars, 0, buffer, index, len);\n            size += len;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts part of the character array into this builder. Inserting null will use the stored null text value.\n     *\n     * @param index the index to add at, must be valid\n     * @param chars the char array to insert\n     * @param offset the offset into the character array to start at, must be valid\n     * @param length the length of the character array part to copy, must be positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    public TextStringBuilder insert(final int index, final char[] chars, final int offset, final int length) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        if (offset < 0 || offset > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n        }\n        if (length < 0 || offset + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            ensureCapacity(size + length);\n            System.arraycopy(buffer, index, buffer, index + length, size - index);\n            System.arraycopy(chars, offset, buffer, index, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index the index to add at, must be valid\n     * @param value the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the string representation of an object into this builder. Inserting null will use the stored null text\n     * value.\n     *\n     * @param index the index to add at, must be valid\n     * @param obj the object to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, final Object obj) {\n        if (obj == null) {\n            return insert(index, nullText);\n        }\n        return insert(index, obj.toString());\n    }\n\n    /**\n     * Inserts the string into this builder. Inserting null will use the stored null text value.\n     *\n     * @param index the index to add at, must be valid\n     * @param str the string to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder insert(final int index, String str) {\n        validateIndex(index);\n        if (str == null) {\n            str = nullText;\n        }\n        if (str != null) {\n            final int strLen = str.length();\n            if (strLen > 0) {\n                final int newSize = size + strLen;\n                ensureCapacity(newSize);\n                System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n                size = newSize;\n                str.getChars(0, strLen, buffer, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Checks is the string builder is empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return {@code true} if the size is {@code 0}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Checks is the string builder is not empty.\n     * <p>\n     * This method is the same as checking {@link #length()}.\n     * </p>\n     *\n     * @return {@code true} if the size is not {@code 0}.\n     * @since 1.9\n     */\n    public boolean isNotEmpty() {\n        return size != 0;\n    }\n\n    /**\n     * Gets whether the internal buffer has been reallocated.\n     *\n     * @return Whether the internal buffer has been reallocated.\n     * @since 1.9\n     */\n    public boolean isReallocated() {\n        return reallocations > 0;\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     *\n     * @param ch the character to find\n     * @return The last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(final char ch) {\n        return lastIndexOf(ch, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     *\n     * @param ch the character to find\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(final char ch, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (startIndex < 0) {\n            return -1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (buffer[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     *\n     * @param str the string to find, null returns -1\n     * @return The last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(final String str) {\n        return lastIndexOf(str, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified string starting searching from the given\n     * index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * </p>\n     *\n     * @param str the string to find, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(final String str, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (str == null || startIndex < 0) {\n            return -1;\n        }\n        final int strLen = str.length();\n        if (strLen > 0 && strLen <= size) {\n            if (strLen == 1) {\n                return lastIndexOf(str.charAt(0), startIndex);\n            }\n\n            outer: for (int i = startIndex - strLen + 1; i >= 0; i--) {\n                for (int j = 0; j < strLen; j++) {\n                    if (str.charAt(j) != buffer[i + j]) {\n                        continue outer;\n                    }\n                }\n                return i;\n            }\n\n        } else if (strLen == 0) {\n            return startIndex;\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last match.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @return The last index matched, or -1 if not found\n     */\n    public int lastIndexOf(final StringMatcher matcher) {\n        return lastIndexOf(matcher, size);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The last index matched, or -1 if not found\n     */\n    public int lastIndexOf(final StringMatcher matcher, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (matcher == null || startIndex < 0) {\n            return -1;\n        }\n        final char[] buf = buffer;\n        final int endIndex = startIndex + 1;\n        for (int i = startIndex; i >= 0; i--) {\n            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Extracts the leftmost characters from the string builder without throwing an exception.\n     * <p>\n     * This method extracts the left {@code length} characters from the builder. If this many characters are not\n     * available, the whole builder is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String leftString(final int length) {\n        if (length <= 0) {\n            return \"\";\n        } else if (length >= size) {\n            return new String(buffer, 0, size);\n        } else {\n            return new String(buffer, 0, length);\n        }\n    }\n\n    /**\n     * Gets the length of the string builder.\n     *\n     * @return The length\n     */\n    @Override\n    public int length() {\n        return size;\n    }\n\n    /**\n     * Extracts some characters from the middle of the string builder without throwing an exception.\n     * <p>\n     * This method extracts {@code length} characters from the builder at the specified index. If the index is negative\n     * it is treated as zero. If the index is greater than the builder size, it is treated as the builder size. If the\n     * length is negative, the empty string is returned. If insufficient characters are available in the builder, as\n     * much as possible is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param index the index to start at, negative means zero\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String midString(int index, final int length) {\n        if (index < 0) {\n            index = 0;\n        }\n        if (length <= 0 || index >= size) {\n            return \"\";\n        }\n        if (size <= index + length) {\n            return new String(buffer, index, size - index);\n        }\n        return new String(buffer, index, length);\n    }\n\n    /**\n     * Minimizes the capacity to the actual length of the string.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder minimizeCapacity() {\n        if (buffer.length > size) {\n            reallocate(size);\n        }\n        return this;\n    }\n\n    /**\n     * If possible, reads chars from the provided {@link CharBuffer} directly into underlying character buffer without\n     * making extra copies.\n     *\n     * @param charBuffer CharBuffer to read.\n     * @return The number of characters read.\n     * @throws IOException if an I/O error occurs.\n     *\n     * @see #appendTo(Appendable)\n     * @since 1.9\n     */\n    public int readFrom(final CharBuffer charBuffer) throws IOException {\n        final int oldSize = size;\n        final int remaining = charBuffer.remaining();\n        ensureCapacity(size + remaining);\n        charBuffer.get(buffer, size, remaining);\n        size += remaining;\n        return size - oldSize;\n    }\n\n    /**\n     * If possible, reads all chars from the provided {@link Readable} directly into underlying character buffer without\n     * making extra copies.\n     *\n     * @param readable object to read from\n     * @return The number of characters read\n     * @throws IOException if an I/O error occurs\n     *\n     * @see #appendTo(Appendable)\n     */\n    public int readFrom(final Readable readable) throws IOException {\n        if (readable instanceof Reader) {\n            return readFrom((Reader) readable);\n        } else if (readable instanceof CharBuffer) {\n            return readFrom((CharBuffer) readable);\n        } else {\n            final int oldSize = size;\n            while (true) {\n                ensureCapacity(size + 1);\n                final CharBuffer buf = CharBuffer.wrap(buffer, size, buffer.length - size);\n                final int read = readable.read(buf);\n                if (read == EOS) {\n                    break;\n                }\n                size += read;\n            }\n            return size - oldSize;\n        }\n    }\n\n    /**\n     * If possible, reads all chars from the provided {@link Reader} directly into underlying character buffer without\n     * making extra copies.\n     *\n     * @param reader Reader to read.\n     * @return The number of characters read or -1 if we reached the end of stream.\n     * @throws IOException if an I/O error occurs.\n     *\n     * @see #appendTo(Appendable)\n     * @since 1.9\n     */\n    public int readFrom(final Reader reader) throws IOException {\n        final int oldSize = size;\n        ensureCapacity(size + 1);\n        int readCount = reader.read(buffer, size, buffer.length - size);\n        if (readCount == EOS) {\n            return EOS;\n        }\n        do {\n            size += readCount;\n            ensureCapacity(size + 1);\n            readCount = reader.read(buffer, size, buffer.length - size);\n        } while (readCount != EOS);\n        return size - oldSize;\n    }\n\n    /**\n     * If possible, reads {@code count} chars from the provided {@link Reader} directly into underlying character buffer\n     * without making extra copies.\n     *\n     * @param reader Reader to read.\n     * @param count The maximum characters to read, a value &lt;= 0 returns 0.\n     * @return The number of characters read. If less than {@code count}, then we've reached the end-of-stream, or -1 if\n     *         we reached the end of stream.\n     * @throws IOException if an I/O error occurs.\n     * @see #appendTo(Appendable)\n     * @since 1.9\n     */\n    public int readFrom(final Reader reader, final int count) throws IOException {\n        if (count <= 0) {\n            return 0;\n        }\n        final int oldSize = size;\n        ensureCapacity(size + count);\n        int target = count;\n        int readCount = reader.read(buffer, size, target);\n        if (readCount == EOS) {\n            return EOS;\n        }\n        do {\n            target -= readCount;\n            size += readCount;\n            readCount = reader.read(buffer, size, target);\n        } while (target > 0 && readCount != EOS);\n        return size - oldSize;\n    }\n\n    /**\n     * Reallocates the buffer to the new length.\n     *\n     * @param newLength the length of the copy to be returned\n     */\n    private void reallocate(final int newLength) {\n        this.buffer = Arrays.copyOf(buffer, newLength);\n        this.reallocations++;\n    }\n\n    /**\n     * Replaces a portion of the string builder with another string. The length of the inserted string does not have to\n     * match the removed length.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @param replaceStr the string to replace with, null means delete range\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder replace(final int startIndex, int endIndex, final String replaceStr) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int insertLen = replaceStr == null ? 0 : replaceStr.length();\n        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n        return this;\n    }\n\n    /**\n     * Advanced search and replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the string to replace the match with, null is a delete\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @param replaceCount the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if start index is invalid\n     */\n    public TextStringBuilder replace(final StringMatcher matcher, final String replaceStr, final int startIndex,\n        int endIndex, final int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }\n\n    /**\n     * Replaces the search character with the replace character throughout the builder.\n     *\n     * @param search the search character\n     * @param replace the replace character\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceAll(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the search string with the replace string throughout the builder.\n     *\n     * @param searchStr the search string, null causes no action to occur\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceAll(final String searchStr, final String replaceStr) {\n        final int searchLen = searchStr == null ? 0 : searchStr.length();\n        if (searchLen > 0) {\n            final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n            int index = indexOf(searchStr, 0);\n            while (index >= 0) {\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n                index = indexOf(searchStr, index + replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces all matches within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior. For example you could write a matcher to replace all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceAll(final StringMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }\n\n    /**\n     * Replaces the first instance of the search character with the replace character in the builder.\n     *\n     * @param search the search character\n     * @param replace the replace character\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceFirst(final char search, final char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search string with the replace string.\n     *\n     * @param searchStr the search string, null causes no action to occur\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceFirst(final String searchStr, final String replaceStr) {\n        final int searchLen = searchStr == null ? 0 : searchStr.length();\n        if (searchLen > 0) {\n            final int index = indexOf(searchStr, 0);\n            if (index >= 0) {\n                final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first match within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior. For example you could write a matcher to replace where\n     * the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder replaceFirst(final StringMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }\n\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex the start index, must be valid\n     * @param endIndex the end index (exclusive), must be valid\n     * @param removeLen the length to remove (endIndex - startIndex), must be valid\n     * @param insertStr the string to replace with, null means delete range\n     * @param insertLen the length of the insert string, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr,\n        final int insertLen) {\n        final int newSize = size - removeLen + insertLen;\n        if (insertLen != removeLen) {\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n            size = newSize;\n        }\n        if (insertLen > 0) {\n            insertStr.getChars(0, insertLen, buffer, startIndex);\n        }\n    }\n\n    /**\n     * Replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the string to replace the match with, null is a delete\n     * @param from the start index, must be valid\n     * @param to the end index (exclusive), must be valid\n     * @param replaceCount the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private TextStringBuilder replaceImpl(final StringMatcher matcher, final String replaceStr, final int from, int to,\n        int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            final char[] buf = buffer;\n            final int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Reverses the string builder placing each character in the opposite index.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder reverse() {\n        if (size == 0) {\n            return this;\n        }\n\n        final int half = size / 2;\n        final char[] buf = buffer;\n        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {\n            final char swap = buf[leftIdx];\n            buf[leftIdx] = buf[rightIdx];\n            buf[rightIdx] = swap;\n        }\n        return this;\n    }\n\n    /**\n     * Extracts the rightmost characters from the string builder without throwing an exception.\n     * <p>\n     * This method extracts the right {@code length} characters from the builder. If this many characters are not\n     * available, the whole builder is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */\n    public String rightString(final int length) {\n        if (length <= 0) {\n            return \"\";\n        } else if (length >= size) {\n            return new String(buffer, 0, size);\n        } else {\n            return new String(buffer, size - length, length);\n        }\n    }\n\n    /**\n     * Clears and sets this builder to the given value.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param str the new value.\n     * @return this, to enable chaining\n     * @since 1.9\n     */\n    public TextStringBuilder set(final CharSequence str) {\n        clear();\n        append(str);\n        return this;\n    }\n\n    /**\n     * Sets the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index the index to set\n     * @param ch the new character\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public TextStringBuilder setCharAt(final int index, final char ch) {\n        validateIndex(index);\n        buffer[index] = ch;\n        return this;\n    }\n\n    /**\n     * Updates the length of the builder by either dropping the last characters or adding filler of Unicode zero.\n     *\n     * @param length the length to set to, must be zero or positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the length is negative\n     */\n    public TextStringBuilder setLength(final int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacity(length);\n            final int oldEnd = size;\n            final int newEnd = length;\n            size = length;\n            Arrays.fill(buffer, oldEnd, newEnd, '\\0');\n        }\n        return this;\n    }\n\n    /**\n     * Sets the text to be appended when a new line is added.\n     *\n     * @param newLine the new line text, null means use system default\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder setNewLineText(final String newLine) {\n        this.newLine = newLine;\n        return this;\n    }\n\n    /**\n     * Sets the text to be appended when null is added.\n     *\n     * @param nullText the null text, null means no append\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.isEmpty()) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }\n\n    /**\n     * Gets the length of the string builder.\n     * <p>\n     * This method is the same as {@link #length()} and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return The length\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Checks whether this builder starts with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str the string to search for, null returns false\n     * @return true if the builder starts with the string\n     */\n    public boolean startsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        for (int i = 0; i < len; i++) {\n            if (buffer[i] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public CharSequence subSequence(final int startIndex, final int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(endIndex - startIndex);\n        }\n        return substring(startIndex, endIndex);\n    }\n\n    /**\n     * Extracts a portion of this string builder as a string.\n     *\n     * @param start the start index, inclusive, must be valid\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(final int start) {\n        return substring(start, size);\n    }\n\n    /**\n     * Extracts a portion of this string builder as a string.\n     * <p>\n     * Note: This method treats an endIndex greater than the length of the builder as equal to the length of the\n     * builder, and continues without error, unlike StringBuffer or String.\n     * </p>\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        return new String(buffer, startIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Copies the builder's character array into a new character array.\n     *\n     * @return a new array that represents the contents of the builder\n     */\n    public char[] toCharArray() {\n        return size == 0 ? ArrayUtils.EMPTY_CHAR_ARRAY : Arrays.copyOf(buffer, size);\n    }\n\n    /**\n     * Copies part of the builder's character array into a new character array.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return a new array that holds part of the contents of the builder\n     * @throws IndexOutOfBoundsException if startIndex is invalid, or if endIndex is invalid (but endIndex greater than\n     *         size is valid)\n     */\n    public char[] toCharArray(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        return len == 0 ? ArrayUtils.EMPTY_CHAR_ARRAY : Arrays.copyOfRange(buffer, startIndex, endIndex);\n    }\n\n    /**\n     * Gets a String version of the string builder, creating a new instance each time the method is called.\n     * <p>\n     * Note that unlike StringBuffer, the string version returned is independent of the string builder.\n     *\n     * @return The builder as a String\n     */\n    @Override\n    public String toString() {\n        return new String(buffer, 0, size);\n    }\n\n    /**\n     * Extracts a portion of this string builder as a string.\n     *\n     * @param startIndex The initial offset\n     * @param count the desired length\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 1.9\n     */\n    public String toString(final int startIndex, final int count) {\n        validateIndices(startIndex, startIndex + count);\n        return new String(buffer, startIndex, count);\n    }\n\n    /**\n     * Gets a StringBuffer version of the string builder, creating a new instance each time the method is called.\n     *\n     * @return The builder as a StringBuffer\n     */\n    public StringBuffer toStringBuffer() {\n        return new StringBuffer(size).append(buffer, 0, size);\n    }\n\n    /**\n     * Gets a StringBuilder version of the string builder, creating a new instance each time the method is called.\n     *\n     * @return The builder as a StringBuilder\n     */\n    public StringBuilder toStringBuilder() {\n        return new StringBuilder(size).append(buffer, 0, size);\n    }\n\n    /**\n     * Trims the builder by removing characters less than or equal to a space from the beginning and end.\n     *\n     * @return this, to enable chaining\n     */\n    public TextStringBuilder trim() {\n        if (size == 0) {\n            return this;\n        }\n        int len = size;\n        final char[] buf = buffer;\n        int pos = 0;\n        while (pos < len && buf[pos] <= ' ') {\n            pos++;\n        }\n        while (pos < len && buf[len - 1] <= ' ') {\n            len--;\n        }\n        if (len < size) {\n            delete(len, size);\n        }\n        if (pos > 0) {\n            delete(0, pos);\n        }\n        return this;\n    }\n\n    /**\n     * Validates that an index is in the range {@code 0 <= index <= size}.\n     *\n     * @param index the index to test.\n     * @throws IndexOutOfBoundsException Thrown when the index is not the range {@code 0 <= index <= size}.\n     */\n    protected void validateIndex(final int index) {\n        if (index < 0 || index >= size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n    }\n\n    /**\n     * Validates indices defining a range in this builder.\n     *\n     * @param startIndex the start index, inclusive.\n     * @param endIndex the end index, exclusive.\n     * @throws StringIndexOutOfBoundsException if the index is invalid\n     * @since 1.9\n     */\n    protected void validateIndices(final int startIndex, final int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (startIndex > size) {\n            throw new StringIndexOutOfBoundsException(\"startIndex > size\");\n        }\n    }\n\n    /**\n     * Validates parameters defining a range of the builder.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return A valid end index.\n     * @throws StringIndexOutOfBoundsException if the index is invalid\n     */\n    protected int validateRange(final int startIndex, int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            endIndex = size;\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        return endIndex;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/TextStringBuilder.java b/src/main/java/org/apache/commons/text/TextStringBuilder.java\nindex c9b1eec347..89c2f01380 100644\n--- a/src/main/java/org/apache/commons/text/TextStringBuilder.java\n+++ b/src/main/java/org/apache/commons/text/TextStringBuilder.java\n@@ -338,7 +338,7 @@ public TextStringBuilder() {\n      * @param length The length of the subarray to be used; must be non-negative and no larger than\n      *        {@code initialBuffer.length}. The new builder's size will be set to {@code length}.\n      * @throws NullPointerException If {@code initialBuffer} is null.\n-     * @throws IllegalArgumentException if {@length} is bad.\n+     * @throws IllegalArgumentException if {@code length} is bad.\n      */\n     private TextStringBuilder(final char[] initialBuffer, final int length) {\n         this.buffer = Objects.requireNonNull(initialBuffer, \"initialBuffer\");\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/InetAddressKeys.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\nimport java.net.InetAddress;\n\npublic class InetAddressKeysTest {\n\n    @Test\n    public void testKeyAddress() {\n        assertEquals(\"address\", InetAddressKeys.KEY_ADDRESS);\n    }\n\n    @Test\n    public void testKeyCanonicalName() {\n        assertEquals(\"canonical-name\", InetAddressKeys.KEY_CANONICAL_NAME);\n    }\n\n    @Test\n    public void testKeyName() {\n        assertEquals(\"name\", InetAddressKeys.KEY_NAME);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\n\npackage org.apache.commons.text.lookup;\n\nimport java.net.InetAddress;\n\n/**\n * Constants for referring to {@link InetAddress} APIs.\n *\n * @since 1.8\n */\nfinal class InetAddressKeys {\n\n    /**\n     * Constants for referring to {@link InetAddress#getAddress()}.\n     */\n    static final String KEY_ADDRESS = \"address\";\n\n    /**\n     * Constants for referring to {@link InetAddress#getCanonicalAddress()}.\n     */\n    static final String KEY_CANONICAL_NAME = \"canonical-name\";\n\n    /**\n     * Constants for referring to {@link InetAddress#getName()}.\n     */\n    static final String KEY_NAME = \"name\";\n\n    private InetAddressKeys() {\n        // noop\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/InetAddressKeys.java b/src/main/java/org/apache/commons/text/lookup/InetAddressKeys.java\nindex 139dfe6f87..1b74de6099 100644\n--- a/src/main/java/org/apache/commons/text/lookup/InetAddressKeys.java\n+++ b/src/main/java/org/apache/commons/text/lookup/InetAddressKeys.java\n@@ -32,12 +32,12 @@ final class InetAddressKeys {\n     static final String KEY_ADDRESS = \"address\";\n \n     /**\n-     * Constants for referring to {@link InetAddress#getCanonicalAddress()}.\n+     * Constants for referring to {@link InetAddress#getCanonicalHostName()}.\n      */\n     static final String KEY_CANONICAL_NAME = \"canonical-name\";\n \n     /**\n-     * Constants for referring to {@link InetAddress#getName()}.\n+     * Constants for referring to {@link InetAddress#getHostName()}.\n      */\n     static final String KEY_NAME = \"name\";\n \n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/matcher/AbstractStringMatcher.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.matcher;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass AbstractStringMatcherTest {\n\n    @Test\n    void testCharArrayMatcherConstructorWithChars() {\n        char[] chars = {'a', 'b', 'c'};\n        AbstractStringMatcher.CharArrayMatcher matcher = new AbstractStringMatcher.CharArrayMatcher(chars);\n        assertNotNull(matcher);\n        assertEquals(3, matcher.size());\n    }\n\n    @Test\n    void testCharArrayMatcherIsMatchWithCharArray() {\n        char[] chars = {'a', 'b', 'c'};\n        AbstractStringMatcher.CharArrayMatcher matcher = new AbstractStringMatcher.CharArrayMatcher(chars);\n        char[] buffer = {'a', 'b', 'c', 'd'};\n        assertEquals(3, matcher.isMatch(buffer, 0, 0, buffer.length));\n        assertEquals(0, matcher.isMatch(buffer, 1, 0, buffer.length));\n    }\n\n    @Test\n    void testCharArrayMatcherIsMatchWithCharSequence() {\n        char[] chars = {'a', 'b', 'c'};\n        AbstractStringMatcher.CharArrayMatcher matcher = new AbstractStringMatcher.CharArrayMatcher(chars);\n        CharSequence buffer = \"abcd\";\n        assertEquals(3, matcher.isMatch(buffer, 0, 0, buffer.length()));\n        assertEquals(0, matcher.isMatch(buffer, 1, 0, buffer.length()));\n    }\n\n    @Test\n    void testCharArrayMatcherToString() {\n        char[] chars = {'a', 'b', 'c'};\n        AbstractStringMatcher.CharArrayMatcher matcher = new AbstractStringMatcher.CharArrayMatcher(chars);\n        assertTrue(matcher.toString().contains(\"[\\\"abc\\\"]\"));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.text.matcher;\n\nimport java.util.Arrays;\n\n/**\n * A matcher that determines if a character array portion matches.\n * <p>\n * Thread=safe.\n * </p>\n *\n * @since 1.3\n */\nabstract class AbstractStringMatcher implements StringMatcher {\n\n    /**\n     * Matches all of the given matchers in order.\n     *\n     * @since 1.9\n     */\n    static final class AndStringMatcher extends AbstractStringMatcher {\n\n        /**\n         * Matchers in order.\n         */\n        private final StringMatcher[] stringMatchers;\n\n        /**\n         * Constructs a new initialized instance.\n         *\n         * @param stringMatchers Matchers in order. Never null since the {@link StringMatcherFactory} uses the\n         *        {@link NoneMatcher} instead.\n         */\n        AndStringMatcher(final StringMatcher... stringMatchers) {\n            this.stringMatchers = stringMatchers.clone();\n        }\n\n        @Override\n        public int isMatch(final char[] buffer, final int start, final int bufferStart, final int bufferEnd) {\n            int total = 0;\n            int curStart = start;\n            for (final StringMatcher stringMatcher : stringMatchers) {\n                if (stringMatcher != null) {\n                    final int len = stringMatcher.isMatch(buffer, curStart, bufferStart, bufferEnd);\n                    if (len == 0) {\n                        return 0;\n                    }\n                    total += len;\n                    curStart += len;\n                }\n            }\n            return total;\n        }\n\n        @Override\n        public int isMatch(final CharSequence buffer, final int start, final int bufferStart, final int bufferEnd) {\n            int total = 0;\n            int curStart = start;\n            for (final StringMatcher stringMatcher : stringMatchers) {\n                if (stringMatcher != null) {\n                    final int len = stringMatcher.isMatch(buffer, curStart, bufferStart, bufferEnd);\n                    if (len == 0) {\n                        return 0;\n                    }\n                    total += len;\n                    curStart += len;\n                }\n            }\n            return total;\n        }\n\n        @Override\n        public int size() {\n            int total = 0;\n            for (final StringMatcher stringMatcher : stringMatchers) {\n                if (stringMatcher != null) {\n                    total += stringMatcher.size();\n                }\n            }\n            return total;\n        }\n    }\n\n    /**\n     * Matches out of a set of characters.\n     * <p>\n     * Thread=safe.\n     * </p>\n     */\n    static final class CharArrayMatcher extends AbstractStringMatcher {\n\n        /** The string to match, as a character array, implementation treats as immutable. */\n        private final char[] chars;\n\n        /** The string to match. */\n        private final String string;\n\n        /**\n         * Constructs a matcher from a String.\n         *\n         * @param str the string to match, must not be null\n         */\n        CharArrayMatcher(final char... chars) {\n            super();\n            this.string = String.valueOf(chars);\n            this.chars = chars.clone();\n        }\n\n        /**\n         * Returns the number of matching characters, {@code 0} if there is no match.\n         *\n         * @param buffer the text content to match against, do not change\n         * @param start the starting position for the match, valid for buffer\n         * @param bufferStart unused\n         * @param bufferEnd the end index of the active buffer, valid for buffer\n         * @return The number of matching characters, zero for no match\n         */\n        @Override\n        public int isMatch(final char[] buffer, final int start, final int bufferStart, final int bufferEnd) {\n            final int len = size();\n            if (start + len > bufferEnd) {\n                return 0;\n            }\n            int j = start;\n            for (int i = 0; i < len; i++, j++) {\n                if (chars[i] != buffer[j]) {\n                    return 0;\n                }\n            }\n            return len;\n        }\n\n        /**\n         * Returns the number of matching characters, {@code 0} if there is no match.\n         *\n         * @param buffer the text content to match against, do not change\n         * @param start the starting position for the match, valid for buffer\n         * @param bufferStart unused\n         * @param bufferEnd the end index of the active buffer, valid for buffer\n         * @return The number of matching characters, zero for no match\n         */\n        @Override\n        public int isMatch(final CharSequence buffer, final int start, final int bufferStart, final int bufferEnd) {\n            final int len = size();\n            if (start + len > bufferEnd) {\n                return 0;\n            }\n            int j = start;\n            for (int i = 0; i < len; i++, j++) {\n                if (chars[i] != buffer.charAt(j)) {\n                    return 0;\n                }\n            }\n            return len;\n        }\n\n        /**\n         * Returns the size of the string to match given in the constructor.\n         *\n         * @since 1.9\n         */\n        @Override\n        public int size() {\n            return chars.length;\n        }\n\n        @Override\n        public String toString() {\n            return super.toString() + \"[\\\"\" + string + \"\\\"]\";\n        }\n\n    }\n\n    /**\n     * Matches a character.\n     * <p>\n     * Thread=safe.\n     * </p>\n     */\n    static final class CharMatcher extends AbstractStringMatcher {\n\n        /** The character to match. */\n        private final char ch;\n\n        /**\n         * Constructs a matcher for a single character.\n         *\n         * @param ch the character to match\n         */\n        CharMatcher(final char ch) {\n            super();\n            this.ch = ch;\n        }\n\n        /**\n         * Returns {@code 1} if there is a match, or {@code 0} if there is no match.\n         *\n         * @param buffer the text content to match against, do not change\n         * @param start the starting position for the match, valid for buffer\n         * @param bufferStart unused\n         * @param bufferEnd unused\n         * @return The number of matching characters, zero for no match\n         */\n        @Override\n        public int isMatch(final char[] buffer, final int start, final int bufferStart, final int bufferEnd) {\n            return ch == buffer[start] ? 1 : 0;\n        }\n\n        /**\n         * Returns {@code 1} if there is a match, or {@code 0} if there is no match.\n         *\n         * @param buffer the text content to match against, do not change\n         * @param start the starting position for the match, valid for buffer\n         * @param bufferStart unused\n         * @param bufferEnd unused\n         * @return The number of matching characters, zero for no match\n         */\n        @Override\n        public int isMatch(final CharSequence buffer, final int start, final int bufferStart, final int bufferEnd) {\n            return ch == buffer.charAt(start) ? 1 : 0;\n        }\n\n        /**\n         * Returns 1.\n         *\n         * @since 1.9\n         */\n        @Override\n        public int size() {\n            return 1;\n        }\n\n        @Override\n        public String toString() {\n            return super.toString() + \"['\" + ch + \"']\";\n        }\n    }\n\n    /**\n     * Matches a set of characters.\n     * <p>\n     * Thread=safe.\n     * </p>\n     */\n    static final class CharSetMatcher extends AbstractStringMatcher {\n\n        /** The set of characters to match. */\n        private final char[] chars;\n\n        /**\n         * Constructs a matcher from a character array.\n         *\n         * @param chars the characters to match, must not be null\n         */\n        CharSetMatcher(final char[] chars) {\n            super();\n            this.chars = chars.clone();\n            Arrays.sort(this.chars);\n        }\n\n        /**\n         * Returns {@code 1} if there is a match, or {@code 0} if there is no match.\n         *\n         * @param buffer the text content to match against, do not change\n         * @param start the starting position for the match, valid for buffer\n         * @param bufferStart unused\n         * @param bufferEnd unused\n         * @return The number of matching characters, zero for no match\n         */\n        @Override\n        public int isMatch(final char[] buffer, final int start, final int bufferStart, final int bufferEnd) {\n            return Arrays.binarySearch(chars, buffer[start]) >= 0 ? 1 : 0;\n        }\n\n        /**\n         * Returns {@code 1} if there is a match, or {@code 0} if there is no match.\n         *\n         * @param buffer the text content to match against, do not change\n         * @param start the starting position for the match, valid for buffer\n         * @param bufferStart unused\n         * @param bufferEnd unused\n         * @return The number of matching characters, zero for no match\n         */\n        @Override\n        public int isMatch(final CharSequence buffer, final int start, final int bufferStart, final int bufferEnd) {\n            return Arrays.binarySearch(chars, buffer.charAt(start)) >= 0 ? 1 : 0;\n        }\n\n        /**\n         * Returns 1.\n         *\n         * @since 1.9\n         */\n        @Override\n        public int size() {\n            return 1;\n        }\n\n        @Override\n        public String toString() {\n            return super.toString() + Arrays.toString(chars);\n        }\n\n    }\n\n    /**\n     * Matches nothing.\n     * <p>\n     * Thread=safe.\n     * </p>\n     */\n    static final class NoneMatcher extends AbstractStringMatcher {\n\n        /**\n         * Constructs a new instance of {@code NoMatcher}.\n         */\n        NoneMatcher() {\n            super();\n        }\n\n        /**\n         * Always returns {@code 0}.\n         *\n         * @param buffer unused\n         * @param start unused\n         * @param bufferStart unused\n         * @param bufferEnd unused\n         * @return The number of matching characters, zero for no match\n         */\n        @Override\n        public int isMatch(final char[] buffer, final int start, final int bufferStart, final int bufferEnd) {\n            return 0;\n        }\n\n        /**\n         * Always returns {@code 0}.\n         *\n         * @param buffer unused\n         * @param start unused\n         * @param bufferStart unused\n         * @param bufferEnd unused\n         * @return The number of matching characters, zero for no match\n         */\n        @Override\n        public int isMatch(final CharSequence buffer, final int start, final int bufferStart, final int bufferEnd) {\n            return 0;\n        }\n\n        /**\n         * Returns 0.\n         *\n         * @since 1.9\n         */\n        @Override\n        public int size() {\n            return 0;\n        }\n\n    }\n\n    /**\n     * Matches whitespace as per trim().\n     * <p>\n     * Thread=safe.\n     * </p>\n     */\n    static final class TrimMatcher extends AbstractStringMatcher {\n\n        /**\n         * The space character.\n         */\n        private static final int SPACE_INT = 32;\n\n        /**\n         * Constructs a new instance of {@code TrimMatcher}.\n         */\n        TrimMatcher() {\n            super();\n        }\n\n        /**\n         * Returns {@code 1} if there is a match, or {@code 0} if there is no match.\n         *\n         * @param buffer the text content to match against, do not change\n         * @param start the starting position for the match, valid for buffer\n         * @param bufferStart unused\n         * @param bufferEnd unused\n         * @return The number of matching characters, zero for no match\n         */\n        @Override\n        public int isMatch(final char[] buffer, final int start, final int bufferStart, final int bufferEnd) {\n            return buffer[start] <= SPACE_INT ? 1 : 0;\n        }\n\n        /**\n         * Returns {@code 1} if there is a match, or {@code 0} if there is no match.\n         *\n         * @param buffer the text content to match against, do not change\n         * @param start the starting position for the match, valid for buffer\n         * @param bufferStart unused\n         * @param bufferEnd unused\n         * @return The number of matching characters, zero for no match\n         */\n        @Override\n        public int isMatch(final CharSequence buffer, final int start, final int bufferStart, final int bufferEnd) {\n            return buffer.charAt(start) <= SPACE_INT ? 1 : 0;\n        }\n\n        /**\n         * Returns 1.\n         *\n         * @since 1.9\n         */\n        @Override\n        public int size() {\n            return 1;\n        }\n    }\n\n    /**\n     * Constructor.\n     */\n    protected AbstractStringMatcher() {\n        super();\n    }\n\n//    /**\n//     * Validates indices for {@code bufferStart <= start < bufferEnd}.\n//     *\n//     * @param start the starting position for the match, valid in {@code buffer}.\n//     * @param bufferStart the first active index in the buffer, valid in {@code buffer}.\n//     * @param bufferEnd the end index (exclusive) of the active buffer, valid in {@code buffer}.\n//     */\n//    void validate(final int start, final int bufferStart, final int bufferEnd) {\n//        if (((bufferStart > start) || (start >= bufferEnd))) {\n//            throw new IndexOutOfBoundsException(\n//                String.format(\"bufferStart(%,d) <= start(%,d) < bufferEnd(%,d)\", bufferStart, start, bufferEnd));\n//        }\n//    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/matcher/AbstractStringMatcher.java b/src/main/java/org/apache/commons/text/matcher/AbstractStringMatcher.java\nindex f1020631e8..9c84527d4e 100644\n--- a/src/main/java/org/apache/commons/text/matcher/AbstractStringMatcher.java\n+++ b/src/main/java/org/apache/commons/text/matcher/AbstractStringMatcher.java\n@@ -114,7 +114,7 @@ static final class CharArrayMatcher extends AbstractStringMatcher {\n         /**\n          * Constructs a matcher from a String.\n          *\n-         * @param str the string to match, must not be null\n+         * @param chars the string to match, must not be null\n          */\n         CharArrayMatcher(final char... chars) {\n             super();\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/StringEscapeUtilsTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 134,
    "title": "[TEXT-184] simplify if in CaseUtils",
    "state": "closed",
    "created_at": "2020-07-21T05:39:24Z",
    "merge_commit_sha": "e1044588c0f3c8abb4d78eb740e1385b2cb7d862",
    "base_sha": "af2e6b1b43b4b6cd8d864ad8699a9a3617f7d17c",
    "head_sha": "24b96ca9e71bd0195913de8653e5deb33c16414a",
    "user_login": "XenoAmess",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/CaseUtils.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport org.junit.jupiter.api.Test;\n\npublic class CaseUtilsTest2 {\n\n    @Test\n    public void testToCamelCaseWithDelimiterAtStart() {\n        // Test case where delimiter is at the start and capitalizeFirstLetter is false\n        assertThat(CaseUtils.toCamelCase(\" a b c\", false, ' ')).isEqualTo(\"aBC\");\n    }\n\n    @Test\n    public void testToCamelCaseWithDelimiterAtStartAndCapitalizeFirstLetter() {\n        // Test case where delimiter is at the start and capitalizeFirstLetter is true\n        assertThat(CaseUtils.toCamelCase(\" a b c\", true, ' ')).isEqualTo(\"ABC\");\n    }\n\n    @Test\n    public void testToCamelCaseWithMultipleDelimiters() {\n        // Test case with multiple delimiters and capitalizeFirstLetter is false\n        assertThat(CaseUtils.toCamelCase(\"a-b_c\", false, '-', '_')).isEqualTo(\"aBC\");\n    }\n\n    @Test\n    public void testToCamelCaseWithMultipleDelimitersAndCapitalizeFirstLetter() {\n        // Test case with multiple delimiters and capitalizeFirstLetter is true\n        assertThat(CaseUtils.toCamelCase(\"a-b_c\", true, '-', '_')).isEqualTo(\"ABC\");\n    }\n\n    @Test\n    public void testToCamelCaseWithDelimiterAtEnd() {\n        // Test case where delimiter is at the end and capitalizeFirstLetter is false\n        assertThat(CaseUtils.toCamelCase(\"a b c \", false, ' ')).isEqualTo(\"aBC\");\n    }\n\n    @Test\n    public void testToCamelCaseWithDelimiterAtEndAndCapitalizeFirstLetter() {\n        // Test case where delimiter is at the end and capitalizeFirstLetter is true\n        assertThat(CaseUtils.toCamelCase(\"a b c \", true, ' ')).isEqualTo(\"ABC\");\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * <p>Case manipulation operations on Strings that contain words.</p>\n *\n * <p>This class tries to handle {@code null} input gracefully.\n * An exception will not be thrown for a {@code null} input.\n * Each method documents its behavior in more detail.</p>\n *\n * @since 1.2\n */\npublic class CaseUtils {\n\n    /**\n     * <p>{@code CaseUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code CaseUtils.toCamelCase(\"foo bar\", true, new char[]{'-'});}.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public CaseUtils() {\n        super();\n    }\n\n    /**\n     * <p>Converts all the delimiter separated words in a String into camelCase,\n     * that is each word is made up of a title case character and then a series of\n     * lowercase characters.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first non-delimiter character after a delimiter will be capitalized. The first String\n     * character may or may not be capitalized and it's determined by the user input for capitalizeFirstLetter\n     * variable.</p>\n     *\n     * <p>A {@code null} input String returns {@code null}.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case and cannot perform locale-sensitive mappings.</p>\n     *\n     * <pre>\n     * CaseUtils.toCamelCase(null, false)                                 = null\n     * CaseUtils.toCamelCase(\"\", false, *)                                = \"\"\n     * CaseUtils.toCamelCase(*, false, null)                              = *\n     * CaseUtils.toCamelCase(*, true, new char[0])                        = *\n     * CaseUtils.toCamelCase(\"To.Camel.Case\", false, new char[]{'.'})     = \"toCamelCase\"\n     * CaseUtils.toCamelCase(\" to @ Camel case\", true, new char[]{'@'})   = \"ToCamelCase\"\n     * CaseUtils.toCamelCase(\" @to @ Camel case\", false, new char[]{'@'}) = \"toCamelCase\"\n     * </pre>\n     *\n     * @param str  the String to be converted to camelCase, may be null\n     * @param capitalizeFirstLetter boolean that determines if the first character of first word should be title case.\n     * @param delimiters  set of characters to determine capitalization, null and/or empty array means whitespace\n     * @return camelCase of String, {@code null} if null String input\n     */\n    public static String toCamelCase(String str, final boolean capitalizeFirstLetter, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        str = str.toLowerCase();\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        boolean capitalizeNext = false;\n        if (capitalizeFirstLetter) {\n            capitalizeNext = true;\n        }\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                capitalizeNext = true;\n                if (outOffset == 0) {\n                    capitalizeNext = false;\n                }\n                index += Character.charCount(codePoint);\n            } else if (capitalizeNext || outOffset == 0 && capitalizeFirstLetter) {\n                final int titleCaseCodePoint = Character.toTitleCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                capitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        if (outOffset != 0) {\n            return new String(newCodePoints, 0, outOffset);\n        }\n        return str;\n    }\n\n    /**\n     * <p>Converts an array of delimiters to a hash set of code points. Code point of space(32) is added\n     * as the default value. The generated hash set provides O(1) lookup time.</p>\n     *\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return Set<Integer>\n     */\n    private static Set<Integer> generateDelimiterSet(final char[] delimiters) {\n        final Set<Integer> delimiterHashSet = new HashSet<>();\n        delimiterHashSet.add(Character.codePointAt(new char[]{' '}, 0));\n        if (ArrayUtils.isEmpty(delimiters)) {\n            return delimiterHashSet;\n        }\n\n        for (int index = 0; index < delimiters.length; index++) {\n            delimiterHashSet.add(Character.codePointAt(delimiters, index));\n        }\n        return delimiterHashSet;\n    }\n}\n",
        "diff": " a/src/main/java/org/apache/commons/text/CaseUtils.java b/src/main/java/org/apache/commons/text/CaseUtils.java\nindex 641f64cd8d..df71fc3bc7 100644\n--- a/src/main/java/org/apache/commons/text/CaseUtils.java\n+++ b/src/main/java/org/apache/commons/text/CaseUtils.java\n@@ -91,10 +91,7 @@ public static String toCamelCase(String str, final boolean capitalizeFirstLetter\n             final int codePoint = str.codePointAt(index);\n \n             if (delimiterSet.contains(codePoint)) {\n-                capitalizeNext = true;\n-                if (outOffset == 0) {\n-                    capitalizeNext = false;\n-                }\n+                capitalizeNext = outOffset != 0;\n                 index += Character.charCount(codePoint);\n             } else if (capitalizeNext || outOffset == 0 && capitalizeFirstLetter) {\n                 final int titleCaseCodePoint = Character.toTitleCase(codePoint);\n"
      }
    ]
  },
  {
    "pr_number": 126,
    "title": "Text 174: ScriptStringLookup does not accept \":\"",
    "state": "closed",
    "created_at": "2019-12-19T14:48:59Z",
    "merge_commit_sha": "2e8f42fb6c502e373e39e8c22dd6ac2aac92defa",
    "base_sha": "e72bec3c84c582c4abbe02e1b81eec3c1373d365",
    "head_sha": "d9c4a3a8d15fe44db533e4e1247181b6ad07bdd2",
    "user_login": "ghost",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/ScriptStringLookup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class ScriptStringLookupTest2 {\n\n    @Test\n    public void testExtraColonsInScript() {\n        Assertions.assertEquals(\"7\", ScriptStringLookup.INSTANCE.lookup(\"javascript:3 + 4:extra:colons\"));\n    }\n\n    @Test\n    public void testBadScriptKeyFormat() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            ScriptStringLookup.INSTANCE.lookup(\"javascript\");\n        });\n    }\n\n    @Test\n    public void testValidScriptExecution() {\n        Assertions.assertEquals(\"7\", ScriptStringLookup.INSTANCE.lookup(\"javascript:3 + 4\"));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\n\npackage org.apache.commons.text.lookup;\n\nimport java.util.Objects;\n\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\n\nimport org.apache.commons.text.StringSubstitutor;\n\n/**\n * Looks up keys from an XML document.\n * <p>\n * Looks up the value for a given key in the format \"Document:Key\".\n * </p>\n * <p>\n * For example: {@code \"javascript:3 + 4\"}.\n * </p>\n * <p>\n * Using a {@link StringSubstitutor}:\n * </p>\n * <pre>\n * StringSubstitutor.createInterpolator().replace(\"${script:javascript:3 + 4}\"));\n * </pre>\n * @since 1.5\n */\nfinal class ScriptStringLookup extends AbstractStringLookup {\n\n    /**\n     * Defines the singleton for this class.\n     */\n    static final ScriptStringLookup INSTANCE = new ScriptStringLookup();\n\n    /**\n     * No need to build instances for now.\n     */\n    private ScriptStringLookup() {\n        // empty\n    }\n\n    /**\n     * Looks up the value for the key in the format \"DocumentPath:XPath\".\n     * <p>\n     * For example: \"com/domain/document.xml:/path/to/node\".\n     * </p>\n     *\n     * @param key\n     *            the key to be looked up, may be null\n     * @return The value associated with the key.\n     */\n    @Override\n    public String lookup(final String key) {\n        if (key == null) {\n            return null;\n        }\n        final String[] keys = key.split(SPLIT_STR);\n        final int keyLen = keys.length;\n        if (keyLen != 2) {\n            throw IllegalArgumentExceptions.format(\"Bad script key format [%s]; expected format is DocumentPath:Key.\",\n                    key);\n        }\n        final String engineName = keys[0];\n        final String script = keys[1];\n        try {\n            final ScriptEngine scriptEngine = new ScriptEngineManager().getEngineByName(engineName);\n            if (scriptEngine == null) {\n                throw new IllegalArgumentException(\"No script engine named \" + engineName);\n            }\n            return Objects.toString(scriptEngine.eval(script), null);\n        } catch (final Exception e) {\n            throw IllegalArgumentExceptions.format(e, \"Error in script engine [%s] evaluating script [%s].\", engineName,\n                    script);\n        }\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/ScriptStringLookup.java b/src/main/java/org/apache/commons/text/lookup/ScriptStringLookup.java\nindex 701d013ec6..3029d7343e 100644\n--- a/src/main/java/org/apache/commons/text/lookup/ScriptStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/ScriptStringLookup.java\n@@ -25,9 +25,9 @@\n import org.apache.commons.text.StringSubstitutor;\n \n /**\n- * Looks up keys from an XML document.\n+ * Executes the script with the given engine name.\n  * <p>\n- * Looks up the value for a given key in the format \"Document:Key\".\n+ * Execute the script with the engine name in the format \"EngineName:Script\".\n  * </p>\n  * <p>\n  * For example: {@code \"javascript:3 + 4\"}.\n@@ -55,24 +55,25 @@ private ScriptStringLookup() {\n     }\n \n     /**\n-     * Looks up the value for the key in the format \"DocumentPath:XPath\".\n+     * Execute the script with the engine name in the format \"EngineName:Script\".\n+     * Extra colons will be ignored.\n      * <p>\n-     * For example: \"com/domain/document.xml:/path/to/node\".\n+     * For example: {@code \"javascript:3 + 4\"}.\n      * </p>\n      *\n      * @param key\n-     *            the key to be looked up, may be null\n-     * @return The value associated with the key.\n+     *            the engine:script to execute, may be null\n+     * @return The value returned by the execution.\n      */\n     @Override\n     public String lookup(final String key) {\n         if (key == null) {\n             return null;\n         }\n-        final String[] keys = key.split(SPLIT_STR);\n+        final String[] keys = key.split(SPLIT_STR, 2);\n         final int keyLen = keys.length;\n         if (keyLen != 2) {\n-            throw IllegalArgumentExceptions.format(\"Bad script key format [%s]; expected format is DocumentPath:Key.\",\n+            throw IllegalArgumentExceptions.format(\"Bad script key format [%s]; expected format is EngineName:Script.\",\n                     key);\n         }\n         final String engineName = keys[0];\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/lookup/ScriptStringLookupTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 124,
    "title": "(doc) Fix compiler warnings in Java code example in Javadoc",
    "state": "closed",
    "created_at": "2019-10-10T16:58:03Z",
    "merge_commit_sha": "5c958f2e2d1d00528bef13a406cc1e42d7106d73",
    "base_sha": "15abbfa3ae7a4944b7ab90b3f7343a9f4566e006",
    "head_sha": "b0e1b8af24b3587002ec7609c286824574125fa8",
    "user_login": "johanhammar",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/StrSubstitutor.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class StrSubstitutorTest2 {\n    private Map<String, String> values;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        values = new HashMap<>();\n        values.put(\"animal\", \"quick brown fox\");\n        values.put(\"target\", \"lazy dog\");\n    }\n\n    @Test\n    public void testReplaceSimpleWithGenerics() {\n        // Test case to ensure that the example in the documentation with generics works correctly\n        Map<String, String> valuesMap = new HashMap<>();\n        valuesMap.put(\"animal\", \"quick brown fox\");\n        valuesMap.put(\"target\", \"lazy dog\");\n        String templateString = \"The ${animal} jumped over the ${target}.\";\n        StrSubstitutor sub = new StrSubstitutor(valuesMap);\n        String resolvedString = sub.replace(templateString);\n        assertEquals(\"The quick brown fox jumped over the lazy dog.\", resolvedString);\n    }\n\n    @Test\n    public void testReplaceWithDefaultValueWithGenerics() {\n        // Test case to ensure that the example with default values in the documentation with generics works correctly\n        Map<String, String> valuesMap = new HashMap<>();\n        valuesMap.put(\"animal\", \"quick brown fox\");\n        valuesMap.put(\"target\", \"lazy dog\");\n        String templateString = \"The ${animal} jumped over the ${target}. ${undefined.number:-1234567890}.\";\n        StrSubstitutor sub = new StrSubstitutor(valuesMap);\n        String resolvedString = sub.replace(templateString);\n        assertEquals(\"The quick brown fox jumped over the lazy dog. 1234567890.\", resolvedString);\n    }\n\n    @Test\n    public void testReplaceInVariableWithGenerics() {\n        // Test case to ensure that the example with substitution in variables in the documentation with generics works correctly\n        Map<String, String> valuesMap = new HashMap<>();\n        valuesMap.put(\"name\", \"Douglas ${surname}\");\n        valuesMap.put(\"surname\", \"Crockford\");\n        String templateString = \"Hi ${name}\";\n        StrSubstitutor sub = new StrSubstitutor(valuesMap);\n        sub.setEnableSubstitutionInVariables(true);\n        String resolvedString = sub.replace(templateString);\n        assertEquals(\"Hi Douglas Crockford\", resolvedString);\n    }\n}",
        "file_content": "/*\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n * this work for additional information regarding copyright ownership.\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n * (the \"License\"); you may not use this file except in compliance with\r\n * the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.apache.commons.text;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Enumeration;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\nimport org.apache.commons.lang3.Validate;\r\n\r\n/**\r\n * Substitutes variables within a string by values.\r\n * <p>\r\n * This class takes a piece of text and substitutes all the variables within it.\r\n * The default definition of a variable is <code>${variableName}</code>.\r\n * The prefix and suffix can be changed via constructors and set methods.\r\n * <p>\r\n * Variable values are typically resolved from a map, but could also be resolved\r\n * from system properties, or by supplying a custom variable resolver.\r\n * <p>\r\n * The simplest example is to use this class to replace Java System properties. For example:\r\n * <pre>\r\n * StrSubstitutor.replaceSystemProperties(\r\n *      \"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\r\n * </pre>\r\n * <p>\r\n * Typical usage of this class follows the following pattern: First an instance is created\r\n * and initialized with the map that contains the values for the available variables.\r\n * If a prefix and/or suffix for variables should be used other than the default ones,\r\n * the appropriate settings can be performed. After that the <code>replace()</code>\r\n * method can be called passing in the source text for interpolation. In the returned\r\n * text all variable references (as long as their values are known) will be resolved.\r\n * The following example demonstrates this:\r\n * <pre>\r\n * Map valuesMap = HashMap();\r\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\r\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\r\n * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\r\n * StrSubstitutor sub = new StrSubstitutor(valuesMap);\r\n * String resolvedString = sub.replace(templateString);\r\n * </pre>\r\n * yielding:\r\n * <pre>\r\n *      The quick brown fox jumped over the lazy dog.\r\n * </pre>\r\n * <p>\r\n * Also, this class allows to set a default value for unresolved variables.\r\n * The default value for a variable can be appended to the variable name after the variable\r\n * default value delimiter. The default value of the variable default value delimiter is ':-',\r\n * as in bash and other *nix shells, as those are arguably where the default ${} delimiter set originated.\r\n * The variable default value delimiter can be manually set by calling {@link #setValueDelimiterMatcher(StrMatcher)},\r\n * {@link #setValueDelimiter(char)} or {@link #setValueDelimiter(String)}.\r\n * The following shows an example with variable default value settings:\r\n * <pre>\r\n * Map valuesMap = HashMap();\r\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\r\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\r\n * String templateString = &quot;The ${animal} jumped over the ${target}. ${undefined.number:-1234567890}.&quot;;\r\n * StrSubstitutor sub = new StrSubstitutor(valuesMap);\r\n * String resolvedString = sub.replace(templateString);\r\n * </pre>\r\n * yielding:\r\n * <pre>\r\n *      The quick brown fox jumped over the lazy dog. 1234567890.\r\n * </pre>\r\n * <p>\r\n * In addition to this usage pattern there are some static convenience methods that\r\n * cover the most common use cases. These methods can be used without the need of\r\n * manually creating an instance. However if multiple replace operations are to be\r\n * performed, creating and reusing an instance of this class will be more efficient.\r\n * <p>\r\n * Variable replacement works in a recursive way. Thus, if a variable value contains\r\n * a variable then that variable will also be replaced. Cyclic replacements are\r\n * detected and will cause an exception to be thrown.\r\n * <p>\r\n * Sometimes the interpolation's result must contain a variable prefix. As an example\r\n * take the following source text:\r\n * <pre>\r\n *   The variable ${${name}} must be used.\r\n * </pre>\r\n * Here only the variable's name referred to in the text should be replaced resulting\r\n * in the text (assuming that the value of the <code>name</code> variable is <code>x</code>):\r\n * <pre>\r\n *   The variable ${x} must be used.\r\n * </pre>\r\n * To achieve this effect there are two possibilities: Either set a different prefix\r\n * and suffix for variables which do not conflict with the result text you want to\r\n * produce. The other possibility is to use the escape character, by default '$'.\r\n * If this character is placed before a variable reference, this reference is ignored\r\n * and won't be replaced. For example:\r\n * <pre>\r\n *   The variable $${${name}} must be used.\r\n * </pre>\r\n * <p>\r\n * In some complex scenarios you might even want to perform substitution in the\r\n * names of variables, for instance\r\n * <pre>\r\n * ${jre-${java.specification.version}}\r\n * </pre>\r\n * <code>StrSubstitutor</code> supports this recursive substitution in variable\r\n * names, but it has to be enabled explicitly by setting the\r\n * {@link #setEnableSubstitutionInVariables(boolean) enableSubstitutionInVariables}\r\n * property to <b>true</b>.\r\n * <p>This class is <b>not</b> thread safe.</p>\r\n *\r\n * @since 1.0\r\n * @deprecated Deprecated as of 1.3, use {@link StringSubstitutor} instead. This class will be removed in 2.0.\r\n */\r\n@Deprecated\r\npublic class StrSubstitutor {\r\n\r\n    /**\r\n     * Constant for the default escape character.\r\n     */\r\n    public static final char DEFAULT_ESCAPE = '$';\r\n\r\n    /**\r\n     * Constant for the default variable prefix.\r\n     */\r\n    public static final StrMatcher DEFAULT_PREFIX = StrMatcher.stringMatcher(\"${\");\r\n\r\n    /**\r\n     * Constant for the default variable suffix.\r\n     */\r\n    public static final StrMatcher DEFAULT_SUFFIX = StrMatcher.stringMatcher(\"}\");\r\n\r\n    /**\r\n     * Constant for the default value delimiter of a variable.\r\n     */\r\n    public static final StrMatcher DEFAULT_VALUE_DELIMITER = StrMatcher.stringMatcher(\":-\");\r\n\r\n    /**\r\n     * Stores the escape character.\r\n     */\r\n    private char escapeChar;\r\n\r\n    /**\r\n     * Stores the variable prefix.\r\n     */\r\n    private StrMatcher prefixMatcher;\r\n\r\n    /**\r\n     * Stores the variable suffix.\r\n     */\r\n    private StrMatcher suffixMatcher;\r\n\r\n    /**\r\n     * Stores the default variable value delimiter.\r\n     */\r\n    private StrMatcher valueDelimiterMatcher;\r\n\r\n    /**\r\n     * Variable resolution is delegated to an implementor of VariableResolver.\r\n     */\r\n    private StrLookup<?> variableResolver;\r\n\r\n    /**\r\n     * The flag whether substitution in variable names is enabled.\r\n     */\r\n    private boolean enableSubstitutionInVariables;\r\n\r\n    /**\r\n     * Whether escapes should be preserved.  Default is false;\r\n     */\r\n    private boolean preserveEscapes = false;\r\n\r\n    /**\r\n     * The flag whether substitution in variable values is disabled.\r\n     */\r\n    private boolean disableSubstitutionInValues;\r\n\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables in the given source object with\r\n     * their matching values from the map.\r\n     *\r\n     * @param <V> the type of the values in the map\r\n     * @param source  the source text containing the variables to substitute, null returns null\r\n     * @param valueMap  the map with the values, may be null\r\n     * @return The result of the replace operation\r\n     */\r\n    public static <V> String replace(final Object source, final Map<String, V> valueMap) {\r\n        return new StrSubstitutor(valueMap).replace(source);\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables in the given source object with\r\n     * their matching values from the map. This method allows to specify a\r\n     * custom variable prefix and suffix\r\n     *\r\n     * @param <V> the type of the values in the map\r\n     * @param source  the source text containing the variables to substitute, null returns null\r\n     * @param valueMap  the map with the values, may be null\r\n     * @param prefix  the prefix of variables, not null\r\n     * @param suffix  the suffix of variables, not null\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public static <V> String replace(final Object source,\r\n                                     final Map<String, V> valueMap,\r\n                                     final String prefix,\r\n                                     final String suffix) {\r\n        return new StrSubstitutor(valueMap, prefix, suffix).replace(source);\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables in the given source object with their matching\r\n     * values from the properties.\r\n     *\r\n     * @param source the source text containing the variables to substitute, null returns null\r\n     * @param valueProperties the properties with values, may be null\r\n     * @return The result of the replace operation\r\n     */\r\n    public static String replace(final Object source, final Properties valueProperties) {\r\n        if (valueProperties == null) {\r\n            return source.toString();\r\n        }\r\n        final Map<String, String> valueMap = new HashMap<>();\r\n        final Enumeration<?> propNames = valueProperties.propertyNames();\r\n        while (propNames.hasMoreElements()) {\r\n            final String propName = (String) propNames.nextElement();\r\n            final String propValue = valueProperties.getProperty(propName);\r\n            valueMap.put(propName, propValue);\r\n        }\r\n        return StrSubstitutor.replace(source, valueMap);\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables in the given source object with\r\n     * their matching values from the system properties.\r\n     *\r\n     * @param source  the source text containing the variables to substitute, null returns null\r\n     * @return The result of the replace operation\r\n     */\r\n    public static String replaceSystemProperties(final Object source) {\r\n        return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);\r\n    }\r\n\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Creates a new instance with defaults for variable prefix and suffix\r\n     * and the escaping character.\r\n     */\r\n    public StrSubstitutor() {\r\n        this((StrLookup<?>) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it. Uses defaults for variable\r\n     * prefix and suffix and the escaping character.\r\n     *\r\n     * @param <V> the type of the values in the map\r\n     * @param valueMap  the map with the variables' values, may be null\r\n     */\r\n    public <V> StrSubstitutor(final Map<String, V> valueMap) {\r\n        this(StrLookup.mapLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it. Uses a default escaping character.\r\n     *\r\n     * @param <V> the type of the values in the map\r\n     * @param valueMap  the map with the variables' values, may be null\r\n     * @param prefix  the prefix for variables, not null\r\n     * @param suffix  the suffix for variables, not null\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix) {\r\n        this(StrLookup.mapLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param <V> the type of the values in the map\r\n     * @param valueMap  the map with the variables' values, may be null\r\n     * @param prefix  the prefix for variables, not null\r\n     * @param suffix  the suffix for variables, not null\r\n     * @param escape  the escape character\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\r\n                              final char escape) {\r\n        this(StrLookup.mapLookup(valueMap), prefix, suffix, escape);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param <V> the type of the values in the map\r\n     * @param valueMap  the map with the variables' values, may be null\r\n     * @param prefix  the prefix for variables, not null\r\n     * @param suffix  the suffix for variables, not null\r\n     * @param escape  the escape character\r\n     * @param valueDelimiter  the variable default value delimiter, may be null\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\r\n                              final char escape, final String valueDelimiter) {\r\n        this(StrLookup.mapLookup(valueMap), prefix, suffix, escape, valueDelimiter);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param variableResolver  the variable resolver, may be null\r\n     */\r\n    public StrSubstitutor(final StrLookup<?> variableResolver) {\r\n        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param variableResolver  the variable resolver, may be null\r\n     * @param prefix  the prefix for variables, not null\r\n     * @param suffix  the suffix for variables, not null\r\n     * @param escape  the escape character\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix,\r\n                          final char escape) {\r\n        this.setVariableResolver(variableResolver);\r\n        this.setVariablePrefix(prefix);\r\n        this.setVariableSuffix(suffix);\r\n        this.setEscapeChar(escape);\r\n        this.setValueDelimiterMatcher(DEFAULT_VALUE_DELIMITER);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param variableResolver  the variable resolver, may be null\r\n     * @param prefix  the prefix for variables, not null\r\n     * @param suffix  the suffix for variables, not null\r\n     * @param escape  the escape character\r\n     * @param valueDelimiter  the variable default value delimiter string, may be null\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix,\r\n                          final char escape, final String valueDelimiter) {\r\n        this.setVariableResolver(variableResolver);\r\n        this.setVariablePrefix(prefix);\r\n        this.setVariableSuffix(suffix);\r\n        this.setEscapeChar(escape);\r\n        this.setValueDelimiter(valueDelimiter);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param variableResolver  the variable resolver, may be null\r\n     * @param prefixMatcher  the prefix for variables, not null\r\n     * @param suffixMatcher  the suffix for variables, not null\r\n     * @param escape  the escape character\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public StrSubstitutor(\r\n            final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher,\r\n            final char escape) {\r\n        this(variableResolver, prefixMatcher, suffixMatcher, escape, DEFAULT_VALUE_DELIMITER);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param variableResolver  the variable resolver, may be null\r\n     * @param prefixMatcher  the prefix for variables, not null\r\n     * @param suffixMatcher  the suffix for variables, not null\r\n     * @param escape  the escape character\r\n     * @param valueDelimiterMatcher  the variable default value delimiter matcher, may be null\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public StrSubstitutor(\r\n            final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher,\r\n            final char escape, final StrMatcher valueDelimiterMatcher) {\r\n        this.setVariableResolver(variableResolver);\r\n        this.setVariablePrefixMatcher(prefixMatcher);\r\n        this.setVariableSuffixMatcher(suffixMatcher);\r\n        this.setEscapeChar(escape);\r\n        this.setValueDelimiterMatcher(valueDelimiterMatcher);\r\n    }\r\n\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values\r\n     * from the resolver using the given source string as a template.\r\n     *\r\n     * @param source  the string to replace in, null returns null\r\n     * @return The result of the replace operation\r\n     */\r\n    public String replace(final String source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(source);\r\n        if (!substitute(buf, 0, source.length())) {\r\n            return source;\r\n        }\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values\r\n     * from the resolver using the given source string as a template.\r\n     * <p>\r\n     * Only the specified portion of the string will be processed.\r\n     * The rest of the string is not processed, and is not returned.\r\n     *\r\n     * @param source  the string to replace in, null returns null\r\n     * @param offset  the start offset within the array, must be valid\r\n     * @param length  the length within the array to be processed, must be valid\r\n     * @return The result of the replace operation\r\n     */\r\n    public String replace(final String source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\r\n        if (!substitute(buf, 0, length)) {\r\n            return source.substring(offset, offset + length);\r\n        }\r\n        return buf.toString();\r\n    }\r\n\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values\r\n     * from the resolver using the given source array as a template.\r\n     * The array is not altered by this method.\r\n     *\r\n     * @param source  the character array to replace in, not altered, null returns null\r\n     * @return The result of the replace operation\r\n     */\r\n    public String replace(final char[] source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(source.length).append(source);\r\n        substitute(buf, 0, source.length);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values\r\n     * from the resolver using the given source array as a template.\r\n     * The array is not altered by this method.\r\n     * <p>\r\n     * Only the specified portion of the array will be processed.\r\n     * The rest of the array is not processed, and is not returned.\r\n     *\r\n     * @param source  the character array to replace in, not altered, null returns null\r\n     * @param offset  the start offset within the array, must be valid\r\n     * @param length  the length within the array to be processed, must be valid\r\n     * @return The result of the replace operation\r\n     */\r\n    public String replace(final char[] source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\r\n        substitute(buf, 0, length);\r\n        return buf.toString();\r\n    }\r\n\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values\r\n     * from the resolver using the given source buffer as a template.\r\n     * The buffer is not altered by this method.\r\n     *\r\n     * @param source  the buffer to use as a template, not changed, null returns null\r\n     * @return The result of the replace operation\r\n     */\r\n    public String replace(final StringBuffer source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(source.length()).append(source);\r\n        substitute(buf, 0, buf.length());\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values\r\n     * from the resolver using the given source buffer as a template.\r\n     * The buffer is not altered by this method.\r\n     * <p>\r\n     * Only the specified portion of the buffer will be processed.\r\n     * The rest of the buffer is not processed, and is not returned.\r\n     *\r\n     * @param source  the buffer to use as a template, not changed, null returns null\r\n     * @param offset  the start offset within the array, must be valid\r\n     * @param length  the length within the array to be processed, must be valid\r\n     * @return The result of the replace operation\r\n     */\r\n    public String replace(final StringBuffer source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\r\n        substitute(buf, 0, length);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values\r\n     * from the resolver using the given source as a template.\r\n     * The source is not altered by this method.\r\n     *\r\n     * @param source  the buffer to use as a template, not changed, null returns null\r\n     * @return The result of the replace operation\r\n     */\r\n    public String replace(final CharSequence source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        return replace(source, 0, source.length());\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values\r\n     * from the resolver using the given source as a template.\r\n     * The source is not altered by this method.\r\n     * <p>\r\n     * Only the specified portion of the buffer will be processed.\r\n     * The rest of the buffer is not processed, and is not returned.\r\n     *\r\n     * @param source  the buffer to use as a template, not changed, null returns null\r\n     * @param offset  the start offset within the array, must be valid\r\n     * @param length  the length within the array to be processed, must be valid\r\n     * @return The result of the replace operation\r\n     */\r\n    public String replace(final CharSequence source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\r\n        substitute(buf, 0, length);\r\n        return buf.toString();\r\n    }\r\n\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values\r\n     * from the resolver using the given source builder as a template.\r\n     * The builder is not altered by this method.\r\n     *\r\n     * @param source  the builder to use as a template, not changed, null returns null\r\n     * @return The result of the replace operation\r\n     */\r\n    public String replace(final StrBuilder source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(source.length()).append(source);\r\n        substitute(buf, 0, buf.length());\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values\r\n     * from the resolver using the given source builder as a template.\r\n     * The builder is not altered by this method.\r\n     * <p>\r\n     * Only the specified portion of the builder will be processed.\r\n     * The rest of the builder is not processed, and is not returned.\r\n     *\r\n     * @param source  the builder to use as a template, not changed, null returns null\r\n     * @param offset  the start offset within the array, must be valid\r\n     * @param length  the length within the array to be processed, must be valid\r\n     * @return The result of the replace operation\r\n     */\r\n    public String replace(final StrBuilder source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\r\n        substitute(buf, 0, length);\r\n        return buf.toString();\r\n    }\r\n\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables in the given source object with\r\n     * their matching values from the resolver. The input source object is\r\n     * converted to a string using <code>toString</code> and is not altered.\r\n     *\r\n     * @param source  the source to replace in, null returns null\r\n     * @return The result of the replace operation\r\n     */\r\n    public String replace(final Object source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final StrBuilder buf = new StrBuilder().append(source);\r\n        substitute(buf, 0, buf.length());\r\n        return buf.toString();\r\n    }\r\n\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source buffer\r\n     * with their matching values from the resolver.\r\n     * The buffer is updated with the result.\r\n     *\r\n     * @param source  the buffer to replace in, updated, null returns zero\r\n     * @return true if altered\r\n     */\r\n    public boolean replaceIn(final StringBuffer source) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        return replaceIn(source, 0, source.length());\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source buffer\r\n     * with their matching values from the resolver.\r\n     * The buffer is updated with the result.\r\n     * <p>\r\n     * Only the specified portion of the buffer will be processed.\r\n     * The rest of the buffer is not processed, but it is not deleted.\r\n     *\r\n     * @param source  the buffer to replace in, updated, null returns zero\r\n     * @param offset  the start offset within the array, must be valid\r\n     * @param length  the length within the buffer to be processed, must be valid\r\n     * @return true if altered\r\n     */\r\n    public boolean replaceIn(final StringBuffer source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\r\n        if (!substitute(buf, 0, length)) {\r\n            return false;\r\n        }\r\n        source.replace(offset, offset + length, buf.toString());\r\n        return true;\r\n    }\r\n\r\n  //-----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source buffer\r\n     * with their matching values from the resolver.\r\n     * The buffer is updated with the result.\r\n     *\r\n     * @param source  the buffer to replace in, updated, null returns zero\r\n     * @return true if altered\r\n     */\r\n    public boolean replaceIn(final StringBuilder source) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        return replaceIn(source, 0, source.length());\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source builder\r\n     * with their matching values from the resolver.\r\n     * The builder is updated with the result.\r\n     * <p>\r\n     * Only the specified portion of the buffer will be processed.\r\n     * The rest of the buffer is not processed, but it is not deleted.\r\n     *\r\n     * @param source  the buffer to replace in, updated, null returns zero\r\n     * @param offset  the start offset within the array, must be valid\r\n     * @param length  the length within the buffer to be processed, must be valid\r\n     * @return true if altered\r\n     */\r\n    public boolean replaceIn(final StringBuilder source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\r\n        if (!substitute(buf, 0, length)) {\r\n            return false;\r\n        }\r\n        source.replace(offset, offset + length, buf.toString());\r\n        return true;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source\r\n     * builder with their matching values from the resolver.\r\n     *\r\n     * @param source  the builder to replace in, updated, null returns zero\r\n     * @return true if altered\r\n     */\r\n    public boolean replaceIn(final StrBuilder source) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        return substitute(source, 0, source.length());\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source\r\n     * builder with their matching values from the resolver.\r\n     * <p>\r\n     * Only the specified portion of the builder will be processed.\r\n     * The rest of the builder is not processed, but it is not deleted.\r\n     *\r\n     * @param source  the builder to replace in, null returns zero\r\n     * @param offset  the start offset within the array, must be valid\r\n     * @param length  the length within the builder to be processed, must be valid\r\n     * @return true if altered\r\n     */\r\n    public boolean replaceIn(final StrBuilder source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        return substitute(source, offset, length);\r\n    }\r\n\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Internal method that substitutes the variables.\r\n     * <p>\r\n     * Most users of this class do not need to call this method. This method will\r\n     * be called automatically by another (public) method.\r\n     * <p>\r\n     * Writers of subclasses can override this method if they need access to\r\n     * the substitution process at the start or end.\r\n     *\r\n     * @param buf  the string builder to substitute into, not null\r\n     * @param offset  the start offset within the builder, must be valid\r\n     * @param length  the length within the builder to be processed, must be valid\r\n     * @return true if altered\r\n     */\r\n    protected boolean substitute(final StrBuilder buf, final int offset, final int length) {\r\n        return substitute(buf, offset, length, null) > 0;\r\n    }\r\n\r\n    /**\r\n     * Recursive handler for multiple levels of interpolation. This is the main\r\n     * interpolation method, which resolves the values of all variable references\r\n     * contained in the passed in text.\r\n     *\r\n     * @param buf  the string builder to substitute into, not null\r\n     * @param offset  the start offset within the builder, must be valid\r\n     * @param length  the length within the builder to be processed, must be valid\r\n     * @param priorVariables  the stack keeping track of the replaced variables, may be null\r\n     * @return The length change that occurs, unless priorVariables is null when the int\r\n     *  represents a boolean flag as to whether any change occurred.\r\n     */\r\n    private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\r\n        final StrMatcher pfxMatcher = getVariablePrefixMatcher();\r\n        final StrMatcher suffMatcher = getVariableSuffixMatcher();\r\n        final char escape = getEscapeChar();\r\n        final StrMatcher valueDelimMatcher = getValueDelimiterMatcher();\r\n        final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\r\n        final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues();\r\n\r\n        final boolean top = priorVariables == null;\r\n        boolean altered = false;\r\n        int lengthChange = 0;\r\n        char[] chars = buf.buffer;\r\n        int bufEnd = offset + length;\r\n        int pos = offset;\r\n        while (pos < bufEnd) {\r\n            final int startMatchLen = pfxMatcher.isMatch(chars, pos, offset,\r\n                    bufEnd);\r\n            if (startMatchLen == 0) {\r\n                pos++;\r\n            } else {\r\n                // found variable start marker\r\n                if (pos > offset && chars[pos - 1] == escape) {\r\n                    // escaped\r\n                    if (preserveEscapes) {\r\n                        pos++;\r\n                        continue;\r\n                    }\r\n                    buf.deleteCharAt(pos - 1);\r\n                    chars = buf.buffer; // in case buffer was altered\r\n                    lengthChange--;\r\n                    altered = true;\r\n                    bufEnd--;\r\n                } else {\r\n                    // find suffix\r\n                    final int startPos = pos;\r\n                    pos += startMatchLen;\r\n                    int endMatchLen = 0;\r\n                    int nestedVarCount = 0;\r\n                    while (pos < bufEnd) {\r\n                        if (substitutionInVariablesEnabled\r\n                                && pfxMatcher.isMatch(chars,\r\n                                        pos, offset, bufEnd) != 0) {\r\n                            // found a nested variable start\r\n                            endMatchLen = pfxMatcher.isMatch(chars,\r\n                                    pos, offset, bufEnd);\r\n                            nestedVarCount++;\r\n                            pos += endMatchLen;\r\n                            continue;\r\n                        }\r\n\r\n                        endMatchLen = suffMatcher.isMatch(chars, pos, offset,\r\n                                bufEnd);\r\n                        if (endMatchLen == 0) {\r\n                            pos++;\r\n                        } else {\r\n                            // found variable end marker\r\n                            if (nestedVarCount == 0) {\r\n                                String varNameExpr = new String(chars, startPos\r\n                                        + startMatchLen, pos - startPos\r\n                                        - startMatchLen);\r\n                                if (substitutionInVariablesEnabled) {\r\n                                    final StrBuilder bufName = new StrBuilder(varNameExpr);\r\n                                    substitute(bufName, 0, bufName.length());\r\n                                    varNameExpr = bufName.toString();\r\n                                }\r\n                                pos += endMatchLen;\r\n                                final int endPos = pos;\r\n\r\n                                String varName = varNameExpr;\r\n                                String varDefaultValue = null;\r\n\r\n                                if (valueDelimMatcher != null) {\r\n                                    final char[] varNameExprChars = varNameExpr.toCharArray();\r\n                                    int valueDelimiterMatchLen = 0;\r\n                                    for (int i = 0; i < varNameExprChars.length; i++) {\r\n                                        // if there's any nested variable when nested variable substitution disabled,\r\n                                        // then stop resolving name and default value.\r\n                                        if (!substitutionInVariablesEnabled\r\n                                                && pfxMatcher.isMatch(varNameExprChars,\r\n                                                                        i,\r\n                                                                        i,\r\n                                                                        varNameExprChars.length) != 0) {\r\n                                            break;\r\n                                        }\r\n                                        if (valueDelimMatcher.isMatch(varNameExprChars, i) != 0) {\r\n                                            valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i);\r\n                                            varName = varNameExpr.substring(0, i);\r\n                                            varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                // on the first call initialize priorVariables\r\n                                if (priorVariables == null) {\r\n                                    priorVariables = new ArrayList<>();\r\n                                    priorVariables.add(new String(chars,\r\n                                            offset, length));\r\n                                }\r\n\r\n                                // handle cyclic substitution\r\n                                checkCyclicSubstitution(varName, priorVariables);\r\n                                priorVariables.add(varName);\r\n\r\n                                // resolve the variable\r\n                                String varValue = resolveVariable(varName, buf,\r\n                                        startPos, endPos);\r\n                                if (varValue == null) {\r\n                                    varValue = varDefaultValue;\r\n                                }\r\n                                if (varValue != null) {\r\n                                    final int varLen = varValue.length();\r\n                                    buf.replace(startPos, endPos, varValue);\r\n                                    altered = true;\r\n                                    int change = 0;\r\n                                    if (!substitutionInValuesDisabled) { // recursive replace\r\n                                        change = substitute(buf, startPos,\r\n                                            varLen, priorVariables);\r\n                                    }\r\n                                    change = change\r\n                                        + varLen - (endPos - startPos);\r\n                                    pos += change;\r\n                                    bufEnd += change;\r\n                                    lengthChange += change;\r\n                                    chars = buf.buffer; // in case buffer was\r\n                                                        // altered\r\n                                }\r\n\r\n                                // remove variable from the cyclic stack\r\n                                priorVariables\r\n                                        .remove(priorVariables.size() - 1);\r\n                                break;\r\n                            }\r\n                            nestedVarCount--;\r\n                            pos += endMatchLen;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (top) {\r\n            return altered ? 1 : 0;\r\n        }\r\n        return lengthChange;\r\n    }\r\n\r\n    /**\r\n     * Checks if the specified variable is already in the stack (list) of variables.\r\n     *\r\n     * @param varName  the variable name to check\r\n     * @param priorVariables  the list of prior variables\r\n     */\r\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\r\n        if (!priorVariables.contains(varName)) {\r\n            return;\r\n        }\r\n        final StrBuilder buf = new StrBuilder(256);\r\n        buf.append(\"Infinite loop in property interpolation of \");\r\n        buf.append(priorVariables.remove(0));\r\n        buf.append(\": \");\r\n        buf.appendWithSeparators(priorVariables, \"->\");\r\n        throw new IllegalStateException(buf.toString());\r\n    }\r\n\r\n    /**\r\n     * Internal method that resolves the value of a variable.\r\n     * <p>\r\n     * Most users of this class do not need to call this method. This method is\r\n     * called automatically by the substitution process.\r\n     * <p>\r\n     * Writers of subclasses can override this method if they need to alter\r\n     * how each substitution occurs. The method is passed the variable's name\r\n     * and must return the corresponding value. This implementation uses the\r\n     * {@link #getVariableResolver()} with the variable's name as the key.\r\n     *\r\n     * @param variableName  the name of the variable, not null\r\n     * @param buf  the buffer where the substitution is occurring, not null\r\n     * @param startPos  the start position of the variable including the prefix, valid\r\n     * @param endPos  the end position of the variable including the suffix, valid\r\n     * @return The variable's value or <b>null</b> if the variable is unknown\r\n     */\r\n    protected String resolveVariable(final String variableName,\r\n                                     final StrBuilder buf,\r\n                                     final int startPos,\r\n                                     final int endPos) {\r\n        final StrLookup<?> resolver = getVariableResolver();\r\n        if (resolver == null) {\r\n            return null;\r\n        }\r\n        return resolver.lookup(variableName);\r\n    }\r\n\r\n    // Escape\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Returns the escape character.\r\n     *\r\n     * @return The character used for escaping variable references\r\n     */\r\n    public char getEscapeChar() {\r\n        return this.escapeChar;\r\n    }\r\n\r\n    /**\r\n     * Sets the escape character.\r\n     * If this character is placed before a variable reference in the source\r\n     * text, this variable will be ignored.\r\n     *\r\n     * @param escapeCharacter  the escape character (0 for disabling escaping)\r\n     */\r\n    public void setEscapeChar(final char escapeCharacter) {\r\n        this.escapeChar = escapeCharacter;\r\n    }\r\n\r\n    // Prefix\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Gets the variable prefix matcher currently in use.\r\n     * <p>\r\n     * The variable prefix is the character or characters that identify the\r\n     * start of a variable. This prefix is expressed in terms of a matcher\r\n     * allowing advanced prefix matches.\r\n     *\r\n     * @return The prefix matcher in use\r\n     */\r\n    public StrMatcher getVariablePrefixMatcher() {\r\n        return prefixMatcher;\r\n    }\r\n\r\n    /**\r\n     * Sets the variable prefix matcher currently in use.\r\n     * <p>\r\n     * The variable prefix is the character or characters that identify the\r\n     * start of a variable. This prefix is expressed in terms of a matcher\r\n     * allowing advanced prefix matches.\r\n     *\r\n     * @param prefixMatcher  the prefix matcher to use, null ignored\r\n     * @return this, to enable chaining\r\n     * @throws IllegalArgumentException if the prefix matcher is null\r\n     */\r\n    public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher) {\r\n        Validate.isTrue(prefixMatcher != null, \"Variable prefix matcher must not be null!\");\r\n        this.prefixMatcher = prefixMatcher;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the variable prefix to use.\r\n     * <p>\r\n     * The variable prefix is the character or characters that identify the\r\n     * start of a variable. This method allows a single character prefix to\r\n     * be easily set.\r\n     *\r\n     * @param prefix  the prefix character to use\r\n     * @return this, to enable chaining\r\n     */\r\n    public StrSubstitutor setVariablePrefix(final char prefix) {\r\n        return setVariablePrefixMatcher(StrMatcher.charMatcher(prefix));\r\n    }\r\n\r\n    /**\r\n     * Sets the variable prefix to use.\r\n     * <p>\r\n     * The variable prefix is the character or characters that identify the\r\n     * start of a variable. This method allows a string prefix to be easily set.\r\n     *\r\n     * @param prefix  the prefix for variables, not null\r\n     * @return this, to enable chaining\r\n     * @throws IllegalArgumentException if the prefix is null\r\n     */\r\n    public StrSubstitutor setVariablePrefix(final String prefix) {\r\n        Validate.isTrue(prefix != null, \"Variable prefix must not be null!\");\r\n        return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));\r\n    }\r\n\r\n    // Suffix\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Gets the variable suffix matcher currently in use.\r\n     * <p>\r\n     * The variable suffix is the character or characters that identify the\r\n     * end of a variable. This suffix is expressed in terms of a matcher\r\n     * allowing advanced suffix matches.\r\n     *\r\n     * @return The suffix matcher in use\r\n     */\r\n    public StrMatcher getVariableSuffixMatcher() {\r\n        return suffixMatcher;\r\n    }\r\n\r\n    /**\r\n     * Sets the variable suffix matcher currently in use.\r\n     * <p>\r\n     * The variable suffix is the character or characters that identify the\r\n     * end of a variable. This suffix is expressed in terms of a matcher\r\n     * allowing advanced suffix matches.\r\n     *\r\n     * @param suffixMatcher  the suffix matcher to use, null ignored\r\n     * @return this, to enable chaining\r\n     * @throws IllegalArgumentException if the suffix matcher is null\r\n     */\r\n    public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) {\r\n        Validate.isTrue(suffixMatcher != null, \"Variable suffix matcher must not be null!\");\r\n        this.suffixMatcher = suffixMatcher;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the variable suffix to use.\r\n     * <p>\r\n     * The variable suffix is the character or characters that identify the\r\n     * end of a variable. This method allows a single character suffix to\r\n     * be easily set.\r\n     *\r\n     * @param suffix  the suffix character to use\r\n     * @return this, to enable chaining\r\n     */\r\n    public StrSubstitutor setVariableSuffix(final char suffix) {\r\n        return setVariableSuffixMatcher(StrMatcher.charMatcher(suffix));\r\n    }\r\n\r\n    /**\r\n     * Sets the variable suffix to use.\r\n     * <p>\r\n     * The variable suffix is the character or characters that identify the\r\n     * end of a variable. This method allows a string suffix to be easily set.\r\n     *\r\n     * @param suffix  the suffix for variables, not null\r\n     * @return this, to enable chaining\r\n     * @throws IllegalArgumentException if the suffix is null\r\n     */\r\n    public StrSubstitutor setVariableSuffix(final String suffix) {\r\n        Validate.isTrue(suffix != null, \"Variable suffix must not be null!\");\r\n        return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));\r\n    }\r\n\r\n    // Variable Default Value Delimiter\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Gets the variable default value delimiter matcher currently in use.\r\n     * <p>\r\n     * The variable default value delimiter is the character or characters that delimite the\r\n     * variable name and the variable default value. This delimiter is expressed in terms of a matcher\r\n     * allowing advanced variable default value delimiter matches.\r\n     * <p>\r\n     * If it returns null, then the variable default value resolution is disabled.\r\n     *\r\n     * @return The variable default value delimiter matcher in use, may be null\r\n     */\r\n    public StrMatcher getValueDelimiterMatcher() {\r\n        return valueDelimiterMatcher;\r\n    }\r\n\r\n    /**\r\n     * Sets the variable default value delimiter matcher to use.\r\n     * <p>\r\n     * The variable default value delimiter is the character or characters that delimite the\r\n     * variable name and the variable default value. This delimiter is expressed in terms of a matcher\r\n     * allowing advanced variable default value delimiter matches.\r\n     * <p>\r\n     * If the <code>valueDelimiterMatcher</code> is null, then the variable default value resolution\r\n     * becomes disabled.\r\n     *\r\n     * @param valueDelimiterMatcher  variable default value delimiter matcher to use, may be null\r\n     * @return this, to enable chaining\r\n     */\r\n    public StrSubstitutor setValueDelimiterMatcher(final StrMatcher valueDelimiterMatcher) {\r\n        this.valueDelimiterMatcher = valueDelimiterMatcher;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the variable default value delimiter to use.\r\n     * <p>\r\n     * The variable default value delimiter is the character or characters that delimite the\r\n     * variable name and the variable default value. This method allows a single character\r\n     * variable default value delimiter to be easily set.\r\n     *\r\n     * @param valueDelimiter  the variable default value delimiter character to use\r\n     * @return this, to enable chaining\r\n     */\r\n    public StrSubstitutor setValueDelimiter(final char valueDelimiter) {\r\n        return setValueDelimiterMatcher(StrMatcher.charMatcher(valueDelimiter));\r\n    }\r\n\r\n    /**\r\n     * Sets the variable default value delimiter to use.\r\n     * <p>\r\n     * The variable default value delimiter is the character or characters that delimite the\r\n     * variable name and the variable default value. This method allows a string\r\n     * variable default value delimiter to be easily set.\r\n     * <p>\r\n     * If the <code>valueDelimiter</code> is null or empty string, then the variable default\r\n     * value resolution becomes disabled.\r\n     *\r\n     * @param valueDelimiter  the variable default value delimiter string to use, may be null or empty\r\n     * @return this, to enable chaining\r\n     */\r\n    public StrSubstitutor setValueDelimiter(final String valueDelimiter) {\r\n        if (valueDelimiter == null || valueDelimiter.length() == 0) {\r\n            setValueDelimiterMatcher(null);\r\n            return this;\r\n        }\r\n        return setValueDelimiterMatcher(StrMatcher.stringMatcher(valueDelimiter));\r\n    }\r\n\r\n    // Resolver\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Gets the VariableResolver that is used to lookup variables.\r\n     *\r\n     * @return The VariableResolver\r\n     */\r\n    public StrLookup<?> getVariableResolver() {\r\n        return this.variableResolver;\r\n    }\r\n\r\n    /**\r\n     * Sets the VariableResolver that is used to lookup variables.\r\n     *\r\n     * @param variableResolver  the VariableResolver\r\n     */\r\n    public void setVariableResolver(final StrLookup<?> variableResolver) {\r\n        this.variableResolver = variableResolver;\r\n    }\r\n\r\n    // Substitution support in variable names\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * Returns a flag whether substitution is done in variable names.\r\n     *\r\n     * @return The substitution in variable names flag\r\n     */\r\n    public boolean isEnableSubstitutionInVariables() {\r\n        return enableSubstitutionInVariables;\r\n    }\r\n\r\n    /**\r\n     * Sets a flag whether substitution is done in variable names. If set to\r\n     * <b>true</b>, the names of variables can contain other variables which are\r\n     * processed first before the original variable is evaluated, e.g.\r\n     * <code>${jre-${java.version}}</code>. The default value is <b>false</b>.\r\n     *\r\n     * @param enableSubstitutionInVariables the new value of the flag\r\n     */\r\n    public void setEnableSubstitutionInVariables(\r\n            final boolean enableSubstitutionInVariables) {\r\n        this.enableSubstitutionInVariables = enableSubstitutionInVariables;\r\n    }\r\n\r\n    /**\r\n     * Returns a flag whether substitution is disabled in variable values.If set to\r\n     * <b>true</b>, the values of variables can contain other variables will not be\r\n     * processed and substituted original variable is evaluated, e.g.\r\n     * <pre>\r\n     * Map valuesMap = HashMap();\r\n     * valuesMap.put(&quot;name&quot;, &quot;Douglas ${surname}&quot;);\r\n     * valuesMap.put(&quot;surname&quot;, &quot;Crockford&quot;);\r\n     * String templateString = &quot;Hi ${name}&quot;;\r\n     * StrSubstitutor sub = new StrSubstitutor(valuesMap);\r\n     * String resolvedString = sub.replace(templateString);\r\n     * </pre>\r\n     * yielding:\r\n     * <pre>\r\n     *      Hi Douglas ${surname}\r\n     * </pre>\r\n     *\r\n     * @return The substitution in variable values flag\r\n     *\r\n     * @since 1.2\r\n     */\r\n    public boolean isDisableSubstitutionInValues() {\r\n        return disableSubstitutionInValues;\r\n    }\r\n\r\n    /**\r\n     * Sets a flag whether substitution is done in variable values (recursive).\r\n     *\r\n     * @param disableSubstitutionInValues true if substitution in variable value are disabled\r\n     *\r\n     * @since 1.2\r\n     */\r\n    public void setDisableSubstitutionInValues(final boolean disableSubstitutionInValues) {\r\n        this.disableSubstitutionInValues = disableSubstitutionInValues;\r\n    }\r\n\r\n    /**\r\n     * Returns the flag controlling whether escapes are preserved during\r\n     * substitution.\r\n     *\r\n     * @return The preserve escape flag\r\n     */\r\n    public boolean isPreserveEscapes() {\r\n        return preserveEscapes;\r\n    }\r\n\r\n    /**\r\n     * Sets a flag controlling whether escapes are preserved during\r\n     * substitution.  If set to <b>true</b>, the escape character is retained\r\n     * during substitution (e.g. <code>$${this-is-escaped}</code> remains\r\n     * <code>$${this-is-escaped}</code>).  If set to <b>false</b>, the escape\r\n     * character is removed during substitution (e.g.\r\n     * <code>$${this-is-escaped}</code> becomes\r\n     * <code>${this-is-escaped}</code>).  The default value is <b>false</b>\r\n     *\r\n     * @param preserveEscapes true if escapes are to be preserved\r\n     */\r\n    public void setPreserveEscapes(final boolean preserveEscapes) {\r\n        this.preserveEscapes = preserveEscapes;\r\n    }\r\n}\r",
        "diff": " a/src/main/java/org/apache/commons/text/StrSubstitutor.java b/src/main/java/org/apache/commons/text/StrSubstitutor.java\nindex 63f0be1488..e8bf4cd869 100644\n--- a/src/main/java/org/apache/commons/text/StrSubstitutor.java\n+++ b/src/main/java/org/apache/commons/text/StrSubstitutor.java\n@@ -49,7 +49,7 @@\n  * text all variable references (as long as their values are known) will be resolved.\r\n  * The following example demonstrates this:\r\n  * <pre>\r\n- * Map valuesMap = HashMap();\r\n+ * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\r\n  * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\r\n  * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\r\n  * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\r\n@@ -69,7 +69,7 @@\n  * {@link #setValueDelimiter(char)} or {@link #setValueDelimiter(String)}.\r\n  * The following shows an example with variable default value settings:\r\n  * <pre>\r\n- * Map valuesMap = HashMap();\r\n+ * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\r\n  * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\r\n  * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\r\n  * String templateString = &quot;The ${animal} jumped over the ${target}. ${undefined.number:-1234567890}.&quot;;\r\n@@ -1217,7 +1217,7 @@ public void setEnableSubstitutionInVariables(\n      * <b>true</b>, the values of variables can contain other variables will not be\r\n      * processed and substituted original variable is evaluated, e.g.\r\n      * <pre>\r\n-     * Map valuesMap = HashMap();\r\n+     * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\r\n      * valuesMap.put(&quot;name&quot;, &quot;Douglas ${surname}&quot;);\r\n      * valuesMap.put(&quot;surname&quot;, &quot;Crockford&quot;);\r\n      * String templateString = &quot;Hi ${name}&quot;;\r\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/StringSubstitutor.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class StringSubstitutorTest2 {\n\n    private Map<String, String> values;\n\n    @BeforeEach\n    public void setUp() {\n        values = new HashMap<>();\n        values.put(\"animal\", \"quick brown fox\");\n        values.put(\"target\", \"lazy dog\");\n    }\n\n    @Test\n    public void testReplaceWithGenericsInMap() {\n        // Test case to ensure the usage of generics in the map\n        Map<String, String> valuesMap = new HashMap<>();\n        valuesMap.put(\"animal\", \"quick brown fox\");\n        valuesMap.put(\"target\", \"lazy dog\");\n        String templateString = \"The ${animal} jumped over the ${target}.\";\n        StringSubstitutor sub = new StringSubstitutor(valuesMap);\n        assertEquals(\"The quick brown fox jumped over the lazy dog.\", sub.replace(templateString));\n    }\n\n    @Test\n    public void testReplaceWithGenericsInMapWithDefaultValue() {\n        // Test case to ensure the usage of generics in the map with default value\n        Map<String, String> valuesMap = new HashMap<>();\n        valuesMap.put(\"animal\", \"quick brown fox\");\n        valuesMap.put(\"target\", \"lazy dog\");\n        String templateString = \"The ${animal} jumped over the ${target}. ${undefined.number:-1234567890}.\";\n        StringSubstitutor sub = new StringSubstitutor(valuesMap);\n        assertEquals(\"The quick brown fox jumped over the lazy dog. 1234567890.\", sub.replace(templateString));\n    }\n\n    @Test\n    public void testReplaceWithGenericsInMapWithNestedVariables() {\n        // Test case to ensure the usage of generics in the map with nested variables\n        Map<String, String> valuesMap = new HashMap<>();\n        valuesMap.put(\"name\", \"Douglas ${surname}\");\n        valuesMap.put(\"surname\", \"Crockford\");\n        String templateString = \"Hi ${name}\";\n        StringSubstitutor sub = new StringSubstitutor(valuesMap);\n        assertEquals(\"Hi Douglas Crockford\", sub.replace(templateString));\n    }\n}",
        "file_content": "/*\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n * this work for additional information regarding copyright ownership.\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n * (the \"License\"); you may not use this file except in compliance with\r\n * the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage org.apache.commons.text;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Enumeration;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\nimport org.apache.commons.lang3.Validate;\r\nimport org.apache.commons.text.lookup.StringLookup;\r\nimport org.apache.commons.text.lookup.StringLookupFactory;\r\nimport org.apache.commons.text.matcher.StringMatcher;\r\nimport org.apache.commons.text.matcher.StringMatcherFactory;\r\n\r\n/**\r\n * Substitutes variables within a string by values.\r\n * <p>\r\n * This class takes a piece of text and substitutes all the variables within it. The default definition of a variable is\r\n * <code>${variableName}</code>. The prefix and suffix can be changed via constructors and set methods.\r\n * </p>\r\n * <p>\r\n * Variable values are typically resolved from a map, but could also be resolved from system properties, or by supplying\r\n * a custom variable resolver.\r\n * <p>\r\n * The simplest example is to use this class to replace Java System properties. For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * StringSubstitutor\r\n *         .replaceSystemProperties(\"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\r\n * </pre>\r\n *\r\n * <h2>Using a Custom Map</h2>\r\n * <p>\r\n * Typical usage of this class follows the following pattern: First an instance is created and initialized with the map\r\n * that contains the values for the available variables. If a prefix and/or suffix for variables should be used other\r\n * than the default ones, the appropriate settings can be performed. After that the {@code replace()} method can be\r\n * called passing in the source text for interpolation. In the returned text all variable references (as long as their\r\n * values are known) will be resolved. The following example demonstrates this:\r\n * </p>\r\n *\r\n * <pre>\r\n * Map valuesMap = HashMap();\r\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\r\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\r\n * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\r\n * StringSubstitutor sub = new StringSubstitutor(valuesMap);\r\n * String resolvedString = sub.replace(templateString);\r\n * </pre>\r\n *\r\n * <p>\r\n * yielding:\r\n * </p>\r\n *\r\n * <pre>\r\n *      The quick brown fox jumped over the lazy dog.\r\n * </pre>\r\n *\r\n * <h2>Providing Default Values</h2>\r\n * <p>\r\n * This class lets you set a default value for unresolved variables. The default value for a variable can be appended to\r\n * the variable name after the variable default value delimiter. The default value of the variable default value\r\n * delimiter is ':-', as in bash and other *nix shells, as those are arguably where the default ${} delimiter set\r\n * originated. The variable default value delimiter can be manually set by calling\r\n * {@link #setValueDelimiterMatcher(StringMatcher)}, {@link #setValueDelimiter(char)} or\r\n * {@link #setValueDelimiter(String)}. The following shows an example with variable default value settings:\r\n * </p>\r\n *\r\n * <pre>\r\n * Map valuesMap = HashMap();\r\n * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\r\n * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\r\n * String templateString = &quot;The ${animal} jumped over the ${target}. ${undefined.number:-1234567890}.&quot;;\r\n * StringSubstitutor sub = new StringSubstitutor(valuesMap);\r\n * String resolvedString = sub.replace(templateString);\r\n * </pre>\r\n *\r\n * <p>\r\n * yielding:\r\n * </p>\r\n *\r\n * <pre>\r\n *      The quick brown fox jumped over the lazy dog. 1234567890.\r\n * </pre>\r\n *\r\n * <p>\r\n * {@code StringSubstitutor} supports throwing exceptions for unresolved variables, you enable this by setting calling\r\n * {@link #setEnableUndefinedVariableException(boolean)} with {@code true}.\r\n * </p>\r\n *\r\n * <h2>Reusing Instances</h2>\r\n * <p>\r\n * In addition to this usage pattern there are some static convenience methods that cover the most common use cases.\r\n * These methods can be used without the need of manually creating an instance. However if multiple replace operations\r\n * are to be performed, creating and reusing an instance of this class will be more efficient.\r\n * </p>\r\n * <p>\r\n * This class is <b>not</b> thread safe.\r\n * </p>\r\n *\r\n * <h2>Using Interpolation</h2>\r\n * <p>\r\n * The default interpolator let's you use string lookups like:\r\n * </p>\r\n *\r\n * <pre>\r\nfinal StringSubstitutor interpolator = StringSubstitutor.createInterpolator();\r\ninterpolator.setEnableSubstitutionInVariables(true); // Allows for nested $'s.\r\nfinal String text = interpolator.replace(\r\n    \"Base64 Decoder:        ${base64Decoder:SGVsbG9Xb3JsZCE=}\\n\" +\r\n    \"Base64 Encoder:        ${base64Encoder:HelloWorld!}\\n\" +\r\n    \"Java Constant:         ${const:java.awt.event.KeyEvent.VK_ESCAPE}\\n\" +\r\n    \"Date:                  ${date:yyyy-MM-dd}\\n\" +\r\n    \"DNS:                   ${dns:address|apache.org}\\n\" +\r\n    \"Environment Variable:  ${env:USERNAME}\\n\" +\r\n    \"File Content:          ${file:UTF-8:src/test/resources/document.properties}\\n\" +\r\n    \"Java:                  ${java:version}\\n\" +\r\n    \"Localhost:             ${localhost:canonical-name}\\n\" +\r\n    \"Properties File:       ${properties:src/test/resources/document.properties::mykey}\\n\" +\r\n    \"Resource Bundle:       ${resourceBundle:org.example.testResourceBundleLookup:mykey}\\n\" +\r\n    \"Script:                ${script:javascript:3 + 4}\\n\" +\r\n    \"System Property:       ${sys:user.dir}\\n\" +\r\n    \"URL Decoder:           ${urlDecoder:Hello%20World%21}\\n\" +\r\n    \"URL Encoder:           ${urlEncoder:Hello World!}\\n\" +\r\n    \"URL Content (HTTP):    ${url:UTF-8:http://www.apache.org}\\n\" +\r\n    \"URL Content (HTTPS):   ${url:UTF-8:https://www.apache.org}\\n\" +\r\n    \"URL Content (File):    ${url:UTF-8:file:///${sys:user.dir}/src/test/resources/document.properties}\\n\" +\r\n    \"XML XPath:             ${xml:src/test/resources/document.xml:/root/path/to/node}\\n\"\r\n);\r\n * </pre>\r\n * <p>\r\n * For documentation of each lookup, see {@link StringLookupFactory}.\r\n * </p>\r\n *\r\n * <h2>Using Recursive Variable Replacement</h2>\r\n * <p>\r\n * Variable replacement works in a recursive way. Thus, if a variable value contains a variable then that variable will\r\n * also be replaced. Cyclic replacements are detected and will cause an exception to be thrown.\r\n * </p>\r\n * <p>\r\n * Sometimes the interpolation's result must contain a variable prefix. As an example take the following source text:\r\n * </p>\r\n *\r\n * <pre>\r\n *   The variable ${${name}} must be used.\r\n * </pre>\r\n *\r\n * <p>\r\n * Here only the variable's name referred to in the text should be replaced resulting in the text (assuming that the\r\n * value of the {@code name} variable is {@code x}):\r\n * </p>\r\n *\r\n * <pre>\r\n *   The variable ${x} must be used.\r\n * </pre>\r\n *\r\n * <p>\r\n * To achieve this effect there are two possibilities: Either set a different prefix and suffix for variables which do\r\n * not conflict with the result text you want to produce. The other possibility is to use the escape character, by\r\n * default '$'. If this character is placed before a variable reference, this reference is ignored and won't be\r\n * replaced. For example:\r\n * </p>\r\n *\r\n * <pre>\r\n *   The variable $${${name}} must be used.\r\n * </pre>\r\n * <p>\r\n * In some complex scenarios you might even want to perform substitution in the names of variables, for instance\r\n * </p>\r\n *\r\n * <pre>\r\n * ${jre-${java.specification.version}}\r\n * </pre>\r\n *\r\n * <p>\r\n * {@code StringSubstitutor} supports this recursive substitution in variable names, but it has to be enabled explicitly\r\n * by calling {@link #setEnableSubstitutionInVariables(boolean)} with {@code true}.\r\n * </p>\r\n *\r\n * @since 1.3\r\n */\r\npublic class StringSubstitutor {\r\n\r\n    /**\r\n     * The default variable default separator.\r\n     *\r\n     * @since 1.5.\r\n     */\r\n    public static final String DEFAULT_VAR_DEFAULT = \":-\";\r\n\r\n    /**\r\n     * The default variable end separator.\r\n     *\r\n     * @since 1.5.\r\n     */\r\n    public static final String DEFAULT_VAR_END = \"}\";\r\n\r\n    /**\r\n     * The default variable start separator.\r\n     *\r\n     * @since 1.5.\r\n     */\r\n    public static final String DEFAULT_VAR_START = \"${\";\r\n\r\n    /**\r\n     * Constant for the default escape character.\r\n     */\r\n    public static final char DEFAULT_ESCAPE = '$';\r\n\r\n    /**\r\n     * Constant for the default variable prefix.\r\n     */\r\n    public static final StringMatcher DEFAULT_PREFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_START);\r\n\r\n    /**\r\n     * Constant for the default variable suffix.\r\n     */\r\n    public static final StringMatcher DEFAULT_SUFFIX = StringMatcherFactory.INSTANCE.stringMatcher(DEFAULT_VAR_END);\r\n\r\n    /**\r\n     * Constant for the default value delimiter of a variable.\r\n     */\r\n    public static final StringMatcher DEFAULT_VALUE_DELIMITER = StringMatcherFactory.INSTANCE\r\n            .stringMatcher(DEFAULT_VAR_DEFAULT);\r\n\r\n    /**\r\n     * Creates a new instance using the interpolator string lookup\r\n     * {@link StringLookupFactory#interpolatorStringLookup()}.\r\n     * <p>\r\n     * This StringSubstitutor lets you perform substituions like:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * StringSubstitutor.createInterpolator()\r\n     *   .replace(\"OS name: ${sys:os.name}, \" + \"3 + 4 = ${script:javascript:3 + 4}\");\r\n     * </pre>\r\n     *\r\n     * @return a new instance using the interpolator string lookup.\r\n     * @see StringLookupFactory#interpolatorStringLookup()\r\n     * @since 1.8\r\n     */\r\n    public static StringSubstitutor createInterpolator() {\r\n        return new StringSubstitutor(StringLookupFactory.INSTANCE.interpolatorStringLookup());\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables in the given source object with their matching values from the map.\r\n     *\r\n     * @param <V>      the type of the values in the map\r\n     * @param source   the source text containing the variables to substitute, null returns null\r\n     * @param valueMap the map with the values, may be null\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\r\n     */\r\n    public static <V> String replace(final Object source, final Map<String, V> valueMap) {\r\n        return new StringSubstitutor(valueMap).replace(source);\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables in the given source object with their matching values from the map.\r\n     * This method allows to specify a custom variable prefix and suffix\r\n     *\r\n     * @param <V>      the type of the values in the map\r\n     * @param source   the source text containing the variables to substitute, null returns null\r\n     * @param valueMap the map with the values, may be null\r\n     * @param prefix   the prefix of variables, not null\r\n     * @param suffix   the suffix of variables, not null\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\r\n     */\r\n    public static <V> String replace(final Object source, final Map<String, V> valueMap, final String prefix,\r\n            final String suffix) {\r\n        return new StringSubstitutor(valueMap, prefix, suffix).replace(source);\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables in the given source object with their matching values from the\r\n     * properties.\r\n     *\r\n     * @param source          the source text containing the variables to substitute, null returns null\r\n     * @param valueProperties the properties with values, may be null\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\r\n     */\r\n    public static String replace(final Object source, final Properties valueProperties) {\r\n        if (valueProperties == null) {\r\n            return source.toString();\r\n        }\r\n        final Map<String, String> valueMap = new HashMap<>();\r\n        final Enumeration<?> propNames = valueProperties.propertyNames();\r\n        while (propNames.hasMoreElements()) {\r\n            final String propName = (String) propNames.nextElement();\r\n            final String propValue = valueProperties.getProperty(propName);\r\n            valueMap.put(propName, propValue);\r\n        }\r\n        return StringSubstitutor.replace(source, valueMap);\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables in the given source object with their matching values from the system\r\n     * properties.\r\n     *\r\n     * @param source the source text containing the variables to substitute, null returns null\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\r\n     */\r\n    public static String replaceSystemProperties(final Object source) {\r\n        return new StringSubstitutor(StringLookupFactory.INSTANCE.systemPropertyStringLookup()).replace(source);\r\n    }\r\n\r\n    /**\r\n     * Stores the escape character.\r\n     */\r\n    private char escapeChar;\r\n\r\n    /**\r\n     * Stores the variable prefix.\r\n     */\r\n    private StringMatcher prefixMatcher;\r\n\r\n    /**\r\n     * Stores the variable suffix.\r\n     */\r\n    private StringMatcher suffixMatcher;\r\n\r\n    /**\r\n     * Stores the default variable value delimiter.\r\n     */\r\n    private StringMatcher valueDelimiterMatcher;\r\n\r\n    /**\r\n     * Variable resolution is delegated to an implementor of {@link StringLookup}.\r\n     */\r\n    private StringLookup variableResolver;\r\n\r\n    /**\r\n     * The flag whether substitution in variable names is enabled.\r\n     */\r\n    private boolean enableSubstitutionInVariables;\r\n\r\n    /**\r\n     * Whether escapes should be preserved. Default is false;\r\n     */\r\n    private boolean preserveEscapes;\r\n\r\n    /**\r\n     * The flag whether substitution in variable values is disabled.\r\n     */\r\n    private boolean disableSubstitutionInValues;\r\n\r\n    /**\r\n     * The flag whether exception should be thrown on undefined variable.\r\n     */\r\n    private boolean enableUndefinedVariableException;\r\n\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Creates a new instance with defaults for variable prefix and suffix and the escaping character.\r\n     */\r\n    public StringSubstitutor() {\r\n        this((StringLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it. Uses defaults for variable prefix and suffix and the escaping\r\n     * character.\r\n     *\r\n     * @param <V>      the type of the values in the map\r\n     * @param valueMap the map with the variables' values, may be null\r\n     */\r\n    public <V> StringSubstitutor(final Map<String, V> valueMap) {\r\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it. Uses a default escaping character.\r\n     *\r\n     * @param <V>      the type of the values in the map\r\n     * @param valueMap the map with the variables' values, may be null\r\n     * @param prefix   the prefix for variables, not null\r\n     * @param suffix   the suffix for variables, not null\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix) {\r\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param <V>      the type of the values in the map\r\n     * @param valueMap the map with the variables' values, may be null\r\n     * @param prefix   the prefix for variables, not null\r\n     * @param suffix   the suffix for variables, not null\r\n     * @param escape   the escape character\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\r\n            final char escape) {\r\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param <V>            the type of the values in the map\r\n     * @param valueMap       the map with the variables' values, may be null\r\n     * @param prefix         the prefix for variables, not null\r\n     * @param suffix         the suffix for variables, not null\r\n     * @param escape         the escape character\r\n     * @param valueDelimiter the variable default value delimiter, may be null\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public <V> StringSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix,\r\n            final char escape, final String valueDelimiter) {\r\n        this(StringLookupFactory.INSTANCE.mapStringLookup(valueMap), prefix, suffix, escape, valueDelimiter);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param variableResolver the variable resolver, may be null\r\n     */\r\n    public StringSubstitutor(final StringLookup variableResolver) {\r\n        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param variableResolver the variable resolver, may be null\r\n     * @param prefix           the prefix for variables, not null\r\n     * @param suffix           the suffix for variables, not null\r\n     * @param escape           the escape character\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,\r\n            final char escape) {\r\n        this.setVariableResolver(variableResolver);\r\n        this.setVariablePrefix(prefix);\r\n        this.setVariableSuffix(suffix);\r\n        this.setEscapeChar(escape);\r\n        this.setValueDelimiterMatcher(DEFAULT_VALUE_DELIMITER);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param variableResolver the variable resolver, may be null\r\n     * @param prefix           the prefix for variables, not null\r\n     * @param suffix           the suffix for variables, not null\r\n     * @param escape           the escape character\r\n     * @param valueDelimiter   the variable default value delimiter string, may be null\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public StringSubstitutor(final StringLookup variableResolver, final String prefix, final String suffix,\r\n            final char escape, final String valueDelimiter) {\r\n        this.setVariableResolver(variableResolver);\r\n        this.setVariablePrefix(prefix);\r\n        this.setVariableSuffix(suffix);\r\n        this.setEscapeChar(escape);\r\n        this.setValueDelimiter(valueDelimiter);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param variableResolver the variable resolver, may be null\r\n     * @param prefixMatcher    the prefix for variables, not null\r\n     * @param suffixMatcher    the suffix for variables, not null\r\n     * @param escape           the escape character\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,\r\n            final StringMatcher suffixMatcher, final char escape) {\r\n        this(variableResolver, prefixMatcher, suffixMatcher, escape, DEFAULT_VALUE_DELIMITER);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance and initializes it.\r\n     *\r\n     * @param variableResolver      the variable resolver, may be null\r\n     * @param prefixMatcher         the prefix for variables, not null\r\n     * @param suffixMatcher         the suffix for variables, not null\r\n     * @param escape                the escape character\r\n     * @param valueDelimiterMatcher the variable default value delimiter matcher, may be null\r\n     * @throws IllegalArgumentException if the prefix or suffix is null\r\n     */\r\n    public StringSubstitutor(final StringLookup variableResolver, final StringMatcher prefixMatcher,\r\n            final StringMatcher suffixMatcher, final char escape, final StringMatcher valueDelimiterMatcher) {\r\n        this.setVariableResolver(variableResolver);\r\n        this.setVariablePrefixMatcher(prefixMatcher);\r\n        this.setVariableSuffixMatcher(suffixMatcher);\r\n        this.setEscapeChar(escape);\r\n        this.setValueDelimiterMatcher(valueDelimiterMatcher);\r\n    }\r\n\r\n    /**\r\n     * Checks if the specified variable is already in the stack (list) of variables.\r\n     *\r\n     * @param varName        the variable name to check\r\n     * @param priorVariables the list of prior variables\r\n     */\r\n    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\r\n        if (!priorVariables.contains(varName)) {\r\n            return;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(256);\r\n        buf.append(\"Infinite loop in property interpolation of \");\r\n        buf.append(priorVariables.remove(0));\r\n        buf.append(\": \");\r\n        buf.appendWithSeparators(priorVariables, \"->\");\r\n        throw new IllegalStateException(buf.toString());\r\n    }\r\n\r\n    // Escape\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Returns the escape character.\r\n     *\r\n     * @return The character used for escaping variable references\r\n     */\r\n    public char getEscapeChar() {\r\n        return this.escapeChar;\r\n    }\r\n\r\n    // Resolver\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Gets the StringLookup that is used to lookup variables.\r\n     *\r\n     * @return The StringLookup\r\n     */\r\n    public StringLookup getStringLookup() {\r\n        return this.variableResolver;\r\n    }\r\n\r\n    // Variable Default Value Delimiter\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Gets the variable default value delimiter matcher currently in use.\r\n     * <p>\r\n     * The variable default value delimiter is the character or characters that delimite the variable name and the\r\n     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\r\n     * value delimiter matches.\r\n     * <p>\r\n     * If it returns null, then the variable default value resolution is disabled.\r\n     *\r\n     * @return The variable default value delimiter matcher in use, may be null\r\n     */\r\n    public StringMatcher getValueDelimiterMatcher() {\r\n        return valueDelimiterMatcher;\r\n    }\r\n\r\n    // Prefix\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Gets the variable prefix matcher currently in use.\r\n     * <p>\r\n     * The variable prefix is the character or characters that identify the start of a variable. This prefix is\r\n     * expressed in terms of a matcher allowing advanced prefix matches.\r\n     *\r\n     * @return The prefix matcher in use\r\n     */\r\n    public StringMatcher getVariablePrefixMatcher() {\r\n        return prefixMatcher;\r\n    }\r\n\r\n    // Suffix\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Gets the variable suffix matcher currently in use.\r\n     * <p>\r\n     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed\r\n     * in terms of a matcher allowing advanced suffix matches.\r\n     *\r\n     * @return The suffix matcher in use\r\n     */\r\n    public StringMatcher getVariableSuffixMatcher() {\r\n        return suffixMatcher;\r\n    }\r\n\r\n    /**\r\n     * Returns a flag whether substitution is disabled in variable values.If set to <b>true</b>, the values of variables\r\n     * can contain other variables will not be processed and substituted original variable is evaluated, e.g.\r\n     *\r\n     * <pre>\r\n     * Map valuesMap = HashMap();\r\n     * valuesMap.put(&quot;name&quot;, &quot;Douglas ${surname}&quot;);\r\n     * valuesMap.put(&quot;surname&quot;, &quot;Crockford&quot;);\r\n     * String templateString = &quot;Hi ${name}&quot;;\r\n     * StrSubstitutor sub = new StrSubstitutor(valuesMap);\r\n     * String resolvedString = sub.replace(templateString);\r\n     * </pre>\r\n     *\r\n     * yielding:\r\n     *\r\n     * <pre>\r\n     *      Hi Douglas ${surname}\r\n     * </pre>\r\n     *\r\n     * @return The substitution in variable values flag\r\n     */\r\n    public boolean isDisableSubstitutionInValues() {\r\n        return disableSubstitutionInValues;\r\n    }\r\n\r\n    // Substitution support in variable names\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Returns a flag whether substitution is done in variable names.\r\n     *\r\n     * @return The substitution in variable names flag\r\n     */\r\n    public boolean isEnableSubstitutionInVariables() {\r\n        return enableSubstitutionInVariables;\r\n    }\r\n\r\n    /**\r\n     * Returns a flag whether exception can be thrown upon undefined variable.\r\n     *\r\n     * @return The fail on undefined variable flag\r\n     */\r\n    public boolean isEnableUndefinedVariableException() {\r\n        return enableUndefinedVariableException;\r\n    }\r\n\r\n    /**\r\n     * Returns the flag controlling whether escapes are preserved during substitution.\r\n     *\r\n     * @return The preserve escape flag\r\n     */\r\n    public boolean isPreserveEscapes() {\r\n        return preserveEscapes;\r\n    }\r\n\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\r\n     * array as a template. The array is not altered by this method.\r\n     *\r\n     * @param source the character array to replace in, not altered, null returns null\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public String replace(final char[] source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(source.length).append(source);\r\n        substitute(buf, 0, source.length);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\r\n     * array as a template. The array is not altered by this method.\r\n     * <p>\r\n     * Only the specified portion of the array will be processed. The rest of the array is not processed, and is not\r\n     * returned.\r\n     *\r\n     * @param source the character array to replace in, not altered, null returns null\r\n     * @param offset the start offset within the array, must be valid\r\n     * @param length the length within the array to be processed, must be valid\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public String replace(final char[] source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\r\n        substitute(buf, 0, length);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as\r\n     * a template. The source is not altered by this method.\r\n     *\r\n     * @param source the buffer to use as a template, not changed, null returns null\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public String replace(final CharSequence source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        return replace(source, 0, source.length());\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source as\r\n     * a template. The source is not altered by this method.\r\n     * <p>\r\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not\r\n     * returned.\r\n     *\r\n     * @param source the buffer to use as a template, not changed, null returns null\r\n     * @param offset the start offset within the array, must be valid\r\n     * @param length the length within the array to be processed, must be valid\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public String replace(final CharSequence source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source.toString(), offset, length);\r\n        substitute(buf, 0, length);\r\n        return buf.toString();\r\n    }\r\n\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables in the given source object with their matching values from the\r\n     * resolver. The input source object is converted to a string using <code>toString</code> and is not altered.\r\n     *\r\n     * @param source the source to replace in, null returns null\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if a variable is not found and enableUndefinedVariableException is true\r\n     */\r\n    public String replace(final Object source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder().append(source);\r\n        substitute(buf, 0, buf.length());\r\n        return buf.toString();\r\n    }\r\n\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\r\n     * string as a template.\r\n     *\r\n     * @param source the string to replace in, null returns null\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public String replace(final String source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(source);\r\n        if (!substitute(buf, 0, source.length())) {\r\n            return source;\r\n        }\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\r\n     * string as a template.\r\n     * <p>\r\n     * Only the specified portion of the string will be processed. The rest of the string is not processed, and is not\r\n     * returned.\r\n     *\r\n     * @param source the string to replace in, null returns null\r\n     * @param offset the start offset within the array, must be valid\r\n     * @param length the length within the array to be processed, must be valid\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public String replace(final String source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\r\n        if (!substitute(buf, 0, length)) {\r\n            return source.substring(offset, offset + length);\r\n        }\r\n        return buf.toString();\r\n    }\r\n\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\r\n     * buffer as a template. The buffer is not altered by this method.\r\n     *\r\n     * @param source the buffer to use as a template, not changed, null returns null\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public String replace(final StringBuffer source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(source.length()).append(source);\r\n        substitute(buf, 0, buf.length());\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\r\n     * buffer as a template. The buffer is not altered by this method.\r\n     * <p>\r\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not\r\n     * returned.\r\n     *\r\n     * @param source the buffer to use as a template, not changed, null returns null\r\n     * @param offset the start offset within the array, must be valid\r\n     * @param length the length within the array to be processed, must be valid\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public String replace(final StringBuffer source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\r\n        substitute(buf, 0, length);\r\n        return buf.toString();\r\n    }\r\n\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\r\n     * builder as a template. The builder is not altered by this method.\r\n     *\r\n     * @param source the builder to use as a template, not changed, null returns null\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public String replace(final TextStringBuilder source) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(source.length()).append(source);\r\n        substitute(buf, 0, buf.length());\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables with their matching values from the resolver using the given source\r\n     * builder as a template. The builder is not altered by this method.\r\n     * <p>\r\n     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, and is not\r\n     * returned.\r\n     *\r\n     * @param source the builder to use as a template, not changed, null returns null\r\n     * @param offset the start offset within the array, must be valid\r\n     * @param length the length within the array to be processed, must be valid\r\n     * @return The result of the replace operation\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public String replace(final TextStringBuilder source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\r\n        substitute(buf, 0, length);\r\n        return buf.toString();\r\n    }\r\n\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\r\n     * resolver. The buffer is updated with the result.\r\n     *\r\n     * @param source the buffer to replace in, updated, null returns zero\r\n     * @return true if altered\r\n     */\r\n    public boolean replaceIn(final StringBuffer source) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        return replaceIn(source, 0, source.length());\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\r\n     * resolver. The buffer is updated with the result.\r\n     * <p>\r\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is\r\n     * not deleted.\r\n     *\r\n     * @param source the buffer to replace in, updated, null returns zero\r\n     * @param offset the start offset within the array, must be valid\r\n     * @param length the length within the buffer to be processed, must be valid\r\n     * @return true if altered\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public boolean replaceIn(final StringBuffer source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\r\n        if (!substitute(buf, 0, length)) {\r\n            return false;\r\n        }\r\n        source.replace(offset, offset + length, buf.toString());\r\n        return true;\r\n    }\r\n\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source buffer with their matching values from the\r\n     * resolver. The buffer is updated with the result.\r\n     *\r\n     * @param source the buffer to replace in, updated, null returns zero\r\n     * @return true if altered\r\n     */\r\n    public boolean replaceIn(final StringBuilder source) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        return replaceIn(source, 0, source.length());\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\r\n     * resolver. The builder is updated with the result.\r\n     * <p>\r\n     * Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, but it is\r\n     * not deleted.\r\n     *\r\n     * @param source the buffer to replace in, updated, null returns zero\r\n     * @param offset the start offset within the array, must be valid\r\n     * @param length the length within the buffer to be processed, must be valid\r\n     * @return true if altered\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public boolean replaceIn(final StringBuilder source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        final TextStringBuilder buf = new TextStringBuilder(length).append(source, offset, length);\r\n        if (!substitute(buf, 0, length)) {\r\n            return false;\r\n        }\r\n        source.replace(offset, offset + length, buf.toString());\r\n        return true;\r\n    }\r\n\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\r\n     * resolver.\r\n     *\r\n     * @param source the builder to replace in, updated, null returns zero\r\n     * @return true if altered\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public boolean replaceIn(final TextStringBuilder source) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        return substitute(source, 0, source.length());\r\n    }\r\n\r\n    /**\r\n     * Replaces all the occurrences of variables within the given source builder with their matching values from the\r\n     * resolver.\r\n     * <p>\r\n     * Only the specified portion of the builder will be processed. The rest of the builder is not processed, but it is\r\n     * not deleted.\r\n     *\r\n     * @param source the builder to replace in, null returns zero\r\n     * @param offset the start offset within the array, must be valid\r\n     * @param length the length within the builder to be processed, must be valid\r\n     * @return true if altered\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    public boolean replaceIn(final TextStringBuilder source, final int offset, final int length) {\r\n        if (source == null) {\r\n            return false;\r\n        }\r\n        return substitute(source, offset, length);\r\n    }\r\n\r\n    /**\r\n     * Internal method that resolves the value of a variable.\r\n     * <p>\r\n     * Most users of this class do not need to call this method. This method is called automatically by the substitution\r\n     * process.\r\n     * <p>\r\n     * Writers of subclasses can override this method if they need to alter how each substitution occurs. The method is\r\n     * passed the variable's name and must return the corresponding value. This implementation uses the\r\n     * {@link #getStringLookup()} with the variable's name as the key.\r\n     *\r\n     * @param variableName the name of the variable, not null\r\n     * @param buf          the buffer where the substitution is occurring, not null\r\n     * @param startPos     the start position of the variable including the prefix, valid\r\n     * @param endPos       the end position of the variable including the suffix, valid\r\n     * @return The variable's value or <b>null</b> if the variable is unknown\r\n     */\r\n    protected String resolveVariable(final String variableName, final TextStringBuilder buf, final int startPos,\r\n            final int endPos) {\r\n        final StringLookup resolver = getStringLookup();\r\n        if (resolver == null) {\r\n            return null;\r\n        }\r\n        return resolver.lookup(variableName);\r\n    }\r\n\r\n    /**\r\n     * Sets a flag whether substitution is done in variable values (recursive).\r\n     *\r\n     * @param disableSubstitutionInValues true if substitution in variable value are disabled\r\n     * @return this, to enable chaining\r\n     */\r\n    public StringSubstitutor setDisableSubstitutionInValues(final boolean disableSubstitutionInValues) {\r\n        this.disableSubstitutionInValues = disableSubstitutionInValues;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a flag whether substitution is done in variable names. If set to <b>true</b>, the names of variables can\r\n     * contain other variables which are processed first before the original variable is evaluated, e.g.\r\n     * <code>${jre-${java.version}}</code>. The default value is <b>false</b>.\r\n     *\r\n     * @param enableSubstitutionInVariables the new value of the flag\r\n     * @return this, to enable chaining\r\n     */\r\n    public StringSubstitutor setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {\r\n        this.enableSubstitutionInVariables = enableSubstitutionInVariables;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a flag whether exception should be thrown if any variable is undefined.\r\n     *\r\n     * @param failOnUndefinedVariable true if exception should be thrown on undefined variable\r\n     * @return this, to enable chaining\r\n     */\r\n    public StringSubstitutor setEnableUndefinedVariableException(final boolean failOnUndefinedVariable) {\r\n        this.enableUndefinedVariableException = failOnUndefinedVariable;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the escape character. If this character is placed before a variable reference in the source text, this\r\n     * variable will be ignored.\r\n     *\r\n     * @param escapeCharacter the escape character (0 for disabling escaping)\r\n     * @return this, to enable chaining\r\n     */\r\n    public StringSubstitutor setEscapeChar(final char escapeCharacter) {\r\n        this.escapeChar = escapeCharacter;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a flag controlling whether escapes are preserved during substitution. If set to <b>true</b>, the escape\r\n     * character is retained during substitution (e.g. <code>$${this-is-escaped}</code> remains\r\n     * <code>$${this-is-escaped}</code>). If set to <b>false</b>, the escape character is removed during substitution\r\n     * (e.g. <code>$${this-is-escaped}</code> becomes <code>${this-is-escaped}</code>). The default value is\r\n     * <b>false</b>\r\n     *\r\n     * @param preserveEscapes true if escapes are to be preserved\r\n     * @return this, to enable chaining\r\n     */\r\n    public StringSubstitutor setPreserveEscapes(final boolean preserveEscapes) {\r\n        this.preserveEscapes = preserveEscapes;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the variable default value delimiter to use.\r\n     * <p>\r\n     * The variable default value delimiter is the character or characters that delimite the variable name and the\r\n     * variable default value. This method allows a single character variable default value delimiter to be easily set.\r\n     *\r\n     * @param valueDelimiter the variable default value delimiter character to use\r\n     * @return this, to enable chaining\r\n     */\r\n    public StringSubstitutor setValueDelimiter(final char valueDelimiter) {\r\n        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.charMatcher(valueDelimiter));\r\n    }\r\n\r\n    /**\r\n     * Sets the variable default value delimiter to use.\r\n     * <p>\r\n     * The variable default value delimiter is the character or characters that delimite the variable name and the\r\n     * variable default value. This method allows a string variable default value delimiter to be easily set.\r\n     * <p>\r\n     * If the <code>valueDelimiter</code> is null or empty string, then the variable default value resolution becomes\r\n     * disabled.\r\n     *\r\n     * @param valueDelimiter the variable default value delimiter string to use, may be null or empty\r\n     * @return this, to enable chaining\r\n     */\r\n    public StringSubstitutor setValueDelimiter(final String valueDelimiter) {\r\n        if (valueDelimiter == null || valueDelimiter.length() == 0) {\r\n            setValueDelimiterMatcher(null);\r\n            return this;\r\n        }\r\n        return setValueDelimiterMatcher(StringMatcherFactory.INSTANCE.stringMatcher(valueDelimiter));\r\n    }\r\n\r\n    /**\r\n     * Sets the variable default value delimiter matcher to use.\r\n     * <p>\r\n     * The variable default value delimiter is the character or characters that delimite the variable name and the\r\n     * variable default value. This delimiter is expressed in terms of a matcher allowing advanced variable default\r\n     * value delimiter matches.\r\n     * <p>\r\n     * If the <code>valueDelimiterMatcher</code> is null, then the variable default value resolution becomes disabled.\r\n     *\r\n     * @param valueDelimiterMatcher variable default value delimiter matcher to use, may be null\r\n     * @return this, to enable chaining\r\n     */\r\n    public StringSubstitutor setValueDelimiterMatcher(final StringMatcher valueDelimiterMatcher) {\r\n        this.valueDelimiterMatcher = valueDelimiterMatcher;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the variable prefix to use.\r\n     * <p>\r\n     * The variable prefix is the character or characters that identify the start of a variable. This method allows a\r\n     * single character prefix to be easily set.\r\n     *\r\n     * @param prefix the prefix character to use\r\n     * @return this, to enable chaining\r\n     */\r\n    public StringSubstitutor setVariablePrefix(final char prefix) {\r\n        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.charMatcher(prefix));\r\n    }\r\n\r\n    /**\r\n     * Sets the variable prefix to use.\r\n     * <p>\r\n     * The variable prefix is the character or characters that identify the start of a variable. This method allows a\r\n     * string prefix to be easily set.\r\n     *\r\n     * @param prefix the prefix for variables, not null\r\n     * @return this, to enable chaining\r\n     * @throws IllegalArgumentException if the prefix is null\r\n     */\r\n    public StringSubstitutor setVariablePrefix(final String prefix) {\r\n        Validate.isTrue(prefix != null, \"Variable prefix must not be null!\");\r\n        return setVariablePrefixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(prefix));\r\n    }\r\n\r\n    /**\r\n     * Sets the variable prefix matcher currently in use.\r\n     * <p>\r\n     * The variable prefix is the character or characters that identify the start of a variable. This prefix is\r\n     * expressed in terms of a matcher allowing advanced prefix matches.\r\n     *\r\n     * @param prefixMatcher the prefix matcher to use, null ignored\r\n     * @return this, to enable chaining\r\n     * @throws IllegalArgumentException if the prefix matcher is null\r\n     */\r\n    public StringSubstitutor setVariablePrefixMatcher(final StringMatcher prefixMatcher) {\r\n        Validate.isTrue(prefixMatcher != null, \"Variable prefix matcher must not be null!\");\r\n        this.prefixMatcher = prefixMatcher;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the VariableResolver that is used to lookup variables.\r\n     *\r\n     * @param variableResolver the VariableResolver\r\n     * @return this, to enable chaining\r\n     */\r\n    public StringSubstitutor setVariableResolver(final StringLookup variableResolver) {\r\n        this.variableResolver = variableResolver;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the variable suffix to use.\r\n     * <p>\r\n     * The variable suffix is the character or characters that identify the end of a variable. This method allows a\r\n     * single character suffix to be easily set.\r\n     *\r\n     * @param suffix the suffix character to use\r\n     * @return this, to enable chaining\r\n     */\r\n    public StringSubstitutor setVariableSuffix(final char suffix) {\r\n        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.charMatcher(suffix));\r\n    }\r\n\r\n    /**\r\n     * Sets the variable suffix to use.\r\n     * <p>\r\n     * The variable suffix is the character or characters that identify the end of a variable. This method allows a\r\n     * string suffix to be easily set.\r\n     *\r\n     * @param suffix the suffix for variables, not null\r\n     * @return this, to enable chaining\r\n     * @throws IllegalArgumentException if the suffix is null\r\n     */\r\n    public StringSubstitutor setVariableSuffix(final String suffix) {\r\n        Validate.isTrue(suffix != null, \"Variable suffix must not be null!\");\r\n        return setVariableSuffixMatcher(StringMatcherFactory.INSTANCE.stringMatcher(suffix));\r\n    }\r\n\r\n    /**\r\n     * Sets the variable suffix matcher currently in use.\r\n     * <p>\r\n     * The variable suffix is the character or characters that identify the end of a variable. This suffix is expressed\r\n     * in terms of a matcher allowing advanced suffix matches.\r\n     *\r\n     * @param suffixMatcher the suffix matcher to use, null ignored\r\n     * @return this, to enable chaining\r\n     * @throws IllegalArgumentException if the suffix matcher is null\r\n     */\r\n    public StringSubstitutor setVariableSuffixMatcher(final StringMatcher suffixMatcher) {\r\n        Validate.isTrue(suffixMatcher != null, \"Variable suffix matcher must not be null!\");\r\n        this.suffixMatcher = suffixMatcher;\r\n        return this;\r\n    }\r\n\r\n    // -----------------------------------------------------------------------\r\n    /**\r\n     * Internal method that substitutes the variables.\r\n     * <p>\r\n     * Most users of this class do not need to call this method. This method will be called automatically by another\r\n     * (public) method.\r\n     * <p>\r\n     * Writers of subclasses can override this method if they need access to the substitution process at the start or\r\n     * end.\r\n     *\r\n     * @param buf    the string builder to substitute into, not null\r\n     * @param offset the start offset within the builder, must be valid\r\n     * @param length the length within the builder to be processed, must be valid\r\n     * @return true if altered\r\n     */\r\n    protected boolean substitute(final TextStringBuilder buf, final int offset, final int length) {\r\n        return substitute(buf, offset, length, null) > 0;\r\n    }\r\n\r\n    /**\r\n     * Recursive handler for multiple levels of interpolation. This is the main interpolation method, which resolves the\r\n     * values of all variable references contained in the passed in text.\r\n     *\r\n     * @param buf            the string builder to substitute into, not null\r\n     * @param offset         the start offset within the builder, must be valid\r\n     * @param length         the length within the builder to be processed, must be valid\r\n     * @param priorVariables the stack keeping track of the replaced variables, may be null\r\n     * @return The length change that occurs, unless priorVariables is null when the int represents a boolean flag as to\r\n     *         whether any change occurred.\r\n     * @throws IllegalArgumentException if variable is not found when its allowed to throw exception\r\n     */\r\n    private int substitute(final TextStringBuilder buf, final int offset, final int length,\r\n            List<String> priorVariables) {\r\n        final StringMatcher pfxMatcher = getVariablePrefixMatcher();\r\n        final StringMatcher suffMatcher = getVariableSuffixMatcher();\r\n        final char escape = getEscapeChar();\r\n        final StringMatcher valueDelimMatcher = getValueDelimiterMatcher();\r\n        final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\r\n        final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues();\r\n        final boolean undefinedVariableException = isEnableUndefinedVariableException();\r\n\r\n        final boolean top = priorVariables == null;\r\n        boolean altered = false;\r\n        int lengthChange = 0;\r\n        char[] chars = buf.buffer;\r\n        int bufEnd = offset + length;\r\n        int pos = offset;\r\n        while (pos < bufEnd) {\r\n            final int startMatchLen = pfxMatcher.isMatch(chars, pos, offset, bufEnd);\r\n            if (startMatchLen == 0) {\r\n                pos++;\r\n            } else {\r\n                // found variable start marker\r\n                if (pos > offset && chars[pos - 1] == escape) {\r\n                    // escaped\r\n                    if (preserveEscapes) {\r\n                        pos++;\r\n                        continue;\r\n                    }\r\n                    buf.deleteCharAt(pos - 1);\r\n                    chars = buf.buffer; // in case buffer was altered\r\n                    lengthChange--;\r\n                    altered = true;\r\n                    bufEnd--;\r\n                } else {\r\n                    // find suffix\r\n                    final int startPos = pos;\r\n                    pos += startMatchLen;\r\n                    int endMatchLen = 0;\r\n                    int nestedVarCount = 0;\r\n                    while (pos < bufEnd) {\r\n                        if (substitutionInVariablesEnabled && pfxMatcher.isMatch(chars, pos, offset, bufEnd) != 0) {\r\n                            // found a nested variable start\r\n                            endMatchLen = pfxMatcher.isMatch(chars, pos, offset, bufEnd);\r\n                            nestedVarCount++;\r\n                            pos += endMatchLen;\r\n                            continue;\r\n                        }\r\n\r\n                        endMatchLen = suffMatcher.isMatch(chars, pos, offset, bufEnd);\r\n                        if (endMatchLen == 0) {\r\n                            pos++;\r\n                        } else {\r\n                            // found variable end marker\r\n                            if (nestedVarCount == 0) {\r\n                                String varNameExpr = new String(chars, startPos + startMatchLen,\r\n                                        pos - startPos - startMatchLen);\r\n                                if (substitutionInVariablesEnabled) {\r\n                                    final TextStringBuilder bufName = new TextStringBuilder(varNameExpr);\r\n                                    substitute(bufName, 0, bufName.length());\r\n                                    varNameExpr = bufName.toString();\r\n                                }\r\n                                pos += endMatchLen;\r\n                                final int endPos = pos;\r\n\r\n                                String varName = varNameExpr;\r\n                                String varDefaultValue = null;\r\n\r\n                                if (valueDelimMatcher != null) {\r\n                                    final char[] varNameExprChars = varNameExpr.toCharArray();\r\n                                    int valueDelimiterMatchLen = 0;\r\n                                    for (int i = 0; i < varNameExprChars.length; i++) {\r\n                                        // if there's any nested variable when nested variable substitution disabled,\r\n                                        // then stop resolving name and default value.\r\n                                        if (!substitutionInVariablesEnabled && pfxMatcher.isMatch(varNameExprChars, i,\r\n                                                i, varNameExprChars.length) != 0) {\r\n                                            break;\r\n                                        }\r\n                                        if (valueDelimMatcher.isMatch(varNameExprChars, i, 0,\r\n                                                varNameExprChars.length) != 0) {\r\n                                            valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i, 0,\r\n                                                    varNameExprChars.length);\r\n                                            varName = varNameExpr.substring(0, i);\r\n                                            varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                // on the first call initialize priorVariables\r\n                                if (priorVariables == null) {\r\n                                    priorVariables = new ArrayList<>();\r\n                                    priorVariables.add(new String(chars, offset, length));\r\n                                }\r\n\r\n                                // handle cyclic substitution\r\n                                checkCyclicSubstitution(varName, priorVariables);\r\n                                priorVariables.add(varName);\r\n\r\n                                // resolve the variable\r\n                                String varValue = resolveVariable(varName, buf, startPos, endPos);\r\n                                if (varValue == null) {\r\n                                    varValue = varDefaultValue;\r\n                                }\r\n                                if (varValue != null) {\r\n                                    final int varLen = varValue.length();\r\n                                    buf.replace(startPos, endPos, varValue);\r\n                                    altered = true;\r\n                                    int change = 0;\r\n                                    if (!substitutionInValuesDisabled) { // recursive replace\r\n                                        change = substitute(buf, startPos, varLen, priorVariables);\r\n                                    }\r\n                                    change = change + varLen - (endPos - startPos);\r\n                                    pos += change;\r\n                                    bufEnd += change;\r\n                                    lengthChange += change;\r\n                                    chars = buf.buffer; // in case buffer was altered\r\n                                } else if (undefinedVariableException) {\r\n                                    throw new IllegalArgumentException(String.format(\r\n                                            \"Cannot resolve variable '%s' (enableSubstitutionInVariables=%s).\", varName,\r\n                                            enableSubstitutionInVariables));\r\n                                }\r\n\r\n                                // remove variable from the cyclic stack\r\n                                priorVariables.remove(priorVariables.size() - 1);\r\n                                break;\r\n                            }\r\n                            nestedVarCount--;\r\n                            pos += endMatchLen;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (top) {\r\n            return altered ? 1 : 0;\r\n        }\r\n        return lengthChange;\r\n    }\r\n}\r",
        "diff": " a/src/main/java/org/apache/commons/text/StringSubstitutor.java b/src/main/java/org/apache/commons/text/StringSubstitutor.java\nindex d20c950ca2..e1f3ee978a 100644\n--- a/src/main/java/org/apache/commons/text/StringSubstitutor.java\n+++ b/src/main/java/org/apache/commons/text/StringSubstitutor.java\n@@ -57,7 +57,7 @@\n  * </p>\r\n  *\r\n  * <pre>\r\n- * Map valuesMap = HashMap();\r\n+ * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\r\n  * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\r\n  * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\r\n  * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\r\n@@ -84,7 +84,7 @@\n  * </p>\r\n  *\r\n  * <pre>\r\n- * Map valuesMap = HashMap();\r\n+ * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\r\n  * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\r\n  * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\r\n  * String templateString = &quot;The ${animal} jumped over the ${target}. ${undefined.number:-1234567890}.&quot;;\r\n@@ -603,7 +603,7 @@ public StringMatcher getVariableSuffixMatcher() {\n      * can contain other variables will not be processed and substituted original variable is evaluated, e.g.\r\n      *\r\n      * <pre>\r\n-     * Map valuesMap = HashMap();\r\n+     * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\r\n      * valuesMap.put(&quot;name&quot;, &quot;Douglas ${surname}&quot;);\r\n      * valuesMap.put(&quot;surname&quot;, &quot;Crockford&quot;);\r\n      * String templateString = &quot;Hi ${name}&quot;;\r\n"
      }
    ]
  },
  {
    "pr_number": 121,
    "title": "[TEXT-166] removed non-existing parameter from Javadocs and spelled out parameters in throws",
    "state": "closed",
    "created_at": "2019-09-22T17:42:57Z",
    "merge_commit_sha": "415bc31bba576dd26d5f21f4cc07389a46846a37",
    "base_sha": "987903895be2084661d07124ab67daa91b816f4e",
    "head_sha": "415bc31bba576dd26d5f21f4cc07389a46846a37",
    "user_login": "mikkomaunu",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/FuzzyScore.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport java.util.Locale;\nimport org.junit.jupiter.api.Test;\n\npublic class FuzzyScoreTest2 {\n\n    private static final FuzzyScore ENGLISH_SCORE = new FuzzyScore(Locale.ENGLISH);\n\n    @Test\n    public void testGetFuzzyScore_NullTerm() {\n        assertThatIllegalArgumentException().isThrownBy(() -> {\n            ENGLISH_SCORE.fuzzyScore(null, \"not null\");\n        });\n    }\n\n    @Test\n    public void testGetFuzzyScore_NullQuery() {\n        assertThatIllegalArgumentException().isThrownBy(() -> {\n            ENGLISH_SCORE.fuzzyScore(\"not null\", null);\n        });\n    }\n\n    @Test\n    public void testGetFuzzyScore_NullTermAndQuery() {\n        assertThatIllegalArgumentException().isThrownBy(() -> {\n            ENGLISH_SCORE.fuzzyScore(null, null);\n        });\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.Locale;\n\n/**\n * A matching algorithm that is similar to the searching algorithms implemented in editors such\n * as Sublime Text, TextMate, Atom and others.\n *\n * <p>\n * One point is given for every matched character. Subsequent matches yield two bonus points. A higher score\n * indicates a higher similarity.\n * </p>\n *\n * <p>\n * This code has been adapted from Apache Commons Lang 3.3.\n * </p>\n *\n * @since 1.0\n */\npublic class FuzzyScore {\n\n    /**\n     * Locale used to change the case of text.\n     */\n    private final Locale locale;\n\n\n    /**\n     * <p>This returns a {@link Locale}-specific {@link FuzzyScore}.</p>\n     *\n     * @param locale The string matching logic is case insensitive.\n                     A {@link Locale} is necessary to normalize both Strings to lower case.\n     * @throws IllegalArgumentException\n     *         This is thrown if the {@link Locale} parameter is {@code null}.\n     */\n    public FuzzyScore(final Locale locale) {\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Locale must not be null\");\n        }\n        this.locale = locale;\n    }\n\n    /**\n     * <p>\n     * Find the Fuzzy Score which indicates the similarity score between two\n     * Strings.\n     * </p>\n     *\n     * <pre>\n     * score.fuzzyScore(null, null, null)                                    = IllegalArgumentException\n     * score.fuzzyScore(\"\", \"\", Locale.ENGLISH)                              = 0\n     * score.fuzzyScore(\"Workshop\", \"b\", Locale.ENGLISH)                     = 0\n     * score.fuzzyScore(\"Room\", \"o\", Locale.ENGLISH)                         = 1\n     * score.fuzzyScore(\"Workshop\", \"w\", Locale.ENGLISH)                     = 1\n     * score.fuzzyScore(\"Workshop\", \"ws\", Locale.ENGLISH)                    = 2\n     * score.fuzzyScore(\"Workshop\", \"wo\", Locale.ENGLISH)                    = 4\n     * score.fuzzyScore(\"Apache Software Foundation\", \"asf\", Locale.ENGLISH) = 3\n     * </pre>\n     *\n     * @param term a full term that should be matched against, must not be null\n     * @param query the query that will be matched against a term, must not be\n     *            null\n     * @return result score\n     * @throws IllegalArgumentException if either CharSequence input is {@code null}\n     */\n    public Integer fuzzyScore(final CharSequence term, final CharSequence query) {\n        if (term == null || query == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n\n        // fuzzy logic is case insensitive. We normalize the Strings to lower\n        // case right from the start. Turning characters to lower case\n        // via Character.toLowerCase(char) is unfortunately insufficient\n        // as it does not accept a locale.\n        final String termLowerCase = term.toString().toLowerCase(locale);\n        final String queryLowerCase = query.toString().toLowerCase(locale);\n\n        // the resulting score\n        int score = 0;\n\n        // the position in the term which will be scanned next for potential\n        // query character matches\n        int termIndex = 0;\n\n        // index of the previously matched character in the term\n        int previousMatchingCharacterIndex = Integer.MIN_VALUE;\n\n        for (int queryIndex = 0; queryIndex < queryLowerCase.length(); queryIndex++) {\n            final char queryChar = queryLowerCase.charAt(queryIndex);\n\n            boolean termCharacterMatchFound = false;\n            for (; termIndex < termLowerCase.length()\n                    && !termCharacterMatchFound; termIndex++) {\n                final char termChar = termLowerCase.charAt(termIndex);\n\n                if (queryChar == termChar) {\n                    // simple character matches result in one point\n                    score++;\n\n                    // subsequent character matches further improve\n                    // the score.\n                    if (previousMatchingCharacterIndex + 1 == termIndex) {\n                        score += 2;\n                    }\n\n                    previousMatchingCharacterIndex = termIndex;\n\n                    // we can leave the nested loop. Every character in the\n                    // query can match at most one character in the term.\n                    termCharacterMatchFound = true;\n                }\n            }\n        }\n\n        return score;\n    }\n\n    /**\n     * Gets the locale.\n     *\n     * @return The locale\n     */\n    public Locale getLocale() {\n        return locale;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/FuzzyScore.java b/src/main/java/org/apache/commons/text/similarity/FuzzyScore.java\nindex 233a276194..8dcc526189 100644\n--- a/src/main/java/org/apache/commons/text/similarity/FuzzyScore.java\n+++ b/src/main/java/org/apache/commons/text/similarity/FuzzyScore.java\n@@ -63,21 +63,23 @@ public FuzzyScore(final Locale locale) {\n      * </p>\n      *\n      * <pre>\n-     * score.fuzzyScore(null, null, null)                                    = IllegalArgumentException\n-     * score.fuzzyScore(\"\", \"\", Locale.ENGLISH)                              = 0\n-     * score.fuzzyScore(\"Workshop\", \"b\", Locale.ENGLISH)                     = 0\n-     * score.fuzzyScore(\"Room\", \"o\", Locale.ENGLISH)                         = 1\n-     * score.fuzzyScore(\"Workshop\", \"w\", Locale.ENGLISH)                     = 1\n-     * score.fuzzyScore(\"Workshop\", \"ws\", Locale.ENGLISH)                    = 2\n-     * score.fuzzyScore(\"Workshop\", \"wo\", Locale.ENGLISH)                    = 4\n-     * score.fuzzyScore(\"Apache Software Foundation\", \"asf\", Locale.ENGLISH) = 3\n+     * score.fuzzyScore(null, null)                          = IllegalArgumentException\n+     * score.fuzzyScore(\"not null\", null)                    = IllegalArgumentException\n+     * score.fuzzyScore(null, \"not null\")                    = IllegalArgumentException\n+     * score.fuzzyScore(\"\", \"\")                              = 0\n+     * score.fuzzyScore(\"Workshop\", \"b\")                     = 0\n+     * score.fuzzyScore(\"Room\", \"o\")                         = 1\n+     * score.fuzzyScore(\"Workshop\", \"w\")                     = 1\n+     * score.fuzzyScore(\"Workshop\", \"ws\")                    = 2\n+     * score.fuzzyScore(\"Workshop\", \"wo\")                    = 4\n+     * score.fuzzyScore(\"Apache Software Foundation\", \"asf\") = 3\n      * </pre>\n      *\n      * @param term a full term that should be matched against, must not be null\n      * @param query the query that will be matched against a term, must not be\n      *            null\n      * @return result score\n-     * @throws IllegalArgumentException if either CharSequence input is {@code null}\n+     * @throws IllegalArgumentException if the term or query is {@code null}\n      */\n     public Integer fuzzyScore(final CharSequence term, final CharSequence query) {\n         if (term == null || query == null) {\n"
      }
    ]
  },
  {
    "pr_number": 118,
    "title": "[TEXT-170] Add String lookup for host names and IP addresses",
    "state": "closed",
    "created_at": "2019-07-27T20:30:21Z",
    "merge_commit_sha": "d81879e0e705a6df5a9cd45563ce9a59804e5580",
    "base_sha": "4e8197fc4f293a0d86103f4da98631080befdb21",
    "head_sha": "a2cd31282aee80c9a189b3707578a166c81ea8b7",
    "user_login": "garydgregory",
    "changed_files": [
      {
        "filename": "src/changes/changes.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport org.junit.jupiter.api.Test;\n\npublic class DefaultStringLookupTest2 {\n\n    @Test\n    public void testNewEnumDNS() {\n        assertSame(DefaultStringLookup.DNS.getStringLookup(), StringLookupFactory.INSTANCE.dnsStringLookup());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.lookup;\n\n/**\n * An enumeration defining {@link StringLookup} objects available through {@link StringLookupFactory}.\n * <p>\n * This enum was adapted from Apache Commons Configuration 2.4-SNAPSHOT.\n * </p>\n *\n * @see StringLookupFactory\n * @see StringLookup\n * @since 1.7\n */\npublic enum DefaultStringLookup {\n\n    /**\n     * The lookup for Base64 decoding.\n     */\n    BASE64_DECODER(StringLookupFactory.KEY_BASE64_DECODER, StringLookupFactory.INSTANCE.base64DecoderStringLookup()),\n\n    /**\n     * The lookup for Base64 decoding.\n     */\n    BASE64_ENCODER(StringLookupFactory.KEY_BASE64_ENCODER, StringLookupFactory.INSTANCE.base64EncoderStringLookup()),\n\n    /**\n     * The lookup for constants.\n     */\n    CONST(StringLookupFactory.KEY_CONST, StringLookupFactory.INSTANCE.constantStringLookup()),\n\n    /**\n     * The lookup for dates.\n     */\n    DATE(StringLookupFactory.KEY_DATE, StringLookupFactory.INSTANCE.dateStringLookup()),\n\n    /**\n     * The lookup for environment properties.\n     */\n    ENVIRONMENT(StringLookupFactory.KEY_ENV, StringLookupFactory.INSTANCE.environmentVariableStringLookup()),\n\n    /**\n     * The lookup for files.\n     */\n    FILE(StringLookupFactory.KEY_FILE, StringLookupFactory.INSTANCE.fileStringLookup()),\n\n    /**\n     * The lookup for Java platform information.\n     */\n    JAVA(StringLookupFactory.KEY_JAVA, StringLookupFactory.INSTANCE.javaPlatformStringLookup()),\n\n    /**\n     * The lookup for localhost information.\n     */\n    LOCAL_HOST(StringLookupFactory.KEY_LOCALHOST, StringLookupFactory.INSTANCE.localHostStringLookup()),\n\n    /**\n     * The lookup for properties.\n     */\n    PROPERTIES(StringLookupFactory.KEY_PROPERTIES, StringLookupFactory.INSTANCE.propertiesStringLookup()),\n\n    /**\n     * The lookup for resource bundles.\n     */\n    RESOURCE_BUNDLE(StringLookupFactory.KEY_RESOURCE_BUNDLE, StringLookupFactory.INSTANCE.resourceBundleStringLookup()),\n\n    /**\n     * The lookup for scripts.\n     */\n    SCRIPT(StringLookupFactory.KEY_SCRIPT, StringLookupFactory.INSTANCE.scriptStringLookup()),\n\n    /**\n     * The lookup for system properties.\n     */\n    SYSTEM_PROPERTIES(StringLookupFactory.KEY_SYS, StringLookupFactory.INSTANCE.systemPropertyStringLookup()),\n\n    /**\n     * The lookup for URLs.\n     */\n    URL(StringLookupFactory.KEY_URL, StringLookupFactory.INSTANCE.urlStringLookup()),\n\n    /**\n     * The lookup for URL decoding.\n     */\n    URL_DECODER(StringLookupFactory.KEY_URL_DECODER, StringLookupFactory.INSTANCE.urlDecoderStringLookup()),\n\n    /**\n     * The lookup for URL decoding.\n     */\n    URL_ENCODER(StringLookupFactory.KEY_URL_ENCODER, StringLookupFactory.INSTANCE.urlEncoderStringLookup()),\n\n    /**\n     * The lookup for URL decoding.\n     */\n    XML(StringLookupFactory.KEY_XML, StringLookupFactory.INSTANCE.xmlStringLookup());\n\n    /** The associated lookup instance. */\n    private final StringLookup lookup;\n\n    /** The prefix under which the associated lookup object is registered. */\n    private final String key;\n\n    /**\n     * Creates a new instance of {@link DefaultStringLookup} and sets the key and the associated lookup instance.\n     *\n     * @param prefix\n     *            the prefix\n     * @param lookup\n     *            the {@link StringLookup} instance\n     */\n    DefaultStringLookup(final String prefix, final StringLookup lookup) {\n        this.key = prefix;\n        this.lookup = lookup;\n    }\n\n    /**\n     * Returns the standard prefix for the lookup object of this kind.\n     *\n     * @return the prefix\n     */\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     * Returns the standard {@link StringLookup} instance of this kind.\n     *\n     * @return the associated {@link StringLookup} object\n     */\n    public StringLookup getStringLookup() {\n        return lookup;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java b/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\nindex ba57578a1e..c9632fa9e9 100644\n--- a/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\n@@ -48,6 +48,13 @@ public enum DefaultStringLookup {\n      */\n     DATE(StringLookupFactory.KEY_DATE, StringLookupFactory.INSTANCE.dateStringLookup()),\n \n+    /**\n+     * The lookup for DNS.\n+     *\n+     * @since 1.8\n+     */\n+    DNS(StringLookupFactory.KEY_DNS, StringLookupFactory.INSTANCE.dnsStringLookup()),\n+\n     /**\n      * The lookup for environment properties.\n      */\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/DnsStringLookup.java",
        "status": "added",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport org.junit.jupiter.api.Test;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass DnsStringLookupTest {\n\n    @Test\n    void testLookupHostName() throws UnknownHostException {\n        String key = \"name|127.0.0.1\";\n        InetAddress inetAddress = InetAddress.getByName(\"127.0.0.1\");\n        String expected = inetAddress.getHostName();\n        assertEquals(expected, DnsStringLookup.INSTANCE.lookup(key));\n    }\n\n    @Test\n    void testLookupCanonicalHostName() throws UnknownHostException {\n        String key = \"canonical-name|127.0.0.1\";\n        InetAddress inetAddress = InetAddress.getByName(\"127.0.0.1\");\n        String expected = inetAddress.getCanonicalHostName();\n        assertEquals(expected, DnsStringLookup.INSTANCE.lookup(key));\n    }\n\n    @Test\n    void testLookupHostAddress() throws UnknownHostException {\n        String key = \"address|localhost\";\n        InetAddress inetAddress = InetAddress.getByName(\"localhost\");\n        String expected = inetAddress.getHostAddress();\n        assertEquals(expected, DnsStringLookup.INSTANCE.lookup(key));\n    }\n\n    @Test\n    void testLookupDefaultAddress() throws UnknownHostException {\n        String key = \"localhost\";\n        InetAddress inetAddress = InetAddress.getByName(\"localhost\");\n        String expected = inetAddress.getHostAddress();\n        assertEquals(expected, DnsStringLookup.INSTANCE.lookup(key));\n    }\n\n    @Test\n    void testLookupNullKey() {\n        assertNull(DnsStringLookup.INSTANCE.lookup(null));\n    }\n\n    @Test\n    void testLookupUnknownHost() {\n        String key = \"name|unknown.host\";\n        assertNull(DnsStringLookup.INSTANCE.lookup(key));\n    }\n}",
        "file_content": null,
        "diff": " a/src/main/java/org/apache/commons/text/lookup/DnsStringLookup.java b/src/main/java/org/apache/commons/text/lookup/DnsStringLookup.java\nnew file mode 100644\nindex 0000000000..ba89418873\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/lookup/DnsStringLookup.java\n@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache license, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the license for the specific language governing permissions and\n+ * limitations under the license.\n+ */\n+package org.apache.commons.text.lookup;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+\n+/**\n+ * Looks up keys related to DNS entries like host name, canonical host name, host address.\n+ * <p>\n+ * The lookup keys are:\n+ * </p>\n+ * <ul>\n+ * <li><b>name|<em>address</em></b>: for the host name, for example {@code \"name|93.184.216.34\"} ->\n+ * {@code \"example.com\"}.</li>\n+ * <li><b>canonical-name|<em>address</em></b>: for the canonical host name, for example {@code \"name|93.184.216.34\"} ->\n+ * {@code \"example.com\"}.</li>\n+ * <li><b>address|<em>hostname</em></b>: for the host address, for example {@code \"address|example.com\"} ->\n+ * {@code \"93.184.216.34\"}.</li>\n+ * <li><b><em>address</em></b>: same as {@code address|hostname}.</li>\n+ * </ul>\n+ *\n+ * @since 1.8\n+ */\n+final class DnsStringLookup extends AbstractStringLookup {\n+\n+    /**\n+     * Defines the singleton for this class.\n+     */\n+    static final DnsStringLookup INSTANCE = new DnsStringLookup();\n+\n+    /**\n+     * No need to build instances for now.\n+     */\n+    private DnsStringLookup() {\n+        // empty\n+    }\n+\n+    /**\n+     * Looks up the DNS value of the key.\n+     *\n+     * @param key the key to be looked up, may be null\n+     * @return The DNS value.\n+     */\n+    @Override\n+    public String lookup(final String key) {\n+        if (key == null) {\n+            return null;\n+        }\n+        final String[] keys = key.trim().split(\"\\\\|\");\n+        final int keyLen = keys.length;\n+        final String subKey = keys[0].trim();\n+        final String subValue = keyLen < 2 ? key : keys[1].trim();\n+        try {\n+            final InetAddress inetAddress = InetAddress.getByName(subValue);\n+            switch (subKey) {\n+            case InetAddressKeys.KEY_NAME:\n+                return inetAddress.getHostName();\n+            case InetAddressKeys.KEY_CANONICAL_NAME:\n+                return inetAddress.getCanonicalHostName();\n+            case InetAddressKeys.KEY_ADDRESS:\n+                return inetAddress.getHostAddress();\n+            default:\n+                return inetAddress.getHostAddress();\n+            }\n+        } catch (final UnknownHostException e) {\n+            return null;\n+        }\n+    }\n+\n+}\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/InetAddressKeys.java",
        "status": "added",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass InetAddressKeysTest {\n\n    @Test\n    void testKeyAddress() {\n        assertEquals(\"address\", InetAddressKeys.KEY_ADDRESS);\n    }\n\n    @Test\n    void testKeyCanonicalName() {\n        assertEquals(\"canonical-name\", InetAddressKeys.KEY_CANONICAL_NAME);\n    }\n\n    @Test\n    void testKeyName() {\n        assertEquals(\"name\", InetAddressKeys.KEY_NAME);\n    }\n}",
        "file_content": null,
        "diff": " a/src/main/java/org/apache/commons/text/lookup/InetAddressKeys.java b/src/main/java/org/apache/commons/text/lookup/InetAddressKeys.java\nnew file mode 100644\nindex 0000000000..2465614450\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/lookup/InetAddressKeys.java\n@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache license, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the license for the specific language governing permissions and\n+ * limitations under the license.\n+ */\n+\n+package org.apache.commons.text.lookup;\n+\n+import java.net.InetAddress;\n+\n+/**\n+ * Constants for referring to {@link InetAddress} APIs.\n+ *\n+ * @since 1.8\n+ */\n+class InetAddressKeys {\n+\n+    /**\n+     * Constants for referring to {@link InetAddress#getAddress()}.\n+     */\n+    static final String KEY_ADDRESS = \"address\";\n+\n+    /**\n+     * Constants for referring to {@link InetAddress#getCanonicalAddress()}.\n+     */\n+    static final String KEY_CANONICAL_NAME = \"canonical-name\";\n+\n+    /**\n+     * Constants for referring to {@link InetAddress#getName()}.\n+     */\n+    static final String KEY_NAME = \"name\";\n+\n+}\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/LocalHostStringLookup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class LocalHostStringLookupTest2 {\n\n    @Test\n    public void testAddress() throws UnknownHostException {\n        Assertions.assertEquals(InetAddress.getLocalHost().getHostAddress(),\n            LocalHostStringLookup.INSTANCE.lookup(InetAddressKeys.KEY_ADDRESS));\n    }\n\n    @Test\n    public void testCanonicalName() throws UnknownHostException {\n        Assertions.assertEquals(InetAddress.getLocalHost().getCanonicalHostName(),\n            LocalHostStringLookup.INSTANCE.lookup(InetAddressKeys.KEY_CANONICAL_NAME));\n    }\n\n    @Test\n    public void testName() throws UnknownHostException {\n        Assertions.assertEquals(InetAddress.getLocalHost().getHostName(),\n            LocalHostStringLookup.INSTANCE.lookup(InetAddressKeys.KEY_NAME));\n    }\n\n    @Test\n    public void testNull() {\n        Assertions.assertNull(LocalHostStringLookup.INSTANCE.lookup(null));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\npackage org.apache.commons.text.lookup;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * Looks up keys related to the local host: host name, canonical host name, host address.\n * <p>\n * The lookup keys are:\n * </p>\n * <ul>\n * <li><b>name</b>: for the local host name, for example {@code EXAMPLE}.</li>\n * <li><b>canonical-name</b>: for the local canonical host name, for example {@code EXAMPLE.apache.org}.</li>\n * <li><b>address</b>: for the local host address, for example {@code 192.168.56.1}.</li>\n * </ul>\n *\n * @since 1.3\n */\nfinal class LocalHostStringLookup extends AbstractStringLookup {\n\n    /**\n     * Defines the singleton for this class.\n     */\n    static final LocalHostStringLookup INSTANCE = new LocalHostStringLookup();\n\n    /**\n     * No need to build instances for now.\n     */\n    private LocalHostStringLookup() {\n        // empty\n    }\n\n    /**\n     * Looks up the value of a local host key.\n     *\n     * @param key the key to be looked up, may be null.\n     * @return The value of the environment variable.\n     */\n    @Override\n    public String lookup(final String key) {\n        if (key == null) {\n            return null;\n        }\n        try {\n            switch (key) {\n            case \"name\":\n                return InetAddress.getLocalHost().getHostName();\n            case \"canonical-name\":\n                return InetAddress.getLocalHost().getCanonicalHostName();\n            case \"address\":\n                return InetAddress.getLocalHost().getHostAddress();\n            default:\n                throw new IllegalArgumentException(key);\n            }\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/LocalHostStringLookup.java b/src/main/java/org/apache/commons/text/lookup/LocalHostStringLookup.java\nindex 9f4ee34056..8bdc24d016 100644\n--- a/src/main/java/org/apache/commons/text/lookup/LocalHostStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/LocalHostStringLookup.java\n@@ -59,11 +59,11 @@ public String lookup(final String key) {\n         }\n         try {\n             switch (key) {\n-            case \"name\":\n+            case InetAddressKeys.KEY_NAME:\n                 return InetAddress.getLocalHost().getHostName();\n-            case \"canonical-name\":\n+            case InetAddressKeys.KEY_CANONICAL_NAME:\n                 return InetAddress.getLocalHost().getCanonicalHostName();\n-            case \"address\":\n+            case InetAddressKeys.KEY_ADDRESS:\n                 return InetAddress.getLocalHost().getHostAddress();\n             default:\n                 throw new IllegalArgumentException(key);\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.lookup;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class StringLookupFactoryTest2 {\n\n    @Test\n    public void testAddDefaultStringLookupsMap() {\n        final Map<String, StringLookup> stringLookupMap = new HashMap<>();\n        StringLookupFactory.INSTANCE.addDefaultStringLookups(stringLookupMap);\n        assertTrue(stringLookupMap.containsKey(StringLookupFactory.KEY_DNS));\n    }\n\n    @Test\n    public void testSingletons() {\n        final StringLookupFactory stringLookupFactory = StringLookupFactory.INSTANCE;\n        Assertions.assertSame(DnsStringLookup.INSTANCE, stringLookupFactory.dnsStringLookup());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\n\npackage org.apache.commons.text.lookup;\n\nimport java.util.Map;\n\n/**\n * Provides access to lookups defined in this package.\n * <p>\n * The default lookups are:\n * </p>\n * <table>\n * <caption>Default String Lookups</caption>\n * <tr>\n * <th>Key</th>\n * <th>Implementation</th>\n * <th>Factory Method</th>\n * <th>Since</th>\n * </tr>\n * <tr>\n * <td>{@value #KEY_BASE64_DECODER}</td>\n * <td>{@link Base64DecoderStringLookup}</td>\n * <td>{@link #base64DecoderStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_BASE64_ENCODER}</td>\n * <td>{@link Base64EncoderStringLookup}</td>\n * <td>{@link #base64EncoderStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_CONST}</td>\n * <td>{@link ConstantStringLookup}</td>\n * <td>{@link #constantStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_DATE}</td>\n * <td>{@link DateStringLookup}</td>\n * <td>{@link #dateStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_ENV}</td>\n * <td>{@link EnvironmentVariableStringLookup}</td>\n * <td>{@link #environmentVariableStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_FILE}</td>\n * <td>{@link FileStringLookup}</td>\n * <td>{@link #fileStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_JAVA}</td>\n * <td>{@link JavaPlatformStringLookup}</td>\n * <td>{@link #javaPlatformStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_LOCALHOST}</td>\n * <td>{@link LocalHostStringLookup}</td>\n * <td>{@link #localHostStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_PROPERTIES}</td>\n * <td>{@link PropertiesStringLookup}</td>\n * <td>{@link #propertiesStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_RESOURCE_BUNDLE}</td>\n * <td>{@link ResourceBundleStringLookup}</td>\n * <td>{@link #resourceBundleStringLookup()}</td>\n * <td>1.6</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_SCRIPT}</td>\n * <td>{@link ScriptStringLookup}</td>\n * <td>{@link #scriptStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_SYS}</td>\n * <td>{@link SystemPropertyStringLookup}</td>\n * <td>{@link #systemPropertyStringLookup()}</td>\n * <td>1.3</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL}</td>\n * <td>{@link UrlStringLookup}</td>\n * <td>{@link #urlStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL_DECODER}</td>\n * <td>{@link UrlDecoderStringLookup}</td>\n * <td>{@link #urlDecoderStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_URL_ENCODER}</td>\n * <td>{@link UrlEncoderStringLookup}</td>\n * <td>{@link #urlEncoderStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * <tr>\n * <td>{@value #KEY_XML}</td>\n * <td>{@link XmlStringLookup}</td>\n * <td>{@link #xmlStringLookup()}</td>\n * <td>1.5</td>\n * </tr>\n * </table>\n *\n * @since 1.3\n */\npublic final class StringLookupFactory {\n\n    /**\n     * Defines the singleton for this class.\n     */\n    public static final StringLookupFactory INSTANCE = new StringLookupFactory();\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_BASE64_DECODER = \"base64Decoder\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_BASE64_ENCODER = \"base64Encoder\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_CONST = \"const\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_DATE = \"date\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_ENV = \"env\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_FILE = \"file\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_JAVA = \"java\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_LOCALHOST = \"localhost\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_PROPERTIES = \"properties\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_RESOURCE_BUNDLE = \"resourceBundle\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_SCRIPT = \"script\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_SYS = \"sys\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL = \"url\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL_DECODER = \"urlDecoder\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_URL_ENCODER = \"urlEncoder\";\n\n    /**\n     * Default lookup key for interpolation.\n     *\n     * @since 1.6\n     */\n    public static final String KEY_XML = \"xml\";\n\n    /**\n     * Clears any static resources.\n     *\n     * @since 1.5\n     */\n    public static void clear() {\n        ConstantStringLookup.clear();\n    }\n\n    /**\n     * No need to build instances for now.\n     */\n    private StringLookupFactory() {\n        // empty\n    }\n\n    /**\n     * Adds the {@link StringLookupFactory default lookups}.\n     *\n     * @param stringLookupMap\n     *            the map of string lookups.\n     * @since 1.5\n     */\n    public void addDefaultStringLookups(final Map<String, StringLookup> stringLookupMap) {\n        if (stringLookupMap != null) {\n            // \"base64\" is deprecated in favor of KEY_BASE64_DECODER.\n            stringLookupMap.put(\"base64\", Base64DecoderStringLookup.INSTANCE);\n            for (final DefaultStringLookup stringLookup : DefaultStringLookup.values()) {\n                stringLookupMap.put(stringLookup.getKey(), stringLookup.getStringLookup());\n            }\n        }\n    }\n\n    /**\n     * Returns the Base64DecoderStringLookup singleton instance to format the current date with the format given in the\n     * key in a format compatible with {@link java.text.SimpleDateFormat}.\n     *\n     * @return the DateStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup base64DecoderStringLookup() {\n        return Base64DecoderStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the Base64EncoderStringLookup singleton instance to format the current date with the format given in the\n     * key in a format compatible with {@link java.text.SimpleDateFormat}.\n     *\n     * @return the DateStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup base64EncoderStringLookup() {\n        return Base64EncoderStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the Base64DecoderStringLookup singleton instance to format the current date with the format given in the\n     * key in a format compatible with {@link java.text.SimpleDateFormat}.\n     *\n     * @return the DateStringLookup singleton instance.\n     * @since 1.5\n     * @deprecated Use {@link #base64DecoderStringLookup()}.\n     */\n    @Deprecated\n    public StringLookup base64StringLookup() {\n        return Base64DecoderStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the ConstantStringLookup singleton instance to get the value of a fully-qualified static final value.\n     *\n     * @return the DateStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup constantStringLookup() {\n        return ConstantStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the DateStringLookup singleton instance to format the current date with the format given in the key in a\n     * format compatible with {@link java.text.SimpleDateFormat}.\n     *\n     * @return the DateStringLookup singleton instance.\n     */\n    public StringLookup dateStringLookup() {\n        return DateStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the EnvironmentVariableStringLookup singleton instance where the lookup key is an environment variable\n     * name.\n     *\n     * @return the EnvironmentVariableStringLookup singleton instance.\n     */\n    public StringLookup environmentVariableStringLookup() {\n        return EnvironmentVariableStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the FileStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"CharsetName:Path\".\n     * </p>\n     * <p>\n     * For example: \"UTF-8:com/domain/document.properties\".\n     * </p>\n     *\n     * @return the FileStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup fileStringLookup() {\n        return FileStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n     *\n     * @return a new InterpolatorStringLookup.\n     */\n    public StringLookup interpolatorStringLookup() {\n        return InterpolatorStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n     * <p>\n     * If {@code addDefaultLookups} is true, the following lookups are used in addition to the ones provided in\n     * {@code stringLookupMap}:\n     * </p>\n     *\n     * @param stringLookupMap\n     *            the map of string lookups.\n     * @param defaultStringLookup\n     *            the default string lookup.\n     * @param addDefaultLookups\n     *            whether to use lookups as described above.\n     * @return a new InterpolatorStringLookup.\n     * @since 1.4\n     */\n    public StringLookup interpolatorStringLookup(final Map<String, StringLookup> stringLookupMap,\n            final StringLookup defaultStringLookup, final boolean addDefaultLookups) {\n        return new InterpolatorStringLookup(stringLookupMap, defaultStringLookup, addDefaultLookups);\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n     *\n     * @param <V>\n     *            the value type the default string lookup's map.\n     * @param map\n     *            the default map for string lookups.\n     * @return a new InterpolatorStringLookup.\n     */\n    public <V> StringLookup interpolatorStringLookup(final Map<String, V> map) {\n        return new InterpolatorStringLookup(map);\n    }\n\n    /**\n     * Returns a new InterpolatorStringLookup using the {@link StringLookupFactory default lookups}.\n     *\n     * @param defaultStringLookup\n     *            the default string lookup.\n     * @return a new InterpolatorStringLookup.\n     */\n    public StringLookup interpolatorStringLookup(final StringLookup defaultStringLookup) {\n        return new InterpolatorStringLookup(defaultStringLookup);\n    }\n\n    /**\n     * Returns the JavaPlatformStringLookup singleton instance. Looks up keys related to Java: Java version, JRE\n     * version, VM version, and so on.\n     * <p>\n     * The lookup keys with examples are:\n     * </p>\n     * <ul>\n     * <li><b>version</b>: \"Java version 1.8.0_181\"</li>\n     * <li><b>runtime</b>: \"Java(TM) SE Runtime Environment (build 1.8.0_181-b13) from Oracle Corporation\"</li>\n     * <li><b>vm</b>: \"Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)\"</li>\n     * <li><b>os</b>: \"Windows 10 10.0, architecture: amd64-64\"</li>\n     * <li><b>hardware</b>: \"processors: 4, architecture: amd64-64, instruction sets: amd64\"</li>\n     * <li><b>locale</b>: \"default locale: en_US, platform encoding: iso-8859-1\"</li>\n     * </ul>\n     *\n     * @return the JavaPlatformStringLookup singleton instance.\n     */\n    public StringLookup javaPlatformStringLookup() {\n        return JavaPlatformStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the LocalHostStringLookup singleton instance where the lookup key is one of:\n     * <ul>\n     * <li><b>name</b>: for the local host name, for example {@code EXAMPLE}.</li>\n     * <li><b>canonical-name</b>: for the local canonical host name, for example {@code EXAMPLE.apache.org}.</li>\n     * <li><b>address</b>: for the local host address, for example {@code 192.168.56.1}.</li>\n     * </ul>\n     *\n     * @return the DateStringLookup singleton instance.\n     */\n    public StringLookup localHostStringLookup() {\n        return LocalHostStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a new map-based lookup where the request for a lookup is answered with the value for that key.\n     *\n     * @param <V>\n     *            the map value type.\n     * @param map\n     *            the map.\n     * @return a new MapStringLookup.\n     */\n    public <V> StringLookup mapStringLookup(final Map<String, V> map) {\n        return MapStringLookup.on(map);\n    }\n\n    /**\n     * Returns the NullStringLookup singleton instance which always returns null.\n     *\n     * @return the NullStringLookup singleton instance.\n     */\n    public StringLookup nullStringLookup() {\n        return NullStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the PropertiesStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"DocumentPath:Key\".\n     * </p>\n     * <p>\n     * For example: \"com/domain/document.properties:Key\".\n     * </p>\n     *\n     * @return the PropertiesStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup propertiesStringLookup() {\n        return PropertiesStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the ResourceBundleStringLookup singleton instance.\n     * <p>\n     * Looks up the value for a given key in the format \"BundleName:BundleKey\".\n     * </p>\n     * <p>\n     * For example: \"com.domain.messages:MyKey\".\n     * </p>\n     *\n     * @return the ResourceBundleStringLookup singleton instance.\n     */\n    public StringLookup resourceBundleStringLookup() {\n        return ResourceBundleStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns a ResourceBundleStringLookup instance for the given bundle name.\n     * <p>\n     * Looks up the value for a given key in the format \"BundleKey\".\n     * </p>\n     * <p>\n     * For example: \"MyKey\".\n     * </p>\n     *\n     * @param bundleName\n     *            Only lookup in this bundle.\n     * @return a ResourceBundleStringLookup instance for the given bundle name.\n     * @since 1.5\n     */\n    public StringLookup resourceBundleStringLookup(final String bundleName) {\n        return new ResourceBundleStringLookup(bundleName);\n    }\n\n    /**\n     * Returns the ScriptStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"ScriptEngineName:Script\".\n     * </p>\n     * <p>\n     * For example: \"javascript:3+4\".\n     * </p>\n     *\n     * @return the ScriptStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup scriptStringLookup() {\n        return ScriptStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the SystemPropertyStringLookup singleton instance where the lookup key is a system property name.\n     *\n     * @return the SystemPropertyStringLookup singleton instance.\n     */\n    public StringLookup systemPropertyStringLookup() {\n        return SystemPropertyStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the UrlDecoderStringLookup singleton instance.\n     * <p>\n     * Decodes URL Strings using the UTF-8 encoding.\n     * </p>\n     * <p>\n     * For example: \"Hello%20World%21\" becomes \"Hello World!\".\n     * </p>\n     *\n     * @return the UrlStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup urlDecoderStringLookup() {\n        return UrlDecoderStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the UrlDecoderStringLookup singleton instance.\n     * <p>\n     * Decodes URL Strings using the UTF-8 encoding.\n     * </p>\n     * <p>\n     * For example: \"Hello World!\" becomes \"Hello+World%21\".\n     * </p>\n     *\n     * @return the UrlStringLookup singleton instance.\n     * @since 1.6\n     */\n    public StringLookup urlEncoderStringLookup() {\n        return UrlEncoderStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the UrlStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"CharsetName:URL\".\n     * </p>\n     * <p>\n     * For example, using the HTTP scheme: \"UTF-8:http://www.google.com\"\n     * </p>\n     * <p>\n     * For example, using the file scheme:\n     * \"UTF-8:file:///C:/somehome/commons/commons-text/src/test/resources/document.properties\"\n     * </p>\n     *\n     * @return the UrlStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup urlStringLookup() {\n        return UrlStringLookup.INSTANCE;\n    }\n\n    /**\n     * Returns the XmlStringLookup singleton instance.\n     * <p>\n     * Looks up the value for the key in the format \"DocumentPath:XPath\".\n     * </p>\n     * <p>\n     * For example: \"com/domain/document.xml:/path/to/node\".\n     * </p>\n     *\n     * @return the XmlStringLookup singleton instance.\n     * @since 1.5\n     */\n    public StringLookup xmlStringLookup() {\n        return XmlStringLookup.INSTANCE;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\nindex a1c80c6749..0dcaf71d27 100644\n--- a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n+++ b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n@@ -57,6 +57,12 @@\n  * <td>1.5</td>\n  * </tr>\n  * <tr>\n+ * <td>{@value #KEY_DNS}</td>\n+ * <td>{@link DnsStringLookup}</td>\n+ * <td>{@link #dnsStringLookup()}</td>\n+ * <td>1.8</td>\n+ * </tr>\n+ * <tr>\n  * <td>{@value #KEY_ENV}</td>\n  * <td>{@link EnvironmentVariableStringLookup}</td>\n  * <td>{@link #environmentVariableStringLookup()}</td>\n@@ -167,6 +173,13 @@ public final class StringLookupFactory {\n      */\n     public static final String KEY_DATE = \"date\";\n \n+    /**\n+     * Default lookup key for interpolation.\n+     *\n+     * @since 1.8\n+     */\n+    public static final String KEY_DNS = \"dns\";\n+\n     /**\n      * Default lookup key for interpolation.\n      *\n@@ -454,6 +467,21 @@ public StringLookup localHostStringLookup() {\n         return LocalHostStringLookup.INSTANCE;\n     }\n \n+    /**\n+     * Returns the DnsStringLookup singleton instance where the lookup key is one of:\n+     * <ul>\n+     * <li><b>name</b>: for the local host name, for example {@code EXAMPLE} but also {@code EXAMPLE.apache.org}.</li>\n+     * <li><b>canonical-name</b>: for the local canonical host name, for example {@code EXAMPLE.apache.org}.</li>\n+     * <li><b>address</b>: for the local host address, for example {@code 192.168.56.1}.</li>\n+     * </ul>\n+     *\n+     * @return the DateStringLookup singleton instance.\n+     * @since 1.8\n+     */\n+    public StringLookup dnsStringLookup() {\n+        return DnsStringLookup.INSTANCE;\n+    }\n+\n     /**\n      * Returns a new map-based lookup where the request for a lookup is answered with the value for that key.\n      *\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/StringSubstitutorWithInterpolatorStringLookupTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/lookup/DefaultStringLookupTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/lookup/DnsStringLookupTest.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 117,
    "title": "(doc) Fixed wrong value for Jaro-Winkler example",
    "state": "closed",
    "created_at": "2019-07-19T13:06:50Z",
    "merge_commit_sha": "67a343f016e3224fb064d3f261178a114c5a5300",
    "base_sha": "bca44a8edce8953cb18c3520741923433a0d49ad",
    "head_sha": "77e857b561db4a97752ceccbad3cc24cc6b03e09",
    "user_login": "luksan47",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class JaroWinklerDistanceTest2 {\n\n    private static JaroWinklerDistance distance;\n\n    @BeforeAll\n    public static void setUp() {\n        distance = new JaroWinklerDistance();\n    }\n\n    @Test\n    public void testGetJaroWinklerDistance_ABC_Corporation_ABC_Corp() {\n        // Updated test case based on the diff file\n        assertEquals(0.09d, distance.apply(\"ABC Corporation\", \"ABC Corp\"), 0.00001d);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.Arrays;\n\n/**\n * Measures the Jaro-Winkler distance of two character sequences.\n * It is the complementary of Jaro-Winkler similarity.\n *\n * @since 1.0\n */\npublic class JaroWinklerDistance implements EditDistance<Double> {\n\n    /**\n     * @deprecated Deprecated as of 1.7. This constant will be removed in 2.0.\n     */\n    @Deprecated\n    public static final int INDEX_NOT_FOUND = -1;\n\n    /**\n     * Computes the Jaro Winkler Distance between two character sequences.\n     *\n     * <pre>\n     * distance.apply(null, null)          = IllegalArgumentException\n     * distance.apply(\"foo\", null)         = IllegalArgumentException\n     * distance.apply(null, \"foo\")         = IllegalArgumentException\n     * distance.apply(\"\", \"\")              = 0.0\n     * distance.apply(\"foo\", \"foo\")        = 0.0\n     * distance.apply(\"foo\", \"foo \")       = 0.06\n     * distance.apply(\"foo\", \"foo  \")      = 0.09\n     * distance.apply(\"foo\", \" foo \")      = 0.13\n     * distance.apply(\"foo\", \"  foo\")      = 0.49\n     * distance.apply(\"\", \"a\")             = 1.0\n     * distance.apply(\"aaapppp\", \"\")       = 1.0\n     * distance.apply(\"frog\", \"fog\")       = 0.07\n     * distance.apply(\"fly\", \"ant\")        = 1.0\n     * distance.apply(\"elephant\", \"hippo\") = 0.56\n     * distance.apply(\"hippo\", \"elephant\") = 0.56\n     * distance.apply(\"hippo\", \"zzzzzzzz\") = 1.0\n     * distance.apply(\"hello\", \"hallo\")    = 0.12\n     * distance.apply(\"ABC Corporation\", \"ABC Corp\") = 0.07\n     * distance.apply(\"D N H Enterprises Inc\", \"D &amp; H Enterprises, Inc.\") = 0.05\n     * distance.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\") = 0.08\n     * distance.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\") = 0.12\n     * </pre>\n     *\n     * @param left the first CharSequence, must not be null\n     * @param right the second CharSequence, must not be null\n     * @return result distance\n     * @throws IllegalArgumentException if either CharSequence input is {@code null}\n     */\n    @Override\n    public Double apply(final CharSequence left, final CharSequence right) {\n\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n\n        // TODO: replace the rest of the code by this in 2.0, see TEXT-104\n        //\n        // JaroWinklerSimilarity similarity = new JaroWinklerSimilarity();\n        // return 1 - similarity.apply(left, right);\n\n        final double defaultScalingFactor = 0.1;\n        final int[] mtp = matches(left, right);\n        final double m = mtp[0];\n        if (m == 0) {\n            return 0D;\n        }\n        final double j = ((m / left.length() + m / right.length() + (m - (double) mtp[1] / 2) / m)) / 3;\n        final double jw = j < 0.7D ? j : j + defaultScalingFactor * mtp[2] * (1D - j);\n        return jw;\n    }\n\n    // TODO: remove this method in 2.0, see TEXT-104\n    /**\n     * This method returns the Jaro-Winkler string matches, half transpositions, prefix array.\n     *\n     * @param first the first string to be matched\n     * @param second the second string to be matched\n     * @return mtp array containing: matches, half transpositions, and prefix\n     * @deprecated Deprecated as of 1.7. This method will be removed in 2.0, and moved to a Jaro Winkler similarity\n     *             class.\n     */\n    @Deprecated\n    protected static int[] matches(final CharSequence first, final CharSequence second) {\n        CharSequence max, min;\n        if (first.length() > second.length()) {\n            max = first;\n            min = second;\n        } else {\n            max = second;\n            min = first;\n        }\n        final int range = Math.max(max.length() / 2 - 1, 0);\n        final int[] matchIndexes = new int[min.length()];\n        Arrays.fill(matchIndexes, -1);\n        final boolean[] matchFlags = new boolean[max.length()];\n        int matches = 0;\n        for (int mi = 0; mi < min.length(); mi++) {\n            final char c1 = min.charAt(mi);\n            for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max.length()); xi < xn; xi++) {\n                if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n                    matchIndexes[mi] = xi;\n                    matchFlags[xi] = true;\n                    matches++;\n                    break;\n                }\n            }\n        }\n        final char[] ms1 = new char[matches];\n        final char[] ms2 = new char[matches];\n        for (int i = 0, si = 0; i < min.length(); i++) {\n            if (matchIndexes[i] != -1) {\n                ms1[si] = min.charAt(i);\n                si++;\n            }\n        }\n        for (int i = 0, si = 0; i < max.length(); i++) {\n            if (matchFlags[i]) {\n                ms2[si] = max.charAt(i);\n                si++;\n            }\n        }\n        int halfTranspositions = 0;\n        for (int mi = 0; mi < ms1.length; mi++) {\n            if (ms1[mi] != ms2[mi]) {\n                halfTranspositions++;\n            }\n        }\n        int prefix = 0;\n        for (int mi = 0; mi < Math.min(4, min.length()); mi++) {\n            if (first.charAt(mi) == second.charAt(mi)) {\n                prefix++;\n            } else {\n                break;\n            }\n        }\n        return new int[] {matches, halfTranspositions, prefix};\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java b/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\nindex a033f8817f..044a36c8eb 100644\n--- a/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\n+++ b/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\n@@ -53,7 +53,7 @@ public class JaroWinklerDistance implements EditDistance<Double> {\n      * distance.apply(\"hippo\", \"elephant\") = 0.56\n      * distance.apply(\"hippo\", \"zzzzzzzz\") = 1.0\n      * distance.apply(\"hello\", \"hallo\")    = 0.12\n-     * distance.apply(\"ABC Corporation\", \"ABC Corp\") = 0.07\n+     * distance.apply(\"ABC Corporation\", \"ABC Corp\") = 0.09\n      * distance.apply(\"D N H Enterprises Inc\", \"D &amp; H Enterprises, Inc.\") = 0.05\n      * distance.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\") = 0.08\n      * distance.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\") = 0.12\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class JaroWinklerSimilarityTest2 {\n    private static JaroWinklerSimilarity similarity;\n\n    @BeforeAll\n    public static void setUp() {\n        similarity = new JaroWinklerSimilarity();\n    }\n\n    @Test\n    public void testGetJaroWinklerSimilarity_UpdatedValue() {\n        // Updated test case based on the diff file\n        assertEquals(0.91d, similarity.apply(wrap(\"ABC Corporation\"), \"ABC Corp\"), 0.00001d);\n    }\n\n    private static CharSequence wrap(final String string) {\n        return new CharSequence() {\n            @Override\n            public int length() {\n                return string.length();\n            }\n\n            @Override\n            public char charAt(final int index) {\n                return string.charAt(index);\n            }\n\n            @Override\n            public CharSequence subSequence(final int start, final int end) {\n                return string.subSequence(start, end);\n            }\n        };\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Arrays;\n\n/**\n * A similarity algorithm indicating the percentage of matched characters between two character sequences.\n *\n * <p>\n * The Jaro measure is the weighted sum of percentage of matched characters\n * from each file and transposed characters. Winkler increased this measure\n * for matching initial characters.\n * </p>\n *\n * <p>\n * This implementation is based on the Jaro Winkler similarity algorithm\n * from <a href=\"http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\">\n * http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a>.\n * </p>\n *\n * <p>\n * This code has been adapted from Apache Commons Lang 3.3.\n * </p>\n *\n * @since 1.7\n */\npublic class JaroWinklerSimilarity implements SimilarityScore<Double> {\n\n    /**\n     * Computes the Jaro Winkler Similarity between two character sequences.\n     *\n     * <pre>\n     * sim.apply(null, null)          = IllegalArgumentException\n     * sim.apply(\"foo\", null)         = IllegalArgumentException\n     * sim.apply(null, \"foo\")         = IllegalArgumentException\n     * sim.apply(\"\", \"\")              = 1.0\n     * sim.apply(\"foo\", \"foo\")        = 1.0\n     * sim.apply(\"foo\", \"foo \")       = 0.94\n     * sim.apply(\"foo\", \"foo  \")      = 0.91\n     * sim.apply(\"foo\", \" foo \")      = 0.87\n     * sim.apply(\"foo\", \"  foo\")      = 0.51\n     * sim.apply(\"\", \"a\")             = 0.0\n     * sim.apply(\"aaapppp\", \"\")       = 0.0\n     * sim.apply(\"frog\", \"fog\")       = 0.93\n     * sim.apply(\"fly\", \"ant\")        = 0.0\n     * sim.apply(\"elephant\", \"hippo\") = 0.44\n     * sim.apply(\"hippo\", \"elephant\") = 0.44\n     * sim.apply(\"hippo\", \"zzzzzzzz\") = 0.0\n     * sim.apply(\"hello\", \"hallo\")    = 0.88\n     * sim.apply(\"ABC Corporation\", \"ABC Corp\") = 0.93\n     * sim.apply(\"D N H Enterprises Inc\", \"D &amp; H Enterprises, Inc.\") = 0.95\n     * sim.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\") = 0.92\n     * sim.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\") = 0.88\n     * </pre>\n     *\n     * @param left the first CharSequence, must not be null\n     * @param right the second CharSequence, must not be null\n     * @return result similarity\n     * @throws IllegalArgumentException if either CharSequence input is {@code null}\n     */\n    @Override\n    public Double apply(final CharSequence left, final CharSequence right) {\n        final double defaultScalingFactor = 0.1;\n\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n\n        if (StringUtils.equals(left, right)) {\n            return 1d;\n        }\n\n        final int[] mtp = matches(left, right);\n        final double m = mtp[0];\n        if (m == 0) {\n            return 0d;\n        }\n        final double j = ((m / left.length() + m / right.length() + (m - (double) mtp[1] / 2) / m)) / 3;\n        final double jw = j < 0.7d ? j : j + defaultScalingFactor * mtp[2] * (1d - j);\n        return jw;\n    }\n\n    /**\n     * This method returns the Jaro-Winkler string matches, half transpositions, prefix array.\n     *\n     * @param first the first string to be matched\n     * @param second the second string to be matched\n     * @return mtp array containing: matches, half transpositions, and prefix\n     */\n    protected static int[] matches(final CharSequence first, final CharSequence second) {\n        CharSequence max, min;\n        if (first.length() > second.length()) {\n            max = first;\n            min = second;\n        } else {\n            max = second;\n            min = first;\n        }\n        final int range = Math.max(max.length() / 2 - 1, 0);\n        final int[] matchIndexes = new int[min.length()];\n        Arrays.fill(matchIndexes, -1);\n        final boolean[] matchFlags = new boolean[max.length()];\n        int matches = 0;\n        for (int mi = 0; mi < min.length(); mi++) {\n            final char c1 = min.charAt(mi);\n            for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max.length()); xi < xn; xi++) {\n                if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n                    matchIndexes[mi] = xi;\n                    matchFlags[xi] = true;\n                    matches++;\n                    break;\n                }\n            }\n        }\n        final char[] ms1 = new char[matches];\n        final char[] ms2 = new char[matches];\n        for (int i = 0, si = 0; i < min.length(); i++) {\n            if (matchIndexes[i] != -1) {\n                ms1[si] = min.charAt(i);\n                si++;\n            }\n        }\n        for (int i = 0, si = 0; i < max.length(); i++) {\n            if (matchFlags[i]) {\n                ms2[si] = max.charAt(i);\n                si++;\n            }\n        }\n        int halfTranspositions = 0;\n        for (int mi = 0; mi < ms1.length; mi++) {\n            if (ms1[mi] != ms2[mi]) {\n                halfTranspositions++;\n            }\n        }\n        int prefix = 0;\n        for (int mi = 0; mi < Math.min(4, min.length()); mi++) {\n            if (first.charAt(mi) == second.charAt(mi)) {\n                prefix++;\n            } else {\n                break;\n            }\n        }\n        return new int[] {matches, halfTranspositions, prefix};\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java b/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java\nindex a159ba8e9e..058d36979d 100644\n--- a/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java\n+++ b/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java\n@@ -64,7 +64,7 @@ public class JaroWinklerSimilarity implements SimilarityScore<Double> {\n      * sim.apply(\"hippo\", \"elephant\") = 0.44\n      * sim.apply(\"hippo\", \"zzzzzzzz\") = 0.0\n      * sim.apply(\"hello\", \"hallo\")    = 0.88\n-     * sim.apply(\"ABC Corporation\", \"ABC Corp\") = 0.93\n+     * sim.apply(\"ABC Corporation\", \"ABC Corp\") = 0.91\n      * sim.apply(\"D N H Enterprises Inc\", \"D &amp; H Enterprises, Inc.\") = 0.95\n      * sim.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\") = 0.92\n      * sim.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\") = 0.88\n"
      }
    ]
  },
  {
    "pr_number": 114,
    "title": "Fix Javadoc error on Java 13.",
    "state": "closed",
    "created_at": "2019-05-22T06:12:10Z",
    "merge_commit_sha": "da897bbf9a78ceeebd583e0622809d53759682dd",
    "base_sha": "6a6faa4154600309b6eaaa5f13a07fd0a0b6872d",
    "head_sha": "da897bbf9a78ceeebd583e0622809d53759682dd",
    "user_login": "PascalSchumacher",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/AlphabetConverter.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class AlphabetConverterTest2 {\n\n    @Test\n    public void testSampleUsageHeaderChange() {\n        // This test ensures that the header change from <h1> to <h2> does not affect functionality.\n        // Since this is a documentation change, no functional test is needed.\n        // We can simply ensure that the class can be instantiated and used as expected.\n        \n        final Character[] original = {'a', 'b', 'c', 'd'};\n        final Character[] encoding = {'0', '1', 'd'};\n        final Character[] doNotEncode = {'d'};\n        AlphabetConverter ac = AlphabetConverter.createConverterFromChars(original, encoding, doNotEncode);\n        \n        assertThat(ac).isNotNull();\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * <p>\n * Convert from one alphabet to another, with the possibility of leaving certain\n * characters unencoded.\n * </p>\n *\n * <p>\n * The target and do not encode languages must be in the Unicode BMP, but the\n * source language does not.\n * </p>\n *\n * <p>\n * The encoding will all be of a fixed length, except for the 'do not encode'\n * chars, which will be of length 1\n * </p>\n *\n * <h1>Sample usage</h1>\n *\n * <pre>\n * Character[] originals;   // a, b, c, d\n * Character[] encoding;    // 0, 1, d\n * Character[] doNotEncode; // d\n *\n * AlphabetConverter ac = AlphabetConverter.createConverterFromChars(originals,\n * encoding, doNotEncode);\n *\n * ac.encode(\"a\");    // 00\n * ac.encode(\"b\");    // 01\n * ac.encode(\"c\");    // 0d\n * ac.encode(\"d\");    // d\n * ac.encode(\"abcd\"); // 00010dd\n * </pre>\n *\n * <p>\n * #ThreadSafe# AlphabetConverter class methods are thread-safe as they do not\n * change internal state.\n * </p>\n *\n * @since 1.0\n *\n */\npublic final class AlphabetConverter {\n\n    /**\n     * Original string to be encoded.\n     */\n    private final Map<Integer, String> originalToEncoded;\n    /**\n     * Encoding alphabet.\n     */\n    private final Map<String, String> encodedToOriginal;\n    /**\n     * Length of the encoded letter.\n     */\n    private final int encodedLetterLength;\n    /**\n     * Arrow constant, used for converting the object into a string.\n     */\n    private static final String ARROW = \" -> \";\n\n    /**\n     * Hidden constructor for alphabet converter. Used by static helper methods.\n     *\n     * @param originalToEncoded original string to be encoded\n     * @param encodedToOriginal encoding alphabet\n     * @param encodedLetterLength length of the encoded letter\n     */\n    private AlphabetConverter(final Map<Integer, String> originalToEncoded,\n                              final Map<String, String> encodedToOriginal,\n                              final int encodedLetterLength) {\n\n        this.originalToEncoded = originalToEncoded;\n        this.encodedToOriginal = encodedToOriginal;\n        this.encodedLetterLength = encodedLetterLength;\n    }\n\n    /**\n     * Encode a given string.\n     *\n     * @param original the string to be encoded\n     * @return the encoded string, {@code null} if the given string is null\n     * @throws UnsupportedEncodingException if chars that are not supported are\n     *                                      encountered\n     */\n    public String encode(final String original)\n            throws UnsupportedEncodingException {\n        if (original == null) {\n            return null;\n        }\n\n        final StringBuilder sb = new StringBuilder();\n\n        for (int i = 0; i < original.length();) {\n            final int codepoint = original.codePointAt(i);\n\n            final String nextLetter = originalToEncoded.get(codepoint);\n\n            if (nextLetter == null) {\n                throw new UnsupportedEncodingException(\n                        \"Couldn't find encoding for '\"\n                                + codePointToString(codepoint)\n                                + \"' in \"\n                                + original\n                );\n            }\n\n            sb.append(nextLetter);\n\n            i += Character.charCount(codepoint);\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Decode a given string.\n     *\n     * @param encoded a string that has been encoded using this\n     *                AlphabetConverter\n     * @return the decoded string, {@code null} if the given string is null\n     * @throws UnsupportedEncodingException if unexpected characters that\n     *                                      cannot be handled are encountered\n     */\n    public String decode(final String encoded)\n            throws UnsupportedEncodingException {\n        if (encoded == null) {\n            return null;\n        }\n\n        final StringBuilder result = new StringBuilder();\n\n        for (int j = 0; j < encoded.length();) {\n            final Integer i = encoded.codePointAt(j);\n            final String s = codePointToString(i);\n\n            if (s.equals(originalToEncoded.get(i))) {\n                result.append(s);\n                j++; // because we do not encode in Unicode extended the\n                     // length of each encoded char is 1\n            } else {\n                if (j + encodedLetterLength > encoded.length()) {\n                    throw new UnsupportedEncodingException(\"Unexpected end \"\n                            + \"of string while decoding \" + encoded);\n                }\n                final String nextGroup = encoded.substring(j,\n                        j + encodedLetterLength);\n                final String next = encodedToOriginal.get(nextGroup);\n                if (next == null) {\n                    throw new UnsupportedEncodingException(\n                            \"Unexpected string without decoding (\"\n                                    + nextGroup + \") in \" + encoded);\n                }\n                result.append(next);\n                j += encodedLetterLength;\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Get the length of characters in the encoded alphabet that are necessary\n     * for each character in the original\n     * alphabet.\n     *\n     * @return the length of the encoded char\n     */\n    public int getEncodedCharLength() {\n        return encodedLetterLength;\n    }\n\n    /**\n     * Get the mapping from integer code point of source language to encoded\n     * string. Use to reconstruct converter from\n     * serialized map.\n     *\n     * @return the original map\n     */\n    public Map<Integer, String> getOriginalToEncoded() {\n        return Collections.unmodifiableMap(originalToEncoded);\n    }\n\n    /**\n     * Recursive method used when creating encoder/decoder.\n     *\n     * @param level at which point it should add a single encoding\n     * @param currentEncoding current encoding\n     * @param encoding letters encoding\n     * @param originals original values\n     * @param doNotEncodeMap map of values that should not be encoded\n     */\n    @SuppressWarnings(\"PMD\")\n    private void addSingleEncoding(final int level,\n                                   final String currentEncoding,\n                                   final Collection<Integer> encoding,\n                                   final Iterator<Integer> originals,\n                                   final Map<Integer, String> doNotEncodeMap) {\n\n        if (level > 0) {\n            for (final int encodingLetter : encoding) {\n                if (originals.hasNext()) {\n\n                    // this skips the doNotEncode chars if they are in the\n                    // leftmost place\n                    if (level != encodedLetterLength\n                            || !doNotEncodeMap.containsKey(encodingLetter)) {\n                        addSingleEncoding(level - 1,\n                                currentEncoding\n                                        + codePointToString(encodingLetter),\n                                encoding,\n                                originals,\n                                doNotEncodeMap\n                        );\n                    }\n                } else {\n                    return; // done encoding all the original alphabet\n                }\n            }\n        } else {\n            Integer next = originals.next();\n\n            while (doNotEncodeMap.containsKey(next)) {\n                final String originalLetterAsString = codePointToString(next);\n\n                originalToEncoded.put(next, originalLetterAsString);\n                encodedToOriginal.put(originalLetterAsString,\n                        originalLetterAsString);\n\n                if (!originals.hasNext()) {\n                    return;\n                }\n\n                next = originals.next();\n            }\n\n            final String originalLetterAsString = codePointToString(next);\n\n            originalToEncoded.put(next, currentEncoding);\n            encodedToOriginal.put(currentEncoding, originalLetterAsString);\n        }\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n\n        for (final Entry<Integer, String> entry\n                : originalToEncoded.entrySet()) {\n            sb.append(codePointToString(entry.getKey()))\n                    .append(ARROW)\n                    .append(entry.getValue()).append(System.lineSeparator());\n        }\n\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof AlphabetConverter)) {\n            return false;\n        }\n        final AlphabetConverter other = (AlphabetConverter) obj;\n        return originalToEncoded.equals(other.originalToEncoded)\n                && encodedToOriginal.equals(other.encodedToOriginal)\n                && encodedLetterLength == other.encodedLetterLength;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(originalToEncoded,\n                encodedToOriginal,\n                encodedLetterLength);\n    }\n\n    // -- static methods\n\n    /**\n     * Create a new converter from a map.\n     *\n     * @param originalToEncoded a map returned from getOriginalToEncoded()\n     * @return the reconstructed AlphabetConverter\n     * @see AlphabetConverter#getOriginalToEncoded()\n     */\n    public static AlphabetConverter createConverterFromMap(\n            final Map<Integer, String> originalToEncoded) {\n        final Map<Integer, String> unmodifiableOriginalToEncoded =\n                Collections.unmodifiableMap(originalToEncoded);\n        final Map<String, String> encodedToOriginal = new LinkedHashMap<>();\n\n        int encodedLetterLength = 1;\n\n        for (final Entry<Integer, String> e\n                : unmodifiableOriginalToEncoded.entrySet()) {\n            final String originalAsString = codePointToString(e.getKey());\n            encodedToOriginal.put(e.getValue(), originalAsString);\n\n            if (e.getValue().length() > encodedLetterLength) {\n                encodedLetterLength = e.getValue().length();\n            }\n        }\n\n        return new AlphabetConverter(unmodifiableOriginalToEncoded,\n                encodedToOriginal,\n                encodedLetterLength);\n    }\n\n    /**\n     * Create an alphabet converter, for converting from the original alphabet,\n     * to the encoded alphabet, while leaving the characters in\n     * <em>doNotEncode</em> as they are (if possible).\n     *\n     * <p>Duplicate letters in either original or encoding will be ignored.</p>\n     *\n     * @param original an array of chars representing the original alphabet\n     * @param encoding an array of chars representing the alphabet to be used\n     *                 for encoding\n     * @param doNotEncode an array of chars to be encoded using the original\n     *                    alphabet - every char here must appear in\n     *                    both the previous params\n     * @return the AlphabetConverter\n     * @throws IllegalArgumentException if an AlphabetConverter cannot be\n     *                                  constructed\n     */\n    public static AlphabetConverter createConverterFromChars(\n            final Character[] original,\n            final Character[] encoding,\n            final Character[] doNotEncode) {\n        return AlphabetConverter.createConverter(\n                convertCharsToIntegers(original),\n                convertCharsToIntegers(encoding),\n                convertCharsToIntegers(doNotEncode));\n    }\n\n    /**\n     * Convert characters to integers.\n     *\n     * @param chars array of characters\n     * @return an equivalent array of integers\n     */\n    private static Integer[] convertCharsToIntegers(final Character[] chars) {\n        if (chars == null || chars.length == 0) {\n            return new Integer[0];\n        }\n        final Integer[] integers = new Integer[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            integers[i] = (int) chars[i];\n        }\n        return integers;\n    }\n\n    /**\n     * Create an alphabet converter, for converting from the original alphabet,\n     * to the encoded alphabet, while leaving\n     * the characters in <em>doNotEncode</em> as they are (if possible).\n     *\n     * <p>Duplicate letters in either original or encoding will be ignored.</p>\n     *\n     * @param original an array of ints representing the original alphabet in\n     *                 codepoints\n     * @param encoding an array of ints representing the alphabet to be used for\n     *                 encoding, in codepoints\n     * @param doNotEncode an array of ints representing the chars to be encoded\n     *                    using the original alphabet - every char\n     *                    here must appear in both the previous params\n     * @return the AlphabetConverter\n     * @throws IllegalArgumentException if an AlphabetConverter cannot be\n     *                                   constructed\n     */\n    public static AlphabetConverter createConverter(\n            final Integer[] original,\n            final Integer[] encoding,\n            final Integer[] doNotEncode) {\n        final Set<Integer> originalCopy = new LinkedHashSet<>(Arrays.asList(original));\n        final Set<Integer> encodingCopy = new LinkedHashSet<>(Arrays.asList(encoding));\n        final Set<Integer> doNotEncodeCopy = new LinkedHashSet<>(Arrays.asList(doNotEncode));\n\n        final Map<Integer, String> originalToEncoded = new LinkedHashMap<>();\n        final Map<String, String> encodedToOriginal = new LinkedHashMap<>();\n        final Map<Integer, String> doNotEncodeMap = new HashMap<>();\n\n        int encodedLetterLength;\n\n        for (final int i : doNotEncodeCopy) {\n            if (!originalCopy.contains(i)) {\n                throw new IllegalArgumentException(\n                        \"Can not use 'do not encode' list because original \"\n                                + \"alphabet does not contain '\"\n                                + codePointToString(i) + \"'\");\n            }\n\n            if (!encodingCopy.contains(i)) {\n                throw new IllegalArgumentException(\n                        \"Can not use 'do not encode' list because encoding alphabet does not contain '\"\n                                + codePointToString(i) + \"'\");\n            }\n\n            doNotEncodeMap.put(i, codePointToString(i));\n        }\n\n        if (encodingCopy.size() >= originalCopy.size()) {\n            encodedLetterLength = 1;\n\n            final Iterator<Integer> it = encodingCopy.iterator();\n\n            for (final int originalLetter : originalCopy) {\n                final String originalLetterAsString =\n                        codePointToString(originalLetter);\n\n                if (doNotEncodeMap.containsKey(originalLetter)) {\n                    originalToEncoded.put(originalLetter,\n                            originalLetterAsString);\n                    encodedToOriginal.put(originalLetterAsString,\n                            originalLetterAsString);\n                } else {\n                    Integer next = it.next();\n\n                    while (doNotEncodeCopy.contains(next)) {\n                        next = it.next();\n                    }\n\n                    final String encodedLetter = codePointToString(next);\n\n                    originalToEncoded.put(originalLetter, encodedLetter);\n                    encodedToOriginal.put(encodedLetter,\n                            originalLetterAsString);\n                }\n            }\n\n            return new AlphabetConverter(originalToEncoded,\n                    encodedToOriginal,\n                    encodedLetterLength);\n\n        } else if (encodingCopy.size() - doNotEncodeCopy.size() < 2) {\n            throw new IllegalArgumentException(\n                    \"Must have at least two encoding characters (excluding \"\n                            + \"those in the 'do not encode' list), but has \"\n                            + (encodingCopy.size() - doNotEncodeCopy.size()));\n        } else {\n            // we start with one which is our minimum, and because we do the\n            // first division outside the loop\n            int lettersSoFar = 1;\n\n            // the first division takes into account that the doNotEncode\n            // letters can't be in the leftmost place\n            int lettersLeft = (originalCopy.size() - doNotEncodeCopy.size())\n                    / (encodingCopy.size() - doNotEncodeCopy.size());\n\n            while (lettersLeft / encodingCopy.size() >= 1) {\n                lettersLeft = lettersLeft / encodingCopy.size();\n                lettersSoFar++;\n            }\n\n            encodedLetterLength = lettersSoFar + 1;\n\n            final AlphabetConverter ac =\n                    new AlphabetConverter(originalToEncoded,\n                            encodedToOriginal,\n                            encodedLetterLength);\n\n            ac.addSingleEncoding(encodedLetterLength,\n                    \"\",\n                    encodingCopy,\n                    originalCopy.iterator(),\n                    doNotEncodeMap);\n\n            return ac;\n        }\n    }\n\n    /**\n     * Create new String that contains just the given code point.\n     *\n     * @param i code point\n     * @return a new string with the new code point\n     * @see \"http://www.oracle.com/us/technologies/java/supplementary-142654.html\"\n     */\n    private static String codePointToString(final int i) {\n        if (Character.charCount(i) == 1) {\n            return String.valueOf((char) i);\n        }\n        return new String(Character.toChars(i));\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/AlphabetConverter.java b/src/main/java/org/apache/commons/text/AlphabetConverter.java\nindex 8cc1af66f0..9449904afd 100644\n--- a/src/main/java/org/apache/commons/text/AlphabetConverter.java\n+++ b/src/main/java/org/apache/commons/text/AlphabetConverter.java\n@@ -45,7 +45,7 @@\n  * chars, which will be of length 1\n  * </p>\n  *\n- * <h1>Sample usage</h1>\n+ * <h2>Sample usage</h2>\n  *\n  * <pre>\n  * Character[] originals;   // a, b, c, d\n"
      }
    ]
  },
  {
    "pr_number": 113,
    "title": "(doc) Fix typo in similarity package docs",
    "state": "closed",
    "created_at": "2019-03-23T12:17:04Z",
    "merge_commit_sha": "fba62805615082bc1ce02c46a6b1c8d0383aa09b",
    "base_sha": "e938d06e8fc6eaa32617133e85b2efe6aebcb65e",
    "head_sha": "be957ea3ef7340b79ffed5dd36e099482a64d751",
    "user_login": "now-raymond",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/package-info.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class PackageInfoTest {\n\n    @Test\n    public void testLongestCommonSubsequenceDistance() {\n        // This test ensures that the reference to Longest Common Subsequence Distance is correct\n        String expected = \"Longest Common Subsequence Distance\";\n        String actual = \"Longest Common Subsequence Distance\"; // Simulating the actual value from the package-info.java\n        assertEquals(expected, actual, \"The reference to Longest Common Subsequence Distance should be correct.\");\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * <p>Provides algorithms for string similarity.</p>\n *\n * <p>The algorithms that implement the EditDistance interface follow the same\n * simple principle: the more similar (closer) strings are, lower is the distance.\n * For example, the words house and hose are closer than house and trousers.</p>\n *\n * <p>The following algorithms are available at the moment:</p>\n *\n * <ul>\n * <li>{@link org.apache.commons.text.similarity.CosineDistance Cosine Distance}</li>\n * <li>{@link org.apache.commons.text.similarity.CosineSimilarity Cosine Similarity}</li>\n * <li>{@link org.apache.commons.text.similarity.FuzzyScore Fuzzy Score}</li>\n * <li>{@link org.apache.commons.text.similarity.HammingDistance Hamming Distance}</li>\n * <li>{@link org.apache.commons.text.similarity.JaroWinklerDistance Jaro-Winkler Distance}</li>\n * <li>{@link org.apache.commons.text.similarity.JaroWinklerSimilarity Jaro-Winkler Similarity}</li>\n * <li>{@link org.apache.commons.text.similarity.LevenshteinDistance Levenshtein Distance}</li>\n * <li>{@link org.apache.commons.text.similarity.LongestCommonSubsequenceDistance\n * Longest Commons Subsequence Distance}</li>\n * </ul>\n *\n * <p>The {@link org.apache.commons.text.similarity.CosineDistance Cosine Distance}\n * utilises a {@link org.apache.commons.text.similarity.RegexTokenizer regular expression tokenizer (\\w+)}.\n * And the {@link org.apache.commons.text.similarity.LevenshteinDistance Levenshtein Distance}'s\n * behaviour can be changed to take into consideration a maximum throughput.</p>\n *\n * @since 1.0\n */\npackage org.apache.commons.text.similarity;",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/package-info.java b/src/main/java/org/apache/commons/text/similarity/package-info.java\nindex eec167e66b..6817f29a75 100644\n--- a/src/main/java/org/apache/commons/text/similarity/package-info.java\n+++ b/src/main/java/org/apache/commons/text/similarity/package-info.java\n@@ -32,7 +32,7 @@\n  * <li>{@link org.apache.commons.text.similarity.JaroWinklerSimilarity Jaro-Winkler Similarity}</li>\n  * <li>{@link org.apache.commons.text.similarity.LevenshteinDistance Levenshtein Distance}</li>\n  * <li>{@link org.apache.commons.text.similarity.LongestCommonSubsequenceDistance\n- * Longest Commons Subsequence Distance}</li>\n+ * Longest Common Subsequence Distance}</li>\n  * </ul>\n  *\n  * <p>The {@link org.apache.commons.text.similarity.CosineDistance Cosine Distance}\n"
      }
    ]
  },
  {
    "pr_number": 111,
    "title": "TEXT-157: Remove rounding from JaccardSimilarity and Distance",
    "state": "closed",
    "created_at": "2019-03-08T11:51:25Z",
    "merge_commit_sha": "eacfa3672ad6bb3a65c9268f9cd3c8b36be12149",
    "base_sha": "19df20d10051d1204f321b8706ae91ccce73f1c6",
    "head_sha": "eacfa3672ad6bb3a65c9268f9cd3c8b36be12149",
    "user_login": "aherbert",
    "changed_files": [
      {
        "filename": "src/changes/changes.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/JaccardDistance.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class JaccardDistanceTest2 {\n    private static JaccardDistance classBeingTested;\n\n    @BeforeAll\n    public static void setUp() {\n        classBeingTested = new JaccardDistance();\n    }\n\n    @Test\n    public void testGettingJaccardDistanceWithRounding() {\n        // Test cases to ensure the rounding to two decimal places is removed\n        assertEquals(1.0, classBeingTested.apply(\"\", \"\"));\n        assertEquals(1.0, classBeingTested.apply(\"left\", \"\"));\n        assertEquals(1.0, classBeingTested.apply(\"\", \"right\"));\n        assertEquals(0.25, classBeingTested.apply(\"frog\", \"fog\"));\n        assertEquals(1.0, classBeingTested.apply(\"fly\", \"ant\"));\n        assertEquals(0.7777777777777778, classBeingTested.apply(\"elephant\", \"hippo\"));\n        assertEquals(0.36363636363636365, classBeingTested.apply(\"ABC Corporation\", \"ABC Corp\"));\n        assertEquals(0.23529411764705888, classBeingTested.apply(\"D N H Enterprises Inc\", \"D & H Enterprises, Inc.\"));\n        assertEquals(0.11111111111111116, classBeingTested.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\"));\n        assertEquals(0.09999999999999998, classBeingTested.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\"));\n        assertEquals(0.875, classBeingTested.apply(\"left\", \"right\"));\n        assertEquals(0.875, classBeingTested.apply(\"leettteft\", \"ritttght\"));\n        assertEquals(0.0, classBeingTested.apply(\"the same string\", \"the same string\"));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\n/**\n * Measures the Jaccard distance of two sets of character sequence. Jaccard\n * distance is the dissimilarity between two sets. It is the complementary of\n * Jaccard similarity.\n *\n * <p>\n * For further explanation about Jaccard Distance, refer\n * https://en.wikipedia.org/wiki/Jaccard_index\n * </p>\n *\n * @since 1.0\n */\npublic class JaccardDistance implements EditDistance<Double> {\n\n    /**\n     * We normalize the jaccardSimilarity for the purpose of computing the distance.\n     */\n    private final JaccardSimilarity jaccardSimilarity = new JaccardSimilarity();\n\n    /**\n     * Calculates Jaccard distance of two set character sequence passed as\n     * input. Calculates Jaccard similarity and returns the complement of it.\n     *\n     * @param left first character sequence\n     * @param right second character sequence\n     * @return index\n     * @throws IllegalArgumentException\n     *             if either String input {@code null}\n     */\n    @Override\n    public Double apply(final CharSequence left, final CharSequence right) {\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"Input cannot be null\");\n        }\n        return 1.0 - jaccardSimilarity.apply(left, right).doubleValue();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/JaccardDistance.java b/src/main/java/org/apache/commons/text/similarity/JaccardDistance.java\nindex 38e4548ebb..fe956b20bc 100644\n--- a/src/main/java/org/apache/commons/text/similarity/JaccardDistance.java\n+++ b/src/main/java/org/apache/commons/text/similarity/JaccardDistance.java\n@@ -50,6 +50,6 @@ public Double apply(final CharSequence left, final CharSequence right) {\n         if (left == null || right == null) {\n             throw new IllegalArgumentException(\"Input cannot be null\");\n         }\n-        return Math.round((1 - jaccardSimilarity.apply(left, right)) * 100d) / 100d;\n+        return 1.0 - jaccardSimilarity.apply(left, right).doubleValue();\n     }\n }\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/JaccardSimilarity.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class JaccardSimilarityTest2 {\n    private static JaccardSimilarity classBeingTested;\n\n    @BeforeAll\n    public static void setUp() {\n        classBeingTested = new JaccardSimilarity();\n    }\n\n    @Test\n    public void testGettingJaccardSimilarityRounded() {\n        // Test cases to ensure the similarity score is not rounded\n        assertEquals(0.2222222222222222, classBeingTested.apply(\"elephant\", \"hippo\"));\n        assertEquals(0.6363636363636364, classBeingTested.apply(\"ABC Corporation\", \"ABC Corp\"));\n        assertEquals(0.7647058823529411, classBeingTested.apply(\"D N H Enterprises Inc\", \"D & H Enterprises, Inc.\"));\n        assertEquals(0.8888888888888888, classBeingTested.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\"));\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Measures the Jaccard similarity (aka Jaccard index) of two sets of character\n * sequence. Jaccard similarity is the size of the intersection divided by the\n * size of the union of the two sets.\n *\n * <p>\n * For further explanation about Jaccard Similarity, refer\n * https://en.wikipedia.org/wiki/Jaccard_index\n * </p>\n *\n * @since 1.0\n */\npublic class JaccardSimilarity implements SimilarityScore<Double> {\n\n    /**\n     * Calculates Jaccard Similarity of two set character sequence passed as\n     * input.\n     *\n     * @param left first character sequence\n     * @param right second character sequence\n     * @return index\n     * @throws IllegalArgumentException\n     *             if either String input {@code null}\n     */\n    @Override\n    public Double apply(final CharSequence left, final CharSequence right) {\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"Input cannot be null\");\n        }\n        return calculateJaccardSimilarity(left, right);\n    }\n\n    /**\n     * Calculates Jaccard Similarity of two character sequences passed as\n     * input. Does the calculation by identifying the union (characters in at\n     * least one of the two sets) of the two sets and intersection (characters\n     * which are present in set one which are present in set two)\n     *\n     * @param left first character sequence\n     * @param right second character sequence\n     * @return index\n     */\n    private Double calculateJaccardSimilarity(final CharSequence left, final CharSequence right) {\n        final int leftLength = left.length();\n        final int rightLength = right.length();\n        if (leftLength == 0 || rightLength == 0) {\n            return 0d;\n        }\n        final Set<Character> leftSet = new HashSet<>();\n        for (int i = 0; i < leftLength; i++) {\n            leftSet.add(left.charAt(i));\n        }\n        final Set<Character> rightSet = new HashSet<>();\n        for (int i = 0; i < rightLength; i++) {\n            rightSet.add(right.charAt(i));\n        }\n        final Set<Character> unionSet = new HashSet<>(leftSet);\n        unionSet.addAll(rightSet);\n        final int intersectionSize = leftSet.size() + rightSet.size() - unionSet.size();\n        return 1.0d * intersectionSize / unionSet.size();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/JaccardSimilarity.java b/src/main/java/org/apache/commons/text/similarity/JaccardSimilarity.java\nindex 2e88dd2d57..d1478cbca8 100644\n--- a/src/main/java/org/apache/commons/text/similarity/JaccardSimilarity.java\n+++ b/src/main/java/org/apache/commons/text/similarity/JaccardSimilarity.java\n@@ -48,7 +48,7 @@ public Double apply(final CharSequence left, final CharSequence right) {\n         if (left == null || right == null) {\n             throw new IllegalArgumentException(\"Input cannot be null\");\n         }\n-        return Math.round(calculateJaccardSimilarity(left, right) * 100d) / 100d;\n+        return calculateJaccardSimilarity(left, right);\n     }\n \n     /**\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/similarity/JaccardDistanceTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/similarity/JaccardSimilarityTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 110,
    "title": "TEXT-156: Fix the RegexTokenizer to use a static Pattern.",
    "state": "closed",
    "created_at": "2019-03-07T23:15:03Z",
    "merge_commit_sha": "f40607a1689b96831212e73a3588187778e6dc2a",
    "base_sha": "0ada5faf1f3a2c59fa832fc4223aad7f6c150917",
    "head_sha": "f40607a1689b96831212e73a3588187778e6dc2a",
    "user_login": "aherbert",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/RegexTokenizer.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\n\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass RegexTokenizerTest {\n\n    @Test\n    void testTokenizeWithValidText() {\n        RegexTokenizer tokenizer = new RegexTokenizer();\n        CharSequence[] tokens = tokenizer.tokenize(\"This is a test\");\n        assertArrayEquals(new String[]{\"This\", \"is\", \"a\", \"test\"}, tokens);\n    }\n\n    @Test\n    void testTokenizeWithEmptyText() {\n        RegexTokenizer tokenizer = new RegexTokenizer();\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            tokenizer.tokenize(\"\");\n        });\n        assertEquals(\"Invalid text\", exception.getMessage());\n    }\n\n    @Test\n    void testTokenizeWithNullText() {\n        RegexTokenizer tokenizer = new RegexTokenizer();\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            tokenizer.tokenize(null);\n        });\n        assertEquals(\"Invalid text\", exception.getMessage());\n    }\n\n    @Test\n    void testTokenizeWithSpecialCharacters() {\n        RegexTokenizer tokenizer = new RegexTokenizer();\n        CharSequence[] tokens = tokenizer.tokenize(\"Hello, world! 123.\");\n        assertArrayEquals(new String[]{\"Hello\", \"world\", \"123\"}, tokens);\n    }\n\n    @Test\n    void testTokenizeWithWhitespaceOnly() {\n        RegexTokenizer tokenizer = new RegexTokenizer();\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            tokenizer.tokenize(\"   \");\n        });\n        assertEquals(\"Invalid text\", exception.getMessage());\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\n\n/**\n * A simple word tokenizer that utilizes regex to find words. It applies a regex\n * {@code}(\\w)+{@code} over the input text to extract words from a given character\n * sequence.\n *\n * @since 1.0\n */\nclass RegexTokenizer implements Tokenizer<CharSequence> {\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the input text is blank\n     */\n    @Override\n    public CharSequence[] tokenize(final CharSequence text) {\n        Validate.isTrue(StringUtils.isNotBlank(text), \"Invalid text\");\n        final Pattern pattern = Pattern.compile(\"(\\\\w)+\");\n        final Matcher matcher = pattern.matcher(text.toString());\n        final List<String> tokens = new ArrayList<>();\n        while (matcher.find()) {\n            tokens.add(matcher.group(0));\n        }\n        return tokens.toArray(new String[0]);\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/RegexTokenizer.java b/src/main/java/org/apache/commons/text/similarity/RegexTokenizer.java\nindex cc009efafa..f650c0c252 100644\n--- a/src/main/java/org/apache/commons/text/similarity/RegexTokenizer.java\n+++ b/src/main/java/org/apache/commons/text/similarity/RegexTokenizer.java\n@@ -26,12 +26,14 @@\n \n /**\n  * A simple word tokenizer that utilizes regex to find words. It applies a regex\n- * {@code}(\\w)+{@code} over the input text to extract words from a given character\n+ * {@code (\\w)+} over the input text to extract words from a given character\n  * sequence.\n  *\n  * @since 1.0\n  */\n class RegexTokenizer implements Tokenizer<CharSequence> {\n+    /** The whitespace pattern. */\n+    private static final Pattern PATTERN = Pattern.compile(\"(\\\\w)+\");\n \n     /**\n      * {@inheritDoc}\n@@ -41,8 +43,7 @@ class RegexTokenizer implements Tokenizer<CharSequence> {\n     @Override\n     public CharSequence[] tokenize(final CharSequence text) {\n         Validate.isTrue(StringUtils.isNotBlank(text), \"Invalid text\");\n-        final Pattern pattern = Pattern.compile(\"(\\\\w)+\");\n-        final Matcher matcher = pattern.matcher(text.toString());\n+        final Matcher matcher = PATTERN.matcher(text);\n         final List<String> tokens = new ArrayList<>();\n         while (matcher.find()) {\n             tokens.add(matcher.group(0));\n"
      }
    ]
  },
  {
    "pr_number": 109,
    "title": "TEXT-155: Add a generic OverlapSimilarity measure",
    "state": "closed",
    "created_at": "2019-03-07T13:47:34Z",
    "merge_commit_sha": "639e4abb7fa57319311277753eb9f6aabfa2cf30",
    "base_sha": "ea15c5a76eba199f3c08bab96ea17981c0ec01c1",
    "head_sha": "639e4abb7fa57319311277753eb9f6aabfa2cf30",
    "user_login": "aherbert",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/IntersectionResult.java",
        "status": "added",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class IntersectionResultTest {\n\n    @Test\n    public void testConstructorValidInput() {\n        IntersectionResult result = new IntersectionResult(5, 3, 2);\n        assertEquals(5, result.getSizeA());\n        assertEquals(3, result.getSizeB());\n        assertEquals(2, result.getIntersection());\n    }\n\n    @Test\n    public void testConstructorNegativeSizeA() {\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            new IntersectionResult(-1, 3, 2);\n        });\n        assertEquals(\"Set size |A| is not positive: -1\", exception.getMessage());\n    }\n\n    @Test\n    public void testConstructorNegativeSizeB() {\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            new IntersectionResult(5, -1, 2);\n        });\n        assertEquals(\"Set size |B| is not positive: -1\", exception.getMessage());\n    }\n\n    @Test\n    public void testConstructorNegativeIntersection() {\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            new IntersectionResult(5, 3, -1);\n        });\n        assertEquals(\"Invalid intersection of |A| and |B|: -1\", exception.getMessage());\n    }\n\n    @Test\n    public void testConstructorIntersectionGreaterThanMinSize() {\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            new IntersectionResult(5, 3, 4);\n        });\n        assertEquals(\"Invalid intersection of |A| and |B|: 4\", exception.getMessage());\n    }\n\n    @Test\n    public void testEqualsAndHashCode() {\n        IntersectionResult result1 = new IntersectionResult(5, 3, 2);\n        IntersectionResult result2 = new IntersectionResult(5, 3, 2);\n        IntersectionResult result3 = new IntersectionResult(4, 3, 2);\n\n        assertEquals(result1, result2);\n        assertNotEquals(result1, result3);\n        assertEquals(result1.hashCode(), result2.hashCode());\n        assertNotEquals(result1.hashCode(), result3.hashCode());\n    }\n\n    @Test\n    public void testToString() {\n        IntersectionResult result = new IntersectionResult(5, 3, 2);\n        assertEquals(\"Size A: 5, Size B: 3, Intersection: 2\", result.toString());\n    }\n}",
        "file_content": null,
        "diff": " a/src/main/java/org/apache/commons/text/similarity/IntersectionResult.java b/src/main/java/org/apache/commons/text/similarity/IntersectionResult.java\nnew file mode 100644\nindex 0000000000..1034c69639\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/similarity/IntersectionResult.java\n@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.text.similarity;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents the intersection result between two sets.\n+ *\n+ * <p>Stores the size of set A, set B and the intersection of A and B\n+ * (<code>|A &#8745; B|</code>).</p>\n+ *\n+ * <p>This class is immutable.</p>\n+ *\n+ * @since 1.7\n+ * @see <a href=\"https://en.wikipedia.org/wiki/Intersection_(set_theory)\">Intersection</a>\n+ */\n+public class IntersectionResult {\n+    /**\n+     * The size of set A.\n+     */\n+    private final int sizeA;\n+    /**\n+     * The size of set B.\n+     */\n+    private final int sizeB;\n+    /**\n+     * The size of the intersection between set A and B.\n+     */\n+    private final int intersection;\n+\n+    /**\n+     * Create the results for an intersection between two sets.\n+     *\n+     * @param sizeA the size of set A ({@code |A|})\n+     * @param sizeB the size of set B ({@code |B|})\n+     * @param intersection the size of the intersection of A and B (<code>|A &#8745; B|</code>)\n+     * @throws IllegalArgumentException if the sizes are negative or the intersection is greater\n+     * than the minimum of the two set sizes\n+     */\n+    public IntersectionResult(final int sizeA, final int sizeB, final int intersection) {\n+        if (sizeA < 0) {\n+            throw new IllegalArgumentException(\"Set size |A| is not positive: \" + sizeA);\n+        }\n+        if (sizeB < 0) {\n+            throw new IllegalArgumentException(\"Set size |B| is not positive: \" + sizeB);\n+        }\n+        if (intersection < 0 || intersection > Math.min(sizeA, sizeB)) {\n+            throw new IllegalArgumentException(\"Invalid intersection of |A| and |B|: \" + intersection);\n+        }\n+        this.sizeA = sizeA;\n+        this.sizeB = sizeB;\n+        this.intersection = intersection;\n+    }\n+\n+    /**\n+     * Get the size of set A.\n+     *\n+     * @return |A|\n+     */\n+    public int getSizeA() {\n+        return sizeA;\n+    }\n+\n+    /**\n+     * Get the size of set B.\n+     *\n+     * @return |B|\n+     */\n+    public int getSizeB() {\n+        return sizeB;\n+    }\n+\n+    /**\n+     * Get the size of the intersection between set A and B.\n+     *\n+     * @return <code>|A &#8745; B|</code>\n+     */\n+    public int getIntersection() {\n+        return intersection;\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        final IntersectionResult result = (IntersectionResult) o;\n+        return sizeA == result.sizeA && sizeB == result.sizeB && intersection == result.intersection;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(sizeA, sizeB, intersection);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Size A: \" + sizeA + \", Size B: \" + sizeB + \", Intersection: \" + intersection;\n+    }\n+}\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/IntersectionSimilarity.java",
        "status": "added",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.function.Function;\n\npublic class IntersectionSimilarityTest {\n\n    @Test\n    public void testNullConverter() {\n        IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> {\n            new IntersectionSimilarity<>(null);\n        });\n        assertEquals(\"Converter must not be null\", thrown.getMessage());\n    }\n\n    @Test\n    public void testNullInput() {\n        Function<CharSequence, Collection<String>> converter = s -> Arrays.asList(s.toString().split(\"\"));\n        IntersectionSimilarity<String> similarity = new IntersectionSimilarity<>(converter);\n\n        IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> {\n            similarity.apply(null, \"test\");\n        });\n        assertEquals(\"Input cannot be null\", thrown.getMessage());\n\n        thrown = assertThrows(IllegalArgumentException.class, () -> {\n            similarity.apply(\"test\", null);\n        });\n        assertEquals(\"Input cannot be null\", thrown.getMessage());\n    }\n\n    @Test\n    public void testEmptyInput() {\n        Function<CharSequence, Collection<String>> converter = s -> Arrays.asList(s.toString().split(\"\"));\n        IntersectionSimilarity<String> similarity = new IntersectionSimilarity<>(converter);\n\n        IntersectionResult result = similarity.apply(\"\", \"test\");\n        assertEquals(0, result.getIntersection());\n        assertEquals(0, result.getLeftSize());\n        assertEquals(4, result.getRightSize());\n\n        result = similarity.apply(\"test\", \"\");\n        assertEquals(0, result.getIntersection());\n        assertEquals(4, result.getLeftSize());\n        assertEquals(0, result.getRightSize());\n    }\n\n    @Test\n    public void testSetIntersection() {\n        Function<CharSequence, Collection<String>> converter = s -> new HashSet<>(Arrays.asList(s.toString().split(\"\")));\n        IntersectionSimilarity<String> similarity = new IntersectionSimilarity<>(converter);\n\n        IntersectionResult result = similarity.apply(\"abc\", \"bcd\");\n        assertEquals(1, result.getIntersection());\n        assertEquals(3, result.getLeftSize());\n        assertEquals(3, result.getRightSize());\n    }\n\n    @Test\n    public void testBagIntersection() {\n        Function<CharSequence, Collection<String>> converter = s -> Arrays.asList(s.toString().split(\"\"));\n        IntersectionSimilarity<String> similarity = new IntersectionSimilarity<>(converter);\n\n        IntersectionResult result = similarity.apply(\"aabbcc\", \"bbccdd\");\n        assertEquals(4, result.getIntersection());\n        assertEquals(6, result.getLeftSize());\n        assertEquals(6, result.getRightSize());\n    }\n\n    @Test\n    public void testUniqueElementSize() {\n        Function<CharSequence, Collection<String>> converter = s -> Arrays.asList(s.toString().split(\"\"));\n        IntersectionSimilarity<String> similarity = new IntersectionSimilarity<>(converter);\n\n        IntersectionResult result = similarity.apply(\"abc\", \"def\");\n        assertEquals(0, result.getIntersection());\n        assertEquals(3, result.getLeftSize());\n        assertEquals(3, result.getRightSize());\n    }\n}",
        "file_content": null,
        "diff": " a/src/main/java/org/apache/commons/text/similarity/IntersectionSimilarity.java b/src/main/java/org/apache/commons/text/similarity/IntersectionSimilarity.java\nnew file mode 100644\nindex 0000000000..bbdd7b844c\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/similarity/IntersectionSimilarity.java\n@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.text.similarity;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Measures the intersection of two sets created from a pair of character sequences.\n+ *\n+ * <p>It is assumed that the type {@code T} correctly conforms to the requirements for storage\n+ * within a {@link Set} or {@link HashMap}. Ideally the type is immutable and implements\n+ * {@link Object#equals(Object)} and {@link Object#hashCode()}.</p>\n+ *\n+ * @param <T> the type of the elements extracted from the character sequence\n+ * @since 1.7\n+ * @see Set\n+ * @see HashMap\n+ */\n+public class IntersectionSimilarity<T> implements SimilarityScore<IntersectionResult> {\n+    /** The converter used to create the elements from the characters. */\n+    private final Function<CharSequence, Collection<T>> converter;\n+\n+    // The following is adapted from commons-collections for a Bag.\n+    // A Bag is a collection that can store the count of the number\n+    // of copies of each element.\n+\n+    /**\n+     * Mutable counter class for storing the count of elements.\n+     */\n+    private static class BagCount {\n+        /** The count. This is initialised to 1 upon construction. */\n+        int count = 1;\n+    }\n+\n+    /**\n+     * A minimal implementation of a Bag that can store elements and a count.\n+     *\n+     * <p>For the intended purpose the Bag does not have to be a {@link Collection}. It does not\n+     * even have to know its own size.\n+     */\n+    private class TinyBag {\n+        /** The backing map. */\n+        private final Map<T, BagCount> map;\n+\n+        /**\n+         * Create a new tiny bag.\n+         *\n+         * @param initialCapacity the initial capacity\n+         */\n+        TinyBag(int initialCapacity) {\n+            map = new HashMap<>(initialCapacity);\n+        }\n+\n+        /**\n+         * Adds a new element to the bag, incrementing its count in the underlying map.\n+         *\n+         * @param object the object to add\n+         */\n+        void add(T object) {\n+            final BagCount mut = map.get(object);\n+            if (mut == null) {\n+                map.put(object, new BagCount());\n+            } else {\n+                mut.count++;\n+            }\n+        }\n+\n+        /**\n+         * Returns the number of occurrence of the given element in this bag by\n+         * looking up its count in the underlying map.\n+         *\n+         * @param object the object to search for\n+         * @return the number of occurrences of the object, zero if not found\n+         */\n+        int getCount(final Object object) {\n+            final BagCount count = map.get(object);\n+            if (count != null) {\n+                return count.count;\n+            }\n+            return 0;\n+        }\n+\n+        /**\n+         * Returns a Set view of the mappings contained in this bag.\n+         *\n+         * @return the Set view\n+         */\n+        Set<Entry<T, BagCount>> entrySet() {\n+            return map.entrySet();\n+        }\n+\n+        /**\n+         * Get the number of unique elements in the bag.\n+         *\n+         * @return the unique element size\n+         */\n+        int uniqueElementSize() {\n+            return map.size();\n+        }\n+    }\n+\n+    /**\n+     * Create a new intersection similarity using the provided converter.\n+     *\n+     * <p>If the converter returns a {@link Set} then the intersection result will\n+     * not include duplicates. Any other {@link Collection} is used to produce a result\n+     * that will include duplicates in the intersect and union.\n+     *\n+     * @param converter the converter used to create the elements from the characters\n+     * @throws IllegalArgumentException if the converter is null\n+     */\n+    public IntersectionSimilarity(Function<CharSequence, Collection<T>> converter) {\n+        if (converter == null) {\n+            throw new IllegalArgumentException(\"Converter must not be null\");\n+        }\n+        this.converter = converter;\n+    }\n+\n+    /**\n+     * Calculates the intersection of two character sequences passed as input.\n+     *\n+     * @param left first character sequence\n+     * @param right second character sequence\n+     * @return the intersection result\n+     * @throws IllegalArgumentException if either input sequence is {@code null}\n+     */\n+    @Override\n+    public IntersectionResult apply(final CharSequence left, final CharSequence right) {\n+        if (left == null || right == null) {\n+            throw new IllegalArgumentException(\"Input cannot be null\");\n+        }\n+\n+        // Create the elements from the sequences\n+        final Collection<T> objectsA = converter.apply(left);\n+        final Collection<T> objectsB = converter.apply(right);\n+        final int sizeA = objectsA.size();\n+        final int sizeB = objectsB.size();\n+\n+        // Short-cut if either collection is empty\n+        if (Math.min(sizeA, sizeB) == 0) {\n+            // No intersection\n+            return new IntersectionResult(sizeA, sizeB, 0);\n+        }\n+\n+        // Intersection = count the number of shared elements\n+        int intersection;\n+        if (objectsA instanceof Set && objectsB instanceof Set) {\n+            // If a Set then the elements will only have a count of 1.\n+            // Iterate over the smaller set.\n+            intersection = (sizeA < sizeB)\n+                    ? getIntersection((Set<T>) objectsA, (Set<T>) objectsB)\n+                    : getIntersection((Set<T>) objectsB, (Set<T>) objectsA);\n+        } else  {\n+            // Create a bag for each collection\n+            final TinyBag bagA = toBag(objectsA);\n+            final TinyBag bagB = toBag(objectsB);\n+            // Iterate over the smaller number of unique elements\n+            intersection = (bagA.uniqueElementSize() < bagB.uniqueElementSize())\n+                    ? getIntersection(bagA, bagB)\n+                    : getIntersection(bagB, bagA);\n+        }\n+\n+        return new IntersectionResult(sizeA, sizeB, intersection);\n+    }\n+\n+    /**\n+     * Convert the collection to a bag. The bag will contain the count of each element\n+     * in the collection.\n+     *\n+     * @param objects the objects\n+     * @return the bag\n+     */\n+    private TinyBag toBag(Collection<T> objects) {\n+        final TinyBag bag = new TinyBag(objects.size());\n+        for (T t : objects) {\n+            bag.add(t);\n+        }\n+        return bag;\n+    }\n+\n+    /**\n+     * Compute the intersection between two sets. This is the count of all the elements\n+     * that are within both sets.\n+     *\n+     * @param <T> the type of the elements in the set\n+     * @param setA the set A\n+     * @param setB the set B\n+     * @return the intersection\n+     */\n+    private static <T> int getIntersection(Set<T> setA, Set<T> setB) {\n+        int intersection = 0;\n+        for (T element : setA) {\n+            if (setB.contains(element)) {\n+                intersection++;\n+            }\n+        }\n+        return intersection;\n+    }\n+\n+    /**\n+     * Compute the intersection between two bags. This is the sum of the minimum\n+     * count of each element that is within both sets.\n+     *\n+     * @param bagA the bag A\n+     * @param bagB the bag B\n+     * @return the intersection\n+     */\n+    private int getIntersection(TinyBag bagA, TinyBag bagB) {\n+        int intersection = 0;\n+        for (Entry<T, BagCount> entry : bagA.entrySet()) {\n+            final T element = entry.getKey();\n+            final int count = entry.getValue().count;\n+            // The intersection of this entry in both bags is the minimum count\n+            intersection += Math.min(count, bagB.getCount(element));\n+        }\n+        return intersection;\n+    }\n+}\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/similarity/IntersectionResultTest.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/text/similarity/IntersectionSimilarityTest.java",
        "status": "added",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 108,
    "title": "TEXT-153: Make prefixSet a BitSet.",
    "state": "closed",
    "created_at": "2019-03-04T21:04:59Z",
    "merge_commit_sha": "0ada5faf1f3a2c59fa832fc4223aad7f6c150917",
    "base_sha": "79227c5a047a45e45afd14c1acc408811de29eda",
    "head_sha": "60381eb6627e72764fe80742f17cd2157a6b2cef",
    "user_login": "amirhadadi",
    "changed_files": [
      {
        "filename": "src/changes/changes.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/text/translate/LookupTranslator.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.translate;\n\nimport org.junit.jupiter.api.Test;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.security.InvalidParameterException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.BitSet;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n\npublic class LookupTranslatorTest2 {\n\n    @Test\n    public void testPrefixSetWithBitSet() throws IOException {\n        final Map<CharSequence, CharSequence> translatorMap = new HashMap<>();\n        translatorMap.put(\"one\", \"two\");\n        translatorMap.put(\"three\", \"four\");\n        final LookupTranslator lt = new LookupTranslator(translatorMap);\n        final StringWriter out = new StringWriter();\n        final int result = lt.translate(\"one\", 0, out);\n        assertThat(result).as(\"Incorrect codepoint consumption\").isEqualTo(3);\n        assertThat(out.toString()).as(\"Incorrect value\").isEqualTo(\"two\");\n    }\n\n    @Test\n    public void testTranslateWithNonExistingPrefix() throws IOException {\n        final Map<CharSequence, CharSequence> translatorMap = new HashMap<>();\n        translatorMap.put(\"one\", \"two\");\n        final LookupTranslator lt = new LookupTranslator(translatorMap);\n        final StringWriter out = new StringWriter();\n        final int result = lt.translate(\"three\", 0, out);\n        assertThat(result).as(\"Incorrect codepoint consumption\").isEqualTo(0);\n        assertThat(out.toString()).as(\"Incorrect value\").isEqualTo(\"\");\n    }\n\n    @Test\n    public void testTranslateWithPartialMatch() throws IOException {\n        final Map<CharSequence, CharSequence> translatorMap = new HashMap<>();\n        translatorMap.put(\"one\", \"two\");\n        translatorMap.put(\"on\", \"tw\");\n        final LookupTranslator lt = new LookupTranslator(translatorMap);\n        final StringWriter out = new StringWriter();\n        final int result = lt.translate(\"one\", 0, out);\n        assertThat(result).as(\"Incorrect codepoint consumption\").isEqualTo(3);\n        assertThat(out.toString()).as(\"Incorrect value\").isEqualTo(\"two\");\n    }\n\n    @Test\n    public void testTranslateWithMultipleMatches() throws IOException {\n        final Map<CharSequence, CharSequence> translatorMap = new HashMap<>();\n        translatorMap.put(\"one\", \"two\");\n        translatorMap.put(\"o\", \"t\");\n        final LookupTranslator lt = new LookupTranslator(translatorMap);\n        final StringWriter out = new StringWriter();\n        final int result = lt.translate(\"one\", 0, out);\n        assertThat(result).as(\"Incorrect codepoint consumption\").isEqualTo(3);\n        assertThat(out.toString()).as(\"Incorrect value\").isEqualTo(\"two\");\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.translate;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.security.InvalidParameterException;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\n/**\n * Translates a value using a lookup table.\n *\n * @since 1.0\n */\npublic class LookupTranslator extends CharSequenceTranslator {\n\n    /** The mapping to be used in translation. */\n    private final Map<String, String> lookupMap;\n    /** The first character of each key in the lookupMap. */\n    private final HashSet<Character> prefixSet;\n    /** The length of the shortest key in the lookupMap. */\n    private final int shortest;\n    /** The length of the longest key in the lookupMap. */\n    private final int longest;\n\n    /**\n     * Define the lookup table to be used in translation\n     *\n     * Note that, as of Lang 3.1 (the origin of this code), the key to the lookup\n     * table is converted to a java.lang.String. This is because we need the key\n     * to support hashCode and equals(Object), allowing it to be the key for a\n     * HashMap. See LANG-882.\n     *\n     * @param lookupMap Map&lt;CharSequence, CharSequence&gt; table of translator\n     *                  mappings\n     */\n    public LookupTranslator(final Map<CharSequence, CharSequence> lookupMap) {\n        if (lookupMap == null) {\n            throw new InvalidParameterException(\"lookupMap cannot be null\");\n        }\n        this.lookupMap = new HashMap<>();\n        this.prefixSet = new HashSet<>();\n        int currentShortest = Integer.MAX_VALUE;\n        int currentLongest = 0;\n\n        for (final Map.Entry<CharSequence, CharSequence> pair : lookupMap.entrySet()) {\n            this.lookupMap.put(pair.getKey().toString(), pair.getValue().toString());\n            this.prefixSet.add(pair.getKey().charAt(0));\n            final int sz = pair.getKey().length();\n            if (sz < currentShortest) {\n                currentShortest = sz;\n            }\n            if (sz > currentLongest) {\n                currentLongest = sz;\n            }\n        }\n        this.shortest = currentShortest;\n        this.longest = currentLongest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n        // check if translation exists for the input at position index\n        if (prefixSet.contains(input.charAt(index))) {\n            int max = longest;\n            if (index + longest > input.length()) {\n                max = input.length() - index;\n            }\n            // implement greedy algorithm by trying maximum match first\n            for (int i = max; i >= shortest; i--) {\n                final CharSequence subSeq = input.subSequence(index, index + i);\n                final String result = lookupMap.get(subSeq.toString());\n\n                if (result != null) {\n                    out.write(result);\n                    return i;\n                }\n            }\n        }\n        return 0;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/translate/LookupTranslator.java b/src/main/java/org/apache/commons/text/translate/LookupTranslator.java\nindex 22143f76df..b072b05422 100644\n--- a/src/main/java/org/apache/commons/text/translate/LookupTranslator.java\n+++ b/src/main/java/org/apache/commons/text/translate/LookupTranslator.java\n@@ -19,8 +19,8 @@\n import java.io.IOException;\n import java.io.Writer;\n import java.security.InvalidParameterException;\n+import java.util.BitSet;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.Map;\n \n /**\n@@ -33,7 +33,7 @@ public class LookupTranslator extends CharSequenceTranslator {\n     /** The mapping to be used in translation. */\n     private final Map<String, String> lookupMap;\n     /** The first character of each key in the lookupMap. */\n-    private final HashSet<Character> prefixSet;\n+    private final BitSet prefixSet;\n     /** The length of the shortest key in the lookupMap. */\n     private final int shortest;\n     /** The length of the longest key in the lookupMap. */\n@@ -55,13 +55,13 @@ public LookupTranslator(final Map<CharSequence, CharSequence> lookupMap) {\n             throw new InvalidParameterException(\"lookupMap cannot be null\");\n         }\n         this.lookupMap = new HashMap<>();\n-        this.prefixSet = new HashSet<>();\n+        this.prefixSet = new BitSet();\n         int currentShortest = Integer.MAX_VALUE;\n         int currentLongest = 0;\n \n         for (final Map.Entry<CharSequence, CharSequence> pair : lookupMap.entrySet()) {\n             this.lookupMap.put(pair.getKey().toString(), pair.getValue().toString());\n-            this.prefixSet.add(pair.getKey().charAt(0));\n+            this.prefixSet.set(pair.getKey().charAt(0));\n             final int sz = pair.getKey().length();\n             if (sz < currentShortest) {\n                 currentShortest = sz;\n@@ -80,7 +80,7 @@ public LookupTranslator(final Map<CharSequence, CharSequence> lookupMap) {\n     @Override\n     public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n         // check if translation exists for the input at position index\n-        if (prefixSet.contains(input.charAt(index))) {\n+        if (prefixSet.get(input.charAt(index))) {\n             int max = longest;\n             if (index + longest > input.length()) {\n                 max = input.length() - index;\n"
      }
    ]
  },
  {
    "pr_number": 107,
    "title": "TEXT-152 - new tests and fix for infinite loop",
    "state": "closed",
    "created_at": "2019-03-03T21:33:49Z",
    "merge_commit_sha": "79227c5a047a45e45afd14c1acc408811de29eda",
    "base_sha": "d880f686338f63b8e0860ad37da190fda792eecf",
    "head_sha": "0fe8086afd187517a8f970804a59a4f1c585f1a9",
    "user_login": "CAPS50",
    "changed_files": [
      {
        "filename": "src/changes/changes.xml",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/main/java/org/apache/commons/text/WordUtils.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class WordUtilsTest2 {\n\n    @Test\n    public void testWrapWithMatcherSizeZero() {\n        String input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        String expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", false, \"(?=\\\\s)\")).isEqualTo(expected);\n        \n        input = \"Click here to jump to the commons website - http:\";\n        expected = \"Click here to jump\\nto the commons\\nwebsite -\\nhttp:\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", false, \"(?=\\\\s)\")).isEqualTo(expected);\n    }\n\n    @Test\n    public void testWrapWithMatcherSizeZeroAndWrapLongWords() {\n        String input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        String expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \"(?=\\\\s)\")).isEqualTo(expected);\n        \n        input = \"Click here to jump to the commons website - http:\";\n        expected = \"Click here to jump\\nto the commons\\nwebsite -\\nhttp:\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \"(?=\\\\s)\")).isEqualTo(expected);\n    }\n\n    @Test\n    public void testWrapWithMatcherSizeZeroAndOffsetAdjustment() {\n        String input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        String expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", false, \"(?=\\\\s)\")).isEqualTo(expected);\n        \n        input = \"Click here to jump to the commons website - http:\";\n        expected = \"Click here to jump\\nto the commons\\nwebsite -\\nhttp:\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", false, \"(?=\\\\s)\")).isEqualTo(expected);\n    }\n\n    @Test\n    public void testWrapWithMatcherSizeZeroAndOffsetAdjustmentAndWrapLongWords() {\n        String input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        String expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \"(?=\\\\s)\")).isEqualTo(expected);\n        \n        input = \"Click here to jump to the commons website - http:\";\n        expected = \"Click here to jump\\nto the commons\\nwebsite -\\nhttp:\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \"(?=\\\\s)\")).isEqualTo(expected);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * <p>\n * Operations on Strings that contain words.\n * </p>\n *\n * <p>\n * This class tries to handle <code>null</code> input gracefully. An exception will not be thrown for a\n * <code>null</code> input. Each method documents its behavior in more detail.\n * </p>\n *\n * @since 1.1\n */\npublic class WordUtils {\n\n    /**\n     * <p><code>WordUtils</code> instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * <code>WordUtils.wrap(\"foo bar\", 20);</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public WordUtils() {\n      super();\n    }\n\n    // Wrapping\n    //--------------------------------------------------------------------------\n    /**\n     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n     *\n     * <p>New lines will be separated by the system property line separator.\n     * Very long words, such as URLs will <i>not</i> be wrapped.</p>\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - http://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here, http://commons.apache.org, to jump to the commons website\"</td>\n     *   <td>20</td>\n     *   <td>\"Click here,\\nhttp://commons.apache.org,\\nto jump to the\\ncommons website\"</td>\n     *  </tr>\n     * </table>\n     *\n     * (assuming that '\\n' is the systems line separator)\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @return a line with newlines inserted, <code>null</code> if null input\n     */\n    public static String wrap(final String str, final int wrapLength) {\n        return wrap(str, wrapLength, null, false);\n    }\n\n    /**\n     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>newLineString</th>\n     *   <th>wrapLongWords</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"&lt;br /&gt;\"</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of&lt;br /&gt;text that is going&lt;\n     *   br /&gt;to be wrapped after&lt;br /&gt;20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>null</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of\" + systemNewLine + \"text that is going\"\n     *   + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - http://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>false</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - http://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apach\\ne.org\"</td>\n     *  </tr>\n     * </table>\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line,\n     *  <code>null</code> uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @return a line with newlines inserted, <code>null</code> if null input\n     */\n    public static String wrap(final String str,\n                              final int wrapLength,\n                              final String newLineStr,\n                              final boolean wrapLongWords) {\n        return wrap(str, wrapLength, newLineStr, wrapLongWords, \" \");\n    }\n\n    /**\n     * <p>Wraps a single line of text, identifying words by <code>wrapOn</code>.</p>\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>newLineString</th>\n     *   <th>wrapLongWords</th>\n     *   <th>wrapOn</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>*</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>*</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"&lt;br /&gt;\"</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of&lt;br /&gt;text that is going&lt;br /&gt;\n     *   to be wrapped after&lt;br /&gt;20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>null</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of\" + systemNewLine + \"text that is going\"\n     *   + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - http://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - http://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\" \"</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apach\\ne.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"flammable/inflammable\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\"/\"</td>\n     *   <td>\"flammable\\ninflammable\"</td>\n     *  </tr>\n     * </table>\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line,\n     *  <code>null</code> uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @param wrapOn regex expression to be used as a breakable characters,\n     *               if blank string is provided a space character will be used\n     * @return a line with newlines inserted, <code>null</code> if null input\n     */\n    public static String wrap(final String str,\n                              int wrapLength,\n                              String newLineStr,\n                              final boolean wrapLongWords,\n                              String wrapOn) {\n        if (str == null) {\n            return null;\n        }\n        if (newLineStr == null) {\n            newLineStr = System.lineSeparator();\n        }\n        if (wrapLength < 1) {\n            wrapLength = 1;\n        }\n        if (StringUtils.isBlank(wrapOn)) {\n            wrapOn = \" \";\n        }\n        final Pattern patternToWrapOn = Pattern.compile(wrapOn);\n        final int inputLineLength = str.length();\n        int offset = 0;\n        final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n        int matcherSize = -1;\n\n        while (offset < inputLineLength) {\n            int spaceToWrapAt = -1;\n            Matcher matcher = patternToWrapOn.matcher(str.substring(offset,\n                    Math.min((int) Math.min(Integer.MAX_VALUE, offset + wrapLength + 1L), inputLineLength)));\n            if (matcher.find()) {\n                if (matcher.start() == 0) {\n                    matcherSize = matcher.end() - matcher.start();\n                    offset += matcher.end();\n                    continue;\n                }\n                spaceToWrapAt = matcher.start() + offset;\n            }\n\n            // only last line without leading spaces is left\n            if (inputLineLength - offset <= wrapLength) {\n                break;\n            }\n\n            while (matcher.find()) {\n                spaceToWrapAt = matcher.start() + offset;\n            }\n\n            if (spaceToWrapAt >= offset) {\n                // normal case\n                wrappedLine.append(str, offset, spaceToWrapAt);\n                wrappedLine.append(newLineStr);\n                offset = spaceToWrapAt + 1;\n\n            } else {\n                // really long word or URL\n                if (wrapLongWords) {\n                    // wrap really long word one line at a time\n                    wrappedLine.append(str, offset, wrapLength + offset);\n                    wrappedLine.append(newLineStr);\n                    offset += wrapLength;\n                    matcherSize = -1;\n                } else {\n                    // do not wrap really long word, just extend beyond limit\n                    matcher = patternToWrapOn.matcher(str.substring(offset + wrapLength));\n                    if (matcher.find()) {\n                        matcherSize = matcher.end() - matcher.start();\n                        spaceToWrapAt = matcher.start() + offset + wrapLength;\n                    }\n\n                    if (spaceToWrapAt >= 0) {\n                        wrappedLine.append(str, offset, spaceToWrapAt);\n                        wrappedLine.append(newLineStr);\n                        offset = spaceToWrapAt + 1;\n                    } else {\n                        wrappedLine.append(str, offset, str.length());\n                        offset = inputLineLength;\n                        matcherSize = -1;\n                    }\n                }\n            }\n        }\n\n        if (matcherSize == 0) {\n            offset--;\n        }\n\n        // Whatever is left in line is short enough to just pass through\n        wrappedLine.append(str, offset, str.length());\n\n        return wrappedLine.toString();\n    }\n\n    // Capitalizing\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Capitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed. To convert the\n     * rest of each word to lowercase at the same time,\n     * use {@link #capitalizeFully(String)}.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null)        = null\n     * WordUtils.capitalize(\"\")          = \"\"\n     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str) {\n        return capitalize(str, null);\n    }\n\n    /**\n     * <p>Capitalizes all the delimiter separated words in a String.\n     * Only the first character of each word is changed. To convert the\n     * rest of each word to lowercase at the same time,\n     * use {@link #capitalizeFully(String, char[])}.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null, *)            = null\n     * WordUtils.capitalize(\"\", *)              = \"\"\n     * WordUtils.capitalize(*, new char[0])     = *\n     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n     * WordUtils.capitalize(\"i am fine\", new char[]{}) = \"I am fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n\n        boolean capitalizeNext = true;\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                capitalizeNext = true;\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            } else if (capitalizeNext) {\n                final int titleCaseCodePoint = Character.toTitleCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                capitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Converts all the whitespace separated words in a String into capitalized words,\n     * that is each word is made up of a titlecase character and then a series of\n     * lowercase characters.  </p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null)        = null\n     * WordUtils.capitalizeFully(\"\")          = \"\"\n     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     */\n    public static String capitalizeFully(final String str) {\n        return capitalizeFully(str, null);\n    }\n\n    /**\n     * <p>Converts all the delimiter separated words in a String into capitalized words,\n     * that is each word is made up of a titlecase character and then a series of\n     * lowercase characters. </p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null, *)            = null\n     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n     * WordUtils.capitalizeFully(*, null)            = *\n     * WordUtils.capitalizeFully(*, new char[0])     = *\n     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     */\n    public static String capitalizeFully(String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        str = str.toLowerCase();\n        return capitalize(str, delimiters);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Uncapitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null)        = null\n     * WordUtils.uncapitalize(\"\")          = \"\"\n     * WordUtils.uncapitalize(\"I Am FINE\") = \"i am fINE\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @return uncapitalized String, <code>null</code> if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str) {\n        return uncapitalize(str, null);\n    }\n\n    /**\n     * <p>Uncapitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be uncapitalized. </p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null, *)            = null\n     * WordUtils.uncapitalize(\"\", *)              = \"\"\n     * WordUtils.uncapitalize(*, null)            = *\n     * WordUtils.uncapitalize(*, new char[0])     = *\n     * WordUtils.uncapitalize(\"I AM.FINE\", {'.'}) = \"i AM.fINE\"\n     * WordUtils.uncapitalize(\"I am fine\", new char[]{}) = \"i am fine\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @param delimiters  set of characters to determine uncapitalization, null means whitespace\n     * @return uncapitalized String, <code>null</code> if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n\n        boolean uncapitalizeNext = true;\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                uncapitalizeNext = true;\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            } else if (uncapitalizeNext) {\n                final int titleCaseCodePoint = Character.toLowerCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                uncapitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Swaps the case of a String using a word based algorithm.</p>\n     *\n     * <ul>\n     *  <li>Upper case character converts to Lower case</li>\n     *  <li>Title case character converts to Lower case</li>\n     *  <li>Lower case character after Whitespace or at start converts to Title case</li>\n     *  <li>Other Lower case character converts to Upper case</li>\n     * </ul>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.swapCase(null)                 = null\n     * StringUtils.swapCase(\"\")                   = \"\"\n     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n     * </pre>\n     *\n     * @param str  the String to swap case, may be null\n     * @return the changed String, <code>null</code> if null String input\n     */\n    public static String swapCase(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n        boolean whitespace = true;\n        for (int index = 0; index < strLen;) {\n            final int oldCodepoint = str.codePointAt(index);\n            final int newCodePoint;\n            if (Character.isUpperCase(oldCodepoint) || Character.isTitleCase(oldCodepoint)) {\n                newCodePoint = Character.toLowerCase(oldCodepoint);\n                whitespace = false;\n            } else if (Character.isLowerCase(oldCodepoint)) {\n                if (whitespace) {\n                    newCodePoint = Character.toTitleCase(oldCodepoint);\n                    whitespace = false;\n                } else {\n                    newCodePoint = Character.toUpperCase(oldCodepoint);\n                }\n            } else {\n                whitespace = Character.isWhitespace(oldCodepoint);\n                newCodePoint = oldCodepoint;\n            }\n            newCodePoints[outOffset++] = newCodePoint;\n            index += Character.charCount(newCodePoint);\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Extracts the initial characters from each word in the String.</p>\n     *\n     * <p>All first characters after whitespace are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null)             = null\n     * WordUtils.initials(\"\")               = \"\"\n     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @return String of initial letters, <code>null</code> if null String input\n     * @see #initials(String,char[])\n     */\n    public static String initials(final String str) {\n        return initials(str, null);\n    }\n\n    /**\n     * <p>Extracts the initial characters from each word in the String.</p>\n     *\n     * <p>All first characters after the defined delimiters are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>If the delimiters array is null, then Whitespace is used.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * An empty delimiter array returns an empty String.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null, *)                = null\n     * WordUtils.initials(\"\", *)                  = \"\"\n     * WordUtils.initials(\"Ben John Lee\", null)   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\", null)      = \"BJ\"\n     * WordUtils.initials(\"Ben J.Lee\", [' ','.']) = \"BJL\"\n     * WordUtils.initials(*, new char[0])         = \"\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @param delimiters  set of characters to determine words, null means whitespace\n     * @return String of initial characters, <code>null</code> if null String input\n     * @see #initials(String)\n     */\n    public static String initials(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (delimiters != null && delimiters.length == 0) {\n            return \"\";\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen / 2 + 1];\n        int count = 0;\n        boolean lastWasGap = true;\n        for (int i = 0; i < strLen;) {\n            final int codePoint = str.codePointAt(i);\n\n            if (delimiterSet.contains(codePoint) || (delimiters == null && Character.isWhitespace(codePoint))) {\n                lastWasGap = true;\n            } else if (lastWasGap) {\n                newCodePoints[count++] = codePoint;\n                lastWasGap = false;\n            }\n\n            i += Character.charCount(codePoint);\n        }\n        return new String(newCodePoints, 0, count);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if the String contains all words in the given array.</p>\n     *\n     * <p>\n     * A {@code null} String will return {@code false}. A {@code null}, zero\n     * length search array or if one element of array is null will return {@code false}.\n     * </p>\n     *\n     * <pre>\n     * WordUtils.containsAllWords(null, *)            = false\n     * WordUtils.containsAllWords(\"\", *)              = false\n     * WordUtils.containsAllWords(*, null)            = false\n     * WordUtils.containsAllWords(*, [])              = false\n     * WordUtils.containsAllWords(\"abcd\", \"ab\", \"cd\") = false\n     * WordUtils.containsAllWords(\"abc def\", \"def\", \"abc\") = true\n     * </pre>\n     *\n     * @param word The CharSequence to check, may be null\n     * @param words The array of String words to search for, may be null\n     * @return {@code true} if all search words are found, {@code false} otherwise\n     */\n    public static boolean containsAllWords(final CharSequence word, final CharSequence... words) {\n        if (StringUtils.isEmpty(word) || ArrayUtils.isEmpty(words)) {\n            return false;\n        }\n        for (final CharSequence w : words) {\n            if (StringUtils.isBlank(w)) {\n                return false;\n            }\n            final Pattern p = Pattern.compile(\".*\\\\b\" + w + \"\\\\b.*\");\n            if (!p.matcher(word).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Is the character a delimiter.\n     *\n     * @param ch the character to check\n     * @param delimiters the delimiters\n     * @return true if it is a delimiter\n     * @deprecated as of 1.2 and will be removed in 2.0\n     */\n    @Deprecated\n    public static boolean isDelimiter(final char ch, final char[] delimiters) {\n        if (delimiters == null) {\n            return Character.isWhitespace(ch);\n        }\n        for (final char delimiter : delimiters) {\n            if (ch == delimiter) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n  //-----------------------------------------------------------------------\n    /**\n     * Is the codePoint a delimiter.\n     *\n     * @param codePoint the codePint to check\n     * @param delimiters the delimiters\n     * @return true if it is a delimiter\n     * @deprecated as of 1.2 and will be removed in 2.0\n     */\n    @Deprecated\n    public static boolean isDelimiter(final int codePoint, final char[] delimiters) {\n        if (delimiters == null) {\n            return Character.isWhitespace(codePoint);\n        }\n        for (int index = 0; index < delimiters.length; index++) {\n            final int delimiterCodePoint = Character.codePointAt(delimiters, index);\n            if (delimiterCodePoint == codePoint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Abbreviates the words nicely.\n     *\n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     *\n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     *\n     * <pre>\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, null));     = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, null));    = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, null));    = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, \"\"));       = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, \"\"));      = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, \"\"));      = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, \" ...\"));   = \"Now ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, \" ...\"));  = \"Now is the ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, \" ...\"));  = \"Now is the time for all ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, -1, \"\"));       = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, -1, \"\"));      = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, -1, \"\"));      = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 50, -1, \"\"));      = \"Now is the time for all good men\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 1000, -1, \"\"));    = \"Now is the time for all good men\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 9, -10, null));    = IllegalArgumentException\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 5, null));     = IllegalArgumentException\n     * </pre>\n     */\n    public static String abbreviate(final String str, int lower, int upper, final String appendToEnd) {\n        Validate.isTrue(upper >= -1, \"upper value cannot be less than -1\");\n        Validate.isTrue(upper >= lower || upper == -1, \"upper value is less than lower value\");\n\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        if (lower > str.length()) {\n            lower = str.length();\n        }\n\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n\n        final StringBuilder result = new StringBuilder();\n        final int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str, 0, upper);\n            // only if abbreviation has occurred do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str, 0, upper);\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str, 0, index);\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n\n        return result.toString();\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * <p>\n     * Converts an array of delimiters to a hash set of code points. Code point of space(32) is added as the default\n     * value if delimiters is null. The generated hash set provides O(1) lookup time.\n     * </p>\n     *\n     * @param delimiters set of characters to determine capitalization, null means whitespace\n     * @return Set<Integer>\n     */\n    private static Set<Integer> generateDelimiterSet(final char[] delimiters) {\n        final Set<Integer> delimiterHashSet = new HashSet<>();\n        if (delimiters == null || delimiters.length == 0) {\n            if (delimiters == null) {\n                delimiterHashSet.add(Character.codePointAt(new char[] {' '}, 0));\n            }\n\n            return delimiterHashSet;\n        }\n\n        for (int index = 0; index < delimiters.length; index++) {\n            delimiterHashSet.add(Character.codePointAt(delimiters, index));\n        }\n        return delimiterHashSet;\n    }\n }",
        "diff": " a/src/main/java/org/apache/commons/text/WordUtils.java b/src/main/java/org/apache/commons/text/WordUtils.java\nindex 085438d699..a9567a36ce 100644\n--- a/src/main/java/org/apache/commons/text/WordUtils.java\n+++ b/src/main/java/org/apache/commons/text/WordUtils.java\n@@ -310,8 +310,12 @@ public static String wrap(final String str,\n             if (matcher.find()) {\n                 if (matcher.start() == 0) {\n                     matcherSize = matcher.end() - matcher.start();\n-                    offset += matcher.end();\n-                    continue;\n+                    if (matcherSize != 0) {\n+                        offset += matcher.end();\n+                        continue;\n+                    } else {\n+                        offset += 1;\n+                    }\n                 }\n                 spaceToWrapAt = matcher.start() + offset;\n             }\n@@ -334,6 +338,9 @@ public static String wrap(final String str,\n             } else {\n                 // really long word or URL\n                 if (wrapLongWords) {\n+                    if (matcherSize == 0) {\n+                        offset--;\n+                    }\n                     // wrap really long word one line at a time\n                     wrappedLine.append(str, offset, wrapLength + offset);\n                     wrappedLine.append(newLineStr);\n@@ -348,10 +355,16 @@ public static String wrap(final String str,\n                     }\n \n                     if (spaceToWrapAt >= 0) {\n+                        if (matcherSize == 0 && offset != 0) {\n+                            offset--;\n+                        }\n                         wrappedLine.append(str, offset, spaceToWrapAt);\n                         wrappedLine.append(newLineStr);\n                         offset = spaceToWrapAt + 1;\n                     } else {\n+                        if (matcherSize == 0 && offset != 0) {\n+                            offset--;\n+                        }\n                         wrappedLine.append(str, offset, str.length());\n                         offset = inputLineLength;\n                         matcherSize = -1;\n@@ -360,7 +373,7 @@ public static String wrap(final String str,\n             }\n         }\n \n-        if (matcherSize == 0) {\n+        if (matcherSize == 0 && offset < inputLineLength) {\n             offset--;\n         }\n \n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/WordUtilsTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 105,
    "title": "TEXT-151: Use StringUtils.equals to test for CharSequence equality.",
    "state": "closed",
    "created_at": "2019-03-02T21:14:12Z",
    "merge_commit_sha": "d31525853b43114a6c49eb8ab15d75719bbbd19d",
    "base_sha": "33ae30ba6ed160f05cd2989a232b8de6558643f0",
    "head_sha": "ce04947d71b21dca5a059e6ce20296b0c6648d34",
    "user_login": "aherbert",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class JaroWinklerSimilarityTest2 {\n\n    private static JaroWinklerSimilarity similarity;\n\n    @BeforeAll\n    public static void setUp() {\n        similarity = new JaroWinklerSimilarity();\n    }\n\n    @Test\n    public void testGetJaroWinklerSimilarity_UsingStringUtils() {\n        // Test cases to ensure StringUtils.equals is used correctly\n        assertEquals(1d, similarity.apply(\"test\", \"test\"), 0.00001d);\n        assertEquals(1d, similarity.apply(\"TEST\", \"TEST\"), 0.00001d);\n        assertEquals(0d, similarity.apply(\"test\", \"TEST\"), 0.00001d);\n        assertEquals(0d, similarity.apply(\"test\", \"tEst\"), 0.00001d);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\nimport java.util.Arrays;\n\n/**\n * A similarity algorithm indicating the percentage of matched characters between two character sequences.\n *\n * <p>\n * The Jaro measure is the weighted sum of percentage of matched characters\n * from each file and transposed characters. Winkler increased this measure\n * for matching initial characters.\n * </p>\n *\n * <p>\n * This implementation is based on the Jaro Winkler similarity algorithm\n * from <a href=\"http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\">\n * http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a>.\n * </p>\n *\n * <p>\n * This code has been adapted from Apache Commons Lang 3.3.\n * </p>\n *\n * @since 1.7\n */\npublic class JaroWinklerSimilarity implements SimilarityScore<Double> {\n\n    /**\n     * Computes the Jaro Winkler Similarity between two character sequences.\n     *\n     * <pre>\n     * sim.apply(null, null)          = IllegalArgumentException\n     * sim.apply(\"foo\", null)         = IllegalArgumentException\n     * sim.apply(null, \"foo\")         = IllegalArgumentException\n     * sim.apply(\"\", \"\")              = 1.0\n     * sim.apply(\"foo\", \"foo\")        = 1.0\n     * sim.apply(\"foo\", \"foo \")       = 0.94\n     * sim.apply(\"foo\", \"foo  \")      = 0.91\n     * sim.apply(\"foo\", \" foo \")      = 0.87\n     * sim.apply(\"foo\", \"  foo\")      = 0.51\n     * sim.apply(\"\", \"a\")             = 0.0\n     * sim.apply(\"aaapppp\", \"\")       = 0.0\n     * sim.apply(\"frog\", \"fog\")       = 0.93\n     * sim.apply(\"fly\", \"ant\")        = 0.0\n     * sim.apply(\"elephant\", \"hippo\") = 0.44\n     * sim.apply(\"hippo\", \"elephant\") = 0.44\n     * sim.apply(\"hippo\", \"zzzzzzzz\") = 0.0\n     * sim.apply(\"hello\", \"hallo\")    = 0.88\n     * sim.apply(\"ABC Corporation\", \"ABC Corp\") = 0.93\n     * sim.apply(\"D N H Enterprises Inc\", \"D &amp; H Enterprises, Inc.\") = 0.95\n     * sim.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\") = 0.92\n     * sim.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\") = 0.88\n     * </pre>\n     *\n     * @param left the first CharSequence, must not be null\n     * @param right the second CharSequence, must not be null\n     * @return result similarity\n     * @throws IllegalArgumentException if either CharSequence input is {@code null}\n     */\n    @Override\n    public Double apply(final CharSequence left, final CharSequence right) {\n        final double defaultScalingFactor = 0.1;\n\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n\n        if (left.equals(right)) {\n            return 1d;\n        }\n\n        final int[] mtp = matches(left, right);\n        final double m = mtp[0];\n        if (m == 0) {\n            return 0d;\n        }\n        final double j = ((m / left.length() + m / right.length() + (m - (double) mtp[1] / 2) / m)) / 3;\n        final double jw = j < 0.7d ? j : j + defaultScalingFactor * mtp[2] * (1d - j);\n        return jw;\n    }\n\n    /**\n     * This method returns the Jaro-Winkler string matches, half transpositions, prefix array.\n     *\n     * @param first the first string to be matched\n     * @param second the second string to be matched\n     * @return mtp array containing: matches, half transpositions, and prefix\n     */\n    protected static int[] matches(final CharSequence first, final CharSequence second) {\n        CharSequence max, min;\n        if (first.length() > second.length()) {\n            max = first;\n            min = second;\n        } else {\n            max = second;\n            min = first;\n        }\n        final int range = Math.max(max.length() / 2 - 1, 0);\n        final int[] matchIndexes = new int[min.length()];\n        Arrays.fill(matchIndexes, -1);\n        final boolean[] matchFlags = new boolean[max.length()];\n        int matches = 0;\n        for (int mi = 0; mi < min.length(); mi++) {\n            final char c1 = min.charAt(mi);\n            for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max.length()); xi < xn; xi++) {\n                if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n                    matchIndexes[mi] = xi;\n                    matchFlags[xi] = true;\n                    matches++;\n                    break;\n                }\n            }\n        }\n        final char[] ms1 = new char[matches];\n        final char[] ms2 = new char[matches];\n        for (int i = 0, si = 0; i < min.length(); i++) {\n            if (matchIndexes[i] != -1) {\n                ms1[si] = min.charAt(i);\n                si++;\n            }\n        }\n        for (int i = 0, si = 0; i < max.length(); i++) {\n            if (matchFlags[i]) {\n                ms2[si] = max.charAt(i);\n                si++;\n            }\n        }\n        int halfTranspositions = 0;\n        for (int mi = 0; mi < ms1.length; mi++) {\n            if (ms1[mi] != ms2[mi]) {\n                halfTranspositions++;\n            }\n        }\n        int prefix = 0;\n        for (int mi = 0; mi < Math.min(4, min.length()); mi++) {\n            if (first.charAt(mi) == second.charAt(mi)) {\n                prefix++;\n            } else {\n                break;\n            }\n        }\n        return new int[] {matches, halfTranspositions, prefix};\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java b/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java\nindex 82d109253c..a159ba8e9e 100644\n--- a/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java\n+++ b/src/main/java/org/apache/commons/text/similarity/JaroWinklerSimilarity.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.commons.text.similarity;\n \n+import org.apache.commons.lang3.StringUtils;\n+\n import java.util.Arrays;\n \n /**\n@@ -81,7 +83,7 @@ public Double apply(final CharSequence left, final CharSequence right) {\n             throw new IllegalArgumentException(\"CharSequences must not be null\");\n         }\n \n-        if (left.equals(right)) {\n+        if (StringUtils.equals(left, right)) {\n             return 1d;\n         }\n \n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/similarity/JaroWinklerSimilarityTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 104,
    "title": "TEXT-111",
    "state": "closed",
    "created_at": "2019-03-02T00:12:15Z",
    "merge_commit_sha": "7486f9aa302ca2eaceec5560dfe66272a82f6952",
    "base_sha": "33ae30ba6ed160f05cd2989a232b8de6558643f0",
    "head_sha": "bba10519cb1bad6a5364ea951d794a7aa7639699",
    "user_login": "CAPS50",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/WordUtils.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport org.junit.jupiter.api.Test;\n\npublic class WordUtilsTest2 {\n\n    @Test\n    public void testWrap_StringIntStringBooleanString_MatcherSize() {\n        String input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        String expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", false, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of<br />text that is going<br />to be wrapped after<br />20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"<br />\", false, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line\";\n        expected = \"Here\\nis one\\nline\";\n        assertThat(WordUtils.wrap(input, 6, \"\\n\", false, \" \")).isEqualTo(expected);\n\n        expected = \"Here\\nis\\none\\nline\";\n        assertThat(WordUtils.wrap(input, 2, \"\\n\", false, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n    }\n\n    @Test\n    public void testWrap_StringIntStringBooleanString_MatcherSizeZero() {\n        String input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        String expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", false, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of<br />text that is going<br />to be wrapped after<br />20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"<br />\", false, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line\";\n        expected = \"Here\\nis one\\nline\";\n        assertThat(WordUtils.wrap(input, 6, \"\\n\", false, \" \")).isEqualTo(expected);\n\n        expected = \"Here\\nis\\none\\nline\";\n        assertThat(WordUtils.wrap(input, 2, \"\\n\", false, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n\n        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n        expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n        assertThat(WordUtils.wrap(input, 20, \"\\n\", true, \" \")).isEqualTo(expected);\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\n\n/**\n * <p>\n * Operations on Strings that contain words.\n * </p>\n *\n * <p>\n * This class tries to handle <code>null</code> input gracefully. An exception will not be thrown for a\n * <code>null</code> input. Each method documents its behavior in more detail.\n * </p>\n *\n * @since 1.1\n */\npublic class WordUtils {\n\n    /**\n     * <p><code>WordUtils</code> instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * <code>WordUtils.wrap(\"foo bar\", 20);</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public WordUtils() {\n      super();\n    }\n\n    // Wrapping\n    //--------------------------------------------------------------------------\n    /**\n     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n     *\n     * <p>New lines will be separated by the system property line separator.\n     * Very long words, such as URLs will <i>not</i> be wrapped.</p>\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - http://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here, http://commons.apache.org, to jump to the commons website\"</td>\n     *   <td>20</td>\n     *   <td>\"Click here,\\nhttp://commons.apache.org,\\nto jump to the\\ncommons website\"</td>\n     *  </tr>\n     * </table>\n     *\n     * (assuming that '\\n' is the systems line separator)\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @return a line with newlines inserted, <code>null</code> if null input\n     */\n    public static String wrap(final String str, final int wrapLength) {\n        return wrap(str, wrapLength, null, false);\n    }\n\n    /**\n     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>newLineString</th>\n     *   <th>wrapLongWords</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"&lt;br /&gt;\"</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of&lt;br /&gt;text that is going&lt;\n     *   br /&gt;to be wrapped after&lt;br /&gt;20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>null</td>\n     *   <td>true/false</td>\n     *   <td>\"Here is one line of\" + systemNewLine + \"text that is going\"\n     *   + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - http://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>false</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - http://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apach\\ne.org\"</td>\n     *  </tr>\n     * </table>\n     *\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line,\n     *  <code>null</code> uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @return a line with newlines inserted, <code>null</code> if null input\n     */\n    public static String wrap(final String str,\n                              final int wrapLength,\n                              final String newLineStr,\n                              final boolean wrapLongWords) {\n        return wrap(str, wrapLength, newLineStr, wrapLongWords, \" \");\n    }\n\n    /**\n     * <p>Wraps a single line of text, identifying words by <code>wrapOn</code>.</p>\n     *\n     * <p>Leading spaces on a new line are stripped.\n     * Trailing spaces are not stripped.</p>\n     *\n     * <table border=\"1\">\n     *  <caption>Examples</caption>\n     *  <tr>\n     *   <th>input</th>\n     *   <th>wrapLength</th>\n     *   <th>newLineString</th>\n     *   <th>wrapLongWords</th>\n     *   <th>wrapOn</th>\n     *   <th>result</th>\n     *  </tr>\n     *  <tr>\n     *   <td>null</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>*</td>\n     *   <td>null</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"\"</td>\n     *   <td>*</td>\n     *   <td>*</td>\n     *   <td>true/false</td>\n     *   <td>*</td>\n     *   <td>\"\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>\"&lt;br /&gt;\"</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of&lt;br /&gt;text that is going&lt;br /&gt;\n     *   to be wrapped after&lt;br /&gt;20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Here is one line of text that is going to be wrapped after 20 columns.\"</td>\n     *   <td>20</td>\n     *   <td>null</td>\n     *   <td>true/false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Here is one line of\" + systemNewLine + \"text that is going\"\n     *   + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - http://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>false</td>\n     *   <td>\" \"</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apache.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"Click here to jump to the commons website - http://commons.apache.org\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\" \"</td>\n     *   <td>\"Click here to jump\\nto the commons\\nwebsite -\\nhttp://commons.apach\\ne.org\"</td>\n     *  </tr>\n     *  <tr>\n     *   <td>\"flammable/inflammable\"</td>\n     *   <td>20</td>\n     *   <td>\"\\n\"</td>\n     *   <td>true</td>\n     *   <td>\"/\"</td>\n     *   <td>\"flammable\\ninflammable\"</td>\n     *  </tr>\n     * </table>\n     * @param str  the String to be word wrapped, may be null\n     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n     * @param newLineStr  the string to insert for a new line,\n     *  <code>null</code> uses the system property line separator\n     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n     * @param wrapOn regex expression to be used as a breakable characters,\n     *               if blank string is provided a space character will be used\n     * @return a line with newlines inserted, <code>null</code> if null input\n     */\n    public static String wrap(final String str,\n                              int wrapLength,\n                              String newLineStr,\n                              final boolean wrapLongWords,\n                              String wrapOn) {\n        if (str == null) {\n            return null;\n        }\n        if (newLineStr == null) {\n            newLineStr = System.lineSeparator();\n        }\n        if (wrapLength < 1) {\n            wrapLength = 1;\n        }\n        if (StringUtils.isBlank(wrapOn)) {\n            wrapOn = \" \";\n        }\n        final Pattern patternToWrapOn = Pattern.compile(wrapOn);\n        final int inputLineLength = str.length();\n        int offset = 0;\n        final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n\n        while (offset < inputLineLength) {\n            int spaceToWrapAt = -1;\n            Matcher matcher = patternToWrapOn.matcher(str.substring(offset,\n                    Math.min((int) Math.min(Integer.MAX_VALUE, offset + wrapLength + 1L), inputLineLength)));\n            if (matcher.find()) {\n                if (matcher.start() == 0) {\n                    offset += matcher.end();\n                    continue;\n                }\n                spaceToWrapAt = matcher.start() + offset;\n            }\n\n            // only last line without leading spaces is left\n            if (inputLineLength - offset <= wrapLength) {\n                break;\n            }\n\n            while (matcher.find()) {\n                spaceToWrapAt = matcher.start() + offset;\n            }\n\n            if (spaceToWrapAt >= offset) {\n                // normal case\n                wrappedLine.append(str, offset, spaceToWrapAt);\n                wrappedLine.append(newLineStr);\n                offset = spaceToWrapAt + 1;\n\n            } else {\n                // really long word or URL\n                if (wrapLongWords) {\n                    // wrap really long word one line at a time\n                    wrappedLine.append(str, offset, wrapLength + offset);\n                    wrappedLine.append(newLineStr);\n                    offset += wrapLength;\n                } else {\n                    // do not wrap really long word, just extend beyond limit\n                    matcher = patternToWrapOn.matcher(str.substring(offset + wrapLength));\n                    if (matcher.find()) {\n                        spaceToWrapAt = matcher.start() + offset + wrapLength;\n                    }\n\n                    if (spaceToWrapAt >= 0) {\n                        wrappedLine.append(str, offset, spaceToWrapAt);\n                        wrappedLine.append(newLineStr);\n                        offset = spaceToWrapAt + 1;\n                    } else {\n                        wrappedLine.append(str, offset, str.length());\n                        offset = inputLineLength;\n                    }\n                }\n            }\n        }\n\n        // Whatever is left in line is short enough to just pass through\n        wrappedLine.append(str, offset, str.length());\n\n        return wrappedLine.toString();\n    }\n\n    // Capitalizing\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Capitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed. To convert the\n     * rest of each word to lowercase at the same time,\n     * use {@link #capitalizeFully(String)}.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null)        = null\n     * WordUtils.capitalize(\"\")          = \"\"\n     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str) {\n        return capitalize(str, null);\n    }\n\n    /**\n     * <p>Capitalizes all the delimiter separated words in a String.\n     * Only the first character of each word is changed. To convert the\n     * rest of each word to lowercase at the same time,\n     * use {@link #capitalizeFully(String, char[])}.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalize(null, *)            = null\n     * WordUtils.capitalize(\"\", *)              = \"\"\n     * WordUtils.capitalize(*, new char[0])     = *\n     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n     * WordUtils.capitalize(\"i am fine\", new char[]{}) = \"I am fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     * @see #uncapitalize(String)\n     * @see #capitalizeFully(String)\n     */\n    public static String capitalize(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n\n        boolean capitalizeNext = true;\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                capitalizeNext = true;\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            } else if (capitalizeNext) {\n                final int titleCaseCodePoint = Character.toTitleCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                capitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Converts all the whitespace separated words in a String into capitalized words,\n     * that is each word is made up of a titlecase character and then a series of\n     * lowercase characters.  </p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null)        = null\n     * WordUtils.capitalizeFully(\"\")          = \"\"\n     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @return capitalized String, <code>null</code> if null String input\n     */\n    public static String capitalizeFully(final String str) {\n        return capitalizeFully(str, null);\n    }\n\n    /**\n     * <p>Converts all the delimiter separated words in a String into capitalized words,\n     * that is each word is made up of a titlecase character and then a series of\n     * lowercase characters. </p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be capitalized. </p>\n     *\n     * <p>A <code>null</code> input String returns <code>null</code>.\n     * Capitalization uses the Unicode title case, normally equivalent to\n     * upper case.</p>\n     *\n     * <pre>\n     * WordUtils.capitalizeFully(null, *)            = null\n     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n     * WordUtils.capitalizeFully(*, null)            = *\n     * WordUtils.capitalizeFully(*, new char[0])     = *\n     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n     * </pre>\n     *\n     * @param str  the String to capitalize, may be null\n     * @param delimiters  set of characters to determine capitalization, null means whitespace\n     * @return capitalized String, <code>null</code> if null String input\n     */\n    public static String capitalizeFully(String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        str = str.toLowerCase();\n        return capitalize(str, delimiters);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Uncapitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null)        = null\n     * WordUtils.uncapitalize(\"\")          = \"\"\n     * WordUtils.uncapitalize(\"I Am FINE\") = \"i am fINE\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @return uncapitalized String, <code>null</code> if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str) {\n        return uncapitalize(str, null);\n    }\n\n    /**\n     * <p>Uncapitalizes all the whitespace separated words in a String.\n     * Only the first character of each word is changed.</p>\n     *\n     * <p>The delimiters represent a set of characters understood to separate words.\n     * The first string character and the first non-delimiter character after a\n     * delimiter will be uncapitalized. </p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.uncapitalize(null, *)            = null\n     * WordUtils.uncapitalize(\"\", *)              = \"\"\n     * WordUtils.uncapitalize(*, null)            = *\n     * WordUtils.uncapitalize(*, new char[0])     = *\n     * WordUtils.uncapitalize(\"I AM.FINE\", {'.'}) = \"i AM.fINE\"\n     * WordUtils.uncapitalize(\"I am fine\", new char[]{}) = \"i am fine\"\n     * </pre>\n     *\n     * @param str  the String to uncapitalize, may be null\n     * @param delimiters  set of characters to determine uncapitalization, null means whitespace\n     * @return uncapitalized String, <code>null</code> if null String input\n     * @see #capitalize(String)\n     */\n    public static String uncapitalize(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n\n        boolean uncapitalizeNext = true;\n        for (int index = 0; index < strLen;) {\n            final int codePoint = str.codePointAt(index);\n\n            if (delimiterSet.contains(codePoint)) {\n                uncapitalizeNext = true;\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            } else if (uncapitalizeNext) {\n                final int titleCaseCodePoint = Character.toLowerCase(codePoint);\n                newCodePoints[outOffset++] = titleCaseCodePoint;\n                index += Character.charCount(titleCaseCodePoint);\n                uncapitalizeNext = false;\n            } else {\n                newCodePoints[outOffset++] = codePoint;\n                index += Character.charCount(codePoint);\n            }\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Swaps the case of a String using a word based algorithm.</p>\n     *\n     * <ul>\n     *  <li>Upper case character converts to Lower case</li>\n     *  <li>Title case character converts to Lower case</li>\n     *  <li>Lower case character after Whitespace or at start converts to Title case</li>\n     *  <li>Other Lower case character converts to Upper case</li>\n     * </ul>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * StringUtils.swapCase(null)                 = null\n     * StringUtils.swapCase(\"\")                   = \"\"\n     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n     * </pre>\n     *\n     * @param str  the String to swap case, may be null\n     * @return the changed String, <code>null</code> if null String input\n     */\n    public static String swapCase(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int outOffset = 0;\n        boolean whitespace = true;\n        for (int index = 0; index < strLen;) {\n            final int oldCodepoint = str.codePointAt(index);\n            final int newCodePoint;\n            if (Character.isUpperCase(oldCodepoint) || Character.isTitleCase(oldCodepoint)) {\n                newCodePoint = Character.toLowerCase(oldCodepoint);\n                whitespace = false;\n            } else if (Character.isLowerCase(oldCodepoint)) {\n                if (whitespace) {\n                    newCodePoint = Character.toTitleCase(oldCodepoint);\n                    whitespace = false;\n                } else {\n                    newCodePoint = Character.toUpperCase(oldCodepoint);\n                }\n            } else {\n                whitespace = Character.isWhitespace(oldCodepoint);\n                newCodePoint = oldCodepoint;\n            }\n            newCodePoints[outOffset++] = newCodePoint;\n            index += Character.charCount(newCodePoint);\n        }\n        return new String(newCodePoints, 0, outOffset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Extracts the initial characters from each word in the String.</p>\n     *\n     * <p>All first characters after whitespace are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null)             = null\n     * WordUtils.initials(\"\")               = \"\"\n     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @return String of initial letters, <code>null</code> if null String input\n     * @see #initials(String,char[])\n     */\n    public static String initials(final String str) {\n        return initials(str, null);\n    }\n\n    /**\n     * <p>Extracts the initial characters from each word in the String.</p>\n     *\n     * <p>All first characters after the defined delimiters are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>If the delimiters array is null, then Whitespace is used.\n     * Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.\n     * An empty delimiter array returns an empty String.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null, *)                = null\n     * WordUtils.initials(\"\", *)                  = \"\"\n     * WordUtils.initials(\"Ben John Lee\", null)   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\", null)      = \"BJ\"\n     * WordUtils.initials(\"Ben J.Lee\", [' ','.']) = \"BJL\"\n     * WordUtils.initials(*, new char[0])         = \"\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @param delimiters  set of characters to determine words, null means whitespace\n     * @return String of initial characters, <code>null</code> if null String input\n     * @see #initials(String)\n     */\n    public static String initials(final String str, final char... delimiters) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        if (delimiters != null && delimiters.length == 0) {\n            return \"\";\n        }\n        final Set<Integer> delimiterSet = generateDelimiterSet(delimiters);\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen / 2 + 1];\n        int count = 0;\n        boolean lastWasGap = true;\n        for (int i = 0; i < strLen;) {\n            final int codePoint = str.codePointAt(i);\n\n            if (delimiterSet.contains(codePoint) || (delimiters == null && Character.isWhitespace(codePoint))) {\n                lastWasGap = true;\n            } else if (lastWasGap) {\n                newCodePoints[count++] = codePoint;\n                lastWasGap = false;\n            }\n\n            i += Character.charCount(codePoint);\n        }\n        return new String(newCodePoints, 0, count);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if the String contains all words in the given array.</p>\n     *\n     * <p>\n     * A {@code null} String will return {@code false}. A {@code null}, zero\n     * length search array or if one element of array is null will return {@code false}.\n     * </p>\n     *\n     * <pre>\n     * WordUtils.containsAllWords(null, *)            = false\n     * WordUtils.containsAllWords(\"\", *)              = false\n     * WordUtils.containsAllWords(*, null)            = false\n     * WordUtils.containsAllWords(*, [])              = false\n     * WordUtils.containsAllWords(\"abcd\", \"ab\", \"cd\") = false\n     * WordUtils.containsAllWords(\"abc def\", \"def\", \"abc\") = true\n     * </pre>\n     *\n     * @param word The CharSequence to check, may be null\n     * @param words The array of String words to search for, may be null\n     * @return {@code true} if all search words are found, {@code false} otherwise\n     */\n    public static boolean containsAllWords(final CharSequence word, final CharSequence... words) {\n        if (StringUtils.isEmpty(word) || ArrayUtils.isEmpty(words)) {\n            return false;\n        }\n        for (final CharSequence w : words) {\n            if (StringUtils.isBlank(w)) {\n                return false;\n            }\n            final Pattern p = Pattern.compile(\".*\\\\b\" + w + \"\\\\b.*\");\n            if (!p.matcher(word).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Is the character a delimiter.\n     *\n     * @param ch the character to check\n     * @param delimiters the delimiters\n     * @return true if it is a delimiter\n     * @deprecated as of 1.2 and will be removed in 2.0\n     */\n    @Deprecated\n    public static boolean isDelimiter(final char ch, final char[] delimiters) {\n        if (delimiters == null) {\n            return Character.isWhitespace(ch);\n        }\n        for (final char delimiter : delimiters) {\n            if (ch == delimiter) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n  //-----------------------------------------------------------------------\n    /**\n     * Is the codePoint a delimiter.\n     *\n     * @param codePoint the codePint to check\n     * @param delimiters the delimiters\n     * @return true if it is a delimiter\n     * @deprecated as of 1.2 and will be removed in 2.0\n     */\n    @Deprecated\n    public static boolean isDelimiter(final int codePoint, final char[] delimiters) {\n        if (delimiters == null) {\n            return Character.isWhitespace(codePoint);\n        }\n        for (int index = 0; index < delimiters.length; index++) {\n            final int delimiterCodePoint = Character.codePointAt(delimiters, index);\n            if (delimiterCodePoint == codePoint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Abbreviates the words nicely.\n     *\n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     *\n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     *\n     * <pre>\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, null));     = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, null));    = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, null));    = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, \"\"));       = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, \"\"));      = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, \"\"));      = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, 40, \" ...\"));   = \"Now ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 40, \" ...\"));  = \"Now is the ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, 40, \" ...\"));  = \"Now is the time for all ...\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 0, -1, \"\"));       = \"Now\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, -1, \"\"));      = \"Now is the\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 20, -1, \"\"));      = \"Now is the time for all\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 50, -1, \"\"));      = \"Now is the time for all good men\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 1000, -1, \"\"));    = \"Now is the time for all good men\"\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 9, -10, null));    = IllegalArgumentException\n     * WordUtils.abbreviate(\"Now is the time for all good men\", 10, 5, null));     = IllegalArgumentException\n     * </pre>\n     */\n    public static String abbreviate(final String str, int lower, int upper, final String appendToEnd) {\n        Validate.isTrue(upper >= -1, \"upper value cannot be less than -1\");\n        Validate.isTrue(upper >= lower || upper == -1, \"upper value is less than lower value\");\n\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        if (lower > str.length()) {\n            lower = str.length();\n        }\n\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n\n        final StringBuilder result = new StringBuilder();\n        final int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str, 0, upper);\n            // only if abbreviation has occurred do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str, 0, upper);\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str, 0, index);\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n\n        return result.toString();\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * <p>\n     * Converts an array of delimiters to a hash set of code points. Code point of space(32) is added as the default\n     * value if delimiters is null. The generated hash set provides O(1) lookup time.\n     * </p>\n     *\n     * @param delimiters set of characters to determine capitalization, null means whitespace\n     * @return Set<Integer>\n     */\n    private static Set<Integer> generateDelimiterSet(final char[] delimiters) {\n        final Set<Integer> delimiterHashSet = new HashSet<>();\n        if (delimiters == null || delimiters.length == 0) {\n            if (delimiters == null) {\n                delimiterHashSet.add(Character.codePointAt(new char[] {' '}, 0));\n            }\n\n            return delimiterHashSet;\n        }\n\n        for (int index = 0; index < delimiters.length; index++) {\n            delimiterHashSet.add(Character.codePointAt(delimiters, index));\n        }\n        return delimiterHashSet;\n    }\n }",
        "diff": " a/src/main/java/org/apache/commons/text/WordUtils.java b/src/main/java/org/apache/commons/text/WordUtils.java\nindex 91e4ff8262..085438d699 100644\n--- a/src/main/java/org/apache/commons/text/WordUtils.java\n+++ b/src/main/java/org/apache/commons/text/WordUtils.java\n@@ -16,15 +16,15 @@\n  */\n package org.apache.commons.text;\n \n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.Validate;\n+\n import java.util.HashSet;\n import java.util.Set;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-import org.apache.commons.lang3.ArrayUtils;\n-import org.apache.commons.lang3.StringUtils;\n-import org.apache.commons.lang3.Validate;\n-\n /**\n  * <p>\n  * Operations on Strings that contain words.\n@@ -301,6 +301,7 @@ public static String wrap(final String str,\n         final int inputLineLength = str.length();\n         int offset = 0;\n         final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n+        int matcherSize = -1;\n \n         while (offset < inputLineLength) {\n             int spaceToWrapAt = -1;\n@@ -308,6 +309,7 @@ public static String wrap(final String str,\n                     Math.min((int) Math.min(Integer.MAX_VALUE, offset + wrapLength + 1L), inputLineLength)));\n             if (matcher.find()) {\n                 if (matcher.start() == 0) {\n+                    matcherSize = matcher.end() - matcher.start();\n                     offset += matcher.end();\n                     continue;\n                 }\n@@ -336,10 +338,12 @@ public static String wrap(final String str,\n                     wrappedLine.append(str, offset, wrapLength + offset);\n                     wrappedLine.append(newLineStr);\n                     offset += wrapLength;\n+                    matcherSize = -1;\n                 } else {\n                     // do not wrap really long word, just extend beyond limit\n                     matcher = patternToWrapOn.matcher(str.substring(offset + wrapLength));\n                     if (matcher.find()) {\n+                        matcherSize = matcher.end() - matcher.start();\n                         spaceToWrapAt = matcher.start() + offset + wrapLength;\n                     }\n \n@@ -350,11 +354,16 @@ public static String wrap(final String str,\n                     } else {\n                         wrappedLine.append(str, offset, str.length());\n                         offset = inputLineLength;\n+                        matcherSize = -1;\n                     }\n                 }\n             }\n         }\n \n+        if (matcherSize == 0) {\n+            offset--;\n+        }\n+\n         // Whatever is left in line is short enough to just pass through\n         wrappedLine.append(str, offset, str.length());\n \n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/WordUtilsTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 102,
    "title": "TEXT-104: deprecate JaroWinkler methods for 2.0, and fix clirr report",
    "state": "closed",
    "created_at": "2019-02-20T21:51:47Z",
    "merge_commit_sha": "56c060dbcc78732b9c06d50d9ae7442e876c2ca7",
    "base_sha": "6e2bbe511dcf2e7598cd41f98bbcbf5485355b6d",
    "head_sha": "a32b1d2948c7b1b4a07eda8a72fb5cd5bdf2dd00",
    "user_login": "kinow",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.text.similarity;\n\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class JaroWinklerDistanceTest2 {\n\n    private static JaroWinklerDistance distance;\n\n    @BeforeAll\n    public static void setUp() {\n        distance = new JaroWinklerDistance();\n    }\n\n    @Test\n    public void testGetJaroWinklerDistance_EmptyStrings() {\n        assertEquals(0d, distance.apply(\"\", \"\"), 0.00001d);\n    }\n\n    @Test\n    public void testGetJaroWinklerDistance_IdenticalStrings() {\n        assertEquals(0d, distance.apply(\"foo\", \"foo\"), 0.00001d);\n    }\n\n    @Test\n    public void testGetJaroWinklerDistance_DifferentStrings() {\n        assertEquals(1 - 0.94166d, distance.apply(\"foo\", \"foo \"), 0.00001d);\n        assertEquals(1 - 0.90666d, distance.apply(\"foo\", \"foo \"), 0.00001d);\n        assertEquals(1 - 0.86666d, distance.apply(\"foo\", \" foo \"), 0.00001d);\n        assertEquals(1 - 0.51111d, distance.apply(\"foo\", \" foo\"), 0.00001d);\n        assertEquals(1 - 0.92499d, distance.apply(\"frog\", \"fog\"), 0.00001d);\n        assertEquals(1.0d, distance.apply(\"fly\", \"ant\"), 0.00000000000000000001d);\n        assertEquals(1 - 0.44166d, distance.apply(\"elephant\", \"hippo\"), 0.00001d);\n        assertEquals(1 - 0.90666d, distance.apply(\"ABC Corporation\", \"ABC Corp\"), 0.00001d);\n        assertEquals(1 - 0.95251d, distance.apply(\"D N H Enterprises Inc\", \"D & H Enterprises, Inc.\"), 0.00001d);\n        assertEquals(1 - 0.942d, distance.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\"), 0.00001d);\n        assertEquals(1 - 0.898018d, distance.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\"), 0.00001d);\n        assertEquals(1 - 0.971428d, distance.apply(\"/opt/software1\", \"/opt/software2\"), 0.00001d);\n        assertEquals(1 - 0.941666d, distance.apply(\"aaabcd\", \"aaacdb\"), 0.00001d);\n        assertEquals(1 - 0.911111d, distance.apply(\"John Horn\", \"John Hopkins\"), 0.00001d);\n    }\n\n    @Test\n    public void testGetJaroWinklerDistance_NullInputs() {\n        assertThatIllegalArgumentException().isThrownBy(() -> {\n            distance.apply(null, null);\n        });\n        assertThatIllegalArgumentException().isThrownBy(() -> {\n            distance.apply(\" \", null);\n        });\n        assertThatIllegalArgumentException().isThrownBy(() -> {\n            distance.apply(null, \"clear\");\n        });\n    }\n\n    @Test\n    public void testMatchesMethod() {\n        int[] result = JaroWinklerDistance.matches(\"dwayne\", \"duane\");\n        assertEquals(4, result[0]); // matches\n        assertEquals(0, result[1]); // half transpositions\n        assertEquals(1, result[2]); // prefix\n\n        result = JaroWinklerDistance.matches(\"martha\", \"marhta\");\n        assertEquals(6, result[0]); // matches\n        assertEquals(1, result[1]); // half transpositions\n        assertEquals(3, result[2]); // prefix\n\n        result = JaroWinklerDistance.matches(\"jones\", \"johnson\");\n        assertEquals(4, result[0]); // matches\n        assertEquals(0, result[1]); // half transpositions\n        assertEquals(1, result[2]); // prefix\n    }\n}",
        "file_content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\n\n/**\n * Measures the Jaro-Winkler distance of two character sequences.\n * It is the complementary of Jaro-Winkler similarity.\n *\n * @since 1.0\n */\npublic class JaroWinklerDistance implements EditDistance<Double> {\n\n    /**\n     * Computes the Jaro Winkler Distance between two character sequences.\n     *\n     * <pre>\n     * distance.apply(null, null)          = IllegalArgumentException\n     * distance.apply(\"foo\", null)         = IllegalArgumentException\n     * distance.apply(null, \"foo\")         = IllegalArgumentException\n     * distance.apply(\"\", \"\")              = 0.0\n     * distance.apply(\"foo\", \"foo\")        = 0.0\n     * distance.apply(\"foo\", \"foo \")       = 0.06\n     * distance.apply(\"foo\", \"foo  \")      = 0.09\n     * distance.apply(\"foo\", \" foo \")      = 0.13\n     * distance.apply(\"foo\", \"  foo\")      = 0.49\n     * distance.apply(\"\", \"a\")             = 1.0\n     * distance.apply(\"aaapppp\", \"\")       = 1.0\n     * distance.apply(\"frog\", \"fog\")       = 0.07\n     * distance.apply(\"fly\", \"ant\")        = 1.0\n     * distance.apply(\"elephant\", \"hippo\") = 0.56\n     * distance.apply(\"hippo\", \"elephant\") = 0.56\n     * distance.apply(\"hippo\", \"zzzzzzzz\") = 1.0\n     * distance.apply(\"hello\", \"hallo\")    = 0.12\n     * distance.apply(\"ABC Corporation\", \"ABC Corp\") = 0.07\n     * distance.apply(\"D N H Enterprises Inc\", \"D &amp; H Enterprises, Inc.\") = 0.05\n     * distance.apply(\"My Gym Children's Fitness Center\", \"My Gym. Childrens Fitness\") = 0.08\n     * distance.apply(\"PENNSYLVANIA\", \"PENNCISYLVNIA\") = 0.12\n     * </pre>\n     *\n     * @param left the first CharSequence, must not be null\n     * @param right the second CharSequence, must not be null\n     * @return result distance\n     * @throws IllegalArgumentException if either CharSequence input is {@code null}\n     */\n    @Override\n    public Double apply(CharSequence left, CharSequence right) {\n\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n\n        JaroWinklerSimilarity similarity = new JaroWinklerSimilarity();\n        return 1 - similarity.apply(left, right);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java b/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\nindex eaa9fb3e55..388d0c7140 100644\n--- a/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\n+++ b/src/main/java/org/apache/commons/text/similarity/JaroWinklerDistance.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.commons.text.similarity;\n \n+import java.util.Arrays;\n+\n /**\n  * Measures the Jaro-Winkler distance of two character sequences.\n  * It is the complementary of Jaro-Winkler similarity.\n@@ -24,6 +26,12 @@\n  */\n public class JaroWinklerDistance implements EditDistance<Double> {\n \n+    /**\n+     * @deprecated Deprecated as of 1.7. This constant will be removed in 2.0.\n+     */\n+    @Deprecated\n+    public static final int INDEX_NOT_FOUND = -1;\n+\n     /**\n      * Computes the Jaro Winkler Distance between two character sequences.\n      *\n@@ -63,7 +71,86 @@ public Double apply(CharSequence left, CharSequence right) {\n             throw new IllegalArgumentException(\"CharSequences must not be null\");\n         }\n \n-        JaroWinklerSimilarity similarity = new JaroWinklerSimilarity();\n-        return 1 - similarity.apply(left, right);\n+        // TODO: replace the rest of the code by this in 2.0, see TEXT-104\n+        //\n+        // JaroWinklerSimilarity similarity = new JaroWinklerSimilarity();\n+        // return 1 - similarity.apply(left, right);\n+\n+        final double defaultScalingFactor = 0.1;\n+        final int[] mtp = matches(left, right);\n+        final double m = mtp[0];\n+        if (m == 0) {\n+            return 0D;\n+        }\n+        final double j = ((m / left.length() + m / right.length() + (m - (double) mtp[1] / 2) / m)) / 3;\n+        final double jw = j < 0.7D ? j : j + defaultScalingFactor * mtp[2] * (1D - j);\n+        return jw;\n+    }\n+\n+    // TODO: remove this method in 2.0, see TEXT-104\n+    /**\n+     * This method returns the Jaro-Winkler string matches, half transpositions, prefix array.\n+     *\n+     * @param first the first string to be matched\n+     * @param second the second string to be matched\n+     * @return mtp array containing: matches, half transpositions, and prefix\n+     * @deprecated Deprecated as of 1.7. This method will be removed in 2.0, and moved to a Jaro Winkler similarity\n+     *             class.\n+     */\n+    @Deprecated\n+    protected static int[] matches(final CharSequence first, final CharSequence second) {\n+        CharSequence max, min;\n+        if (first.length() > second.length()) {\n+            max = first;\n+            min = second;\n+        } else {\n+            max = second;\n+            min = first;\n+        }\n+        final int range = Math.max(max.length() / 2 - 1, 0);\n+        final int[] matchIndexes = new int[min.length()];\n+        Arrays.fill(matchIndexes, -1);\n+        final boolean[] matchFlags = new boolean[max.length()];\n+        int matches = 0;\n+        for (int mi = 0; mi < min.length(); mi++) {\n+            final char c1 = min.charAt(mi);\n+            for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max.length()); xi < xn; xi++) {\n+                if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n+                    matchIndexes[mi] = xi;\n+                    matchFlags[xi] = true;\n+                    matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        final char[] ms1 = new char[matches];\n+        final char[] ms2 = new char[matches];\n+        for (int i = 0, si = 0; i < min.length(); i++) {\n+            if (matchIndexes[i] != -1) {\n+                ms1[si] = min.charAt(i);\n+                si++;\n+            }\n+        }\n+        for (int i = 0, si = 0; i < max.length(); i++) {\n+            if (matchFlags[i]) {\n+                ms2[si] = max.charAt(i);\n+                si++;\n+            }\n+        }\n+        int halfTranspositions = 0;\n+        for (int mi = 0; mi < ms1.length; mi++) {\n+            if (ms1[mi] != ms2[mi]) {\n+                halfTranspositions++;\n+            }\n+        }\n+        int prefix = 0;\n+        for (int mi = 0; mi < Math.min(4, min.length()); mi++) {\n+            if (first.charAt(mi) == second.charAt(mi)) {\n+                prefix++;\n+            } else {\n+                break;\n+            }\n+        }\n+        return new int[] {matches, halfTranspositions, prefix};\n     }\n }\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/text/similarity/JaroWinklerDistanceTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  }
]