[
  {
    "pr_number": 206,
    "title": "[CLI-320] Awkward behavior of Option.builder() for multiple optional args",
    "state": "closed",
    "created_at": "2023-11-02T02:45:00Z",
    "merge_commit_sha": "fbd01940d2e675fb1fd2a5b526f831bd0853ce55",
    "base_sha": "fb92585d967e53e87886e0652755ad921b645c32",
    "head_sha": "03e9ab2dc275f762b86ce2b51e1ce3f669f4896b",
    "user_login": "paulk-asert",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/cli/Option.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.Test;\n\npublic class OptionTest2 {\n\n    /**\n     * Test to ensure that when optionalArg is true and argCount is UNINITIALIZED,\n     * argCount is set to 1.\n     */\n    @Test\n    public void testOptionalArgSetsArgCount() {\n        Option option = Option.builder(\"a\").optionalArg(true).build();\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n    }\n\n    /**\n     * Test to ensure that when optionalArg is true and argCount is already set,\n     * argCount is not overridden.\n     */\n    @Test\n    public void testOptionalArgDoesNotOverrideArgCount() {\n        Option option = Option.builder(\"a\").numberOfArgs(3).optionalArg(true).build();\n        assertTrue(option.hasOptionalArg());\n        assertEquals(3, option.getArgs());\n    }\n\n    /**\n     * Test to ensure that when optionalArg is false, argCount is set to UNINITIALIZED.\n     */\n    @Test\n    public void testOptionalArgFalseSetsArgCountUninitialized() {\n        Option option = Option.builder(\"a\").optionalArg(false).build();\n        assertFalse(option.hasOptionalArg());\n        assertEquals(Option.UNINITIALIZED, option.getArgs());\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.apache.commons.cli.Util.EMPTY_STRING_ARRAY;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * Describes a single command-line option. It maintains information regarding the short-name of the option, the\n * long-name, if any exists, a flag indicating if an argument is required for this option, and a self-documenting\n * description of the option.\n * <p>\n * An Option is not created independently, but is created through an instance of {@link Options}. An Option is required\n * to have at least a short or a long-name.\n * </p>\n * <p>\n * <b>Note:</b> once an {@link Option} has been added to an instance of {@link Options}, its required flag cannot be\n * changed.\n * </p>\n *\n * @see org.apache.commons.cli.Options\n * @see org.apache.commons.cli.CommandLine\n */\npublic class Option implements Cloneable, Serializable {\n\n    /**\n     * A nested builder class to create {@code Option} instances using descriptive methods.\n     * <p>\n     * Example usage:\n     * </p>\n     *\n     * <pre>\n     * Option option = Option.builder(\"a\").required(true).longOpt(\"arg-name\").build();\n     * </pre>\n     *\n     * @since 1.3\n     */\n    public static final class Builder {\n\n        /** The name of the option */\n        private String option;\n\n        /** Description of the option */\n        private String description;\n\n        /** The long representation of the option */\n        private String longOption;\n\n        /** The name of the argument for this option */\n        private String argName;\n\n        /** Specifies whether this option is required to be present */\n        private boolean required;\n\n        /** Specifies whether the argument value of this Option is optional */\n        private boolean optionalArg;\n\n        /** The number of argument values this option can have */\n        private int argCount = UNINITIALIZED;\n\n        /** The type of this Option */\n        private Class<?> type = String.class;\n\n        /** The character that is the value separator */\n        private char valueSeparator;\n\n        /** The converter to convert to type **/\n        private Converter<?, ?> converter;\n\n        /**\n         * Constructs a new {@code Builder} with the minimum required parameters for an {@code Option} instance.\n         *\n         * @param option short representation of the option\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n         */\n        private Builder(final String option) throws IllegalArgumentException {\n            option(option);\n        }\n\n        /**\n         * Sets the display name for the argument value.\n         *\n         * @param argName the display name for the argument value.\n         * @return this builder, to allow method chaining\n         */\n        public Builder argName(final String argName) {\n            this.argName = argName;\n            return this;\n        }\n\n        /**\n         * Constructs an Option with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link Option}\n         * @throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set\n         */\n        public Option build() {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }\n\n        /**\n         * Sets the converter for the option.\n         * <p>Note: see {@link TypeHandler} for serialization discussion.</p>\n         * @param converter the Converter to use.\n         * @return this builder, to allow method chaining.\n         * @since 1.7.0\n         */\n        public Builder converter(final Converter<?, ?> converter) {\n            this.converter = converter;\n            return this;\n        }\n\n        /**\n         * Sets the description for this option.\n         *\n         * @param description the description of the option.\n         * @return this builder, to allow method chaining\n         */\n        public Builder desc(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Indicates that the Option will require an argument.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArg() {\n            return hasArg(true);\n        }\n\n        /**\n         * Indicates if the Option has an argument or not.\n         *\n         * @param hasArg specifies whether the Option takes an argument or not\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArg(final boolean hasArg) {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : Option.UNINITIALIZED;\n            return this;\n        }\n\n        /**\n         * Indicates that the Option can have unlimited argument values.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArgs() {\n            argCount = Option.UNLIMITED_VALUES;\n            return this;\n        }\n\n        /**\n         * Sets the long name of the Option.\n         *\n         * @param longOpt the long name of the Option\n         * @return this builder, to allow method chaining\n         */\n        public Builder longOpt(final String longOpt) {\n            this.longOption = longOpt;\n            return this;\n        }\n\n        /**\n         * Sets the number of argument values the Option can take.\n         *\n         * @param argCount the number of argument values\n         * @return this builder, to allow method chaining\n         */\n        public Builder numberOfArgs(final int argCount) {\n            this.argCount = argCount;\n            return this;\n        }\n\n        /**\n         * Sets the name of the Option.\n         *\n         * @param option the name of the Option\n         * @return this builder, to allow method chaining\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n         * @since 1.5.0\n         */\n        public Builder option(final String option) throws IllegalArgumentException {\n            this.option = OptionValidator.validate(option);\n            return this;\n        }\n\n        /**\n         * Sets whether the Option can have an optional argument.\n         *\n         * @param optionalArg specifies whether the Option can have an optional argument.\n         * @return this builder, to allow method chaining\n         */\n        public Builder optionalArg(final boolean optionalArg) {\n            this.argCount = optionalArg ? 1 : UNINITIALIZED;\n            this.optionalArg = optionalArg;\n            return this;\n        }\n\n        /**\n         * Marks this Option as required.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder required() {\n            return required(true);\n        }\n\n        /**\n         * Sets whether the Option is mandatory.\n         *\n         * @param required specifies whether the Option is mandatory\n         * @return this builder, to allow method chaining\n         */\n        public Builder required(final boolean required) {\n            this.required = required;\n            return this;\n        }\n\n        /**\n         * Sets the type of the Option.\n         *\n         * @param type the type of the Option\n         * @return this builder, to allow method chaining\n         */\n        public Builder type(final Class<?> type) {\n            this.type = type;\n            return this;\n        }\n\n        /**\n         * The Option will use '=' as a means to separate argument value.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder valueSeparator() {\n            return valueSeparator('=');\n        }\n\n        /**\n         * The Option will use {@code sep} as a means to separate argument values.\n         * <p>\n         * <b>Example:</b>\n         * </p>\n         *\n         * <pre>\n         * Option opt = Option.builder(\"D\").hasArgs().valueSeparator('=').build();\n         * Options options = new Options();\n         * options.addOption(opt);\n         * String[] args = {\"-Dkey=value\"};\n         * CommandLineParser parser = new DefaultParser();\n         * CommandLine line = parser.parse(options, args);\n         * String propertyName = line.getOptionValues(\"D\")[0]; // will be \"key\"\n         * String propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n         * </pre>\n         *\n         * @param valueSeparator The value separator.\n         * @return this builder, to allow method chaining\n         */\n        public Builder valueSeparator(final char valueSeparator) {\n            this.valueSeparator = valueSeparator;\n            return this;\n        }\n\n    }\n\n    /** Specifies the number of argument values has not been specified */\n    public static final int UNINITIALIZED = -1;\n\n    /** Specifies the number of argument values is infinite */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** Empty array. */\n    static final Option[] EMPTY_ARRAY = {};\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @return a new {@link Builder} instance\n     * @since 1.3\n     */\n    public static Builder builder() {\n        return builder(null);\n    }\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @param option short representation of the option\n     * @return a new {@link Builder} instance\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n     * @since 1.3\n     */\n    public static Builder builder(final String option) {\n        return new Builder(option);\n    }\n\n    /** The name of the option. */\n    private final String option;\n\n    /** The long representation of the option. */\n    private String longOption;\n\n    /** The name of the argument for this option. */\n    private String argName;\n\n    /** Description of the option. */\n    private String description;\n\n    /** Specifies whether this option is required to be present. */\n    private boolean required;\n\n    /** Specifies whether the argument value of this Option is optional. */\n    private boolean optionalArg;\n\n    /** The number of argument values this option can have. */\n    private int argCount = UNINITIALIZED;\n\n    /** The type of this Option. */\n    private Class<?> type = String.class;\n\n    /** The list of argument values. **/\n    private List<String> values = new ArrayList<>();\n\n    /** The character that is the value separator. */\n    private char valuesep;\n\n    /** The explicit converter for this option.  May be null */\n    private transient Converter<?, ?> converter;\n\n    /**\n     * Private constructor used by the nested Builder class.\n     *\n     * @param builder builder used to create this option\n     */\n    private Option(final Builder builder) {\n        this.argName = builder.argName;\n        this.description = builder.description;\n        this.longOption = builder.longOption;\n        this.argCount = builder.argCount;\n        this.option = builder.option;\n        this.optionalArg = builder.optionalArg;\n        this.required = builder.required;\n        this.type = builder.type;\n        this.valuesep = builder.valueSeparator;\n        this.converter = builder.converter;\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option short representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final boolean hasArg, final String description) throws IllegalArgumentException {\n        this(option, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters. The option does not take an argument.\n     *\n     * @param option short representation of the option\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String description) throws IllegalArgumentException {\n        this(option, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option short representation of the option\n     * @param longOption the long representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String longOption, final boolean hasArg, final String description) throws IllegalArgumentException {\n        // ensure that the option is valid\n        this.option = OptionValidator.validate(option);\n        this.longOption = longOption;\n\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg) {\n            this.argCount = 1;\n        }\n\n        this.description = description;\n    }\n\n    /**\n     * Tells if the option can accept more arguments.\n     *\n     * @return false if the maximum number of arguments is reached\n     * @since 1.3\n     */\n    boolean acceptsArg() {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (argCount <= 0 || values.size() < argCount);\n    }\n\n    /**\n     * Add the value to this Option. If the number of arguments is greater than zero and there is enough space in the list\n     * then add the value. Otherwise, throw a runtime exception.\n     *\n     * @param value The value to be added to this Option\n     *\n     * @since 1.0.1\n     */\n    private void add(final String value) {\n        if (!acceptsArg()) {\n            throw new IllegalArgumentException(\"Cannot add value, list full.\");\n        }\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal API that was made public in 1.0. It currently\n     * throws an UnsupportedOperationException.\n     *\n     * @param value the value to add\n     * @return always throws an {@link UnsupportedOperationException}\n     * @throws UnsupportedOperationException always\n     * @deprecated Unused.\n     */\n    @Deprecated\n    public boolean addValue(final String value) {\n        throw new UnsupportedOperationException(\n            \"The addValue method is not intended for client use. \" + \"Subclasses should use the addValueForProcessing method instead. \");\n    }\n\n    /**\n     * Adds the specified value to this Option.\n     *\n     * @param value is a/the value of this Option\n     */\n    void addValueForProcessing(final String value) {\n        if (argCount == UNINITIALIZED) {\n            throw new IllegalArgumentException(\"NO_ARGS_ALLOWED\");\n        }\n        processValue(value);\n    }\n\n    /**\n     * Clear the Option values. After a parse is complete, these are left with data in them and they need clearing if\n     * another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues() {\n        values.clear();\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public and in 1.1 rather than throwing a\n     * CloneNotSupportedException it throws a RuntimeException so as to maintain backwards compat at the API level.\n     *\n     * After calling this method, it is very likely you will want to call clearValues().\n     *\n     * @return a clone of this Option instance\n     * @throws RuntimeException if a {@link CloneNotSupportedException} has been thrown by {@code super.clone()}\n     */\n    @Override\n    public Object clone() {\n        try {\n            final Option option = (Option) super.clone();\n            option.values = new ArrayList<>(values);\n            return option;\n        } catch (final CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Option)) {\n            return false;\n        }\n        final Option other = (Option) obj;\n        return Objects.equals(longOption, other.longOption) && Objects.equals(option, other.option);\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName() {\n        return argName;\n    }\n\n    /**\n     * Gets the number of argument values this Option can take.\n     *\n     * <p>\n     * A value equal to the constant {@link #UNINITIALIZED} (= -1) indicates the number of arguments has not been specified.\n     * A value equal to the constant {@link #UNLIMITED_VALUES} (= -2) indicates that this options takes an unlimited amount\n     * of values.\n     * </p>\n     *\n     * @return num the number of argument values\n     * @see #UNINITIALIZED\n     * @see #UNLIMITED_VALUES\n     */\n    public int getArgs() {\n        return argCount;\n    }\n\n    /**\n     * Gets the value to type converter.\n     * @return the value to type converter\n     * @since 1.7.0\n     */\n    public Converter<?, ?> getConverter() {\n        return converter == null ? TypeHandler.getConverter(type) : converter;\n    }\n\n    /**\n     * Gets the self-documenting description of this Option\n     *\n     * @return The string description of this option\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Gets the id of this Option. This is only set when the Option shortOpt is a single character. This is used for\n     * switch statements.\n     *\n     * @return the id of this Option\n     */\n    public int getId() {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Gets the 'unique' Option identifier.\n     *\n     * @return the 'unique' Option identifier\n     */\n    String getKey() {\n        // if 'opt' is null, then it is a 'long' option\n        return option == null ? longOption : option;\n    }\n\n    /**\n     * Gets the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name\n     */\n    public String getLongOpt() {\n        return longOption;\n    }\n\n    /**\n     * Gets the name of this Option.\n     *\n     * It is this String which can be used with {@link CommandLine#hasOption(String opt)} and\n     * {@link CommandLine#getOptionValue(String opt)} to check for existence and argument.\n     *\n     * @return The name of this option\n     */\n    public String getOpt() {\n        return option;\n    }\n\n    /**\n     * Gets the type of this Option.\n     *\n     * @return The type of this option\n     */\n    public Object getType() {\n        return type;\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @return the value/first value of this Option or {@code null} if there is no value.\n     */\n    public String getValue() {\n        return hasNoValues() ? null : values.get(0);\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or {@code null} if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1 or greater than the number of the values for this Option.\n     */\n    public String getValue(final int index) throws IndexOutOfBoundsException {\n        return hasNoValues() ? null : values.get(index);\n    }\n\n    /**\n     * Gets the value/first value of this Option or the {@code defaultValue} if there is no value.\n     *\n     * @param defaultValue The value to be returned if there is no value.\n     *\n     * @return the value/first value of this Option or the {@code defaultValue} if there are no values.\n     */\n    public String getValue(final String defaultValue) {\n        final String value = getValue();\n\n        return value != null ? value : defaultValue;\n    }\n\n    /**\n     * Gets the values of this Option as a String array or null if there are no values\n     *\n     * @return the values of this Option as a String array or null if there are no values\n     */\n    public String[] getValues() {\n        return hasNoValues() ? null : values.toArray(EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Gets the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator() {\n        return valuesep;\n    }\n\n    /**\n     * Gets the values of this Option as a List or null if there are no values.\n     *\n     * @return the values of this Option as a List or null if there are no values\n     */\n    public List<String> getValuesList() {\n        return values;\n    }\n\n    /**\n     * Query to see if this Option requires an argument\n     *\n     * @return boolean flag indicating if an argument is required\n     */\n    public boolean hasArg() {\n        return argCount > 0 || argCount == UNLIMITED_VALUES;\n    }\n\n    /**\n     * Returns whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName() {\n        return argName != null && !argName.isEmpty();\n    }\n\n    /**\n     * Query to see if this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed\n     */\n    public boolean hasArgs() {\n        return argCount > 1 || argCount == UNLIMITED_VALUES;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(longOption, option);\n    }\n\n    /**\n     * Query to see if this Option has a long name\n     *\n     * @return boolean flag indicating existence of a long name\n     */\n    public boolean hasLongOpt() {\n        return longOption != null;\n    }\n\n    /**\n     * Returns whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues() {\n        return values.isEmpty();\n    }\n\n    /**\n     * Returns whether this Option can have an optional argument.\n     *\n     * @return whether this Option can have an optional argument\n     */\n    public boolean hasOptionalArg() {\n        return optionalArg;\n    }\n\n    /**\n     * Return whether this Option has specified a value separator.\n     *\n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator() {\n        return valuesep > 0;\n    }\n\n    /**\n     * Query to see if this Option is mandatory\n     *\n     * @return boolean flag indicating whether this Option is mandatory\n     */\n    public boolean isRequired() {\n        return required;\n    }\n\n    /**\n     * Processes the value. If this Option has a value separator the value will have to be parsed into individual tokens.\n     * When n-1 tokens have been processed and there are more value separators in the value, parsing is ceased and the\n     * remaining characters are added as a single token.\n     *\n     * @param value The String to be processed.\n     *\n     * @since 1.0.1\n     */\n    private void processValue(final String value) {\n        String add = value;\n        // this Option has a separator character\n        if (hasValueSeparator()) {\n            // get the separator character\n            final char sep = getValueSeparator();\n\n            // store the index for the value separator\n            int index = add.indexOf(sep);\n\n            // while there are more value separators\n            while (index != -1) {\n                // next value to be added\n                if (values.size() == argCount - 1) {\n                    break;\n                }\n\n                // store\n                add(add.substring(0, index));\n\n                // parse\n                add = add.substring(index + 1);\n\n                // get new index\n                index = add.indexOf(sep);\n            }\n        }\n\n        // store the actual value or the last value that has been parsed\n        add(add);\n    }\n\n    /**\n     * Tells if the option requires more arguments to be valid.\n     *\n     * @return false if the option doesn't require more arguments\n     * @since 1.3\n     */\n    boolean requiresArg() {\n        if (optionalArg) {\n            return false;\n        }\n        if (argCount == UNLIMITED_VALUES) {\n            return values.isEmpty();\n        }\n        return acceptsArg();\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(final String argName) {\n        this.argName = argName;\n    }\n\n    /**\n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values\n     */\n    public void setArgs(final int num) {\n        this.argCount = num;\n    }\n\n    /**\n     * Sets the value to type converter.\n     * @param converter The converter to convert the string value to the type.\n     * @since 1.7.0\n     */\n    public void setConverter(final Converter<?, ?> converter) {\n        this.converter = converter;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option\n     *\n     * @param description The description of this option\n     * @since 1.1\n     */\n    public void setDescription(final String description) {\n        this.description = description;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option\n     */\n    public void setLongOpt(final String longOpt) {\n        this.longOption = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have an optional argument.\n     */\n    public void setOptionalArg(final boolean optionalArg) {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory\n     */\n    public void setRequired(final boolean required) {\n        this.required = required;\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option\n     * @since 1.3\n     */\n    public void setType(final Class<?> type) {\n        this.type = type;\n    }\n\n    /**\n     * Sets the type of this Option.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class}\n     * object.\n     * </p>\n     *\n     * @param type the type of this Option\n     * @deprecated since 1.3, use {@link #setType(Class)} instead\n     */\n    @Deprecated\n    public void setType(final Object type) {\n        setType((Class<?>) type);\n    }\n\n    /**\n     * Sets the value separator. For example if the argument value was a Java property, the value separator would be '='.\n     *\n     * @param sep The value separator.\n     */\n    public void setValueSeparator(final char sep) {\n        this.valuesep = sep;\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder().append(\"[ option: \");\n\n        buf.append(option);\n\n        if (longOption != null) {\n            buf.append(\" \").append(longOption);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs()) {\n            buf.append(\"[ARG...]\");\n        } else if (hasArg()) {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null) {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/Option.java b/src/main/java/org/apache/commons/cli/Option.java\nindex fef6f0343..df7852cfb 100644\n--- a/src/main/java/org/apache/commons/cli/Option.java\n+++ b/src/main/java/org/apache/commons/cli/Option.java\n@@ -201,7 +201,9 @@ public Builder option(final String option) throws IllegalArgumentException {\n          * @return this builder, to allow method chaining\n          */\n         public Builder optionalArg(final boolean optionalArg) {\n-            this.argCount = optionalArg ? 1 : UNINITIALIZED;\n+            if (optionalArg && this.argCount == UNINITIALIZED) {\n+                this.argCount = 1;\n+            }\n             this.optionalArg = optionalArg;\n             return this;\n         }\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/AbstractParserTestCase.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 186,
    "title": "CLI-313: Fixed StringIndexOutOfBoundsException for Java-like property token",
    "state": "closed",
    "created_at": "2023-08-17T14:20:30Z",
    "merge_commit_sha": "0374deecea322be7500dd7164106b1bfe1dd0ce9",
    "base_sha": "3790cec2dbc27f66f4518dcf311cbd70d9e2140b",
    "head_sha": "379558822e41b749b968a9cd7ca90d371c927e30",
    "user_login": "kumarp149",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/cli/DefaultParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class DefaultParserTest2 extends AbstractParserTestCase {\n\n    @Override\n    @Before\n    public void setUp() {\n        super.setUp();\n        parser = new DefaultParser();\n    }\n\n    /**\n     * Test to ensure that isJavaProperty handles empty string correctly.\n     */\n    @Test\n    public void testIsJavaPropertyWithEmptyString() {\n        parser = DefaultParser.builder().build();\n        // Assuming we have access to a method to test private methods or using reflection\n        boolean result = invokeIsJavaProperty(\"\");\n        assertEquals(\"Empty string should not be considered a Java property\", false, result);\n    }\n\n    /**\n     * Test to ensure that isJavaProperty handles null correctly.\n     */\n    @Test\n    public void testIsJavaPropertyWithNull() {\n        parser = DefaultParser.builder().build();\n        // Assuming we have access to a method to test private methods or using reflection\n        boolean result = invokeIsJavaProperty(null);\n        assertEquals(\"Null should not be considered a Java property\", false, result);\n    }\n\n    /**\n     * Utility method to invoke the private isJavaProperty method using reflection.\n     */\n    private boolean invokeIsJavaProperty(String token) {\n        try {\n            java.lang.reflect.Method method = DefaultParser.class.getDeclaredMethod(\"isJavaProperty\", String.class);\n            method.setAccessible(true);\n            return (boolean) method.invoke(parser, token);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Default parser.\n *\n * @since 1.3\n */\npublic class DefaultParser implements CommandLineParser {\n\n    /**\n     * A nested builder class to create {@code DefaultParser} instances\n     * using descriptive methods.\n     *\n     * Example usage:\n     * <pre>\n     * DefaultParser parser = Option.builder()\n     *     .setAllowPartialMatching(false)\n     *     .setStripLeadingAndTrailingQuotes(false)\n     *     .build();\n     * </pre>\n     *\n     * @since 1.5.0\n     */\n    public static final class Builder {\n\n        /** Flag indicating if partial matching of long options is supported. */\n        private boolean allowPartialMatching = true;\n\n        /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments. */\n        private Boolean stripLeadingAndTrailingQuotes;\n\n        /**\n         * Constructs a new {@code Builder} for a {@code DefaultParser} instance.\n         *\n         * Both allowPartialMatching and stripLeadingAndTrailingQuotes are true by default,\n         * mimicking the argument-less constructor.\n         */\n        private Builder() {\n        }\n\n        /**\n         * Builds an DefaultParser with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link DefaultParser}\n         * @since 1.5.0\n         */\n        public DefaultParser build() {\n            return new DefaultParser(allowPartialMatching, stripLeadingAndTrailingQuotes);\n        }\n\n        /**\n         * Sets if partial matching of long options is supported.\n         *\n         * By \"partial matching\" we mean that given the following code:\n         *\n         * <pre>\n         * {\n         *     &#64;code\n         *     final Options options = new Options();\n         *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n         *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n         *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n         * }\n         * </pre>\n         *\n         * If \"partial matching\" is turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n         * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n         *\n         * @param allowPartialMatching whether to allow partial matching of long options\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setAllowPartialMatching(final boolean allowPartialMatching) {\n            this.allowPartialMatching = allowPartialMatching;\n            return this;\n        }\n\n        /**\n         * Sets if balanced leading and trailing double quotes should be stripped from option arguments.\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is true,\n         * the outermost balanced double quotes of option arguments values will be removed.\n         * For example, {@code -o '\"x\"'} getValue() will return {@code x}, instead of {@code \"x\"}\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is null,\n         * then quotes will be stripped from option values separated by space from the option, but\n         * kept in other cases, which is the historic behavior.\n         *\n         * @param stripLeadingAndTrailingQuotes whether balanced leading and trailing double quotes should be stripped from option arguments.\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setStripLeadingAndTrailingQuotes(final Boolean stripLeadingAndTrailingQuotes) {\n            this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n            return this;\n        }\n    }\n\n    /**\n     * Creates a new {@link Builder} to create an {@link DefaultParser} using descriptive\n     * methods.\n     *\n     * @return a new {@link Builder} instance\n     * @since 1.5.0\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    /** The command-line instance. */\n    protected CommandLine cmd;\n\n    /** The current options. */\n    protected Options options;\n\n    /**\n     * Flag indicating how unrecognized tokens are handled. {@code true} to stop the parsing and add the remaining\n     * tokens to the args list. {@code false} to throw an exception.\n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n\n    /** The last option parsed. */\n    protected Option currentOption;\n\n    /** Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n\n    /** The required options and groups expected to be found when parsing the command line. */\n    protected List expectedOpts;\n\n    /** Flag indicating if partial matching of long options is supported. */\n    private final boolean allowPartialMatching;\n\n    /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments.\n     * null represents the historic arbitrary behavior */\n    private final Boolean stripLeadingAndTrailingQuotes;\n\n    /**\n     * Creates a new DefaultParser instance with partial matching enabled.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     *\n     * <pre>\n     * {\n     *     &#64;code\n     *     final Options options = new Options();\n     *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     * }\n     * </pre>\n     *\n     * with \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n     * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n     * options.\n     */\n    public DefaultParser() {\n        this.allowPartialMatching = true;\n        this.stripLeadingAndTrailingQuotes = null;\n    }\n\n    /**\n     * Create a new DefaultParser instance with the specified partial matching policy.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     *\n     * <pre>\n     * {\n     *     &#64;code\n     *     final Options options = new Options();\n     *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     * }\n     * </pre>\n     *\n     * with \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n     * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n     * options.\n     *\n     * @param allowPartialMatching if partial matching of long options shall be enabled\n     */\n    public DefaultParser(final boolean allowPartialMatching) {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = null;\n    }\n\n    /**\n     * Creates a new DefaultParser instance with the specified partial matching and quote\n     * stripping policy.\n     *\n     * @param allowPartialMatching if partial matching of long options shall be enabled\n     * @param stripLeadingAndTrailingQuotes if balanced outer double quoutes should be stripped\n     */\n    private DefaultParser(final boolean allowPartialMatching,\n            final Boolean stripLeadingAndTrailingQuotes) {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n    }\n\n    /**\n     * Throws a {@link MissingArgumentException} if the current option didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg()) {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty()) {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Searches for a prefix that is the long name of an option (-Xmx512m)\n     *\n     * @param token\n     */\n    private String getLongPrefix(final String token) {\n        final String t = Util.stripLeadingHyphens(token);\n\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--) {\n            final String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix)) {\n                opt = prefix;\n                break;\n            }\n        }\n\n        return opt;\n    }\n\n    /**\n     * Gets a list of matching option strings for the given token, depending on the selected partial matching policy.\n     *\n     * @param token the token (may contain leading dashes)\n     * @return the list of matching option strings or an empty list if no matching option could be found\n     */\n    private List<String> getMatchingLongOptions(final String token) {\n        if (allowPartialMatching) {\n            return options.getMatchingOptions(token);\n        }\n        final List<String> matches = new ArrayList<>(1);\n        if (options.hasLongOption(token)) {\n            final Option option = options.getOption(token);\n            matches.add(option.getLongOpt());\n        }\n\n        return matches;\n    }\n\n    /**\n     * Breaks {@code token} into its constituent parts using the following algorithm.\n     *\n     * <ul>\n     * <li>ignore the first character (\"<b>-</b>\")</li>\n     * <li>for each remaining character check if an {@link Option} exists with that id.</li>\n     * <li>if an {@link Option} does exist then add that character prepended with \"<b>-</b>\" to the list of processed\n     * tokens.</li>\n     * <li>if the {@link Option} can have an argument value and there are remaining characters in the token then add the\n     * remaining characters as a token to the list of processed tokens.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS</b> set then add the\n     * special token \"<b>--</b>\" followed by the remaining characters and also the remaining tokens directly to the\n     * processed tokens list.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS NOT</b> set then add\n     * that character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b> at the first non-Option encountered.\n     * @throws ParseException if there are any problems encountered while parsing the command line token.\n     */\n    protected void handleConcatenatedOptions(final String token) throws ParseException {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n\n            if (!options.hasOption(ch)) {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n            handleOption(options.getOption(ch));\n\n            if (currentOption != null && token.length() != i + 1) {\n                // add the trail as an argument of the option\n                currentOption.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOff(token.substring(i + 1)));\n                break;\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L --L=V --L V --l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOption(final String token) throws ParseException {\n        if (token.indexOf('=') == -1) {\n            handleLongOptionWithoutEqual(token);\n        } else {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L=V -L=V --l=V -l=V\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(final String token) throws ParseException {\n        final int pos = token.indexOf('=');\n\n        final String value = token.substring(pos + 1);\n\n        final String opt = token.substring(0, pos);\n\n        final List<String> matchingOpts = getMatchingLongOptions(opt);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(opt)) {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(opt) ? opt : matchingOpts.get(0);\n            final Option option = options.getOption(key);\n\n            if (option.acceptsArg()) {\n                handleOption(option);\n                currentOption.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOff(value));\n                currentOption = null;\n            } else {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L -L --l -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(final String token) throws ParseException {\n        final List<String> matchingOpts = getMatchingLongOptions(token);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(token)) {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(token) ? token : matchingOpts.get(0);\n            handleOption(options.getOption(key));\n        }\n    }\n\n    private void handleOption(Option option) throws ParseException {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n\n        option = (Option) option.clone();\n\n        updateRequiredOptions(option);\n\n        cmd.addOption(option);\n\n        if (option.hasArg()) {\n            currentOption = option;\n        } else {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Sets the values of Options using the values in {@code properties}.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties\n                final String value = properties.getProperty(option);\n\n                if (opt.hasArg()) {\n                    if (opt.getValues() == null || opt.getValues().length == 0) {\n                        opt.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOff(value));\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * -S -SV -S V -S=V -S1S2 -S1S2 V -SV1=V2\n     *\n     * -L -LV -L V -L=V -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleShortAndLongOption(final String token) throws ParseException {\n        final String t = Util.stripLeadingHyphens(token);\n\n        final int pos = t.indexOf('=');\n\n        if (t.length() == 1) {\n            // -S\n            if (options.hasShortOption(t)) {\n                handleOption(options.getOption(t));\n            } else {\n                handleUnknownToken(token);\n            }\n        } else if (pos == -1) {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(t)) {\n                handleOption(options.getOption(t));\n            } else if (!getMatchingLongOptions(t).isEmpty()) {\n                // -L or -l\n                handleLongOptionWithoutEqual(token);\n            } else {\n                // look for a long prefix (-Xmx512m)\n                final String opt = getLongPrefix(t);\n\n                if (opt != null && options.getOption(opt).acceptsArg()) {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOff(t.substring(opt.length())));\n                    currentOption = null;\n                } else if (isJavaProperty(t)) {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOff(t.substring(1)));\n                    currentOption = null;\n                } else {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(token);\n                }\n            }\n        } else {\n            // equal sign found (-xxx=yyy)\n            final String opt = t.substring(0, pos);\n            final String value = t.substring(pos + 1);\n\n            if (opt.length() == 1) {\n                // -S=V\n                final Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg()) {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                } else {\n                    handleUnknownToken(token);\n                }\n            } else if (isJavaProperty(opt)) {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            } else {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    /**\n     * Handles any command line token.\n     *\n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(final String token) throws ParseException {\n        currentToken = token;\n\n        if (skipParsing) {\n            cmd.addArg(token);\n        } else if (\"--\".equals(token)) {\n            skipParsing = true;\n        } else if (currentOption != null && currentOption.acceptsArg() && isArgument(token)) {\n            currentOption.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOn(token));\n        } else if (token.startsWith(\"--\")) {\n            handleLongOption(token);\n        } else if (token.startsWith(\"-\") && !\"-\".equals(token)) {\n            handleShortAndLongOption(token);\n        } else {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg()) {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an UnrecognizedOptionException is thrown. Otherwise the\n     * token is added to the arguments of the command line. If the stopAtNonOption flag is set, this stops the parsing and\n     * the remaining tokens are added as-is in the arguments of the command line.\n     *\n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(final String token) throws ParseException {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n\n        cmd.addArg(token);\n        if (stopAtNonOption) {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Tests if the token is a valid argument.\n     *\n     * @param token\n     */\n    private boolean isArgument(final String token) {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Tests if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(final String token) {\n        final String opt = token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    /**\n     * Tests if the token looks like a long option.\n     *\n     * @param token\n     */\n    private boolean isLongOption(final String token) {\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n\n        final int pos = token.indexOf(\"=\");\n        final String t = pos == -1 ? token : token.substring(0, pos);\n\n        if (!getMatchingLongOptions(t).isEmpty()) {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        if (getLongPrefix(token) != null && !token.startsWith(\"--\")) {\n            // -LV\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Tests if the token is a negative number.\n     *\n     * @param token\n     */\n    private boolean isNegativeNumber(final String token) {\n        try {\n            Double.parseDouble(token);\n            return true;\n        } catch (final NumberFormatException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests if the token looks like an option.\n     *\n     * @param token\n     */\n    private boolean isOption(final String token) {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tests if the token looks like a short option.\n     *\n     * @param token\n     */\n    private boolean isShortOption(final String token) {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        final int pos = token.indexOf(\"=\");\n        final String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName)) {\n            return true;\n        }\n        // check for several concatenated short options\n        return !optName.isEmpty() && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null);\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)\n        throws ParseException {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList<>(options.getRequiredOptions());\n\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n\n        cmd = new CommandLine();\n\n        if (arguments != null) {\n            for (final String argument : arguments) {\n                handleToken(argument);\n            }\n        }\n\n        // check the arguments of the last option\n        checkRequiredArgs();\n\n        // add the default options\n        handleProperties(properties);\n\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Strips balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\n     * If stripLeadingAndTrailingQuotes is null, then do not strip\n     *\n     * @param token a string\n     * @return token with the quotes stripped (if set)\n     */\n    private String stripLeadingAndTrailingQuotesDefaultOff(final String token) {\n        if (stripLeadingAndTrailingQuotes != null && stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }\n\n    /**\n     * Strips balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\n     * If stripLeadingAndTrailingQuotes is null, then do not strip\n     *\n     * @param token a string\n     * @return token with the quotes stripped (if set)\n     */\n    private String stripLeadingAndTrailingQuotesDefaultOn(final String token) {\n        if (stripLeadingAndTrailingQuotes == null || stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param option\n     */\n    private void updateRequiredOptions(final Option option) throws AlreadySelectedException {\n        if (option.isRequired()) {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null) {\n            final OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired()) {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/DefaultParser.java b/src/main/java/org/apache/commons/cli/DefaultParser.java\nindex 8b69a7668..8a027094c 100644\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n@@ -580,7 +580,7 @@ private boolean isArgument(final String token) {\n      * Tests if the specified token is a Java-like property (-Dkey=value).\n      */\n     private boolean isJavaProperty(final String token) {\n-        final String opt = token.substring(0, 1);\n+        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n         final Option option = options.getOption(opt);\n \n         return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/ParserTestCase.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 112,
    "title": "Delete unused assignment.",
    "state": "closed",
    "created_at": "2022-06-24T20:16:18Z",
    "merge_commit_sha": "61a465a96a4c67012a924ee0467760c02ad6f479",
    "base_sha": "88713a0697ec763d36bb4d6b30d7554b2e05a133",
    "head_sha": "5a6968236e177d02f7bc75369f99aca102ffc252",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/cli/OptionBuilder.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport org.junit.Test;\n\n@SuppressWarnings(\"deprecation\")\npublic class OptionBuilderTest2 {\n\n    @Test\n    public void testCreateOptionWithValidStringOpt() {\n        final Option option = OptionBuilder.withDescription(\"test description\").create(\"t\");\n        assertEquals(\"t\", option.getOpt());\n        assertEquals(\"test description\", option.getDescription());\n        assertFalse(option.hasArg());\n    }\n\n    @Test\n    public void testCreateOptionWithInvalidStringOpt() {\n        try {\n            OptionBuilder.withDescription(\"test description\").create(\"\");\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testCreateOptionWithValidCharOpt() {\n        final Option option = OptionBuilder.withDescription(\"test description\").create('t');\n        assertEquals(\"t\", option.getOpt());\n        assertEquals(\"test description\", option.getDescription());\n        assertFalse(option.hasArg());\n    }\n\n    @Test\n    public void testCreateOptionWithInvalidCharOpt() {\n        try {\n            OptionBuilder.withDescription(\"test description\").create(' ');\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testResetAfterException() {\n        try {\n            OptionBuilder.withDescription(\"test description\").create(' ');\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n        assertNull(\"Description should be reset\", OptionBuilder.create('x').getDescription());\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * OptionBuilder allows the user to create Options using descriptive methods.\n * <p>\n * Details on the Builder pattern can be found at\n * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">http://c2.com/cgi-bin/wiki?BuilderPattern</a>.\n * <p>\n * This class is NOT thread safe. See <a href=\"https://issues.apache.org/jira/browse/CLI-209\">CLI-209</a>\n *\n * @since 1.0\n * @deprecated since 1.3, use {@link Option#builder(String)} instead\n */\n@Deprecated\npublic final class OptionBuilder {\n\n    /** Long option */\n    private static String longOption;\n\n    /** Option description */\n    private static String description;\n\n    /** Argument name */\n    private static String argName;\n\n    /** Is required? */\n    private static boolean required;\n\n    /** The number of arguments */\n    private static int argCount = Option.UNINITIALIZED;\n\n    /** Option type */\n    private static Class<?> type;\n\n    /** Option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** Value separator for argument value */\n    private static char valueSeparator;\n\n    /** Option builder instance */\n    private static final OptionBuilder INSTANCE = new OptionBuilder();\n\n    static {\n        // ensure the consistency of the initial values\n        reset();\n    }\n\n    /**\n     * Creates an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code longOpt} has not been set.\n     */\n    public static Option create() throws IllegalArgumentException {\n        if (longOption == null) {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Creates an Option using the current settings and with the specified Option {@code char}.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code opt} is not a valid character. See Option.\n     */\n    public static Option create(final char opt) throws IllegalArgumentException {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Creates an Option using the current settings and with the specified Option {@code char}.\n     *\n     * @param opt the {@code java.lang.String} representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code opt} is not a valid character. See Option.\n     */\n    public static Option create(final String opt) throws IllegalArgumentException {\n        Option option = null;\n        try {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longOption);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(argCount);\n            option.setType(type);\n            option.setValueSeparator(valueSeparator);\n            option.setArgName(argName);\n        } finally {\n            // reset the OptionBuilder properties\n            OptionBuilder.reset();\n        }\n\n        // return the Option instance\n        return option;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg() {\n        OptionBuilder.argCount = 1;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will require an argument value if {@code hasArg} is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(final boolean hasArg) {\n        OptionBuilder.argCount = hasArg ? 1 : Option.UNINITIALIZED;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs() {\n        OptionBuilder.argCount = Option.UNLIMITED_VALUES;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created can have {@code num} argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(final int num) {\n        OptionBuilder.argCount = num;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg() {\n        OptionBuilder.argCount = 1;\n        OptionBuilder.optionalArg = true;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs() {\n        OptionBuilder.argCount = Option.UNLIMITED_VALUES;\n        OptionBuilder.optionalArg = true;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs - the maximum number of optional arguments the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(final int numArgs) {\n        OptionBuilder.argCount = numArgs;\n        OptionBuilder.optionalArg = true;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired() {\n        OptionBuilder.required = true;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will be required if {@code required} is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(final boolean newRequired) {\n        OptionBuilder.required = newRequired;\n\n        return INSTANCE;\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset() {\n        description = null;\n        argName = null;\n        longOption = null;\n        type = String.class;\n        required = false;\n        argCount = Option.UNINITIALIZED;\n        optionalArg = false;\n        valueSeparator = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(final String name) {\n        OptionBuilder.argName = name;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(final String newDescription) {\n        OptionBuilder.description = newDescription;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(final String newLongopt) {\n        OptionBuilder.longOption = newLongopt;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance of {@code type}.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     * @since 1.3\n     */\n    public static OptionBuilder withType(final Class<?> newType) {\n        OptionBuilder.type = newType;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance of {@code type}.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class}\n     * object.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     * @deprecated since 1.3, use {@link #withType(Class)} instead\n     */\n    @Deprecated\n    public static OptionBuilder withType(final Object newType) {\n        return withType((Class<?>) newType);\n    }\n\n    /**\n     * The next Option created uses '{@code =}' as a means to separate argument values.\n     *\n     * <b>Example:</b>\n     *\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator().create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator() {\n        OptionBuilder.valueSeparator = '=';\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created uses {@code sep} as a means to separate argument values.\n     * <p>\n     * <b>Example:</b>\n     *\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator('=').create('D');\n     *\n     * String args = \"-Dkey=value\";\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0); // will be \"key\"\n     * String propertyValue = opt.getValue(1); // will be \"value\"\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(final char sep) {\n        OptionBuilder.valueSeparator = sep;\n\n        return INSTANCE;\n    }\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder() {\n        // hide the constructor\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/OptionBuilder.java b/src/main/java/org/apache/commons/cli/OptionBuilder.java\nindex 8461ad22d..47139bc94 100644\n--- a/src/main/java/org/apache/commons/cli/OptionBuilder.java\n+++ b/src/main/java/org/apache/commons/cli/OptionBuilder.java\n@@ -97,7 +97,7 @@ public static Option create(final char opt) throws IllegalArgumentException {\n      * @throws IllegalArgumentException if {@code opt} is not a valid character. See Option.\n      */\n     public static Option create(final String opt) throws IllegalArgumentException {\n-        Option option = null;\n+        Option option;\n         try {\n             // create the option\n             option = new Option(opt, description);\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/PatternOptionBuilder.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.net.URL;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Vector;\nimport org.junit.Test;\n\n@SuppressWarnings(\"deprecation\")\npublic class PatternOptionBuilderTest2 {\n\n    @Test\n    public void testParsePatternWithConsecutiveOptions() throws Exception {\n        // Test pattern with consecutive options without resetting opt to ' '\n        final Options options = PatternOptionBuilder.parsePattern(\"a:b:c\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-a\", \"valueA\", \"-b\", \"valueB\", \"-c\", \"valueC\"});\n        \n        assertEquals(\"a value\", \"valueA\", line.getOptionValue(\"a\"));\n        assertEquals(\"b value\", \"valueB\", line.getOptionValue(\"b\"));\n        assertEquals(\"c value\", \"valueC\", line.getOptionValue(\"c\"));\n    }\n\n    @Test\n    public void testParsePatternWithRequiredOption() throws Exception {\n        // Test pattern with required option without resetting opt to ' '\n        final Options options = PatternOptionBuilder.parsePattern(\"!a:b:c\");\n        final CommandLineParser parser = new PosixParser();\n        \n        try {\n            parser.parse(options, new String[] {\"-b\", \"valueB\", \"-c\", \"valueC\"});\n            fail(\"MissingOptionException wasn't thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(1, e.getMissingOptions().size());\n            assertTrue(e.getMissingOptions().contains(\"a\"));\n        }\n    }\n\n    @Test\n    public void testParsePatternWithMixedOptions() throws Exception {\n        // Test pattern with mixed options without resetting opt to ' '\n        final Options options = PatternOptionBuilder.parsePattern(\"a:b!c\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-a\", \"valueA\", \"-b\", \"valueB\", \"-c\", \"valueC\"});\n        \n        assertEquals(\"a value\", \"valueA\", line.getOptionValue(\"a\"));\n        assertEquals(\"b value\", \"valueB\", line.getOptionValue(\"b\"));\n        assertEquals(\"c value\", \"valueC\", line.getOptionValue(\"c\"));\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.net.URL;\nimport java.util.Date;\n\n/**\n * Allows Options to be created from a single String. The pattern contains various single character flags and via an\n * optional punctuation character, their expected type.\n *\n * <table border=\"1\">\n * <caption>Overview of PatternOptionBuilder patterns</caption>\n * <tr>\n * <td>a</td>\n * <td>-a flag</td>\n * </tr>\n * <tr>\n * <td>b@</td>\n * <td>-b [classname]</td>\n * </tr>\n * <tr>\n * <td>c&gt;</td>\n * <td>-c [filename]</td>\n * </tr>\n * <tr>\n * <td>d+</td>\n * <td>-d [classname] (creates object via empty constructor)</td>\n * </tr>\n * <tr>\n * <td>e%</td>\n * <td>-e [number] (creates Double/Long instance depending on existing of a '.')</td>\n * </tr>\n * <tr>\n * <td>f/</td>\n * <td>-f [url]</td>\n * </tr>\n * <tr>\n * <td>g:</td>\n * <td>-g [string]</td>\n * </tr>\n * </table>\n *\n * <p>\n * For example, the following allows command line flags of '-v -p string-value -f /dir/file'. The exclamation mark\n * precede a mandatory option.\n * </p>\n *\n * <pre>\n * Options options = PatternOptionBuilder.parsePattern(\"vp:!f/\");\n * </pre>\n *\n * <p>\n * TODO These need to break out to OptionType and also to be pluggable.\n * </p>\n */\npublic class PatternOptionBuilder {\n    /** String class */\n    public static final Class<String> STRING_VALUE = String.class;\n\n    /** Object class */\n    public static final Class<Object> OBJECT_VALUE = Object.class;\n\n    /** Number class */\n    public static final Class<Number> NUMBER_VALUE = Number.class;\n\n    /** Date class */\n    public static final Class<Date> DATE_VALUE = Date.class;\n\n    /** Class class */\n    public static final Class<?> CLASS_VALUE = Class.class;\n\n    /// can we do this one??\n    // is meant to check that the file exists, else it errors.\n    // ie) it's for reading not writing.\n\n    /** FileInputStream class */\n    public static final Class<FileInputStream> EXISTING_FILE_VALUE = FileInputStream.class;\n\n    /** File class */\n    public static final Class<File> FILE_VALUE = File.class;\n\n    /** File array class */\n    public static final Class<File[]> FILES_VALUE = File[].class;\n\n    /** URL class */\n    public static final Class<URL> URL_VALUE = URL.class;\n\n    /**\n     * Retrieve the class that {@code ch} represents.\n     *\n     * @param ch the specified character\n     * @return The class that {@code ch} represents\n     */\n    public static Object getValueClass(final char ch) {\n        switch (ch) {\n        case '@':\n            return PatternOptionBuilder.OBJECT_VALUE;\n        case ':':\n            return PatternOptionBuilder.STRING_VALUE;\n        case '%':\n            return PatternOptionBuilder.NUMBER_VALUE;\n        case '+':\n            return PatternOptionBuilder.CLASS_VALUE;\n        case '#':\n            return PatternOptionBuilder.DATE_VALUE;\n        case '<':\n            return PatternOptionBuilder.EXISTING_FILE_VALUE;\n        case '>':\n            return PatternOptionBuilder.FILE_VALUE;\n        case '*':\n            return PatternOptionBuilder.FILES_VALUE;\n        case '/':\n            return PatternOptionBuilder.URL_VALUE;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns whether {@code ch} is a value code, i.e. whether it represents a class in a pattern.\n     *\n     * @param ch the specified character\n     * @return true if {@code ch} is a value code, otherwise false.\n     */\n    public static boolean isValueCode(final char ch) {\n        return ch == '@' || ch == ':' || ch == '%' || ch == '+' || ch == '#' || ch == '<' || ch == '>' || ch == '*' || ch == '/' || ch == '!';\n    }\n\n    /**\n     * Returns the {@link Options} instance represented by {@code pattern}.\n     *\n     * @param pattern the pattern string\n     * @return The {@link Options} instance\n     */\n    public static Options parsePattern(final String pattern) {\n        char opt = ' ';\n        boolean required = false;\n        Class<?> type = null;\n\n        final Options options = new Options();\n\n        for (int i = 0; i < pattern.length(); i++) {\n            final char ch = pattern.charAt(i);\n\n            // a value code comes after an option and specifies\n            // details about it\n            if (!isValueCode(ch)) {\n                if (opt != ' ') {\n                    final Option option = Option.builder(String.valueOf(opt)).hasArg(type != null).required(required).type(type).build();\n\n                    // we have a previous one to deal with\n                    options.addOption(option);\n                    required = false;\n                    type = null;\n                    opt = ' ';\n                }\n\n                opt = ch;\n            } else if (ch == '!') {\n                required = true;\n            } else {\n                type = (Class<?>) getValueClass(ch);\n            }\n        }\n\n        if (opt != ' ') {\n            final Option option = Option.builder(String.valueOf(opt)).hasArg(type != null).required(required).type(type).build();\n\n            // we have a final one to deal with\n            options.addOption(option);\n        }\n\n        return options;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/PatternOptionBuilder.java b/src/main/java/org/apache/commons/cli/PatternOptionBuilder.java\nindex bc203fe8a..184b45e8c 100644\n--- a/src/main/java/org/apache/commons/cli/PatternOptionBuilder.java\n+++ b/src/main/java/org/apache/commons/cli/PatternOptionBuilder.java\n@@ -170,7 +170,6 @@ public static Options parsePattern(final String pattern) {\n                     options.addOption(option);\n                     required = false;\n                     type = null;\n-                    opt = ' ';\n                 }\n \n                 opt = ch;\n"
      }
    ]
  },
  {
    "pr_number": 111,
    "title": "Use Math.max()",
    "state": "closed",
    "created_at": "2022-06-24T20:12:46Z",
    "merge_commit_sha": "6647dccc95f8ae3f3b5547b7d2cb2cbef6703e91",
    "base_sha": "88713a0697ec763d36bb4d6b30d7554b2e05a133",
    "head_sha": "1d64f9031b2b26614f392f96cad6b58d200e7549",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class HelpFormatterTest2 {\n\n    @Test\n    public void testRenderOptionsMaxCalculation() {\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        options.addOption(\"a\", false, \"option a\");\n        options.addOption(\"b\", false, \"option b\");\n        options.addOption(\"c\", false, \"option c\");\n\n        StringBuffer sb = new StringBuffer();\n        formatter.renderOptions(sb, 80, options, 1, 3);\n\n        // Expected output should have the longest option length calculated correctly\n        String expected = \" -a   option a\\n -b   option b\\n -c   option c\";\n        assertEquals(expected, sb.toString().trim());\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * A formatter of help messages for command line options.\n *\n * <p>\n * Example:\n * </p>\n *\n * <pre>\n * Options options = new Options();\n * options.addOption(OptionBuilder.withLongOpt(\"file\").withDescription(\"The file to be processed\").hasArg().withArgName(\"FILE\").isRequired().create('f'));\n * options.addOption(OptionBuilder.withLongOpt(\"version\").withDescription(\"Print the version of the application\").create('v'));\n * options.addOption(OptionBuilder.withLongOpt(\"help\").create('h'));\n *\n * String header = \"Do something useful with an input file\\n\\n\";\n * String footer = \"\\nPlease report issues at http://example.com/issues\";\n *\n * HelpFormatter formatter = new HelpFormatter();\n * formatter.printHelp(\"myapp\", header, options, footer, true);\n * </pre>\n *\n * This produces the following output:\n *\n * <pre>\n * usage: myapp -f &lt;FILE&gt; [-h] [-v]\n * Do something useful with an input file\n *\n *  -f,--file &lt;FILE&gt;   The file to be processed\n *  -h,--help\n *  -v,--version       Print the version of the application\n *\n * Please report issues at http://example.com/issues\n * </pre>\n */\npublic class HelpFormatter {\n\n    /**\n     * This class implements the {@code Comparator} interface for comparing Options.\n     */\n    private static class OptionComparator implements Comparator<Option>, Serializable {\n        /** The serial version UID. */\n        private static final long serialVersionUID = 5305467873966684014L;\n\n        /**\n         * Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param opt1 The first Option to be compared.\n         * @param opt2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than\n         *         the second.\n         */\n        @Override\n        public int compare(final Option opt1, final Option opt2) {\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n    /** Default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** Default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /** number of space characters to be prefixed to each description line */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** The string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** Default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** Default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /**\n     * default separator displayed between a long Option and its value\n     *\n     * @since 1.3\n     **/\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** Default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setWidth methods instead.\n     */\n    @Deprecated\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setLeftPadding methods instead.\n     */\n    @Deprecated\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed to each description line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setDescPadding methods instead.\n     */\n    @Deprecated\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the beginning of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version - use get/setSyntaxPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version - use get/setNewLine methods instead.\n     */\n    @Deprecated\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version - use get/setOptPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version - use get/setLongOptPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version - use get/setArgName methods instead.\n     */\n    @Deprecated\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     *\n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator<Option> optionComparator = new OptionComparator();\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.\n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required) {\n        if (!required) {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null) {\n            buff.append(\"-\").append(option.getOpt());\n        } else {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || !option.getArgName().isEmpty())) {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required) {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer. The clause is wrapped in square brackets if the group\n     * is required. The display of the options is handled by appendOption\n     *\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group) {\n        if (!group.isRequired()) {\n            buff.append(\"[\");\n        }\n\n        final List<Option> optList = new ArrayList<>(group.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // for each option in the OptionGroup\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, it.next(), true);\n\n            if (it.hasNext()) {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired()) {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Return a String of padding of length {@code len}.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(final int len) {\n        final char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n\n        return new String(padding);\n    }\n\n    /**\n     * Finds the next text wrap position after {@code startPos} for the text in {@code text} with the column width\n     * {@code width}. The wrap point is the last position before startPos+width having a whitespace character (space,\n     * \\n, \\r). If there is no whitespace character before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace character\n     * @return position on which the text must be wrapped or -1 if the wrap position is at the end of the text\n     */\n    protected int findWrapPos(final String text, final int width, final int startPos) {\n        // the line ends before the max wrap pos or a new line char found\n        int pos = text.indexOf('\\n', startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n\n        pos = text.indexOf('\\t', startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n\n        if (startPos + width >= text.length()) {\n            return -1;\n        }\n\n        // look for the last whitespace character before startPos+width\n        for (pos = startPos + width; pos >= startPos; --pos) {\n            final char c = text.charAt(pos);\n            if (c == ' ' || c == '\\n' || c == '\\r') {\n                break;\n            }\n        }\n\n        // if we found it - just return\n        if (pos > startPos) {\n            return pos;\n        }\n\n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n\n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Gets the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName() {\n        return defaultArgName;\n    }\n\n    /**\n     * Gets the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding() {\n        return defaultDescPad;\n    }\n\n    /**\n     * Gets the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding() {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Gets the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix() {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Gets the separator displayed between a long option and its value.\n     *\n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator() {\n        return longOptSeparator;\n    }\n\n    /**\n     * Gets the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine() {\n        return defaultNewLine;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text. Defaults to case-insensitive alphabetical sorting\n     * by option key.\n     *\n     * @return the {@link Comparator} currently in use to sort the options\n     * @since 1.2\n     */\n    public Comparator<Option> getOptionComparator() {\n        return optionComparator;\n    }\n\n    /**\n     * Gets the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix() {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Gets the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix() {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Gets the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth() {\n        return defaultWidth;\n    }\n\n    /**\n     * Print the help for {@code options} with the specified command line syntax. This method prints help information\n     * to System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for {@code options} with the specified command line syntax. This method prints help information\n     * to System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer,\n        final boolean autoUsage) {\n        final PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, getLeftPadding(), getDescPadding(), footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for {@code options} with the specified command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer) {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n    /**\n     * Print the help for {@code options} with the specified command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer, final boolean autoUsage) {\n        if (cmdLineSyntax == null || cmdLineSyntax.isEmpty()) {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage) {\n            printUsage(pw, width, cmdLineSyntax, options);\n        } else {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if (header != null && !header.isEmpty()) {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if (footer != null && !footer.isEmpty()) {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Print the help for {@code options} with the specified command line syntax. This method prints help information\n     * to System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(final String cmdLineSyntax, final Options options) {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for {@code options} with the specified command line syntax. This method prints help information\n     * to System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage) {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for {@code options} with the specified command line syntax. This method prints help information\n     * to System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for {@code options} with the specified command line syntax. This method prints help information\n     * to System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage) {\n        printHelp(getWidth(), cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, using the specified width, left padding and\n     * description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     */\n    public void printOptions(final PrintWriter pw, final int width, final Options options, final int leftPad, final int descPad) {\n        final StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the cmdLineSyntax to the specified writer, using the specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax) {\n        final int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, getSyntaxPrefix().length() + argPos, getSyntaxPrefix() + cmdLineSyntax);\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement\n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(final PrintWriter pw, final int width, final String app, final Options options) {\n        // initialize the string buffer\n        final StringBuffer buff = new StringBuffer(getSyntaxPrefix()).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection<OptionGroup> processedGroups = new ArrayList<>();\n\n        final List<Option> optList = new ArrayList<>(options.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // iterate over the options\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // get the next Option\n            final Option option = it.next();\n\n            // check if the option is part of an OptionGroup\n            final OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group\n            if (group != null) {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group)) {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (it.hasNext()) {\n                buff.append(\" \");\n            }\n        }\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text) {\n        final StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedTextBlock(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(final PrintWriter pw, final int width, final String text) {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Render the specified Options and return the rendered Options in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad) {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where\n        // -a is opt and --aaa is long opt; in parallel look for\n        // the longest opt string this list will be then used to\n        // sort options ascending\n        int max = 0;\n        final List<StringBuffer> prefixList = new ArrayList<>();\n\n        final List<Option> optList = options.helpOptions();\n\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n\n        for (final Option option : optList) {\n            final StringBuffer optBuf = new StringBuffer();\n\n            if (option.getOpt() == null) {\n                optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\n            } else {\n                optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());\n\n                if (option.hasLongOpt()) {\n                    optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg()) {\n                final String argName = option.getArgName();\n                if (argName != null && argName.isEmpty()) {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                } else {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = optBuf.length() > max ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            final Option option = it.next();\n            final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max) {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            final int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null) {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (it.hasNext()) {\n                sb.append(getNewLine());\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(final StringBuffer sb, final int width, int nextLineTabStop, String text) {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1) {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(getNewLine());\n\n        if (nextLineTabStop >= width) {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true) {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1) {\n                sb.append(text);\n\n                return sb;\n            }\n\n            if (text.length() > width && pos == nextLineTabStop - 1) {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(getNewLine());\n        }\n    }\n\n    /**\n     * Render the specified text width a maximum width. This method differs from renderWrappedText by not removing leading\n     * spaces after a new line.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     */\n    private Appendable renderWrappedTextBlock(final StringBuffer sb, final int width, final int nextLineTabStop, final String text) {\n        try {\n            final BufferedReader in = new BufferedReader(new StringReader(text));\n            String line;\n            boolean firstLine = true;\n            while ((line = in.readLine()) != null) {\n                if (!firstLine) {\n                    sb.append(getNewLine());\n                } else {\n                    firstLine = false;\n                }\n                renderWrappedText(sb, width, nextLineTabStop, line);\n            }\n        } catch (final IOException e) { // NOPMD\n            // cannot happen\n        }\n\n        return sb;\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(final String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while (pos > 0 && Character.isWhitespace(s.charAt(pos - 1))) {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(final String name) {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(final int padding) {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(final int padding) {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(final String prefix) {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value. Ensure that the separator specified is supported by\n     * the parser used, typically ' ' or '='.\n     *\n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(final String longOptSeparator) {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(final String newline) {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text. Passing in a null comparator will keep the\n     * options in the order they were declared.\n     *\n     * @param comparator the {@link Comparator} to use for sorting the options\n     * @since 1.2\n     */\n    public void setOptionComparator(final Comparator<Option> comparator) {\n        this.optionComparator = comparator;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(final String prefix) {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(final String prefix) {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(final int width) {\n        this.defaultWidth = width;\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/HelpFormatter.java b/src/main/java/org/apache/commons/cli/HelpFormatter.java\nindex 911e3f877..b8ef67047 100644\n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n@@ -708,7 +708,7 @@ protected StringBuffer renderOptions(final StringBuffer sb, final int width, fin\n             }\n \n             prefixList.add(optBuf);\n-            max = optBuf.length() > max ? optBuf.length() : max;\n+            max = Math.max(optBuf.length(), max);\n         }\n \n         int x = 0;\n"
      }
    ]
  },
  {
    "pr_number": 102,
    "title": "Use EMPTY_STRING_ARRAY constant.",
    "state": "closed",
    "created_at": "2022-04-17T08:40:02Z",
    "merge_commit_sha": "27b961f2b40a2d2ba695dc50774bed32401201be",
    "base_sha": "7ccf15c0dc620ebcdb59bf15e971cbeffa55eb7c",
    "head_sha": "11783bec6008701c0fd3076d3c0393125e1e919e",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/cli/CommandLine.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertNull;\nimport org.junit.Test;\n\npublic class CommandLineTest2 {\n\n    @Test\n    public void testGetOptionValuesWithEmptyStringArray() {\n        CommandLine cmd = new CommandLine();\n        Option option = Option.builder(\"a\").hasArgs().build();\n        cmd.addOption(option);\n        assertNull(cmd.getOptionValues(option));\n\n        cmd.addOption(Option.builder(\"b\").hasArgs().build());\n        assertArrayEquals(new String[0], cmd.getOptionValues(option));\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Represents list of arguments parsed against a {@link Options} descriptor.\n * <p>\n * It allows querying of a boolean {@link #hasOption(String opt)}, in addition to retrieving the\n * {@link #getOptionValue(String opt)} for options requiring arguments.\n * <p>\n * Additionally, any left-over or unrecognized arguments, are available for further processing.\n */\npublic class CommandLine implements Serializable {\n    /**\n     * A nested builder class to create {@code CommandLine} instance using descriptive methods.\n     *\n     * @since 1.4\n     */\n    public static final class Builder {\n        /**\n         * CommandLine that is being build by this Builder.\n         */\n        private final CommandLine commandLine = new CommandLine();\n\n        /**\n         * Add left-over unrecognized option/argument.\n         *\n         * @param arg the unrecognized option/argument.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addArg(final String arg) {\n            commandLine.addArg(arg);\n            return this;\n        }\n\n        /**\n         * Add an option to the command line. The values of the option are stored.\n         *\n         * @param opt the processed option.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addOption(final Option opt) {\n            commandLine.addOption(opt);\n            return this;\n        }\n\n        public CommandLine build() {\n            return commandLine;\n        }\n    }\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** The unrecognized options/arguments */\n    private final List<String> args = new LinkedList<>();\n\n    /** The processed options */\n    private final List<Option> options = new ArrayList<>();\n\n    /**\n     * Creates a command line.\n     */\n    protected CommandLine() {\n        // nothing to do\n    }\n\n    /**\n     * Add left-over unrecognized option/argument.\n     *\n     * @param arg the unrecognized option/argument.\n     */\n    protected void addArg(final String arg) {\n        args.add(arg);\n    }\n\n    /**\n     * Add an option to the command line. The values of the option are stored.\n     *\n     * @param opt the processed option.\n     */\n    protected void addOption(final Option opt) {\n        options.add(opt);\n    }\n\n    /**\n     * Retrieve any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as a {@code List}.\n     */\n    public List<String> getArgList() {\n        return args;\n    }\n\n    /**\n     * Retrieve any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as an array.\n     */\n    public String[] getArgs() {\n        final String[] answer = new String[args.size()];\n\n        args.toArray(answer);\n\n        return answer;\n    }\n\n    /**\n     * Return the {@code Object} type of this {@code Option}.\n     *\n     * @deprecated due to System.err message. Instead use getParsedOptionValue(char)\n     * @param opt the name of the option.\n     * @return the type of opt.\n     */\n    @Deprecated\n    public Object getOptionObject(final char opt) {\n        return getOptionObject(String.valueOf(opt));\n    }\n\n    /**\n     * Return the {@code Object} type of this {@code Option}.\n     *\n     * @param opt the name of the option.\n     * @return the type of this {@code Option}.\n     * @deprecated due to System.err message. Instead use getParsedOptionValue(String)\n     */\n    @Deprecated\n    public Object getOptionObject(final String opt) {\n        try {\n            return getParsedOptionValue(opt);\n        } catch (final ParseException pe) {\n            System.err.println(\"Exception found converting \" + opt + \" to desired type: \" + pe.getMessage());\n            return null;\n        }\n    }\n\n    /**\n     * Retrieve the map of values associated to the option. This is convenient for options specifying Java properties like\n     * <code>-Dparam1=value1\n     * -Dparam2=value2</code>. The first argument of the option is the key, and the 2nd argument is the value. If the option\n     * has only one argument ({@code -Dfoo}) it is considered as a boolean flag and the value is {@code \"true\"}.\n     *\n     * @param option name of the option.\n     * @return The Properties mapped by the option, never {@code null} even if the option doesn't exists.\n     * @since 1.5.0\n     */\n    public Properties getOptionProperties(final Option option) {\n        final Properties props = new Properties();\n\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                final List<String> values = processedOption.getValuesList();\n                if (values.size() >= 2) {\n                    // use the first 2 arguments as the key/value pair\n                    props.put(values.get(0), values.get(1));\n                } else if (values.size() == 1) {\n                    // no explicit value, handle it as a boolean\n                    props.put(values.get(0), \"true\");\n                }\n            }\n        }\n\n        return props;\n    }\n\n    /**\n     * Retrieve the map of values associated to the option. This is convenient for options specifying Java properties like\n     * <code>-Dparam1=value1\n     * -Dparam2=value2</code>. The first argument of the option is the key, and the 2nd argument is the value. If the option\n     * has only one argument ({@code -Dfoo}) it is considered as a boolean flag and the value is {@code \"true\"}.\n     *\n     * @param opt name of the option.\n     * @return The Properties mapped by the option, never {@code null} even if the option doesn't exists.\n     * @since 1.2\n     */\n    public Properties getOptionProperties(final String opt) {\n        final Properties props = new Properties();\n\n        for (final Option option : options) {\n            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt())) {\n                final List<String> values = option.getValuesList();\n                if (values.size() >= 2) {\n                    // use the first 2 arguments as the key/value pair\n                    props.put(values.get(0), values.get(1));\n                } else if (values.size() == 1) {\n                    // no explicit value, handle it as a boolean\n                    props.put(values.get(0), \"true\");\n                }\n            }\n        }\n\n        return props;\n    }\n\n    /**\n     * Gets an array of the processed {@link Option}s.\n     *\n     * @return an array of the processed {@link Option}s.\n     */\n    public Option[] getOptions() {\n        final Collection<Option> processed = options;\n\n        // reinitialize array\n        final Option[] optionsArray = new Option[processed.size()];\n\n        // return the array\n        return processed.toArray(optionsArray);\n    }\n\n    /**\n     * Retrieve the first argument, if any, of this option.\n     *\n     * @param opt the character name of the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String getOptionValue(final char opt) {\n        return getOptionValue(String.valueOf(opt));\n    }\n\n    /**\n     * Retrieve the argument, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     */\n    public String getOptionValue(final char opt, final String defaultValue) {\n        return getOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /**\n     * Retrieve the first argument, if any, of this option.\n     *\n     * @param option the name of the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     * @since 1.5.0\n     */\n    public String getOptionValue(final Option option) {\n        if (option == null) {\n            return null;\n        }\n        final String[] values = getOptionValues(option);\n        return values == null ? null : values[0];\n    }\n\n    /**\n     * Retrieve the first argument, if any, of an option.\n     *\n     * @param option name of the option.\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.5.0\n     */\n    public String getOptionValue(final Option option, final String defaultValue) {\n        final String answer = getOptionValue(option);\n        return answer != null ? answer : defaultValue;\n    }\n\n    /**\n     * Retrieve the first argument, if any, of this option.\n     *\n     * @param opt the name of the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String getOptionValue(final String opt) {\n        return getOptionValue(resolveOption(opt));\n    }\n\n    /**\n     * Retrieve the first argument, if any, of an option.\n     *\n     * @param opt name of the option.\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     */\n    public String getOptionValue(final String opt, final String defaultValue) {\n        return getOptionValue(resolveOption(opt), defaultValue);\n    }\n\n    /**\n     * Retrieves the array of values, if any, of an option.\n     *\n     * @param opt character name of the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String[] getOptionValues(final char opt) {\n        return getOptionValues(String.valueOf(opt));\n    }\n\n    /**\n     * Retrieves the array of values, if any, of an option.\n     *\n     * @param option string name of the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     * @since 1.5.0\n     */\n    public String[] getOptionValues(final Option option) {\n        final List<String> values = new ArrayList<>();\n\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                values.addAll(processedOption.getValuesList());\n            }\n        }\n\n        return values.isEmpty() ? null : values.toArray(new String[values.size()]);\n    }\n\n    /**\n     * Retrieves the array of values, if any, of an option.\n     *\n     * @param opt string name of the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String[] getOptionValues(final String opt) {\n        return getOptionValues(resolveOption(opt));\n    }\n\n    /**\n     * Return a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.5.0\n     */\n    public Object getParsedOptionValue(final char opt) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt));\n    }\n\n    /**\n     * Return a version of this {@code Option} converted to a particular type.\n     *\n     * @param option the name of the option.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.5.0\n     */\n    public Object getParsedOptionValue(final Option option) throws ParseException {\n        if (option == null) {\n            return null;\n        }\n        final String res = getOptionValue(option);\n        if (res == null) {\n            return null;\n        }\n        return TypeHandler.createValue(res, option.getType());\n    }\n\n    /**\n     * Return a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.2\n     */\n    public Object getParsedOptionValue(final String opt) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt));\n    }\n\n    /**\n     * jkeyes - commented out until it is implemented properly\n     * <p>\n     * Dump state, suitable for debugging.\n     * </p>\n     *\n     * @return Stringified form of this object.\n     */\n\n    /*\n     * public String toString() { StringBuilder buf = new StringBuilder();\n     *\n     * buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \");\n     * buf.append(args.toString()); buf.append(\" ] ]\");\n     *\n     * return buf.toString(); }\n     */\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt character name of the option.\n     * @return true if set, false if not.\n     */\n    public boolean hasOption(final char opt) {\n        return hasOption(String.valueOf(opt));\n    }\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt the option to check.\n     * @return true if set, false if not.\n     * @since 1.5.0\n     */\n    public boolean hasOption(final Option opt) {\n        return options.contains(opt);\n    }\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt Short name of the option.\n     * @return true if set, false if not.\n     */\n    public boolean hasOption(final String opt) {\n        return hasOption(resolveOption(opt));\n    }\n\n    /**\n     * Returns an iterator over the Option members of CommandLine.\n     *\n     * @return an {@code Iterator} over the processed {@link Option} members of this {@link CommandLine}.\n     */\n    public Iterator<Option> iterator() {\n        return options.iterator();\n    }\n\n    /**\n     * Retrieves the option object given the long or short option as a String\n     *\n     * @param opt short or long name of the option.\n     * @return Canonicalized option.\n     */\n    private Option resolveOption(String opt) {\n        opt = Util.stripLeadingHyphens(opt);\n        for (final Option option : options) {\n            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt())) {\n                return option;\n            }\n\n        }\n        return null;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/CommandLine.java b/src/main/java/org/apache/commons/cli/CommandLine.java\nindex 333ef9d40..05d6a93b1 100644\n--- a/src/main/java/org/apache/commons/cli/CommandLine.java\n+++ b/src/main/java/org/apache/commons/cli/CommandLine.java\n@@ -25,6 +25,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.util.List;\n import java.util.Properties;\n \n+import static org.apache.commons.cli.Util.EMPTY_STRING_ARRAY;\n+\n /**\n  * Represents list of arguments parsed against a {@link Options} descriptor.\n  * <p>\n@@ -328,7 +330,7 @@ public String[] getOptionValues(final Option option) {\n             }\n         }\n \n-        return values.isEmpty() ? null : values.toArray(new String[values.size()]);\n+        return values.isEmpty() ? null : values.toArray(EMPTY_STRING_ARRAY);\n     }\n \n     /**\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/Option.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertNull;\nimport org.junit.Test;\n\npublic class OptionTest2 {\n\n    @Test\n    public void testGetValuesWithNoValues() {\n        Option option = new Option(\"f\", null);\n        option.setArgs(Option.UNLIMITED_VALUES);\n        assertNull(option.getValues());\n    }\n\n    @Test\n    public void testGetValuesWithValues() {\n        Option option = new Option(\"f\", null);\n        option.setArgs(Option.UNLIMITED_VALUES);\n        option.addValueForProcessing(\"value1\");\n        option.addValueForProcessing(\"value2\");\n        assertArrayEquals(new String[]{\"value1\", \"value2\"}, option.getValues());\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * Describes a single command-line option. It maintains information regarding the short-name of the option, the\n * long-name, if any exists, a flag indicating if an argument is required for this option, and a self-documenting\n * description of the option.\n * <p>\n * An Option is not created independently, but is created through an instance of {@link Options}. An Option is required\n * to have at least a short or a long-name.\n * </p>\n * <p>\n * <b>Note:</b> once an {@link Option} has been added to an instance of {@link Options}, its required flag cannot be\n * changed.\n * </p>\n *\n * @see org.apache.commons.cli.Options\n * @see org.apache.commons.cli.CommandLine\n */\npublic class Option implements Cloneable, Serializable {\n\n    /**\n     * A nested builder class to create {@code Option} instances using descriptive methods.\n     * <p>\n     * Example usage:\n     * </p>\n     *\n     * <pre>\n     * Option option = Option.builder(\"a\").required(true).longOpt(\"arg-name\").build();\n     * </pre>\n     *\n     * @since 1.3\n     */\n    public static final class Builder {\n\n        /** The name of the option */\n        private String option;\n\n        /** description of the option */\n        private String description;\n\n        /** The long representation of the option */\n        private String longOption;\n\n        /** The name of the argument for this option */\n        private String argName;\n\n        /** specifies whether this option is required to be present */\n        private boolean required;\n\n        /** specifies whether the argument value of this Option is optional */\n        private boolean optionalArg;\n\n        /** The number of argument values this option can have */\n        private int argCount = UNINITIALIZED;\n\n        /** The type of this Option */\n        private Class<?> type = String.class;\n\n        /** The character that is the value separator */\n        private char valueSeparator;\n\n        /**\n         * Constructs a new {@code Builder} with the minimum required parameters for an {@code Option} instance.\n         *\n         * @param option short representation of the option\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n         */\n        private Builder(final String option) throws IllegalArgumentException {\n            option(option);\n        }\n\n        /**\n         * Sets the display name for the argument value.\n         *\n         * @param argName the display name for the argument value.\n         * @return this builder, to allow method chaining\n         */\n        public Builder argName(final String argName) {\n            this.argName = argName;\n            return this;\n        }\n\n        /**\n         * Constructs an Option with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link Option}\n         * @throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set\n         */\n        public Option build() {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }\n\n        /**\n         * Sets the description for this option.\n         *\n         * @param description the description of the option.\n         * @return this builder, to allow method chaining\n         */\n        public Builder desc(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Indicates that the Option will require an argument.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArg() {\n            return hasArg(true);\n        }\n\n        /**\n         * Indicates if the Option has an argument or not.\n         *\n         * @param hasArg specifies whether the Option takes an argument or not\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArg(final boolean hasArg) {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : Option.UNINITIALIZED;\n            return this;\n        }\n\n        /**\n         * Indicates that the Option can have unlimited argument values.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArgs() {\n            argCount = Option.UNLIMITED_VALUES;\n            return this;\n        }\n\n        /**\n         * Sets the long name of the Option.\n         *\n         * @param longOpt the long name of the Option\n         * @return this builder, to allow method chaining\n         */\n        public Builder longOpt(final String longOpt) {\n            this.longOption = longOpt;\n            return this;\n        }\n\n        /**\n         * Sets the number of argument values the Option can take.\n         *\n         * @param numberOfArgs the number of argument values\n         * @return this builder, to allow method chaining\n         */\n        public Builder numberOfArgs(final int numberOfArgs) {\n            this.argCount = numberOfArgs;\n            return this;\n        }\n\n        /**\n         * Sets the name of the Option.\n         *\n         * @param option the name of the Option\n         * @return this builder, to allow method chaining\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n         * @since 1.5.0\n         */\n        public Builder option(final String option) throws IllegalArgumentException {\n            this.option = OptionValidator.validate(option);\n            return this;\n        }\n\n        /**\n         * Sets whether the Option can have an optional argument.\n         *\n         * @param isOptional specifies whether the Option can have an optional argument.\n         * @return this builder, to allow method chaining\n         */\n        public Builder optionalArg(final boolean isOptional) {\n            this.optionalArg = isOptional;\n            return this;\n        }\n\n        /**\n         * Marks this Option as required.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder required() {\n            return required(true);\n        }\n\n        /**\n         * Sets whether the Option is mandatory.\n         *\n         * @param required specifies whether the Option is mandatory\n         * @return this builder, to allow method chaining\n         */\n        public Builder required(final boolean required) {\n            this.required = required;\n            return this;\n        }\n\n        /**\n         * Sets the type of the Option.\n         *\n         * @param type the type of the Option\n         * @return this builder, to allow method chaining\n         */\n        public Builder type(final Class<?> type) {\n            this.type = type;\n            return this;\n        }\n\n        /**\n         * The Option will use '=' as a means to separate argument value.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder valueSeparator() {\n            return valueSeparator('=');\n        }\n\n        /**\n         * The Option will use {@code sep} as a means to separate argument values.\n         * <p>\n         * <b>Example:</b>\n         * </p>\n         *\n         * <pre>\n         * Option opt = Option.builder(\"D\").hasArgs().valueSeparator('=').build();\n         * Options options = new Options();\n         * options.addOption(opt);\n         * String[] args = {\"-Dkey=value\"};\n         * CommandLineParser parser = new DefaultParser();\n         * CommandLine line = parser.parse(options, args);\n         * String propertyName = line.getOptionValues(\"D\")[0]; // will be \"key\"\n         * String propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n         * </pre>\n         *\n         * @param sep The value separator.\n         * @return this builder, to allow method chaining\n         */\n        public Builder valueSeparator(final char sep) {\n            valueSeparator = sep;\n            return this;\n        }\n    }\n\n    /** Specifies the number of argument values has not been specified */\n    public static final int UNINITIALIZED = -1;\n\n    /** Specifies the number of argument values is infinite */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @return a new {@link Builder} instance\n     * @since 1.3\n     */\n    public static Builder builder() {\n        return builder(null);\n    }\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @param option short representation of the option\n     * @return a new {@link Builder} instance\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n     * @since 1.3\n     */\n    public static Builder builder(final String option) {\n        return new Builder(option);\n    }\n\n    /** The name of the option. */\n    private final String option;\n\n    /** The long representation of the option. */\n    private String longOption;\n\n    /** The name of the argument for this option. */\n    private String argName;\n\n    /** Description of the option. */\n    private String description;\n\n    /** Specifies whether this option is required to be present. */\n    private boolean required;\n\n    /** Specifies whether the argument value of this Option is optional. */\n    private boolean optionalArg;\n\n    /** The number of argument values this option can have. */\n    private int argCount = UNINITIALIZED;\n\n    /** The type of this Option. */\n    private Class<?> type = String.class;\n\n    /** The list of argument values. **/\n    private List<String> values = new ArrayList<>();\n\n    /** The character that is the value separator. */\n    private char valuesep;\n\n    /**\n     * Private constructor used by the nested Builder class.\n     *\n     * @param builder builder used to create this option\n     */\n    private Option(final Builder builder) {\n        this.argName = builder.argName;\n        this.description = builder.description;\n        this.longOption = builder.longOption;\n        this.argCount = builder.argCount;\n        this.option = builder.option;\n        this.optionalArg = builder.optionalArg;\n        this.required = builder.required;\n        this.type = builder.type;\n        this.valuesep = builder.valueSeparator;\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option short representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final boolean hasArg, final String description) throws IllegalArgumentException {\n        this(option, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters. The option does not take an argument.\n     *\n     * @param option short representation of the option\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String description) throws IllegalArgumentException {\n        this(option, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option short representation of the option\n     * @param longOption the long representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String longOption, final boolean hasArg, final String description) throws IllegalArgumentException {\n        // ensure that the option is valid\n        this.option = OptionValidator.validate(option);\n        this.longOption = longOption;\n\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg) {\n            this.argCount = 1;\n        }\n\n        this.description = description;\n    }\n\n    /**\n     * Tells if the option can accept more arguments.\n     *\n     * @return false if the maximum number of arguments is reached\n     * @since 1.3\n     */\n    boolean acceptsArg() {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (argCount <= 0 || values.size() < argCount);\n    }\n\n    /**\n     * Add the value to this Option. If the number of arguments is greater than zero and there is enough space in the list\n     * then add the value. Otherwise, throw a runtime exception.\n     *\n     * @param value The value to be added to this Option\n     *\n     * @since 1.0.1\n     */\n    private void add(final String value) {\n        if (!acceptsArg()) {\n            throw new IllegalArgumentException(\"Cannot add value, list full.\");\n        }\n\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal API that was made public in 1.0. It currently\n     * throws an UnsupportedOperationException.\n     *\n     * @param value the value to add\n     * @return always throws an {@link UnsupportedOperationException}\n     * @throws UnsupportedOperationException always\n     * @deprecated Unused.\n     */\n    @Deprecated\n    public boolean addValue(final String value) {\n        throw new UnsupportedOperationException(\n            \"The addValue method is not intended for client use. \" + \"Subclasses should use the addValueForProcessing method instead. \");\n    }\n\n    /**\n     * Adds the specified value to this Option.\n     *\n     * @param value is a/the value of this Option\n     */\n    void addValueForProcessing(final String value) {\n        if (argCount == UNINITIALIZED) {\n            throw new IllegalArgumentException(\"NO_ARGS_ALLOWED\");\n        }\n        processValue(value);\n    }\n\n    /**\n     * Clear the Option values. After a parse is complete, these are left with data in them and they need clearing if\n     * another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues() {\n        values.clear();\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public and in 1.1 rather than throwing a\n     * CloneNotSupportedException it throws a RuntimeException so as to maintain backwards compat at the API level.\n     *\n     * After calling this method, it is very likely you will want to call clearValues().\n     *\n     * @return a clone of this Option instance\n     * @throws RuntimeException if a {@link CloneNotSupportedException} has been thrown by {@code super.clone()}\n     */\n    @Override\n    public Object clone() {\n        try {\n            final Option option = (Option) super.clone();\n            option.values = new ArrayList<>(values);\n            return option;\n        } catch (final CloneNotSupportedException cnse) {\n            throw new IllegalStateException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Option)) {\n            return false;\n        }\n        final Option other = (Option) obj;\n        return Objects.equals(longOption, other.longOption) && Objects.equals(option, other.option);\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName() {\n        return argName;\n    }\n\n    /**\n     * Gets the number of argument values this Option can take.\n     *\n     * <p>\n     * A value equal to the constant {@link #UNINITIALIZED} (= -1) indicates the number of arguments has not been specified.\n     * A value equal to the constant {@link #UNLIMITED_VALUES} (= -2) indicates that this options takes an unlimited amount\n     * of values.\n     * </p>\n     *\n     * @return num the number of argument values\n     * @see #UNINITIALIZED\n     * @see #UNLIMITED_VALUES\n     */\n    public int getArgs() {\n        return argCount;\n    }\n\n    /**\n     * Gets the self-documenting description of this Option\n     *\n     * @return The string description of this option\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Gets the id of this Option. This is only set when the Option shortOpt is a single character. This is used for\n     * switch statements.\n     *\n     * @return the id of this Option\n     */\n    public int getId() {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Gets the 'unique' Option identifier.\n     *\n     * @return the 'unique' Option identifier\n     */\n    String getKey() {\n        // if 'opt' is null, then it is a 'long' option\n        return option == null ? longOption : option;\n    }\n\n    /**\n     * Gets the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name\n     */\n    public String getLongOpt() {\n        return longOption;\n    }\n\n    /**\n     * Gets the name of this Option.\n     *\n     * It is this String which can be used with {@link CommandLine#hasOption(String opt)} and\n     * {@link CommandLine#getOptionValue(String opt)} to check for existence and argument.\n     *\n     * @return The name of this option\n     */\n    public String getOpt() {\n        return option;\n    }\n\n    /**\n     * Gets the type of this Option.\n     *\n     * @return The type of this option\n     */\n    public Object getType() {\n        return type;\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @return the value/first value of this Option or {@code null} if there is no value.\n     */\n    public String getValue() {\n        return hasNoValues() ? null : values.get(0);\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or {@code null} if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1 or greater than the number of the values for this Option.\n     */\n    public String getValue(final int index) throws IndexOutOfBoundsException {\n        return hasNoValues() ? null : values.get(index);\n    }\n\n    /**\n     * Gets the value/first value of this Option or the {@code defaultValue} if there is no value.\n     *\n     * @param defaultValue The value to be returned if there is no value.\n     *\n     * @return the value/first value of this Option or the {@code defaultValue} if there are no values.\n     */\n    public String getValue(final String defaultValue) {\n        final String value = getValue();\n\n        return value != null ? value : defaultValue;\n    }\n\n    /**\n     * Gets the values of this Option as a String array or null if there are no values\n     *\n     * @return the values of this Option as a String array or null if there are no values\n     */\n    public String[] getValues() {\n        return hasNoValues() ? null : values.toArray(new String[values.size()]);\n    }\n\n    /**\n     * Gets the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator() {\n        return valuesep;\n    }\n\n    /**\n     * Gets the values of this Option as a List or null if there are no values.\n     *\n     * @return the values of this Option as a List or null if there are no values\n     */\n    public List<String> getValuesList() {\n        return values;\n    }\n\n    /**\n     * Query to see if this Option requires an argument\n     *\n     * @return boolean flag indicating if an argument is required\n     */\n    public boolean hasArg() {\n        return argCount > 0 || argCount == UNLIMITED_VALUES;\n    }\n\n    /**\n     * Returns whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName() {\n        return argName != null && !argName.isEmpty();\n    }\n\n    /**\n     * Query to see if this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed\n     */\n    public boolean hasArgs() {\n        return argCount > 1 || argCount == UNLIMITED_VALUES;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(longOption, option);\n    }\n\n    /**\n     * Query to see if this Option has a long name\n     *\n     * @return boolean flag indicating existence of a long name\n     */\n    public boolean hasLongOpt() {\n        return longOption != null;\n    }\n\n    /**\n     * Returns whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues() {\n        return values.isEmpty();\n    }\n\n    /**\n     * @return whether this Option can have an optional argument\n     */\n    public boolean hasOptionalArg() {\n        return optionalArg;\n    }\n\n    /**\n     * Return whether this Option has specified a value separator.\n     *\n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator() {\n        return valuesep > 0;\n    }\n\n    /**\n     * Query to see if this Option is mandatory\n     *\n     * @return boolean flag indicating whether this Option is mandatory\n     */\n    public boolean isRequired() {\n        return required;\n    }\n\n    /**\n     * Processes the value. If this Option has a value separator the value will have to be parsed into individual tokens.\n     * When n-1 tokens have been processed and there are more value separators in the value, parsing is ceased and the\n     * remaining characters are added as a single token.\n     *\n     * @param value The String to be processed.\n     *\n     * @since 1.0.1\n     */\n    private void processValue(String value) {\n        // this Option has a separator character\n        if (hasValueSeparator()) {\n            // get the separator character\n            final char sep = getValueSeparator();\n\n            // store the index for the value separator\n            int index = value.indexOf(sep);\n\n            // while there are more value separators\n            while (index != -1) {\n                // next value to be added\n                if (values.size() == argCount - 1) {\n                    break;\n                }\n\n                // store\n                add(value.substring(0, index));\n\n                // parse\n                value = value.substring(index + 1);\n\n                // get new index\n                index = value.indexOf(sep);\n            }\n        }\n\n        // store the actual value or the last value that has been parsed\n        add(value);\n    }\n\n    /**\n     * Tells if the option requires more arguments to be valid.\n     *\n     * @return false if the option doesn't require more arguments\n     * @since 1.3\n     */\n    boolean requiresArg() {\n        if (optionalArg) {\n            return false;\n        }\n        if (argCount == UNLIMITED_VALUES) {\n            return values.isEmpty();\n        }\n        return acceptsArg();\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(final String argName) {\n        this.argName = argName;\n    }\n\n    /**\n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values\n     */\n    public void setArgs(final int num) {\n        this.argCount = num;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option\n     *\n     * @param description The description of this option\n     * @since 1.1\n     */\n    public void setDescription(final String description) {\n        this.description = description;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option\n     */\n    public void setLongOpt(final String longOpt) {\n        this.longOption = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have an optional argument.\n     */\n    public void setOptionalArg(final boolean optionalArg) {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory\n     */\n    public void setRequired(final boolean required) {\n        this.required = required;\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option\n     * @since 1.3\n     */\n    public void setType(final Class<?> type) {\n        this.type = type;\n    }\n\n    /**\n     * Sets the type of this Option.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class}\n     * object.\n     * </p>\n     *\n     * @param type the type of this Option\n     * @deprecated since 1.3, use {@link #setType(Class)} instead\n     */\n    @Deprecated\n    public void setType(final Object type) {\n        setType((Class<?>) type);\n    }\n\n    /**\n     * Sets the value separator. For example if the argument value was a Java property, the value separator would be '='.\n     *\n     * @param sep The value separator.\n     */\n    public void setValueSeparator(final char sep) {\n        this.valuesep = sep;\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder().append(\"[ option: \");\n\n        buf.append(option);\n\n        if (longOption != null) {\n            buf.append(\" \").append(longOption);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs()) {\n            buf.append(\"[ARG...]\");\n        } else if (hasArg()) {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null) {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/Option.java b/src/main/java/org/apache/commons/cli/Option.java\nindex a1c2e4ee7..ec21f7870 100644\n--- a/src/main/java/org/apache/commons/cli/Option.java\n+++ b/src/main/java/org/apache/commons/cli/Option.java\n@@ -22,6 +22,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n import java.util.List;\n import java.util.Objects;\n \n+import static org.apache.commons.cli.Util.EMPTY_STRING_ARRAY;\n+\n /**\n  * Describes a single command-line option. It maintains information regarding the short-name of the option, the\n  * long-name, if any exists, a flag indicating if an argument is required for this option, and a self-documenting\n@@ -617,7 +619,7 @@ public String getValue(final String defaultValue) {\n      * @return the values of this Option as a String array or null if there are no values\n      */\n     public String[] getValues() {\n-        return hasNoValues() ? null : values.toArray(new String[values.size()]);\n+        return hasNoValues() ? null : values.toArray(EMPTY_STRING_ARRAY);\n     }\n \n     /**\n"
      }
    ]
  },
  {
    "pr_number": 61,
    "title": "Minor Improvement",
    "state": "closed",
    "created_at": "2021-03-26T05:46:28Z",
    "merge_commit_sha": "bd39a1c9cfb3ee394791f7e015a3045d042c01ba",
    "base_sha": "d63b4bd3e61e83b6dbe7b3d6f81a06967f17e784",
    "head_sha": "08bc73b9708e9132b59337747c0251783ea4bf19",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/cli/GnuParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\n@SuppressWarnings(\"deprecation\")\npublic class GnuParserTest2 extends ParserTestCase {\n\n    @Override\n    @Before\n    public void setUp() {\n        super.setUp();\n        parser = new GnuParser();\n    }\n\n    @Test\n    public void testFlattenWithEmptyStringArray() throws Exception {\n        Options options = new Options();\n        String[] arguments = {};\n        String[] expected = {};\n        String[] result = parser.flatten(options, arguments, false);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFlattenWithSingleDash() throws Exception {\n        Options options = new Options();\n        String[] arguments = {\"-\"};\n        String[] expected = {\"-\"};\n        String[] result = parser.flatten(options, arguments, false);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFlattenWithDoubleDash() throws Exception {\n        Options options = new Options();\n        String[] arguments = {\"--\"};\n        String[] expected = {\"--\"};\n        String[] result = parser.flatten(options, arguments, false);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFlattenWithOptionAndValue() throws Exception {\n        Options options = new Options();\n        options.addOption(\"a\", false, \"option a\");\n        String[] arguments = {\"-a\", \"value\"};\n        String[] expected = {\"-a\", \"value\"};\n        String[] result = parser.flatten(options, arguments, false);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFlattenWithOptionAndEqualsValue() throws Exception {\n        Options options = new Options();\n        options.addOption(\"a\", true, \"option a\");\n        String[] arguments = {\"-a=value\"};\n        String[] expected = {\"-a\", \"value\"};\n        String[] result = parser.flatten(options, arguments, false);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFlattenWithNonOptionArgument() throws Exception {\n        Options options = new Options();\n        String[] arguments = {\"arg\"};\n        String[] expected = {\"arg\"};\n        String[] result = parser.flatten(options, arguments, false);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFlattenWithStopAtNonOption() throws Exception {\n        Options options = new Options();\n        options.addOption(\"a\", false, \"option a\");\n        String[] arguments = {\"-a\", \"arg\"};\n        String[] expected = {\"-a\", \"arg\"};\n        String[] result = parser.flatten(options, arguments, true);\n        assertArrayEquals(expected, result);\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The class GnuParser provides an implementation of the {@link Parser#flatten(Options, String[], boolean) flatten}\n * method.\n *\n * @deprecated since 1.3, use the {@link DefaultParser} instead\n */\n@Deprecated\npublic class GnuParser extends Parser {\n    /**\n     * This flatten method does so using the following rules:\n     * <ol>\n     * <li>If an {@link Option} exists for the first character of the {@code arguments} entry <b>AND</b> an\n     * {@link Option} does not exist for the whole {@code argument} then add the first character as an option to the\n     * processed tokens list e.g. \"-D\" and add the rest of the entry to the also.</li>\n     * <li>Otherwise just add the token to the processed tokens list.</li>\n     * </ol>\n     *\n     * @param options The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) {\n        final List<String> tokens = new ArrayList<>();\n\n        boolean eatTheRest = false;\n\n        for (int i = 0; i < arguments.length; i++) {\n            final String arg = arguments[i];\n\n            if (\"--\".equals(arg)) {\n                eatTheRest = true;\n                tokens.add(\"--\");\n            } else if (\"-\".equals(arg)) {\n                tokens.add(\"-\");\n            } else if (arg.startsWith(\"-\")) {\n                final String opt = Util.stripLeadingHyphens(arg);\n\n                if (options.hasOption(opt)) {\n                    tokens.add(arg);\n                } else if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('=')))) {\n                    // the format is --foo=value or -foo=value\n                    tokens.add(arg.substring(0, arg.indexOf('='))); // --foo\n                    tokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n                } else if (options.hasOption(arg.substring(0, 2))) {\n                    // the format is a special properties option (-Dproperty=value)\n                    tokens.add(arg.substring(0, 2)); // -D\n                    tokens.add(arg.substring(2)); // property=value\n                } else {\n                    eatTheRest = stopAtNonOption;\n                    tokens.add(arg);\n                }\n            } else {\n                tokens.add(arg);\n            }\n\n            if (eatTheRest) {\n                for (i++; i < arguments.length; i++) // NOPMD\n                {\n                    tokens.add(arguments[i]);\n                }\n            }\n        }\n\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/GnuParser.java b/src/main/java/org/apache/commons/cli/GnuParser.java\nindex 7088c5509..41263522b 100644\n--- a/src/main/java/org/apache/commons/cli/GnuParser.java\n+++ b/src/main/java/org/apache/commons/cli/GnuParser.java\n@@ -85,6 +85,6 @@ protected String[] flatten(final Options options, final String[] arguments, fina\n             }\n         }\n \n-        return tokens.toArray(new String[tokens.size()]);\n+        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n     }\n }\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/PosixParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class PosixParserTest2 extends ParserTestCase {\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    @Before\n    public void setUp() {\n        super.setUp();\n        parser = new PosixParser();\n    }\n\n    @Test\n    public void testFlattenReturnsEmptyStringArray() throws Exception {\n        Options options = new Options();\n        String[] arguments = new String[]{};\n        String[] result = parser.flatten(options, arguments, true);\n        assertArrayEquals(Util.EMPTY_STRING_ARRAY, result);\n    }\n\n    @Test\n    public void testFlattenWithNonEmptyArguments() throws Exception {\n        Options options = new Options();\n        options.addOption(\"a\", false, \"Option a\");\n        options.addOption(\"b\", true, \"Option b\");\n\n        String[] arguments = new String[]{\"-a\", \"-b\", \"value\"};\n        String[] expected = new String[]{\"-a\", \"-b\", \"value\"};\n        String[] result = parser.flatten(options, arguments, true);\n\n        assertArrayEquals(expected, result);\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the {@link Parser#flatten(Options,String[],boolean) flatten}\n * method.\n *\n * @deprecated since 1.3, use the {@link DefaultParser} instead\n */\n@Deprecated\npublic class PosixParser extends Parser {\n    /** holder for flattened tokens */\n    private final List<String> tokens = new ArrayList<>();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** The command line Options */\n    private Options options;\n\n    /**\n     * Breaks {@code token} into its constituent parts using the following algorithm.\n     *\n     * <ul>\n     * <li>ignore the first character (\"<b>-</b>\")</li>\n     * <li>for each remaining character check if an {@link Option} exists with that id.</li>\n     * <li>if an {@link Option} does exist then add that character prepended with \"<b>-</b>\" to the list of processed\n     * tokens.</li>\n     * <li>if the {@link Option} can have an argument value and there are remaining characters in the token then add the\n     * remaining characters as a token to the list of processed tokens.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS</b> set then add the\n     * special token \"<b>--</b>\" followed by the remaining characters and also the remaining tokens directly to the\n     * processed tokens list.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS NOT</b> set then add\n     * that character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing at the first non-Option encountered.\n     */\n    protected void burstToken(final String token, final boolean stopAtNonOption) {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n\n            if (!options.hasOption(ch)) {\n                if (stopAtNonOption) {\n                    processNonOptionToken(token.substring(i), true);\n                } else {\n                    tokens.add(token);\n                }\n                break;\n            }\n            tokens.add(\"-\" + ch);\n            currentOption = options.getOption(ch);\n\n            if (currentOption.hasArg() && token.length() != i + 1) {\n                tokens.add(token.substring(i + 1));\n\n                break;\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * An implementation of {@link Parser}'s abstract {@link Parser#flatten(Options,String[],boolean) flatten} method.\n     * </p>\n     *\n     * <p>\n     * The following are the rules used by this flatten method.\n     * </p>\n     * <ol>\n     * <li>if {@code stopAtNonOption} is <b>true</b> then do not burst anymore of {@code arguments} entries, just\n     * add each successive entry without further processing. Otherwise, ignore {@code stopAtNonOption}.</li>\n     * <li>if the current {@code arguments} entry is \"<b>--</b>\" just add the entry to the list of processed\n     * tokens</li>\n     * <li>if the current {@code arguments} entry is \"<b>-</b>\" just add the entry to the list of processed tokens</li>\n     * <li>if the current {@code arguments} entry is two characters in length and the first character is \"<b>-</b>\"\n     * then check if this is a valid {@link Option} id. If it is a valid id, then add the entry to the list of processed\n     * tokens and set the current {@link Option} member. If it is not a valid id and {@code stopAtNonOption} is true,\n     * then the remaining entries are copied to the list of processed tokens. Otherwise, the current entry is ignored.</li>\n     * <li>if the current {@code arguments} entry is more than two characters in length and the first character is\n     * \"<b>-</b>\" then we need to burst the entry to determine its constituents. For more information on the bursting\n     * algorithm see {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     * <li>if the current {@code arguments} entry is not handled by any of the previous rules, then the entry is added\n     * to the list of processed tokens.</li>\n     * </ol>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening when an non option is found.\n     * @return The flattened {@code arguments} String array.\n     */\n    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        final Iterator<String> iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext()) {\n            // get the next command line token\n            final String token = iter.next();\n\n            // single or double hyphen\n            if (\"-\".equals(token) || \"--\".equals(token)) {\n                tokens.add(token);\n            }\n\n            // handle long option --foo or --foo=bar\n            else if (token.startsWith(\"--\")) {\n                final int pos = token.indexOf('=');\n                final String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                final List<String> matchingOpts = options.getMatchingOptions(opt);\n\n                if (matchingOpts.isEmpty()) {\n                    processNonOptionToken(token, stopAtNonOption);\n                } else if (matchingOpts.size() > 1) {\n                    throw new AmbiguousOptionException(opt, matchingOpts);\n                } else {\n                    currentOption = options.getOption(matchingOpts.get(0));\n\n                    tokens.add(\"--\" + currentOption.getLongOpt());\n                    if (pos != -1) {\n                        tokens.add(token.substring(pos + 1));\n                    }\n                }\n            }\n\n            else if (token.startsWith(\"-\")) {\n                if (token.length() == 2 || options.hasOption(token)) {\n                    processOptionToken(token, stopAtNonOption);\n                } else if (!options.getMatchingOptions(token).isEmpty()) {\n                    final List<String> matchingOpts = options.getMatchingOptions(token);\n                    if (matchingOpts.size() > 1) {\n                        throw new AmbiguousOptionException(token, matchingOpts);\n                    }\n                    final Option opt = options.getOption(matchingOpts.get(0));\n                    processOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n                }\n                // requires bursting\n                else {\n                    burstToken(token, stopAtNonOption);\n                }\n            } else {\n                processNonOptionToken(token, stopAtNonOption);\n            }\n\n            gobble(iter);\n        }\n\n        return tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(final Iterator<String> iter) {\n        if (eatTheRest) {\n            while (iter.hasNext()) {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * Resets the members to their original state i.e. remove all of {@code tokens} entries and set\n     * {@code eatTheRest} to false.\n     */\n    private void init() {\n        eatTheRest = false;\n        tokens.clear();\n    }\n\n    /**\n     * Add the special token \"<b>--</b>\" and the current {@code value} to the processed tokens list. Then add all the\n     * remaining {@code argument} values to the processed tokens list.\n     *\n     * @param value The current token\n     */\n    private void processNonOptionToken(final String value, final boolean stopAtNonOption) {\n        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg())) {\n            eatTheRest = true;\n            tokens.add(\"--\");\n        }\n\n        tokens.add(value);\n    }\n\n    /**\n     * <p>\n     * If an {@link Option} exists for {@code token} then add the token to the processed list.\n     * </p>\n     *\n     * <p>\n     * If an {@link Option} does not exist and {@code stopAtNonOption} is set then add the remaining tokens to the\n     * processed tokens list directly.\n     * </p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt at the first non option.\n     */\n    private void processOptionToken(final String token, final boolean stopAtNonOption) {\n        if (stopAtNonOption && !options.hasOption(token)) {\n            eatTheRest = true;\n        }\n\n        if (options.hasOption(token)) {\n            currentOption = options.getOption(token);\n        }\n\n        tokens.add(token);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/PosixParser.java b/src/main/java/org/apache/commons/cli/PosixParser.java\nindex 0197c493b..2268e8325 100644\n--- a/src/main/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/main/java/org/apache/commons/cli/PosixParser.java\n@@ -176,7 +176,7 @@ else if (token.startsWith(\"-\")) {\n             gobble(iter);\n         }\n \n-        return tokens.toArray(new String[tokens.size()]);\n+        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n     }\n \n     /**\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/Util.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport org.junit.Test;\n\npublic class UtilTest2 {\n\n    /**\n     * Test to ensure EMPTY_STRING_ARRAY is an empty array.\n     */\n    @Test\n    public void testEmptyStringArray() {\n        assertArrayEquals(new String[0], Util.EMPTY_STRING_ARRAY);\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Contains useful helper methods for classes within this package.\n */\nfinal class Util {\n    /**\n     * Remove the leading and trailing quotes from {@code str}. E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(String str) {\n        final int length = str.length();\n        if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1) {\n            str = str.substring(1, length - 1);\n        }\n\n        return str;\n    }\n\n    /**\n     * Remove the hyphens from the beginning of {@code str} and return the new String.\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(final String str) {\n        if (str == null) {\n            return null;\n        }\n        if (str.startsWith(\"--\")) {\n            return str.substring(2);\n        }\n        if (str.startsWith(\"-\")) {\n            return str.substring(1);\n        }\n\n        return str;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/Util.java b/src/main/java/org/apache/commons/cli/Util.java\nindex 7e44fbbeb..de5226541 100644\n--- a/src/main/java/org/apache/commons/cli/Util.java\n+++ b/src/main/java/org/apache/commons/cli/Util.java\n@@ -21,6 +21,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more\n  * Contains useful helper methods for classes within this package.\n  */\n final class Util {\n+\n+    /**\n+     * An empty immutable {@code String} array.\n+     */\n+    static final String[] EMPTY_STRING_ARRAY = new String[0];\n+\n     /**\n      * Remove the leading and trailing quotes from {@code str}. E.g. if str is '\"one two\"', then 'one two' is returned.\n      *\n"
      }
    ]
  },
  {
    "pr_number": 58,
    "title": "CLI-254: \"test\" gets parsed as test, quotes die :-(",
    "state": "closed",
    "created_at": "2021-01-29T09:53:16Z",
    "merge_commit_sha": "44173949e8165537b201d4efd024e31e6e8b06eb",
    "base_sha": "6c94af34d792772a3f736be314093c5f01533cd0",
    "head_sha": "93d13ca0955e95341ef38aeec46c72f2c4b212da",
    "user_login": "stoty",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/cli/DefaultParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DefaultParserTest2 extends ParserTestCase {\n\n    @Override\n    @Before\n    public void setUp() {\n        super.setUp();\n        parser = new DefaultParser();\n    }\n\n    @Test\n    public void testBuilderWithAllowPartialMatching() {\n        DefaultParser parser = DefaultParser.builder()\n            .setAllowPartialMatching(false)\n            .build();\n        assertFalse(parser.allowPartialMatching);\n    }\n\n    @Test\n    public void testBuilderWithStripLeadingAndTrailingQuotes() {\n        DefaultParser parser = DefaultParser.builder()\n            .setStripLeadingAndTrailingQuotes(true)\n            .build();\n        assertTrue(parser.stripLeadingAndTrailingQuotes);\n    }\n\n    @Test\n    public void testBuilderWithNullStripLeadingAndTrailingQuotes() {\n        DefaultParser parser = DefaultParser.builder()\n            .setStripLeadingAndTrailingQuotes(null)\n            .build();\n        assertNull(parser.stripLeadingAndTrailingQuotes);\n    }\n\n    @Test\n    public void testHandleTokenWithStrippingQuotes() throws ParseException {\n        Options options = new Options();\n        options.addOption(Option.builder(\"o\").hasArg().build());\n        parser = DefaultParser.builder()\n            .setStripLeadingAndTrailingQuotes(true)\n            .build();\n        CommandLine cmd = parser.parse(options, new String[]{\"-o\", \"\\\"value\\\"\"});\n        assertEquals(\"value\", cmd.getOptionValue(\"o\"));\n    }\n\n    @Test\n    public void testHandleTokenWithoutStrippingQuotes() throws ParseException {\n        Options options = new Options();\n        options.addOption(Option.builder(\"o\").hasArg().build());\n        parser = DefaultParser.builder()\n            .setStripLeadingAndTrailingQuotes(false)\n            .build();\n        CommandLine cmd = parser.parse(options, new String[]{\"-o\", \"\\\"value\\\"\"});\n        assertEquals(\"\\\"value\\\"\", cmd.getOptionValue(\"o\"));\n    }\n\n    @Test\n    public void testHandleTokenWithDefaultStrippingQuotes() throws ParseException {\n        Options options = new Options();\n        options.addOption(Option.builder(\"o\").hasArg().build());\n        parser = DefaultParser.builder().build();\n        CommandLine cmd = parser.parse(options, new String[]{\"-o\", \"\\\"value\\\"\"});\n        assertEquals(\"value\", cmd.getOptionValue(\"o\"));\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Default parser.\n *\n * @since 1.3\n */\npublic class DefaultParser implements CommandLineParser {\n    /** The command-line instance. */\n    protected CommandLine cmd;\n\n    /** The current options. */\n    protected Options options;\n\n    /**\n     * Flag indicating how unrecognized tokens are handled. {@code true} to stop the parsing and add the remaining\n     * tokens to the args list. {@code false} to throw an exception.\n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n\n    /** The last option parsed. */\n    protected Option currentOption;\n\n    /** Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n\n    /** The required options and groups expected to be found when parsing the command line. */\n    protected List expectedOpts;\n\n    /** Flag indicating if partial matching of long options is supported. */\n    private final boolean allowPartialMatching;\n\n    /**\n     * Creates a new DefaultParser instance with partial matching enabled.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     *\n     * <pre>\n     * {\n     *     &#64;code\n     *     final Options options = new Options();\n     *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     * }\n     * </pre>\n     *\n     * with \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n     * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n     * options.\n     */\n    public DefaultParser() {\n        this.allowPartialMatching = true;\n    }\n\n    /**\n     * Create a new DefaultParser instance with the specified partial matching policy.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     *\n     * <pre>\n     * {\n     *     &#64;code\n     *     final Options options = new Options();\n     *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     * }\n     * </pre>\n     *\n     * with \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n     * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n     * options.\n     *\n     * @param allowPartialMatching if partial matching of long options shall be enabled\n     */\n    public DefaultParser(final boolean allowPartialMatching) {\n        this.allowPartialMatching = allowPartialMatching;\n    }\n\n    /**\n     * Throw a {@link MissingArgumentException} if the current option didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg()) {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty()) {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Search for a prefix that is the long name of an option (-Xmx512m)\n     *\n     * @param token\n     */\n    private String getLongPrefix(final String token) {\n        final String t = Util.stripLeadingHyphens(token);\n\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--) {\n            final String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix)) {\n                opt = prefix;\n                break;\n            }\n        }\n\n        return opt;\n    }\n\n    /**\n     * Gets a list of matching option strings for the given token, depending on the selected partial matching policy.\n     *\n     * @param token the token (may contain leading dashes)\n     * @return the list of matching option strings or an empty list if no matching option could be found\n     */\n    private List<String> getMatchingLongOptions(final String token) {\n        if (allowPartialMatching) {\n            return options.getMatchingOptions(token);\n        }\n        final List<String> matches = new ArrayList<>(1);\n        if (options.hasLongOption(token)) {\n            final Option option = options.getOption(token);\n            matches.add(option.getLongOpt());\n        }\n\n        return matches;\n    }\n\n    /**\n     * Breaks {@code token} into its constituent parts using the following algorithm.\n     *\n     * <ul>\n     * <li>ignore the first character (\"<b>-</b>\")</li>\n     * <li>for each remaining character check if an {@link Option} exists with that id.</li>\n     * <li>if an {@link Option} does exist then add that character prepended with \"<b>-</b>\" to the list of processed\n     * tokens.</li>\n     * <li>if the {@link Option} can have an argument value and there are remaining characters in the token then add the\n     * remaining characters as a token to the list of processed tokens.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS</b> set then add the\n     * special token \"<b>--</b>\" followed by the remaining characters and also the remaining tokens directly to the\n     * processed tokens list.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS NOT</b> set then add\n     * that character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b> at the first non-Option encountered.\n     * @throws ParseException if there are any problems encountered while parsing the command line token.\n     */\n    protected void handleConcatenatedOptions(final String token) throws ParseException {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n\n            if (!options.hasOption(ch)) {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n            handleOption(options.getOption(ch));\n\n            if (currentOption != null && token.length() != i + 1) {\n                // add the trail as an argument of the option\n                currentOption.addValueForProcessing(token.substring(i + 1));\n                break;\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L --L=V --L V --l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOption(final String token) throws ParseException {\n        if (token.indexOf('=') == -1) {\n            handleLongOptionWithoutEqual(token);\n        } else {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L=V -L=V --l=V -l=V\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(final String token) throws ParseException {\n        final int pos = token.indexOf('=');\n\n        final String value = token.substring(pos + 1);\n\n        final String opt = token.substring(0, pos);\n\n        final List<String> matchingOpts = getMatchingLongOptions(opt);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(opt)) {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(opt) ? opt : matchingOpts.get(0);\n            final Option option = options.getOption(key);\n\n            if (option.acceptsArg()) {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            } else {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L -L --l -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(final String token) throws ParseException {\n        final List<String> matchingOpts = getMatchingLongOptions(token);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(token)) {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(token) ? token : matchingOpts.get(0);\n            handleOption(options.getOption(key));\n        }\n    }\n\n    private void handleOption(Option option) throws ParseException {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n\n        option = (Option) option.clone();\n\n        updateRequiredOptions(option);\n\n        cmd.addOption(option);\n\n        if (option.hasArg()) {\n            currentOption = option;\n        } else {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Sets the values of Options using the values in {@code properties}.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties\n                final String value = properties.getProperty(option);\n\n                if (opt.hasArg()) {\n                    if (opt.getValues() == null || opt.getValues().length == 0) {\n                        opt.addValueForProcessing(value);\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * -S -SV -S V -S=V -S1S2 -S1S2 V -SV1=V2\n     *\n     * -L -LV -L V -L=V -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleShortAndLongOption(final String token) throws ParseException {\n        final String t = Util.stripLeadingHyphens(token);\n\n        final int pos = t.indexOf('=');\n\n        if (t.length() == 1) {\n            // -S\n            if (options.hasShortOption(t)) {\n                handleOption(options.getOption(t));\n            } else {\n                handleUnknownToken(token);\n            }\n        } else if (pos == -1) {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(t)) {\n                handleOption(options.getOption(t));\n            } else if (!getMatchingLongOptions(t).isEmpty()) {\n                // -L or -l\n                handleLongOptionWithoutEqual(token);\n            } else {\n                // look for a long prefix (-Xmx512m)\n                final String opt = getLongPrefix(t);\n\n                if (opt != null && options.getOption(opt).acceptsArg()) {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                } else if (isJavaProperty(t)) {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                } else {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(token);\n                }\n            }\n        } else {\n            // equal sign found (-xxx=yyy)\n            final String opt = t.substring(0, pos);\n            final String value = t.substring(pos + 1);\n\n            if (opt.length() == 1) {\n                // -S=V\n                final Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg()) {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                } else {\n                    handleUnknownToken(token);\n                }\n            } else if (isJavaProperty(opt)) {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            } else {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    /**\n     * Handle any command line token.\n     *\n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(final String token) throws ParseException {\n        currentToken = token;\n\n        if (skipParsing) {\n            cmd.addArg(token);\n        } else if (\"--\".equals(token)) {\n            skipParsing = true;\n        } else if (currentOption != null && currentOption.acceptsArg() && isArgument(token)) {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        } else if (token.startsWith(\"--\")) {\n            handleLongOption(token);\n        } else if (token.startsWith(\"-\") && !\"-\".equals(token)) {\n            handleShortAndLongOption(token);\n        } else {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg()) {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an UnrecognizedOptionException is thrown. Otherwise the\n     * token is added to the arguments of the command line. If the stopAtNonOption flag is set, this stops the parsing and\n     * the remaining tokens are added as-is in the arguments of the command line.\n     *\n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(final String token) throws ParseException {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n\n        cmd.addArg(token);\n        if (stopAtNonOption) {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Returns true is the token is a valid argument.\n     *\n     * @param token\n     */\n    private boolean isArgument(final String token) {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Check if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(final String token) {\n        final String opt = token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    /**\n     * Tells if the token looks like a long option.\n     *\n     * @param token\n     */\n    private boolean isLongOption(final String token) {\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n\n        final int pos = token.indexOf(\"=\");\n        final String t = pos == -1 ? token : token.substring(0, pos);\n\n        if (!getMatchingLongOptions(t).isEmpty()) {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        if (getLongPrefix(token) != null && !token.startsWith(\"--\")) {\n            // -LV\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if the token is a negative number.\n     *\n     * @param token\n     */\n    private boolean isNegativeNumber(final String token) {\n        try {\n            Double.parseDouble(token);\n            return true;\n        } catch (final NumberFormatException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Tells if the token looks like an option.\n     *\n     * @param token\n     */\n    private boolean isOption(final String token) {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tells if the token looks like a short option.\n     *\n     * @param token\n     */\n    private boolean isShortOption(final String token) {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        final int pos = token.indexOf(\"=\");\n        final String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName)) {\n            return true;\n        }\n        // check for several concatenated short options\n        return !optName.isEmpty() && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null);\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)\n        throws ParseException {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList<>(options.getRequiredOptions());\n\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n\n        cmd = new CommandLine();\n\n        if (arguments != null) {\n            for (final String argument : arguments) {\n                handleToken(argument);\n            }\n        }\n\n        // check the arguments of the last option\n        checkRequiredArgs();\n\n        // add the default options\n        handleProperties(properties);\n\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param option\n     */\n    private void updateRequiredOptions(final Option option) throws AlreadySelectedException {\n        if (option.isRequired()) {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null) {\n            final OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired()) {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/DefaultParser.java b/src/main/java/org/apache/commons/cli/DefaultParser.java\nindex 0c3d069fb..4a3a65b9e 100644\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n@@ -55,6 +55,10 @@ public class DefaultParser implements CommandLineParser {\n     /** Flag indicating if partial matching of long options is supported. */\n     private final boolean allowPartialMatching;\n \n+    /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments.\n+     * null represents the historic arbitrary behaviour */\n+    private final Boolean stripLeadingAndTrailingQuotes;\n+\n     /**\n      * Creates a new DefaultParser instance with partial matching enabled.\n      *\n@@ -76,6 +80,7 @@ public class DefaultParser implements CommandLineParser {\n      */\n     public DefaultParser() {\n         this.allowPartialMatching = true;\n+        this.stripLeadingAndTrailingQuotes = null;\n     }\n \n     /**\n@@ -101,6 +106,20 @@ public DefaultParser() {\n      */\n     public DefaultParser(final boolean allowPartialMatching) {\n         this.allowPartialMatching = allowPartialMatching;\n+        this.stripLeadingAndTrailingQuotes = null;\n+    }\n+\n+    /**\n+     * Creates a new DefaultParser instance with the specified partial matching and quote\n+     * stripping policy.\n+     *\n+     * @param allowPartialMatching if partial matching of long options shall be enabled\n+     * @param stripLeadingAndTrailingQuotes if balanced outer double quoutes should be stripped\n+     */\n+    private DefaultParser(final boolean allowPartialMatching,\n+            final Boolean stripLeadingAndTrailingQuotes) {\n+        this.allowPartialMatching = allowPartialMatching;\n+        this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n     }\n \n     /**\n@@ -196,7 +215,7 @@ protected void handleConcatenatedOptions(final String token) throws ParseExcepti\n \n             if (currentOption != null && token.length() != i + 1) {\n                 // add the trail as an argument of the option\n-                currentOption.addValueForProcessing(token.substring(i + 1));\n+                currentOption.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOff(token.substring(i + 1)));\n                 break;\n             }\n         }\n@@ -242,7 +261,7 @@ private void handleLongOptionWithEqual(final String token) throws ParseException\n \n             if (option.acceptsArg()) {\n                 handleOption(option);\n-                currentOption.addValueForProcessing(value);\n+                currentOption.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOff(value));\n                 currentOption = null;\n             } else {\n                 handleUnknownToken(currentToken);\n@@ -314,7 +333,7 @@ private void handleProperties(final Properties properties) throws ParseException\n \n                 if (opt.hasArg()) {\n                     if (opt.getValues() == null || opt.getValues().length == 0) {\n-                        opt.addValueForProcessing(value);\n+                        opt.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOff(value));\n                     }\n                 } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                     // if the value is not yes, true or 1 then don't add the option to the CommandLine\n@@ -361,12 +380,12 @@ private void handleShortAndLongOption(final String token) throws ParseException\n \n                 if (opt != null && options.getOption(opt).acceptsArg()) {\n                     handleOption(options.getOption(opt));\n-                    currentOption.addValueForProcessing(t.substring(opt.length()));\n+                    currentOption.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOff(t.substring(opt.length())));\n                     currentOption = null;\n                 } else if (isJavaProperty(t)) {\n                     // -SV1 (-Dflag)\n                     handleOption(options.getOption(t.substring(0, 1)));\n-                    currentOption.addValueForProcessing(t.substring(1));\n+                    currentOption.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOff(t.substring(1)));\n                     currentOption = null;\n                 } else {\n                     // -S1S2S3 or -S1S2V\n@@ -415,7 +434,7 @@ private void handleToken(final String token) throws ParseException {\n         } else if (\"--\".equals(token)) {\n             skipParsing = true;\n         } else if (currentOption != null && currentOption.acceptsArg() && isArgument(token)) {\n-            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n+            currentOption.addValueForProcessing(stripLeadingAndTrailingQuotesDefaultOn(token));\n         } else if (token.startsWith(\"--\")) {\n             handleLongOption(token);\n         } else if (token.startsWith(\"-\") && !\"-\".equals(token)) {\n@@ -625,4 +644,134 @@ private void updateRequiredOptions(final Option option) throws AlreadySelectedEx\n             group.setSelected(option);\n         }\n     }\n+\n+    /**\n+     * Strip balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\n+     * If stripLeadingAndTrailingQuotes is null, then do not strip\n+     *\n+     * @param token a string\n+     * @return token with the quotes stripped (if set)\n+     */\n+    private String stripLeadingAndTrailingQuotesDefaultOff(final String token) {\n+        if (stripLeadingAndTrailingQuotes != null && stripLeadingAndTrailingQuotes) {\n+            return Util.stripLeadingAndTrailingQuotes(token);\n+        } else {\n+            return token;\n+        }\n+    }\n+\n+    /**\n+     * Strip balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\n+     * If stripLeadingAndTrailingQuotes is null, then do not strip\n+     *\n+     * @param token a string\n+     * @return token with the quotes stripped (if set)\n+     */\n+    private String stripLeadingAndTrailingQuotesDefaultOn(final String token) {\n+        if (stripLeadingAndTrailingQuotes == null || stripLeadingAndTrailingQuotes) {\n+            return Util.stripLeadingAndTrailingQuotes(token);\n+        } else {\n+            return token;\n+        }\n+    }\n+\n+    /**\n+     * Returns a {@link Builder} to create an {@link DefaultParser} using descriptive\n+     * methods.\n+     *\n+     * @return a new {@link Builder} instance\n+     * @since 1.5\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * A nested builder class to create <code>DefaultParser</code> instances\n+     * using descriptive methods.\n+     *\n+     * Example usage:\n+     * <pre>\n+     * DefaultParser parser = Option.builder()\n+     *     .setAllowPartialMatching(false)\n+     *     .setStripLeadingAndTrailingQuotes(false)\n+     *     .build();\n+     * </pre>\n+     *\n+     * @since 1.5\n+     */\n+    public static final class Builder {\n+\n+        /** Flag indicating if partial matching of long options is supported. */\n+        private boolean allowPartialMatching = true;\n+\n+        /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments. */\n+        private Boolean stripLeadingAndTrailingQuotes;\n+\n+        /**\n+         * Constructs a new <code>Builder</code> for a <code>DefaultParser</code> instance.\n+         *\n+         * Both allowPartialMatching and stripLeadingAndTrailingQuotes are true by default,\n+         * mimicking the argument-less constructor.\n+         */\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Sets if partial matching of long options is supported.\n+         *\n+         * By \"partial matching\" we mean that given the following code:\n+         *\n+         * <pre>\n+         * {\n+         *     &#64;code\n+         *     final Options options = new Options();\n+         *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n+         *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n+         *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n+         * }\n+         * </pre>\n+         *\n+         * If \"partial matching\" is turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n+         * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n+         *\n+         * @param allowPartialMatching whether to allow partial matching of long options\n+         * @return this builder, to allow method chaining\n+         * @since 1.5\n+         */\n+        public Builder setAllowPartialMatching(final boolean allowPartialMatching) {\n+            this.allowPartialMatching = allowPartialMatching;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets if balanced leading and trailing double quotes should be stripped from option arguments.\n+         *\n+         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is true,\n+         * the outermost balanced double quotes of option arguments values will be removed.\n+         * For example, <code>-o '\"x\"'</code> getValue() will return <code>x</code>, instead of <code>\"x\"</code>\n+         *\n+         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is null,\n+         * then quotes will be stripped from option values separated by space from the option, but\n+         * kept in other cases, which is the historic behaviour.\n+         *\n+         * @param stripLeadingAndTrailingQuotes whether balanced leading and trailing double quotes should be stripped from option arguments.\n+         * @return this builder, to allow method chaining\n+         * @since 1.5\n+         */\n+        public Builder setStripLeadingAndTrailingQuotes(final Boolean stripLeadingAndTrailingQuotes) {\n+            this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds an DefaultParser with the values declared by this {@link Builder}.\n+         *\n+         * @return the new {@link DefaultParser}\n+         * @since 1.5\n+         */\n+        public DefaultParser build() {\n+            return new DefaultParser(allowPartialMatching, stripLeadingAndTrailingQuotes);\n+        }\n+    }\n }\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/BasicParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/DefaultParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/ParserTestCase.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 57,
    "title": "Minor Improvements",
    "state": "closed",
    "created_at": "2020-12-26T18:36:28Z",
    "merge_commit_sha": "c67275279176504a6f5fc556cfa247e1df02a580",
    "base_sha": "d687ec917e84dea7591a01546d4c52611597c3ce",
    "head_sha": "494dafcd94be05d106c0f27972a0ea08ce8738d6",
    "user_login": "arturobernalg",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/cli/AlreadySelectedException.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AlreadySelectedExceptionTest {\n\n    @Test\n    public void testConstructorWithMessage() {\n        String message = \"Test message\";\n        AlreadySelectedException exception = new AlreadySelectedException(message);\n        assertEquals(message, exception.getMessage());\n    }\n\n    @Test\n    public void testConstructorWithGroupAndOption() {\n        OptionGroup group = new OptionGroup();\n        Option option = new Option(\"a\", \"optionA\", false, \"Option A\");\n        group.setSelected(option.getKey());\n        AlreadySelectedException exception = new AlreadySelectedException(group, option);\n        assertEquals(\"The option 'a' was specified but an option from this group has already been selected: 'a'\", exception.getMessage());\n        assertEquals(group, exception.getOptionGroup());\n        assertEquals(option, exception.getOption());\n    }\n\n    @Test\n    public void testGetOptionGroup() {\n        OptionGroup group = new OptionGroup();\n        Option option = new Option(\"b\", \"optionB\", false, \"Option B\");\n        AlreadySelectedException exception = new AlreadySelectedException(group, option);\n        assertEquals(group, exception.getOptionGroup());\n    }\n\n    @Test\n    public void testGetOption() {\n        Option option = new Option(\"c\", \"optionC\", false, \"Option C\");\n        OptionGroup group = new OptionGroup();\n        AlreadySelectedException exception = new AlreadySelectedException(group, option);\n        assertEquals(option, exception.getOption());\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Thrown when more than one option in an option group\n * has been provided.\n */\npublic class AlreadySelectedException extends ParseException\n{\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 3674381532418544760L;\n\n    /** The option group selected. */\n    private OptionGroup group;\n\n    /** The option that triggered the exception. */\n    private Option option;\n\n    /**\n     * Construct a new <code>AlreadySelectedException</code>\n     * with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public AlreadySelectedException(final String message)\n    {\n        super(message);\n    }\n\n    /**\n     * Construct a new <code>AlreadySelectedException</code>\n     * for the specified option group.\n     *\n     * @param group  the option group already selected\n     * @param option the option that triggered the exception\n     * @since 1.2\n     */\n    public AlreadySelectedException(final OptionGroup group, final Option option)\n    {\n        this(\"The option '\" + option.getKey() + \"' was specified but an option from this group \"\n                + \"has already been selected: '\" + group.getSelected() + \"'\");\n        this.group = group;\n        this.option = option;\n    }\n\n    /**\n     * Returns the option group where another option has been selected.\n     *\n     * @return the related option group\n     * @since 1.2\n     */\n    public OptionGroup getOptionGroup()\n    {\n        return group;\n    }\n\n    /**\n     * Returns the option that was added to the group and triggered the exception.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public Option getOption()\n    {\n        return option;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/AlreadySelectedException.java b/src/main/java/org/apache/commons/cli/AlreadySelectedException.java\nindex 2959d4393..28548aeb7 100644\n--- a/src/main/java/org/apache/commons/cli/AlreadySelectedException.java\n+++ b/src/main/java/org/apache/commons/cli/AlreadySelectedException.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/AmbiguousOptionException.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Test;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport static org.junit.Assert.assertEquals;\n\npublic class AmbiguousOptionExceptionTest {\n\n    @Test\n    public void testCreateMessage() {\n        Collection<String> options = Arrays.asList(\"option1\", \"option2\", \"option3\");\n        String message = AmbiguousOptionException.createMessage(\"opt\", options);\n        assertEquals(\"Ambiguous option: 'opt' (could be: 'option1', 'option2', 'option3')\", message);\n    }\n\n    @Test\n    public void testGetMatchingOptions() {\n        Collection<String> options = Arrays.asList(\"option1\", \"option2\", \"option3\");\n        AmbiguousOptionException exception = new AmbiguousOptionException(\"opt\", options);\n        assertEquals(options, exception.getMatchingOptions());\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * Exception thrown when an option can't be identified from a partial name.\n *\n * @since 1.3\n */\npublic class AmbiguousOptionException extends UnrecognizedOptionException\n{\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 5829816121277947229L;\n\n    /** The list of options matching the partial name specified */\n    private final Collection<String> matchingOptions;\n\n    /**\n     * Constructs a new AmbiguousOptionException.\n     *\n     * @param option          the partial option name\n     * @param matchingOptions the options matching the name\n     */\n    public AmbiguousOptionException(final String option, final Collection<String> matchingOptions)\n    {\n        super(createMessage(option, matchingOptions), option);\n        this.matchingOptions = matchingOptions;\n    }\n\n    /**\n     * Returns the options matching the partial name.\n     * @return a collection of options matching the name\n     */\n    public Collection<String> getMatchingOptions()\n    {\n        return matchingOptions;\n    }\n\n    /**\n     * Build the exception message from the specified list of options.\n     *\n     * @param option\n     * @param matchingOptions\n     * @return\n     */\n    private static String createMessage(final String option, final Collection<String> matchingOptions)\n    {\n        final StringBuilder buf = new StringBuilder(\"Ambiguous option: '\");\n        buf.append(option);\n        buf.append(\"'  (could be: \");\n\n        final Iterator<String> it = matchingOptions.iterator();\n        while (it.hasNext())\n        {\n            buf.append(\"'\");\n            buf.append(it.next());\n            buf.append(\"'\");\n            if (it.hasNext())\n            {\n                buf.append(\", \");\n            }\n        }\n        buf.append(\")\");\n\n        return buf.toString();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/AmbiguousOptionException.java b/src/main/java/org/apache/commons/cli/AmbiguousOptionException.java\nindex ef347ee12..c80aeb2fe 100644\n--- a/src/main/java/org/apache/commons/cli/AmbiguousOptionException.java\n+++ b/src/main/java/org/apache/commons/cli/AmbiguousOptionException.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/BasicParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class BasicParserTest2 extends ParserTestCase {\n\n    @Override\n    @Before\n    public void setUp() {\n        super.setUp();\n        parser = new BasicParser();\n    }\n\n    @Test\n    public void testFlattenReturnsArguments() {\n        String[] args = {\"-a\", \"value1\", \"--option\", \"value2\"};\n        Options options = new Options();\n        boolean stopAtNonOption = false;\n\n        String[] result = parser.flatten(options, args, stopAtNonOption);\n\n        assertArrayEquals(args, result);\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * The class BasicParser provides a very simple implementation of\n * the {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @deprecated since 1.3, use the {@link DefaultParser} instead\n */\n@Deprecated\npublic class BasicParser extends Parser\n{\n    /**\n     * <p>A simple implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options, String[], boolean) flatten} method.</p>\n     *\n     * <p><b>Note:</b> <code>options</code> and <code>stopAtNonOption</code>\n     * are not used in this <code>flatten</code> method.</p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The <code>arguments</code> String array.\n     */\n    @Override\n    protected String[] flatten(@SuppressWarnings(\"unused\") final Options options,\n            final String[] arguments,\n            @SuppressWarnings(\"unused\") final boolean stopAtNonOption)\n    {\n        // just echo the arguments\n        return arguments;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/BasicParser.java b/src/main/java/org/apache/commons/cli/BasicParser.java\nindex d173c824f..ac4af9919 100644\n--- a/src/main/java/org/apache/commons/cli/BasicParser.java\n+++ b/src/main/java/org/apache/commons/cli/BasicParser.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/CommandLine.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport java.util.Properties;\nimport org.junit.Test;\n\n@SuppressWarnings(\"deprecation\")\npublic class CommandLineTest2 {\n\n    // No new functionality or changes in the logic of the CommandLine class were introduced in the diff file.\n    // The only changes were in the formatting of the license header.\n    // Therefore, no new tests are required to cover the changes in the diff file.\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Represents list of arguments parsed against a {@link Options} descriptor.\n * <p>\n * It allows querying of a boolean {@link #hasOption(String opt)},\n * in addition to retrieving the {@link #getOptionValue(String opt)}\n * for options requiring arguments.\n * <p>\n * Additionally, any left-over or unrecognized arguments,\n * are available for further processing.\n */\npublic class CommandLine implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** the unrecognized options/arguments */\n    private final List<String> args = new LinkedList<>();\n\n    /** the processed options */\n    private final List<Option> options = new ArrayList<>();\n\n    /**\n     * Creates a command line.\n     */\n    protected CommandLine()\n    {\n        // nothing to do\n    }\n\n    /**\n     * Query to see if an option has been set.\n     *\n     * @param opt the option to check.\n     * @return true if set, false if not.\n     * @since 1.5\n     */\n    public boolean hasOption(final Option opt)\n    {\n        return options.contains(opt);\n    }\n\n    /**\n     * Query to see if an option has been set.\n     *\n     * @param opt Short name of the option.\n     * @return true if set, false if not.\n     */\n    public boolean hasOption(final String opt)\n    {\n        return hasOption(resolveOption(opt));\n    }\n\n    /**\n     * Query to see if an option has been set.\n     *\n     * @param opt character name of the option.\n     * @return true if set, false if not.\n     */\n    public boolean hasOption(final char opt)\n    {\n        return hasOption(String.valueOf(opt));\n    }\n\n    /**\n     * Return the <code>Object</code> type of this <code>Option</code>.\n     *\n     * @param opt the name of the option.\n     * @return the type of this <code>Option</code>.\n     * @deprecated due to System.err message. Instead use getParsedOptionValue(String)\n     */\n    @Deprecated\n    public Object getOptionObject(final String opt)\n    {\n        try\n        {\n            return getParsedOptionValue(opt);\n        }\n        catch (final ParseException pe)\n        {\n            System.err.println(\"Exception found converting \" + opt + \" to desired type: \" + pe.getMessage());\n            return null;\n        }\n    }\n\n    /**\n     * Return a version of this <code>Option</code> converted to a particular type.\n     *\n     * @param option the name of the option.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.5\n     */\n    public Object getParsedOptionValue(final Option option) throws ParseException\n    {\n        if (option == null)\n        {\n            return null;\n        }\n        final String res = getOptionValue(option);\n        if (res == null)\n        {\n            return null;\n        }\n        return TypeHandler.createValue(res, option.getType());\n    }\n\n    /**\n     * Return a version of this <code>Option</code> converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.2\n     */\n    public Object getParsedOptionValue(final String opt) throws ParseException\n    {\n        return getParsedOptionValue(resolveOption(opt));\n    }\n\n    /**\n     * Return a version of this <code>Option</code> converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.5\n     */\n    public Object getParsedOptionValue(final char opt) throws ParseException\n    {\n        return getParsedOptionValue(String.valueOf(opt));\n    }\n\n    /**\n     * Return the <code>Object</code> type of this <code>Option</code>.\n     *\n     * @deprecated due to System.err message. Instead use getParsedOptionValue(char)\n     * @param opt the name of the option.\n     * @return the type of opt.\n     */\n    @Deprecated\n    public Object getOptionObject(final char opt)\n    {\n        return getOptionObject(String.valueOf(opt));\n    }\n\n    /**\n     * Retrieve the first argument, if any, of this option.\n     *\n     * @param option the name of the option.\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise null.\n     * @since 1.5\n     */\n    public String getOptionValue(final Option option)\n    {\n        if (option == null)\n        {\n            return null;\n        }\n        final String[] values = getOptionValues(option);\n        return (values == null) ? null : values[0];\n    }\n\n    /**\n     * Retrieve the first argument, if any, of this option.\n     *\n     * @param opt the name of the option.\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String getOptionValue(final String opt)\n    {\n        return getOptionValue(resolveOption(opt));\n    }\n\n    /**\n     * Retrieve the first argument, if any, of this option.\n     *\n     * @param opt the character name of the option.\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String getOptionValue(final char opt)\n    {\n        return getOptionValue(String.valueOf(opt));\n    }\n\n    /**\n     * Retrieves the array of values, if any, of an option.\n     *\n     * @param option string name of the option.\n     * @return Values of the argument if option is set, and has an argument,\n     * otherwise null.\n     * @since 1.5\n     */\n    public String[] getOptionValues(final Option option)\n    {\n        final List<String> values = new ArrayList<>();\n\n        for (final Option processedOption : options)\n        {\n            if (processedOption.equals(option))\n            {\n                values.addAll(processedOption.getValuesList());\n            }\n        }\n\n        return values.isEmpty() ? null : values.toArray(new String[values.size()]);\n    }\n\n    /**\n     * Retrieves the array of values, if any, of an option.\n     *\n     * @param opt string name of the option.\n     * @return Values of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String[] getOptionValues(final String opt)\n    {\n        return getOptionValues(resolveOption(opt));\n    }\n\n    /**\n     * Retrieves the option object given the long or short option as a String\n     *\n     * @param opt short or long name of the option.\n     * @return Canonicalized option.\n     */\n    private Option resolveOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n        for (final Option option : options)\n        {\n            if (opt.equals(option.getOpt()))\n            {\n                return option;\n            }\n\n            if (opt.equals(option.getLongOpt()))\n            {\n                return option;\n            }\n\n        }\n        return null;\n    }\n\n    /**\n     * Retrieves the array of values, if any, of an option.\n     *\n     * @param opt character name of the option.\n     * @return Values of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String[] getOptionValues(final char opt)\n    {\n        return getOptionValues(String.valueOf(opt));\n    }\n\n    /**\n     * Retrieve the first argument, if any, of an option.\n     *\n     * @param option name of the option.\n     * @param defaultValue is the default value to be returned if the option\n     * is not specified.\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise <code>defaultValue</code>.\n     * @since 1.5\n     */\n    public String getOptionValue(final Option option, final String defaultValue)\n    {\n        final String answer = getOptionValue(option);\n        return (answer != null) ? answer : defaultValue;\n    }\n\n    /**\n     * Retrieve the first argument, if any, of an option.\n     *\n     * @param opt name of the option.\n     * @param defaultValue is the default value to be returned if the option\n     * is not specified.\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise <code>defaultValue</code>.\n     */\n    public String getOptionValue(final String opt, final String defaultValue)\n    {\n        return getOptionValue(resolveOption(opt), defaultValue);\n    }\n\n    /**\n     * Retrieve the argument, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @param defaultValue is the default value to be returned if the option\n     * is not specified.\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise <code>defaultValue</code>.\n     */\n    public String getOptionValue(final char opt, final String defaultValue)\n    {\n        return getOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /**\n     * Retrieve the map of values associated to the option. This is convenient\n     * for options specifying Java properties like <code>-Dparam1=value1\n     * -Dparam2=value2</code>. The first argument of the option is the key, and\n     * the 2nd argument is the value. If the option has only one argument\n     * (<code>-Dfoo</code>) it is considered as a boolean flag and the value is\n     * <code>\"true\"</code>.\n     *\n     * @param option name of the option.\n     * @return The Properties mapped by the option, never <code>null</code>\n     *         even if the option doesn't exists.\n     * @since 1.5\n     */\n    public Properties getOptionProperties(final Option option)\n    {\n        final Properties props = new Properties();\n\n        for (final Option processedOption : options)\n        {\n            if (processedOption.equals(option))\n            {\n                final List<String> values = processedOption.getValuesList();\n                if (values.size() >= 2)\n                {\n                    // use the first 2 arguments as the key/value pair\n                    props.put(values.get(0), values.get(1));\n                }\n                else if (values.size() == 1)\n                {\n                    // no explicit value, handle it as a boolean\n                    props.put(values.get(0), \"true\");\n                }\n            }\n        }\n\n        return props;\n    }\n\n    /**\n     * Retrieve the map of values associated to the option. This is convenient\n     * for options specifying Java properties like <code>-Dparam1=value1\n     * -Dparam2=value2</code>. The first argument of the option is the key, and\n     * the 2nd argument is the value. If the option has only one argument\n     * (<code>-Dfoo</code>) it is considered as a boolean flag and the value is\n     * <code>\"true\"</code>.\n     *\n     * @param opt name of the option.\n     * @return The Properties mapped by the option, never <code>null</code>\n     *         even if the option doesn't exists.\n     * @since 1.2\n     */\n    public Properties getOptionProperties(final String opt)\n    {\n        final Properties props = new Properties();\n\n        for (final Option option : options)\n        {\n            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n            {\n                final List<String> values = option.getValuesList();\n                if (values.size() >= 2)\n                {\n                    // use the first 2 arguments as the key/value pair\n                    props.put(values.get(0), values.get(1));\n                }\n                else if (values.size() == 1)\n                {\n                    // no explicit value, handle it as a boolean\n                    props.put(values.get(0), \"true\");\n                }\n            }\n        }\n\n        return props;\n    }\n\n    /**\n     * Retrieve any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as an array.\n     */\n    public String[] getArgs()\n    {\n        final String[] answer = new String[args.size()];\n\n        args.toArray(answer);\n\n        return answer;\n    }\n\n    /**\n     * Retrieve any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as a <code>List</code>.\n     */\n    public List<String> getArgList()\n    {\n        return args;\n    }\n\n    /**\n     * jkeyes\n     * - commented out until it is implemented properly\n     * <p>Dump state, suitable for debugging.</p>\n     *\n     * @return Stringified form of this object.\n     */\n\n    /*\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n\n        buf.append(\"[ CommandLine: [ options: \");\n        buf.append(options.toString());\n        buf.append(\" ] [ args: \");\n        buf.append(args.toString());\n        buf.append(\" ] ]\");\n\n        return buf.toString();\n    }\n    */\n\n    /**\n     * Add left-over unrecognized option/argument.\n     *\n     * @param arg the unrecognized option/argument.\n     */\n    protected void addArg(final String arg)\n    {\n        args.add(arg);\n    }\n\n    /**\n     * Add an option to the command line.  The values of the option are stored.\n     *\n     * @param opt the processed option.\n     */\n    protected void addOption(final Option opt)\n    {\n        options.add(opt);\n    }\n\n    /**\n     * Returns an iterator over the Option members of CommandLine.\n     *\n     * @return an <code>Iterator</code> over the processed {@link Option}\n     * members of this {@link CommandLine}.\n     */\n    public Iterator<Option> iterator()\n    {\n        return options.iterator();\n    }\n\n    /**\n     * Returns an array of the processed {@link Option}s.\n     *\n     * @return an array of the processed {@link Option}s.\n     */\n    public Option[] getOptions()\n    {\n        final Collection<Option> processed = options;\n\n        // reinitialise array\n        final Option[] optionsArray = new Option[processed.size()];\n\n        // return the array\n        return processed.toArray(optionsArray);\n    }\n\n    /**\n     * A nested builder class to create <code>CommandLine</code> instance\n     * using descriptive methods.\n     *\n     * @since 1.4\n     */\n    public static final class Builder\n    {\n        /**\n         * CommandLine that is being build by this Builder.\n         */\n        private final CommandLine commandLine = new CommandLine();\n\n        /**\n         * Add an option to the command line. The values of the option are stored.\n         *\n         * @param opt the processed option.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addOption(final Option opt)\n        {\n            commandLine.addOption(opt);\n            return this;\n        }\n\n        /**\n         * Add left-over unrecognized option/argument.\n         *\n         * @param arg the unrecognized option/argument.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addArg(final String arg)\n        {\n            commandLine.addArg(arg);\n            return this;\n        }\n\n        public CommandLine build()\n        {\n            return commandLine;\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/CommandLine.java b/src/main/java/org/apache/commons/cli/CommandLine.java\nindex 3a5d4a786..2948b6f5b 100644\n--- a/src/main/java/org/apache/commons/cli/CommandLine.java\n+++ b/src/main/java/org/apache/commons/cli/CommandLine.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/CommandLineParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class CommandLineParserTest {\n\n    @Test\n    public void testParseWithOptionsAndArguments() throws ParseException {\n        CommandLineParser parser = new DefaultParser();\n        Options options = new Options();\n        options.addOption(\"a\", \"alpha\", false, \"Alpha option\");\n        String[] arguments = {\"-a\"};\n\n        CommandLine cmd = parser.parse(options, arguments);\n\n        assertTrue(cmd.hasOption(\"a\"));\n    }\n\n    @Test\n    public void testParseWithOptionsArgumentsAndStopAtNonOption() throws ParseException {\n        CommandLineParser parser = new DefaultParser();\n        Options options = new Options();\n        options.addOption(\"a\", \"alpha\", false, \"Alpha option\");\n        String[] arguments = {\"-a\", \"non-option\"};\n\n        CommandLine cmd = parser.parse(options, arguments, true);\n\n        assertTrue(cmd.hasOption(\"a\"));\n        assertEquals(\"non-option\", cmd.getArgList().get(0));\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * A class that implements the <code>CommandLineParser</code> interface\n * can parse a String array according to the {@link Options} specified\n * and return a {@link CommandLine}.\n */\npublic interface CommandLineParser\n{\n    /**\n     * Parse the arguments according to the specified options.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    CommandLine parse(Options options, String[] arguments) throws ParseException;\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    /* To maintain binary compatibility, this is commented out.\n       It is still in the abstract Parser class, so most users will\n       still reap the benefit.\n    CommandLine parse(Options options, String[] arguments, Properties properties)\n               throws ParseException;\n     */\n\n    /**\n     * Parse the arguments according to the specified options.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param stopAtNonOption if <code>true</code> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the\n     *     {@link CommandLine}s args list. If <code>false</code> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if <code>true</code> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the\n     *     {@link CommandLine}s args list. If <code>false</code> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    /* To maintain binary compatibility, this is commented out.\n       It is still in the abstract Parser class, so most users will\n       still reap the benefit.\n    CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException;\n     */\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/CommandLineParser.java b/src/main/java/org/apache/commons/cli/CommandLineParser.java\nindex 8fbe310a4..ed743d3f4 100644\n--- a/src/main/java/org/apache/commons/cli/CommandLineParser.java\n+++ b/src/main/java/org/apache/commons/cli/CommandLineParser.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/DefaultParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DefaultParserTest2 extends ParserTestCase {\n\n    @Override\n    @Before\n    public void setUp() {\n        super.setUp();\n        parser = new DefaultParser();\n    }\n\n    @Test\n    public void testLicenseHeaderChange() {\n        // This test ensures that the license header change does not affect functionality.\n        // Since the license header change is non-functional, we will perform a basic parse test.\n        Options options = new Options();\n        options.addOption(\"a\", \"alpha\", false, \"Alpha option\");\n        String[] args = new String[] { \"-a\" };\n        \n        try {\n            CommandLine cmd = parser.parse(options, args);\n            assertTrue(cmd.hasOption(\"a\"));\n        } catch (ParseException e) {\n            fail(\"Parsing failed due to license header change.\");\n        }\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Default parser.\n *\n * @since 1.3\n */\npublic class DefaultParser implements CommandLineParser\n{\n    /** The command-line instance. */\n    protected CommandLine cmd;\n\n    /** The current options. */\n    protected Options options;\n\n    /**\n     * Flag indicating how unrecognized tokens are handled. <code>true</code> to stop\n     * the parsing and add the remaining tokens to the args list.\n     * <code>false</code> to throw an exception.\n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n\n    /** The last option parsed. */\n    protected Option currentOption;\n\n    /** Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n\n    /** The required options and groups expected to be found when parsing the command line. */\n    protected List expectedOpts;\n\n    /** Flag indicating if partial matching of long options is supported. */\n    private final  boolean allowPartialMatching;\n\n    /**\n     * Creates a new DefaultParser instance with partial matching enabled.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     * <pre>\n     *     {@code\n     *          final Options options = new Options();\n     *      options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *      options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *      options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     *      }\n     * </pre>\n     * with \"partial matching\" turned on, <code>-de</code> only matches the\n     * <code>\"debug\"</code> option. However, with \"partial matching\" disabled,\n     * <code>-de</code> would enable both <code>debug</code> as well as\n     * <code>extract</code> options.\n     */\n    public DefaultParser() {\n        this.allowPartialMatching = true;\n    }\n\n    /**\n     * Create a new DefaultParser instance with the specified partial matching policy.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     * <pre>\n     *     {@code\n     *          final Options options = new Options();\n     *      options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *      options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *      options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     *      }\n     * </pre>\n     * with \"partial matching\" turned on, <code>-de</code> only matches the\n     * <code>\"debug\"</code> option. However, with \"partial matching\" disabled,\n     * <code>-de</code> would enable both <code>debug</code> as well as\n     * <code>extract</code> options.\n     *\n     * @param allowPartialMatching if partial matching of long options shall be enabled\n     */\n    public DefaultParser(final boolean allowPartialMatching) {\n        this.allowPartialMatching = allowPartialMatching;\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options         the specified Options\n     * @param arguments       the command line arguments\n     * @param properties      command line option name-value pairs\n     * @param stopAtNonOption if <code>true</code> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the\n     *     {@link CommandLine}s args list. If <code>false</code> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)\n            throws ParseException\n    {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups())\n        {\n            group.setSelected(null);\n        }\n\n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (final String argument : arguments)\n            {\n                handleToken(argument);\n            }\n        }\n\n        // check the arguments of the last option\n        checkRequiredArgs();\n\n        // add the default options\n        handleProperties(properties);\n\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(final Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            final String option = e.nextElement().toString();\n\n            final Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties\n                final String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Throw a {@link MissingArgumentException} if the current option\n     * didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException\n    {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Handle any command line token.\n     *\n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(final String token) throws ParseException\n    {\n        currentToken = token;\n\n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Returns true is the token is a valid argument.\n     *\n     * @param token\n     */\n    private boolean isArgument(final String token)\n    {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Check if the token is a negative number.\n     *\n     * @param token\n     */\n    private boolean isNegativeNumber(final String token)\n    {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (final NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Tells if the token looks like an option.\n     *\n     * @param token\n     */\n    private boolean isOption(final String token)\n    {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tells if the token looks like a short option.\n     *\n     * @param token\n     */\n    private boolean isShortOption(final String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        final int pos = token.indexOf(\"=\");\n        final String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName))\n        {\n            return true;\n        }\n        // check for several concatenated short options\n        return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }\n\n    /**\n     * Tells if the token looks like a long option.\n     *\n     * @param token\n     */\n    private boolean isLongOption(final String token)\n    {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        final int pos = token.indexOf(\"=\");\n        final String t = pos == -1 ? token : token.substring(0, pos);\n\n        if (!getMatchingLongOptions(t).isEmpty())\n        {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            // -LV\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an\n     * UnrecognizedOptionException is thrown. Otherwise the token is added\n     * to the arguments of the command line. If the stopAtNonOption flag\n     * is set, this stops the parsing and the remaining tokens are added\n     * as-is in the arguments of the command line.\n     *\n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(final String token) throws ParseException\n    {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n\n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L\n     * --L=V\n     * --L V\n     * --l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOption(final String token) throws ParseException\n    {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L\n     * -L\n     * --l\n     * -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(final String token) throws ParseException\n    {\n        final List<String> matchingOpts = getMatchingLongOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1 && !options.hasLongOption(token))\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            final String key = options.hasLongOption(token) ? token : matchingOpts.get(0);\n            handleOption(options.getOption(key));\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L=V\n     * -L=V\n     * --l=V\n     * -l=V\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(final String token) throws ParseException\n    {\n        final int pos = token.indexOf('=');\n\n        final String value = token.substring(pos + 1);\n\n        final String opt = token.substring(0, pos);\n\n        final List<String> matchingOpts = getMatchingLongOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1 && !options.hasLongOption(opt))\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            final String key = options.hasLongOption(opt) ? opt : matchingOpts.get(0);\n            final Option option = options.getOption(key);\n\n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * -S\n     * -SV\n     * -S V\n     * -S=V\n     * -S1S2\n     * -S1S2 V\n     * -SV1=V2\n     *\n     * -L\n     * -LV\n     * -L V\n     * -L=V\n     * -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleShortAndLongOption(final String token) throws ParseException\n    {\n        final String t = Util.stripLeadingHyphens(token);\n\n        final int pos = t.indexOf('=');\n\n        if (t.length() == 1)\n        {\n            // -S\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!getMatchingLongOptions(t).isEmpty())\n            {\n                // -L or -l\n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                // look for a long prefix (-Xmx512m)\n                final String opt = getLongPrefix(t);\n\n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            // equal sign found (-xxx=yyy)\n            final String opt = t.substring(0, pos);\n            final String value = t.substring(pos + 1);\n\n            if (opt.length() == 1)\n            {\n                // -S=V\n                final Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    /**\n     * Search for a prefix that is the long name of an option (-Xmx512m)\n     *\n     * @param token\n     */\n    private String getLongPrefix(final String token)\n    {\n        final String t = Util.stripLeadingHyphens(token);\n\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            final String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n\n        return opt;\n    }\n\n    /**\n     * Check if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(final String token)\n    {\n        final String opt = token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    private void handleOption(Option option) throws ParseException\n    {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n\n        option = (Option) option.clone();\n\n        updateRequiredOptions(option);\n\n        cmd.addOption(option);\n\n        if (option.hasArg())\n        {\n            currentOption = option;\n        }\n        else\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param option\n     */\n    private void updateRequiredOptions(final Option option) throws AlreadySelectedException\n    {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null)\n        {\n            final OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n\n    /**\n     * Returns a list of matching option strings for the given token, depending\n     * on the selected partial matching policy.\n     *\n     * @param token the token (may contain leading dashes)\n     * @return the list of matching option strings or an empty list if no matching option could be found\n     */\n    private List<String> getMatchingLongOptions(final String token)\n    {\n        if (allowPartialMatching)\n        {\n            return options.getMatchingOptions(token);\n        }\n        final List<String> matches = new ArrayList<>(1);\n        if (options.hasLongOption(token))\n        {\n            final Option option = options.getOption(token);\n            matches.add(option.getLongOpt());\n        }\n\n        return matches;\n    }\n\n    /**\n     * Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     *\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>for each remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there\n     *  are remaining characters in the token then add the remaining\n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also\n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * at the first non-Option encountered.\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line token.\n     */\n    protected void handleConcatenatedOptions(final String token) throws ParseException\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            final String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n\n                if (currentOption != null && token.length() != i + 1)\n                {\n                    // add the trail as an argument of the option\n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/DefaultParser.java b/src/main/java/org/apache/commons/cli/DefaultParser.java\nindex 2dbb10673..6298ce34c 100644\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/GnuParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class GnuParserTest2 extends ParserTestCase {\n\n    @Override\n    @Before\n    public void setUp() {\n        super.setUp();\n        parser = new GnuParser();\n    }\n\n    @Test\n    public void testFlattenWithDoubleDash() throws Exception {\n        Options options = new Options();\n        options.addOption(\"a\", false, \"Option A\");\n        String[] args = new String[] { \"--\", \"arg1\", \"arg2\" };\n        String[] expected = new String[] { \"--\", \"arg1\", \"arg2\" };\n        String[] result = parser.flatten(options, args, false);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFlattenWithSingleDash() throws Exception {\n        Options options = new Options();\n        options.addOption(\"a\", false, \"Option A\");\n        String[] args = new String[] { \"-\", \"arg1\", \"arg2\" };\n        String[] expected = new String[] { \"-\", \"arg1\", \"arg2\" };\n        String[] result = parser.flatten(options, args, false);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFlattenWithOptionAndArgument() throws Exception {\n        Options options = new Options();\n        options.addOption(\"a\", true, \"Option A\");\n        String[] args = new String[] { \"-a\", \"value\" };\n        String[] expected = new String[] { \"-a\", \"value\" };\n        String[] result = parser.flatten(options, args, false);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFlattenWithOptionAndEqualArgument() throws Exception {\n        Options options = new Options();\n        options.addOption(\"a\", true, \"Option A\");\n        String[] args = new String[] { \"-a=value\" };\n        String[] expected = new String[] { \"-a\", \"value\" };\n        String[] result = parser.flatten(options, args, false);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFlattenWithUnknownOption() throws Exception {\n        Options options = new Options();\n        options.addOption(\"a\", false, \"Option A\");\n        String[] args = new String[] { \"-b\" };\n        String[] expected = new String[] { \"-b\" };\n        String[] result = parser.flatten(options, args, false);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFlattenWithStopAtNonOption() throws Exception {\n        Options options = new Options();\n        options.addOption(\"a\", false, \"Option A\");\n        String[] args = new String[] { \"-a\", \"arg1\", \"-b\", \"arg2\" };\n        String[] expected = new String[] { \"-a\", \"arg1\", \"-b\", \"arg2\" };\n        String[] result = parser.flatten(options, args, true);\n        assertArrayEquals(expected, result);\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The class GnuParser provides an implementation of the\n * {@link Parser#flatten(Options, String[], boolean) flatten} method.\n *\n * @deprecated since 1.3, use the {@link DefaultParser} instead\n */\n@Deprecated\npublic class GnuParser extends Parser\n{\n    /**\n     * This flatten method does so using the following rules:\n     * <ol>\n     *   <li>If an {@link Option} exists for the first character of\n     *   the <code>arguments</code> entry <b>AND</b> an {@link Option}\n     *   does not exist for the whole <code>argument</code> then\n     *   add the first character as an option to the processed tokens\n     *   list e.g. \"-D\" and add the rest of the entry to the also.</li>\n     *   <li>Otherwise just add the token to the processed tokens list.</li>\n     * </ol>\n     *\n     * @param options         The Options to parse the arguments by.\n     * @param arguments       The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop flattening when\n     *                        a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption)\n    {\n        final List<String> tokens = new ArrayList<>();\n\n        boolean eatTheRest = false;\n\n        for (int i = 0; i < arguments.length; i++)\n        {\n            final String arg = arguments[i];\n\n            if (\"--\".equals(arg))\n            {\n                eatTheRest = true;\n                tokens.add(\"--\");\n            }\n            else if (\"-\".equals(arg))\n            {\n                tokens.add(\"-\");\n            }\n            else if (arg.startsWith(\"-\"))\n            {\n                final String opt = Util.stripLeadingHyphens(arg);\n\n                if (options.hasOption(opt))\n                {\n                    tokens.add(arg);\n                }\n                else\n                {\n                    if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n                    {\n                        // the format is --foo=value or -foo=value\n                        tokens.add(arg.substring(0, arg.indexOf('='))); // --foo\n                        tokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n                    }\n                    else if (options.hasOption(arg.substring(0, 2)))\n                    {\n                        // the format is a special properties option (-Dproperty=value)\n                        tokens.add(arg.substring(0, 2)); // -D\n                        tokens.add(arg.substring(2)); // property=value\n                    }\n                    else\n                    {\n                        eatTheRest = stopAtNonOption;\n                        tokens.add(arg);\n                    }\n                }\n            }\n            else\n            {\n                tokens.add(arg);\n            }\n\n            if (eatTheRest)\n            {\n                for (i++; i < arguments.length; i++) //NOPMD\n                {\n                    tokens.add(arguments[i]);\n                }\n            }\n        }\n\n        return tokens.toArray(new String[tokens.size()]);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/GnuParser.java b/src/main/java/org/apache/commons/cli/GnuParser.java\nindex 6975aa265..f182caec8 100644\n--- a/src/main/java/org/apache/commons/cli/GnuParser.java\n+++ b/src/main/java/org/apache/commons/cli/GnuParser.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\n\npublic class HelpFormatterTest2 {\n\n    private static final String EOL = System.getProperty(\"line.separator\");\n\n    @Test\n    public void testLicenseHeaderFormat() {\n        String expectedHeader = \"Licensed to the Apache Software Foundation (ASF) under one or more\" + EOL +\n                                \"contributor license agreements.  See the NOTICE file distributed with\" + EOL +\n                                \"this work for additional information regarding copyright ownership.\" + EOL +\n                                \"The ASF licenses this file to You under the Apache License, Version 2.0\" + EOL +\n                                \"(the \\\"License\\\"); you may not use this file except in compliance with\" + EOL +\n                                \"the License.  You may obtain a copy of the License at\" + EOL +\n                                EOL +\n                                \"    http://www.apache.org/licenses/LICENSE-2.0\" + EOL +\n                                EOL +\n                                \"Unless required by applicable law or agreed to in writing, software\" + EOL +\n                                \"distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\" + EOL +\n                                \"WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\" + EOL +\n                                \"See the License for the specific language governing permissions and\" + EOL +\n                                \"limitations under the License.\";\n\n        String actualHeader = HelpFormatter.class.getPackage().getImplementationTitle();\n        assertEquals(\"License header format\", expectedHeader, actualHeader);\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * A formatter of help messages for command line options.\n *\n * <p>Example:</p>\n *\n * <pre>\n * Options options = new Options();\n * options.addOption(OptionBuilder.withLongOpt(\"file\")\n *                                .withDescription(\"The file to be processed\")\n *                                .hasArg()\n *                                .withArgName(\"FILE\")\n *                                .isRequired()\n *                                .create('f'));\n * options.addOption(OptionBuilder.withLongOpt(\"version\")\n *                                .withDescription(\"Print the version of the application\")\n *                                .create('v'));\n * options.addOption(OptionBuilder.withLongOpt(\"help\").create('h'));\n *\n * String header = \"Do something useful with an input file\\n\\n\";\n * String footer = \"\\nPlease report issues at http://example.com/issues\";\n *\n * HelpFormatter formatter = new HelpFormatter();\n * formatter.printHelp(\"myapp\", header, options, footer, true);\n * </pre>\n *\n * This produces the following output:\n *\n * <pre>\n * usage: myapp -f &lt;FILE&gt; [-h] [-v]\n * Do something useful with an input file\n *\n *  -f,--file &lt;FILE&gt;   The file to be processed\n *  -h,--help\n *  -v,--version       Print the version of the application\n *\n * Please report issues at http://example.com/issues\n * </pre>\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /** number of space characters to be prefixed to each description line */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /**\n     * default separator displayed between a long Option and its value\n     *\n     * @since 1.3\n     **/\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    @Deprecated\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    @Deprecated\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    @Deprecated\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the beginning of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    @Deprecated\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    @Deprecated\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     *\n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator<Option> optionComparator = new OptionComparator();\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(final int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(final int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(final int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(final String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(final String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(final String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(final String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     *\n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(final String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     *\n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(final String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     *\n     * @return the {@link Comparator} currently in use to sort the options\n     * @since 1.2\n     */\n    public Comparator<Option> getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null comparator will keep the options in the order they were declared.\n     *\n     * @param comparator the {@link Comparator} to use for sorting the options\n     * @since 1.2\n     */\n    public void setOptionComparator(final Comparator<Option> comparator)\n    {\n        this.optionComparator = comparator;\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(final String cmdLineSyntax, final Options options)\n    {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage)\n    {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage)\n    {\n        printHelp(getWidth(), cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(final int width, final String cmdLineSyntax, final String header,\n                          final Options options, final String footer, final boolean autoUsage)\n    {\n        final PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, getLeftPadding(), getDescPadding(), footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax,\n                          final String header, final Options options, final int leftPad,\n                          final int descPad, final String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax,\n                          final String header, final Options options, final int leftPad,\n                          final int descPad, final String footer, final boolean autoUsage)\n    {\n        if (cmdLineSyntax == null || cmdLineSyntax.length() == 0)\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if (header != null && header.trim().length() > 0)\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if (footer != null && footer.trim().length() > 0)\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement\n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(final PrintWriter pw, final int width, final String app, final Options options)\n    {\n        // initialise the string buffer\n        final StringBuffer buff = new StringBuffer(getSyntaxPrefix()).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection<OptionGroup> processedGroups = new ArrayList<>();\n\n        final List<Option> optList = new ArrayList<>(options.getOptions());\n        if (getOptionComparator() != null)\n        {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // iterate over the options\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();)\n        {\n            // get the next Option\n            final Option option = it.next();\n\n            // check if the option is part of an OptionGroup\n            final OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group\n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (it.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.\n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        final List<Option> optList = new ArrayList<>(group.getOptions());\n        if (getOptionComparator() != null)\n        {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // for each option in the OptionGroup\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, it.next(), true);\n\n            if (it.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.\n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax)\n    {\n        final int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, getSyntaxPrefix().length() + argPos, getSyntaxPrefix() + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer,\n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(final PrintWriter pw, final int width, final Options options,\n                             final int leftPad, final int descPad)\n    {\n        final StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(final PrintWriter pw, final int width, final String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text)\n    {\n        final StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedTextBlock(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where\n        // -a is opt and --aaa is long opt; in parallel look for\n        // the longest opt string this list will be then used to\n        // sort options ascending\n        int max = 0;\n        final List<StringBuffer> prefixList = new ArrayList<>();\n\n        final List<Option> optList = options.helpOptions();\n\n        if (getOptionComparator() != null)\n        {\n            Collections.sort(optList, getOptionComparator());\n        }\n\n        for (final Option option : optList)\n        {\n            final StringBuffer optBuf = new StringBuffer();\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                final String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = optBuf.length() > max ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();)\n        {\n            final Option option = it.next();\n            final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            final int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (it.hasNext())\n            {\n                sb.append(getNewLine());\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(final StringBuffer sb, final int width,\n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(getNewLine());\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            if (text.length() > width && pos == nextLineTabStop - 1)\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(getNewLine());\n        }\n    }\n\n    /**\n     * Render the specified text width a maximum width. This method differs\n     * from renderWrappedText by not removing leading spaces after a new line.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     */\n    private Appendable renderWrappedTextBlock(final StringBuffer sb, final int width, final int nextLineTabStop, final String text)\n    {\n        try\n        {\n            final BufferedReader in = new BufferedReader(new StringReader(text));\n            String line;\n            boolean firstLine = true;\n            while ((line = in.readLine()) != null)\n            {\n                if (!firstLine)\n                {\n                    sb.append(getNewLine());\n                }\n                else\n                {\n                    firstLine = false;\n                }\n                renderWrappedText(sb, width, nextLineTabStop, line);\n            }\n        }\n        catch (final IOException e) //NOPMD\n        {\n            // cannot happen\n        }\n\n        return sb;\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a\n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return position on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(final String text, final int width, final int startPos)\n    {\n        // the line ends before the max wrap pos or a new line char found\n        int pos = text.indexOf('\\n', startPos);\n        if (pos != -1 && pos <= width)\n        {\n            return pos + 1;\n        }\n\n        pos = text.indexOf('\\t', startPos);\n        if (pos != -1 && pos <= width)\n        {\n            return pos + 1;\n        }\n\n        if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n        // look for the last whitespace character before startPos+width\n        for (pos = startPos + width; pos >= startPos; --pos)\n        {\n            final char c = text.charAt(pos);\n            if (c == ' ' || c == '\\n' || c == '\\r')\n            {\n                break;\n            }\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n\n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n\n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(final int len)\n    {\n        final char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n\n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(final String s)\n    {\n        if (s == null || s.length() == 0)\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while (pos > 0 && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator<Option>, Serializable\n    {\n        /** The serial version UID. */\n        private static final long serialVersionUID = 5305467873966684014L;\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param opt1 The first Option to be compared.\n         * @param opt2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        @Override\n        public int compare(final Option opt1, final Option opt2)\n        {\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/HelpFormatter.java b/src/main/java/org/apache/commons/cli/HelpFormatter.java\nindex 961f1300a..981ca5c2f 100644\n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/MissingArgumentException.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MissingArgumentExceptionTest {\n\n    @Test\n    public void testMissingArgumentExceptionWithMessage() {\n        String message = \"Test message\";\n        MissingArgumentException exception = new MissingArgumentException(message);\n        assertEquals(message, exception.getMessage());\n    }\n\n    @Test\n    public void testMissingArgumentExceptionWithOption() {\n        Option option = new Option(\"a\", \"optionA\", true, \"Option A\");\n        MissingArgumentException exception = new MissingArgumentException(option);\n        assertEquals(\"Missing argument for option: a\", exception.getMessage());\n        assertEquals(option, exception.getOption());\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Thrown when an option requiring an argument\n * is not provided with an argument.\n */\npublic class MissingArgumentException extends ParseException\n{\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = -7098538588704965017L;\n\n    /** The option requiring additional arguments */\n    private Option option;\n\n    /**\n     * Construct a new <code>MissingArgumentException</code>\n     * with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public MissingArgumentException(final String message)\n    {\n        super(message);\n    }\n\n    /**\n     * Construct a new <code>MissingArgumentException</code>\n     * with the specified detail message.\n     *\n     * @param option the option requiring an argument\n     * @since 1.2\n     */\n    public MissingArgumentException(final Option option)\n    {\n        this(\"Missing argument for option: \" + option.getKey());\n        this.option = option;\n    }\n\n    /**\n     * Return the option requiring an argument that wasn't provided\n     * on the command line.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public Option getOption()\n    {\n        return option;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/MissingArgumentException.java b/src/main/java/org/apache/commons/cli/MissingArgumentException.java\nindex 88617c295..75af8f0b9 100644\n--- a/src/main/java/org/apache/commons/cli/MissingArgumentException.java\n+++ b/src/main/java/org/apache/commons/cli/MissingArgumentException.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/MissingOptionException.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class MissingOptionExceptionTest {\n\n    @Test\n    public void testSingleMissingOption() {\n        MissingOptionException exception = new MissingOptionException(Collections.singletonList(\"option1\"));\n        assertEquals(\"Missing required option: option1\", exception.getMessage());\n        assertEquals(Collections.singletonList(\"option1\"), exception.getMissingOptions());\n    }\n\n    @Test\n    public void testMultipleMissingOptions() {\n        MissingOptionException exception = new MissingOptionException(Arrays.asList(\"option1\", \"option2\"));\n        assertEquals(\"Missing required options: option1, option2\", exception.getMessage());\n        assertEquals(Arrays.asList(\"option1\", \"option2\"), exception.getMissingOptions());\n    }\n\n    @Test\n    public void testNoMissingOptions() {\n        MissingOptionException exception = new MissingOptionException(Collections.emptyList());\n        assertEquals(\"Missing required options: \", exception.getMessage());\n        assertEquals(Collections.emptyList(), exception.getMissingOptions());\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.List;\nimport java.util.Iterator;\n\n/**\n * Thrown when a required option has not been provided.\n */\npublic class MissingOptionException extends ParseException\n{\n    /** This exception {@code serialVersionUID}. */\n    private static final long serialVersionUID = 8161889051578563249L;\n\n    /** The list of missing options and groups */\n    private List missingOptions;\n\n    /**\n     * Construct a new <code>MissingSelectedException</code>\n     * with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public MissingOptionException(final String message)\n    {\n        super(message);\n    }\n\n    /**\n     * Constructs a new <code>MissingSelectedException</code> with the\n     * specified list of missing options.\n     *\n     * @param missingOptions the list of missing options and groups\n     * @since 1.2\n     */\n    public MissingOptionException(final List missingOptions)\n    {\n        this(createMessage(missingOptions));\n        this.missingOptions = missingOptions;\n    }\n\n    /**\n     * Returns the list of options or option groups missing in the command line parsed.\n     *\n     * @return the missing options, consisting of String instances for simple\n     *         options, and OptionGroup instances for required option groups.\n     * @since 1.2\n     */\n    public List getMissingOptions()\n    {\n        return missingOptions;\n    }\n\n    /**\n     * Build the exception message from the specified list of options.\n     *\n     * @param missingOptions the list of missing options and groups\n     * @since 1.2\n     */\n    private static String createMessage(final List<?> missingOptions)\n    {\n        final StringBuilder buf = new StringBuilder(\"Missing required option\");\n        buf.append(missingOptions.size() == 1 ? \"\" : \"s\");\n        buf.append(\": \");\n\n        final Iterator<?> it = missingOptions.iterator();\n        while (it.hasNext())\n        {\n            buf.append(it.next());\n            if (it.hasNext())\n            {\n                buf.append(\", \");\n            }\n        }\n\n        return buf.toString();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/MissingOptionException.java b/src/main/java/org/apache/commons/cli/MissingOptionException.java\nindex 4160665d8..9c66678f9 100644\n--- a/src/main/java/org/apache/commons/cli/MissingOptionException.java\n+++ b/src/main/java/org/apache/commons/cli/MissingOptionException.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/Option.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\n\npublic class OptionTest2 {\n\n    private static class TestOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        public TestOption(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n            super(opt, hasArg, description);\n        }\n\n        @Override\n        public boolean addValue(final String value) {\n            addValueForProcessing(value);\n            return true;\n        }\n    }\n\n    @Test\n    public void testLicenseHeaderChange() {\n        // This test is a placeholder to ensure that the license header change does not affect functionality.\n        final TestOption option = new TestOption(\"x\", true, \"description\");\n        assertEquals(\"x\", option.getOpt());\n        assertEquals(\"description\", option.getDescription());\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Describes a single command-line option.  It maintains\n * information regarding the short-name of the option, the long-name,\n * if any exists, a flag indicating if an argument is required for\n * this option, and a self-documenting description of the option.\n * <p>\n * An Option is not created independently, but is created through\n * an instance of {@link Options}. An Option is required to have\n * at least a short or a long-name.\n * <p>\n * <b>Note:</b> once an {@link Option} has been added to an instance\n * of {@link Options}, its required flag cannot be changed.\n *\n * @see org.apache.commons.cli.Options\n * @see org.apache.commons.cli.CommandLine\n */\npublic class Option implements Cloneable, Serializable\n{\n    /** constant that specifies the number of argument values has not been specified */\n    public static final int UNINITIALIZED = -1;\n\n    /** constant that specifies the number of argument values is infinite */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** the name of the option */\n    private final String opt;\n\n    /** the long representation of the option */\n    private String longOpt;\n\n    /** the name of the argument for this option */\n    private String argName;\n\n    /** description of the option */\n    private String description;\n\n    /** specifies whether this option is required to be present */\n    private boolean required;\n\n    /** specifies whether the argument value of this Option is optional */\n    private boolean optionalArg;\n\n    /** the number of argument values this option can have */\n    private int numberOfArgs = UNINITIALIZED;\n\n    /** the type of this Option */\n    private Class<?> type = String.class;\n\n    /** the list of argument values **/\n    private List<String> values = new ArrayList<>();\n\n    /** the character that is the value separator */\n    private char valuesep;\n\n    /**\n     * Private constructor used by the nested Builder class.\n     *\n     * @param builder builder used to create this option\n     */\n    private Option(final Builder builder)\n    {\n        this.argName = builder.argName;\n        this.description = builder.description;\n        this.longOpt = builder.longOpt;\n        this.numberOfArgs = builder.numberOfArgs;\n        this.opt = builder.opt;\n        this.optionalArg = builder.optionalArg;\n        this.required = builder.required;\n        this.type = builder.type;\n        this.valuesep = builder.valuesep;\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     * The option does not take an argument.\n     *\n     * @param opt short representation of the option\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(final String opt, final String description) throws IllegalArgumentException\n    {\n        this(opt, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException\n    {\n        this(opt, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param longOpt the long representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(final String opt, final String longOpt, final boolean hasArg, final String description)\n           throws IllegalArgumentException\n    {\n        // ensure that the option is valid\n        OptionValidator.validateOption(opt);\n\n        this.opt = opt;\n        this.longOpt = longOpt;\n\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg)\n        {\n            this.numberOfArgs = 1;\n        }\n\n        this.description = description;\n    }\n\n    /**\n     * Returns the id of this Option.  This is only set when the\n     * Option shortOpt is a single character.  This is used for switch\n     * statements.\n     *\n     * @return the id of this Option\n     */\n    public int getId()\n    {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Returns the 'unique' Option identifier.\n     *\n     * @return the 'unique' Option identifier\n     */\n    String getKey()\n    {\n        // if 'opt' is null, then it is a 'long' option\n        return (opt == null) ? longOpt : opt;\n    }\n\n    /**\n     * Retrieve the name of this Option.\n     *\n     * It is this String which can be used with\n     * {@link CommandLine#hasOption(String opt)} and\n     * {@link CommandLine#getOptionValue(String opt)} to check\n     * for existence and argument.\n     *\n     * @return The name of this option\n     */\n    public String getOpt()\n    {\n        return opt;\n    }\n\n    /**\n     * Retrieve the type of this Option.\n     *\n     * @return The type of this option\n     */\n    public Object getType()\n    {\n        return type;\n    }\n\n    /**\n     * Sets the type of this Option.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the\n     * input type is supposed to be a {@link Class} object.\n     *\n     * @param type the type of this Option\n     * @deprecated since 1.3, use {@link #setType(Class)} instead\n     */\n    @Deprecated\n    public void setType(final Object type)\n    {\n        setType((Class<?>) type);\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option\n     * @since 1.3\n     */\n    public void setType(final Class<?> type)\n    {\n        this.type = type;\n    }\n\n    /**\n     * Retrieve the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name\n     */\n    public String getLongOpt()\n    {\n        return longOpt;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option\n     */\n    public void setLongOpt(final String longOpt)\n    {\n        this.longOpt = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have\n     * an optional argument.\n     */\n    public void setOptionalArg(final boolean optionalArg)\n    {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * @return whether this Option can have an optional argument\n     */\n    public boolean hasOptionalArg()\n    {\n        return optionalArg;\n    }\n\n    /**\n     * Query to see if this Option has a long name\n     *\n     * @return boolean flag indicating existence of a long name\n     */\n    public boolean hasLongOpt()\n    {\n        return longOpt != null;\n    }\n\n    /**\n     * Query to see if this Option requires an argument\n     *\n     * @return boolean flag indicating if an argument is required\n     */\n    public boolean hasArg()\n    {\n        return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /**\n     * Retrieve the self-documenting description of this Option\n     *\n     * @return The string description of this option\n     */\n    public String getDescription()\n    {\n        return description;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option\n     *\n     * @param description The description of this option\n     * @since 1.1\n     */\n    public void setDescription(final String description)\n    {\n        this.description = description;\n    }\n\n    /**\n     * Query to see if this Option is mandatory\n     *\n     * @return boolean flag indicating whether this Option is mandatory\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory\n     */\n    public void setRequired(final boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(final String argName)\n    {\n        this.argName = argName;\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName()\n    {\n        return argName;\n    }\n\n    /**\n     * Returns whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName()\n    {\n        return argName != null && argName.length() > 0;\n    }\n\n    /**\n     * Query to see if this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed\n     */\n    public boolean hasArgs()\n    {\n        return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /**\n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values\n     */\n    public void setArgs(final int num)\n    {\n        this.numberOfArgs = num;\n    }\n\n    /**\n     * Sets the value separator.  For example if the argument value\n     * was a Java property, the value separator would be '='.\n     *\n     * @param sep The value separator.\n     */\n    public void setValueSeparator(final char sep)\n    {\n        this.valuesep = sep;\n    }\n\n    /**\n     * Returns the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator()\n    {\n        return valuesep;\n    }\n\n    /**\n     * Return whether this Option has specified a value separator.\n     *\n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator()\n    {\n        return valuesep > 0;\n    }\n\n    /**\n     * Returns the number of argument values this Option can take.\n     *\n     * <p>\n     * A value equal to the constant {@link #UNINITIALIZED} (= -1) indicates\n     * the number of arguments has not been specified.\n     * A value equal to the constant {@link #UNLIMITED_VALUES} (= -2) indicates\n     * that this options takes an unlimited amount of values.\n     * </p>\n     *\n     * @return num the number of argument values\n     * @see #UNINITIALIZED\n     * @see #UNLIMITED_VALUES\n     */\n    public int getArgs()\n    {\n        return numberOfArgs;\n    }\n\n    /**\n     * Adds the specified value to this Option.\n     *\n     * @param value is a/the value of this Option\n     */\n    void addValueForProcessing(final String value)\n    {\n        if (numberOfArgs == UNINITIALIZED)\n        {\n            throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n        }\n        processValue(value);\n    }\n\n    /**\n     * Processes the value.  If this Option has a value separator\n     * the value will have to be parsed into individual tokens.  When\n     * n-1 tokens have been processed and there are more value separators\n     * in the value, parsing is ceased and the remaining characters are\n     * added as a single token.\n     *\n     * @param value The String to be processed.\n     *\n     * @since 1.0.1\n     */\n    private void processValue(String value)\n    {\n        // this Option has a separator character\n        if (hasValueSeparator())\n        {\n            // get the separator character\n            final char sep = getValueSeparator();\n\n            // store the index for the value separator\n            int index = value.indexOf(sep);\n\n            // while there are more value separators\n            while (index != -1)\n            {\n                // next value to be added\n                if (values.size() == numberOfArgs - 1)\n                {\n                    break;\n                }\n\n                // store\n                add(value.substring(0, index));\n\n                // parse\n                value = value.substring(index + 1);\n\n                // get new index\n                index = value.indexOf(sep);\n            }\n        }\n\n        // store the actual value or the last value that has been parsed\n        add(value);\n    }\n\n    /**\n     * Add the value to this Option.  If the number of arguments\n     * is greater than zero and there is enough space in the list then\n     * add the value.  Otherwise, throw a runtime exception.\n     *\n     * @param value The value to be added to this Option\n     *\n     * @since 1.0.1\n     */\n    private void add(final String value)\n    {\n        if (!acceptsArg())\n        {\n            throw new RuntimeException(\"Cannot add value, list full.\");\n        }\n\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * Returns the specified value of this Option or\n     * <code>null</code> if there is no value.\n     *\n     * @return the value/first value of this Option or\n     * <code>null</code> if there is no value.\n     */\n    public String getValue()\n    {\n        return hasNoValues() ? null : values.get(0);\n    }\n\n    /**\n     * Returns the specified value of this Option or\n     * <code>null</code> if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or\n     * <code>null</code> if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1\n     * or greater than the number of the values for this Option.\n     */\n    public String getValue(final int index) throws IndexOutOfBoundsException\n    {\n        return hasNoValues() ? null : values.get(index);\n    }\n\n    /**\n     * Returns the value/first value of this Option or the\n     * <code>defaultValue</code> if there is no value.\n     *\n     * @param defaultValue The value to be returned if there\n     * is no value.\n     *\n     * @return the value/first value of this Option or the\n     * <code>defaultValue</code> if there are no values.\n     */\n    public String getValue(final String defaultValue)\n    {\n        final String value = getValue();\n\n        return (value != null) ? value : defaultValue;\n    }\n\n    /**\n     * Return the values of this Option as a String array\n     * or null if there are no values\n     *\n     * @return the values of this Option as a String array\n     * or null if there are no values\n     */\n    public String[] getValues()\n    {\n        return hasNoValues() ? null : values.toArray(new String[values.size()]);\n    }\n\n    /**\n     * @return the values of this Option as a List\n     * or null if there are no values\n     */\n    public List<String> getValuesList()\n    {\n        return values;\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString()\n    {\n        final StringBuilder buf = new StringBuilder().append(\"[ option: \");\n\n        buf.append(opt);\n\n        if (longOpt != null)\n        {\n            buf.append(\" \").append(longOpt);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs())\n        {\n            buf.append(\"[ARG...]\");\n        }\n        else if (hasArg())\n        {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null)\n        {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n\n    /**\n     * Returns whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues()\n    {\n        return values.isEmpty();\n    }\n\n    @Override\n    public boolean equals(final Object o)\n    {\n        if (this == o)\n        {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass())\n        {\n            return false;\n        }\n\n        final Option option = (Option) o;\n\n        if (opt != null ? !opt.equals(option.opt) : option.opt != null)\n        {\n            return false;\n        }\n        if (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        int result;\n        result = opt != null ? opt.hashCode() : 0;\n        result = 31 * result + (longOpt != null ? longOpt.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public\n     * and in 1.1 rather than throwing a CloneNotSupportedException it throws\n     * a RuntimeException so as to maintain backwards compat at the API level.\n     *\n     * After calling this method, it is very likely you will want to call\n     * clearValues().\n     *\n     * @return a clone of this Option instance\n     * @throws RuntimeException if a {@link CloneNotSupportedException} has been thrown\n     * by {@code super.clone()}\n     */\n    @Override\n    public Object clone()\n    {\n        try\n        {\n            final Option option = (Option) super.clone();\n            option.values = new ArrayList<>(values);\n            return option;\n        }\n        catch (final CloneNotSupportedException cnse)\n        {\n            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n\n    /**\n     * Clear the Option values. After a parse is complete, these are left with\n     * data in them and they need clearing if another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues()\n    {\n        values.clear();\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal\n     * API that was made public in 1.0. It currently throws an UnsupportedOperationException.\n     *\n     * @param value the value to add\n     * @return always throws an {@link UnsupportedOperationException}\n     * @throws UnsupportedOperationException always\n     * @deprecated\n     */\n    @Deprecated\n    public boolean addValue(final String value)\n    {\n        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. \"\n                + \"Subclasses should use the addValueForProcessing method instead. \");\n    }\n\n    /**\n     * Tells if the option can accept more arguments.\n     *\n     * @return false if the maximum number of arguments is reached\n     * @since 1.3\n     */\n    boolean acceptsArg()\n    {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n    }\n\n    /**\n     * Tells if the option requires more arguments to be valid.\n     *\n     * @return false if the option doesn't require more arguments\n     * @since 1.3\n     */\n    boolean requiresArg()\n    {\n        if (optionalArg)\n        {\n            return false;\n        }\n        if (numberOfArgs == UNLIMITED_VALUES)\n        {\n            return values.isEmpty();\n        }\n        return acceptsArg();\n    }\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive\n     * methods.\n     *\n     * @return a new {@link Builder} instance\n     * @since 1.3\n     */\n    public static Builder builder()\n    {\n        return builder(null);\n    }\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive\n     * methods.\n     *\n     * @param opt short representation of the option\n     * @return a new {@link Builder} instance\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n     * @since 1.3\n     */\n    public static Builder builder(final String opt)\n    {\n        return new Builder(opt);\n    }\n\n    /**\n     * A nested builder class to create <code>Option</code> instances\n     * using descriptive methods.\n     * <p>\n     * Example usage:\n     * <pre>\n     * Option option = Option.builder(\"a\")\n     *     .required(true)\n     *     .longOpt(\"arg-name\")\n     *     .build();\n     * </pre>\n     *\n     * @since 1.3\n     */\n    public static final class Builder\n    {\n        /** the name of the option */\n        private final String opt;\n\n        /** description of the option */\n        private String description;\n\n        /** the long representation of the option */\n        private String longOpt;\n\n        /** the name of the argument for this option */\n        private String argName;\n\n        /** specifies whether this option is required to be present */\n        private boolean required;\n\n        /** specifies whether the argument value of this Option is optional */\n        private boolean optionalArg;\n\n        /** the number of argument values this option can have */\n        private int numberOfArgs = UNINITIALIZED;\n\n        /** the type of this Option */\n        private Class<?> type = String.class;\n\n        /** the character that is the value separator */\n        private char valuesep;\n\n        /**\n         * Constructs a new <code>Builder</code> with the minimum\n         * required parameters for an <code>Option</code> instance.\n         *\n         * @param opt short representation of the option\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n         */\n        private Builder(final String opt) throws IllegalArgumentException\n        {\n            OptionValidator.validateOption(opt);\n            this.opt = opt;\n        }\n\n        /**\n         * Sets the display name for the argument value.\n         *\n         * @param argName the display name for the argument value.\n         * @return this builder, to allow method chaining\n         */\n        public Builder argName(final String argName)\n        {\n            this.argName = argName;\n            return this;\n        }\n\n        /**\n         * Sets the description for this option.\n         *\n         * @param description the description of the option.\n         * @return this builder, to allow method chaining\n         */\n        public Builder desc(final String description)\n        {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Sets the long name of the Option.\n         *\n         * @param longOpt the long name of the Option\n         * @return this builder, to allow method chaining\n         */\n        public Builder longOpt(final String longOpt)\n        {\n            this.longOpt = longOpt;\n            return this;\n        }\n\n        /**\n         * Sets the number of argument values the Option can take.\n         *\n         * @param numberOfArgs the number of argument values\n         * @return this builder, to allow method chaining\n         */\n        public Builder numberOfArgs(final int numberOfArgs)\n        {\n            this.numberOfArgs = numberOfArgs;\n            return this;\n        }\n\n        /**\n         * Sets whether the Option can have an optional argument.\n         *\n         * @param isOptional specifies whether the Option can have\n         * an optional argument.\n         * @return this builder, to allow method chaining\n         */\n        public Builder optionalArg(final boolean isOptional)\n        {\n            this.optionalArg = isOptional;\n            return this;\n        }\n\n        /**\n         * Marks this Option as required.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder required()\n        {\n            return required(true);\n        }\n\n        /**\n         * Sets whether the Option is mandatory.\n         *\n         * @param required specifies whether the Option is mandatory\n         * @return this builder, to allow method chaining\n         */\n        public Builder required(final boolean required)\n        {\n            this.required = required;\n            return this;\n        }\n\n        /**\n         * Sets the type of the Option.\n         *\n         * @param type the type of the Option\n         * @return this builder, to allow method chaining\n         */\n        public Builder type(final Class<?> type)\n        {\n            this.type = type;\n            return this;\n        }\n\n        /**\n         * The Option will use '=' as a means to separate argument value.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder valueSeparator()\n        {\n            return valueSeparator('=');\n        }\n\n        /**\n         * The Option will use <code>sep</code> as a means to\n         * separate argument values.\n         * <p>\n         * <b>Example:</b>\n         * <pre>\n         * Option opt = Option.builder(\"D\").hasArgs()\n         *                                 .valueSeparator('=')\n         *                                 .build();\n         * Options options = new Options();\n         * options.addOption(opt);\n         * String[] args = {\"-Dkey=value\"};\n         * CommandLineParser parser = new DefaultParser();\n         * CommandLine line = parser.parse(options, args);\n         * String propertyName = line.getOptionValues(\"D\")[0];  // will be \"key\"\n         * String propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n         * </pre>\n         *\n         * @param sep The value separator.\n         * @return this builder, to allow method chaining\n         */\n        public Builder valueSeparator(final char sep)\n        {\n            valuesep = sep;\n            return this;\n        }\n\n        /**\n         * Indicates that the Option will require an argument.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArg()\n        {\n            return hasArg(true);\n        }\n\n        /**\n         * Indicates if the Option has an argument or not.\n         *\n         * @param hasArg specifies whether the Option takes an argument or not\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArg(final boolean hasArg)\n        {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n            return this;\n        }\n\n        /**\n         * Indicates that the Option can have unlimited argument values.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArgs()\n        {\n            numberOfArgs = Option.UNLIMITED_VALUES;\n            return this;\n        }\n\n        /**\n         * Constructs an Option with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link Option}\n         * @throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set\n         */\n        public Option build()\n        {\n            if (opt == null && longOpt == null)\n            {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/Option.java b/src/main/java/org/apache/commons/cli/Option.java\nindex 4a9b7741f..65cdafc21 100644\n--- a/src/main/java/org/apache/commons/cli/Option.java\n+++ b/src/main/java/org/apache/commons/cli/Option.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/OptionBuilder.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport org.junit.Test;\n\n@SuppressWarnings(\"deprecation\")\npublic class OptionBuilderTest2 {\n\n    @Test\n    public void testLicenseHeaderChange() {\n        // This test is a placeholder to ensure that the license header change does not affect functionality.\n        // Since the license header change is purely a comment change, no functional test is needed.\n        // We include this test to acknowledge the change.\n        assertTrue(true);\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * OptionBuilder allows the user to create Options using descriptive methods.\n * <p>\n * Details on the Builder pattern can be found at\n * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">http://c2.com/cgi-bin/wiki?BuilderPattern</a>.\n * <p>\n * This class is NOT thread safe. See <a href=\"https://issues.apache.org/jira/browse/CLI-209\">CLI-209</a>\n *\n * @since 1.0\n * @deprecated since 1.3, use {@link Option#builder(String)} instead\n */\n@Deprecated\npublic final class OptionBuilder\n{\n    /** long option */\n    private static String longopt;\n\n    /** option description */\n    private static String description;\n\n    /** argument name */\n    private static String argName;\n\n    /** is required? */\n    private static boolean required;\n\n    /** the number of arguments */\n    private static int numberOfArgs = Option.UNINITIALIZED;\n\n    /** option type */\n    private static Class<?> type;\n\n    /** option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** value separator for argument value */\n    private static char valuesep;\n\n    /** option builder instance */\n    private static final OptionBuilder INSTANCE = new OptionBuilder();\n\n    static\n    {\n        // ensure the consistency of the initial values\n        reset();\n    }\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder()\n    {\n        // hide the constructor\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset()\n    {\n        description = null;\n        argName = null;\n        longopt = null;\n        type = String.class;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n        optionalArg = false;\n        valuesep = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(final String newLongopt)\n    {\n        OptionBuilder.longopt = newLongopt;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will require an argument value if\n     * <code>hasArg</code> is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(final boolean hasArg)\n    {\n        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(final String name)\n    {\n        OptionBuilder.argName = name;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired()\n    {\n        OptionBuilder.required = true;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created uses <code>sep</code> as a means to\n     * separate argument values.\n     * <p>\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator('=')\n     *                           .create('D');\n     *\n     * String args = \"-Dkey=value\";\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);  // will be \"key\"\n     * String propertyValue = opt.getValue(1); // will be \"value\"\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(final char sep)\n    {\n        OptionBuilder.valuesep = sep;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created uses '<code>=</code>' as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator()\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator()\n    {\n        OptionBuilder.valuesep = '=';\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will be required if <code>required</code>\n     * is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(final boolean newRequired)\n    {\n        OptionBuilder.required = newRequired;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created can have <code>num</code> argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(final int num)\n    {\n        OptionBuilder.numberOfArgs = num;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n        OptionBuilder.optionalArg = true;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n        OptionBuilder.optionalArg = true;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs - the maximum number of optional arguments\n     * the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(final int numArgs)\n    {\n        OptionBuilder.numberOfArgs = numArgs;\n        OptionBuilder.optionalArg = true;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance\n     * of <code>type</code>.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the\n     * input type is supposed to be a {@link Class} object.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     * @deprecated since 1.3, use {@link #withType(Class)} instead\n     */\n    @Deprecated\n    public static OptionBuilder withType(final Object newType)\n    {\n        return withType((Class<?>) newType);\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance\n     * of <code>type</code>.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     * @since 1.3\n     */\n    public static OptionBuilder withType(final Class<?> newType)\n    {\n        OptionBuilder.type = newType;\n\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(final String newDescription)\n    {\n        OptionBuilder.description = newDescription;\n\n        return INSTANCE;\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(final char opt) throws IllegalArgumentException\n    {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the <code>java.lang.String</code> representation\n     * of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(final String opt) throws IllegalArgumentException\n    {\n        Option option = null;\n        try\n        {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n        }\n        finally\n        {\n            // reset the OptionBuilder properties\n            OptionBuilder.reset();\n        }\n\n        // return the Option instance\n        return option;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/OptionBuilder.java b/src/main/java/org/apache/commons/cli/OptionBuilder.java\nindex 96b9bc8aa..2ae67035f 100644\n--- a/src/main/java/org/apache/commons/cli/OptionBuilder.java\n+++ b/src/main/java/org/apache/commons/cli/OptionBuilder.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/OptionGroup.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport java.util.Properties;\nimport org.junit.Before;\nimport org.junit.Test;\n\n@SuppressWarnings(\"deprecation\")\npublic class OptionGroupTest2 {\n    private Options _options = null;\n    private final Parser parser = new PosixParser();\n\n    @Before\n    public void setUp() {\n        final Option file = new Option(\"f\", \"file\", false, \"file to process\");\n        final Option dir = new Option(\"d\", \"directory\", false, \"directory to process\");\n        final OptionGroup group = new OptionGroup();\n        group.addOption(file);\n        group.addOption(dir);\n        _options = new Options().addOptionGroup(group);\n\n        final Option section = new Option(\"s\", \"section\", false, \"section to process\");\n        final Option chapter = new Option(\"c\", \"chapter\", false, \"chapter to process\");\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(section);\n        group2.addOption(chapter);\n        _options.addOptionGroup(group2);\n\n        final Option importOpt = new Option(null, \"import\", false, \"section to process\");\n        final Option exportOpt = new Option(null, \"export\", false, \"chapter to process\");\n        final OptionGroup group3 = new OptionGroup();\n        group3.addOption(importOpt);\n        group3.addOption(exportOpt);\n        _options.addOptionGroup(group3);\n\n        _options.addOption(\"r\", \"revision\", false, \"revision number\");\n    }\n\n    @Test\n    public void testSingleOptionFromGroup() throws Exception {\n        final String[] args = new String[] { \"-f\" };\n        final CommandLine cl = parser.parse(_options, args);\n        assertTrue(\"Confirm -r is NOT set\", !cl.hasOption(\"r\"));\n        assertTrue(\"Confirm -f is set\", cl.hasOption(\"f\"));\n        assertTrue(\"Confirm -d is NOT set\", !cl.hasOption(\"d\"));\n        assertTrue(\"Confirm -s is NOT set\", !cl.hasOption(\"s\"));\n        assertTrue(\"Confirm -c is NOT set\", !cl.hasOption(\"c\"));\n        assertTrue(\"Confirm no extra args\", cl.getArgList().size() == 0);\n    }\n\n    @Test\n    public void testSingleOption() throws Exception {\n        final String[] args = new String[] { \"-r\" };\n        final CommandLine cl = parser.parse(_options, args);\n        assertTrue(\"Confirm -r is set\", cl.hasOption(\"r\"));\n        assertTrue(\"Confirm -f is NOT set\", !cl.hasOption(\"f\"));\n        assertTrue(\"Confirm -d is NOT set\", !cl.hasOption(\"d\"));\n        assertTrue(\"Confirm -s is NOT set\", !cl.hasOption(\"s\"));\n        assertTrue(\"Confirm -c is NOT set\", !cl.hasOption(\"c\"));\n        assertTrue(\"Confirm no extra args\", cl.getArgList().size() == 0);\n    }\n\n    @Test\n    public void testTwoValidOptions() throws Exception {\n        final String[] args = new String[] { \"-r\", \"-f\" };\n        final CommandLine cl = parser.parse(_options, args);\n        assertTrue(\"Confirm -r is set\", cl.hasOption(\"r\"));\n        assertTrue(\"Confirm -f is set\", cl.hasOption(\"f\"));\n        assertTrue(\"Confirm -d is NOT set\", !cl.hasOption(\"d\"));\n        assertTrue(\"Confirm -s is NOT set\", !cl.hasOption(\"s\"));\n        assertTrue(\"Confirm -c is NOT set\", !cl.hasOption(\"c\"));\n        assertTrue(\"Confirm no extra args\", cl.getArgList().size() == 0);\n    }\n\n    @Test\n    public void testSingleLongOption() throws Exception {\n        final String[] args = new String[] { \"--file\" };\n        final CommandLine cl = parser.parse(_options, args);\n        assertTrue(\"Confirm -r is NOT set\", !cl.hasOption(\"r\"));\n        assertTrue(\"Confirm -f is set\", cl.hasOption(\"f\"));\n        assertTrue(\"Confirm -d is NOT set\", !cl.hasOption(\"d\"));\n        assertTrue(\"Confirm -s is NOT set\", !cl.hasOption(\"s\"));\n        assertTrue(\"Confirm -c is NOT set\", !cl.hasOption(\"c\"));\n        assertTrue(\"Confirm no extra args\", cl.getArgList().size() == 0);\n    }\n\n    @Test\n    public void testTwoValidLongOptions() throws Exception {\n        final String[] args = new String[] { \"--revision\", \"--file\" };\n        final CommandLine cl = parser.parse(_options, args);\n        assertTrue(\"Confirm -r is set\", cl.hasOption(\"r\"));\n        assertTrue(\"Confirm -f is set\", cl.hasOption(\"f\"));\n        assertTrue(\"Confirm -d is NOT set\", !cl.hasOption(\"d\"));\n        assertTrue(\"Confirm -s is NOT set\", !cl.hasOption(\"s\"));\n        assertTrue(\"Confirm -c is NOT set\", !cl.hasOption(\"c\"));\n        assertTrue(\"Confirm no extra args\", cl.getArgList().size() == 0);\n    }\n\n    @Test\n    public void testNoOptionsExtraArgs() throws Exception {\n        final String[] args = new String[] { \"arg1\", \"arg2\" };\n        final CommandLine cl = parser.parse(_options, args);\n        assertTrue(\"Confirm -r is NOT set\", !cl.hasOption(\"r\"));\n        assertTrue(\"Confirm -f is NOT set\", !cl.hasOption(\"f\"));\n        assertTrue(\"Confirm -d is NOT set\", !cl.hasOption(\"d\"));\n        assertTrue(\"Confirm -s is NOT set\", !cl.hasOption(\"s\"));\n        assertTrue(\"Confirm -c is NOT set\", !cl.hasOption(\"c\"));\n        assertTrue(\"Confirm TWO extra args\", cl.getArgList().size() == 2);\n    }\n\n    @Test\n    public void testTwoOptionsFromGroup() throws Exception {\n        final String[] args = new String[] { \"-f\", \"-d\" };\n        try {\n            parser.parse(_options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(\"null option group\", e.getOptionGroup());\n            assertEquals(\"selected option\", \"f\", e.getOptionGroup().getSelected());\n            assertEquals(\"option\", \"d\", e.getOption().getOpt());\n        }\n    }\n\n    @Test\n    public void testTwoLongOptionsFromGroup() throws Exception {\n        final String[] args = new String[] { \"--file\", \"--directory\" };\n        try {\n            parser.parse(_options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(\"null option group\", e.getOptionGroup());\n            assertEquals(\"selected option\", \"f\", e.getOptionGroup().getSelected());\n            assertEquals(\"option\", \"d\", e.getOption().getOpt());\n        }\n    }\n\n    @Test\n    public void testTwoOptionsFromDifferentGroup() throws Exception {\n        final String[] args = new String[] { \"-f\", \"-s\" };\n        final CommandLine cl = parser.parse(_options, args);\n        assertTrue(\"Confirm -r is NOT set\", !cl.hasOption(\"r\"));\n        assertTrue(\"Confirm -f is set\", cl.hasOption(\"f\"));\n        assertTrue(\"Confirm -d is NOT set\", !cl.hasOption(\"d\"));\n        assertTrue(\"Confirm -s is set\", cl.hasOption(\"s\"));\n        assertTrue(\"Confirm -c is NOT set\", !cl.hasOption(\"c\"));\n        assertTrue(\"Confirm NO extra args\", cl.getArgList().size() == 0);\n    }\n\n    @Test\n    public void testTwoOptionsFromGroupWithProperties() throws Exception {\n        final String[] args = new String[] { \"-f\" };\n        final Properties properties = new Properties();\n        properties.put(\"d\", \"true\");\n        final CommandLine cl = parser.parse(_options, args, properties);\n        assertTrue(cl.hasOption(\"f\"));\n        assertTrue(!cl.hasOption(\"d\"));\n    }\n\n    @Test\n    public void testValidLongOnlyOptions() throws Exception {\n        final CommandLine cl1 = parser.parse(_options, new String[] { \"--export\" });\n        assertTrue(\"Confirm --export is set\", cl1.hasOption(\"export\"));\n        final CommandLine cl2 = parser.parse(_options, new String[] { \"--import\" });\n        assertTrue(\"Confirm --import is set\", cl2.hasOption(\"import\"));\n    }\n\n    @Test\n    public void testToString() {\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(null, \"foo\", false, \"Foo\"));\n        group1.addOption(new Option(null, \"bar\", false, \"Bar\"));\n        if (!\"[--bar Bar, --foo Foo]\".equals(group1.toString())) {\n            assertEquals(\"[--foo Foo, --bar Bar]\", group1.toString());\n        }\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"f\", \"foo\", false, \"Foo\"));\n        group2.addOption(new Option(\"b\", \"bar\", false, \"Bar\"));\n        if (!\"[-b Bar, -f Foo]\".equals(group2.toString())) {\n            assertEquals(\"[-f Foo, -b Bar]\", group2.toString());\n        }\n    }\n\n    @Test\n    public void testGetNames() {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.create('a'));\n        group.addOption(OptionBuilder.create('b'));\n        assertNotNull(\"null names\", group.getNames());\n        assertEquals(2, group.getNames().size());\n        assertTrue(group.getNames().contains(\"a\"));\n        assertTrue(group.getNames().contains(\"b\"));\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(final Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a\n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has\n     * already been selected.\n     */\n    public void setSelected(final Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n\n        // if no option has already been selected or the\n        // same option is being reselected then set the\n        // selected member variable\n        if (selected == null || selected.equals(option.getKey()))\n        {\n            selected = option.getKey();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(final boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     *\n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        final StringBuilder buff = new StringBuilder();\n\n        final Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            final Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n\n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n\n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/OptionGroup.java b/src/main/java/org/apache/commons/cli/OptionGroup.java\nindex 9a70a6237..fc00b9d33 100644\n--- a/src/main/java/org/apache/commons/cli/OptionGroup.java\n+++ b/src/main/java/org/apache/commons/cli/OptionGroup.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/OptionValidator.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass OptionValidatorTest {\n\n    @Test\n    void testValidateOptionWithNull() {\n        assertDoesNotThrow(() -> OptionValidator.validateOption(null));\n    }\n\n    @Test\n    void testValidateOptionWithSingleValidCharacter() {\n        assertDoesNotThrow(() -> OptionValidator.validateOption(\"a\"));\n        assertDoesNotThrow(() -> OptionValidator.validateOption(\"?\"));\n        assertDoesNotThrow(() -> OptionValidator.validateOption(\"@\"));\n    }\n\n    @Test\n    void testValidateOptionWithSingleInvalidCharacter() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> OptionValidator.validateOption(\"!\"));\n        assertEquals(\"Illegal option name '!'\", exception.getMessage());\n    }\n\n    @Test\n    void testValidateOptionWithMultipleValidCharacters() {\n        assertDoesNotThrow(() -> OptionValidator.validateOption(\"abc\"));\n        assertDoesNotThrow(() -> OptionValidator.validateOption(\"a1b2c3\"));\n    }\n\n    @Test\n    void testValidateOptionWithMultipleInvalidCharacters() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> OptionValidator.validateOption(\"a!b\"));\n        assertEquals(\"The option 'a!b' contains an illegal character : '!'\", exception.getMessage());\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Validates an Option string.\n *\n * @since 1.1\n */\nfinal class OptionValidator\n{\n    /**\n     * Validates whether <code>opt</code> is a permissible Option\n     * shortOpt.  The rules that specify if the <code>opt</code>\n     * is valid are:\n     *\n     * <ul>\n     *  <li>a single character <code>opt</code> that is either\n     *  ' '(special case), '?', '@' or a letter</li>\n     *  <li>a multi character <code>opt</code> that only contains\n     *  letters.</li>\n     * </ul>\n     * <p>\n     * In case {@code opt} is {@code null} no further validation is performed.\n     *\n     * @param opt The option string to validate, may be null\n     * @throws IllegalArgumentException if the Option is not valid.\n     */\n    static void validateOption(final String opt) throws IllegalArgumentException\n    {\n        // if opt is NULL do not check further\n        if (opt == null)\n        {\n            return;\n        }\n\n        // handle the single character opt\n        if (opt.length() == 1)\n        {\n            final char ch = opt.charAt(0);\n\n            if (!isValidOpt(ch))\n            {\n                throw new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n            }\n        }\n\n        // handle the multi character opt\n        else\n        {\n            for (final char ch : opt.toCharArray())\n            {\n                if (!isValidChar(ch))\n                {\n                    throw new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal \"\n                                                       + \"character : '\" + ch + \"'\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns whether the specified character is a valid Option.\n     *\n     * @param c the option to validate\n     * @return true if <code>c</code> is a letter, '?' or '@', otherwise false.\n     */\n    private static boolean isValidOpt(final char c)\n    {\n        return isValidChar(c) || c == '?' || c == '@';\n    }\n\n    /**\n     * Returns whether the specified character is a valid character.\n     *\n     * @param c the character to validate\n     * @return true if <code>c</code> is a letter.\n     */\n    private static boolean isValidChar(final char c)\n    {\n        return Character.isJavaIdentifierPart(c);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/OptionValidator.java b/src/main/java/org/apache/commons/cli/OptionValidator.java\nindex 6f65d270b..5c29bdc87 100644\n--- a/src/main/java/org/apache/commons/cli/OptionValidator.java\n+++ b/src/main/java/org/apache/commons/cli/OptionValidator.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/Options.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport org.junit.Test;\n\npublic class OptionsTest2 {\n\n    @Test\n    public void testLicenseHeaderFormat() {\n        // This test ensures that the license header format is correct\n        String licenseHeader = \"Licensed to the Apache Software Foundation (ASF) under one or more\"\n                + \" contributor license agreements.  See the NOTICE file distributed with\"\n                + \" this work for additional information regarding copyright ownership.\"\n                + \" The ASF licenses this file to You under the Apache License, Version 2.0\"\n                + \" (the \\\"License\\\"); you may not use this file except in compliance with\"\n                + \" the License.  You may obtain a copy of the License at\"\n                + \" http://www.apache.org/licenses/LICENSE-2.0\"\n                + \" Unless required by applicable law or agreed to in writing, software\"\n                + \" distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\"\n                + \" WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\"\n                + \" See the License for the specific language governing permissions and\"\n                + \" limitations under the License.\";\n\n        assertTrue(licenseHeader.contains(\"Licensed to the Apache Software Foundation (ASF)\"));\n        assertTrue(licenseHeader.contains(\"http://www.apache.org/licenses/LICENSE-2.0\"));\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Main entry-point into the library.\n * <p>\n * Options represents a collection of {@link Option} objects, which\n * describe the possible options for a command-line.\n * <p>\n * It may flexibly parse long and short options, with or without\n * values.  Additionally, it may parse only a portion of a commandline,\n * allowing for flexible multi-stage parsing.\n *\n * @see org.apache.commons.cli.CommandLine\n */\npublic class Options implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** a map of the options with the character key */\n    private final Map<String, Option> shortOpts = new LinkedHashMap<>();\n\n    /** a map of the options with the long key */\n    private final Map<String, Option> longOpts = new LinkedHashMap<>();\n\n    /** a map of the required options */\n    // N.B. This can contain either a String (addOption) or an OptionGroup (addOptionGroup)\n    // TODO this seems wrong\n    private final List<Object> requiredOpts = new ArrayList<>();\n\n    /** a map of the option groups */\n    private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<>();\n\n    /**\n     * Add the specified option group.\n     *\n     * @param group the OptionGroup that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOptionGroup(final OptionGroup group)\n    {\n        if (group.isRequired())\n        {\n            requiredOpts.add(group);\n        }\n\n        for (final Option option : group.getOptions())\n        {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n\n            optionGroups.put(option.getKey(), group);\n        }\n\n        return this;\n    }\n\n    /**\n     * Lists the OptionGroups that are members of this Options instance.\n     *\n     * @return a Collection of OptionGroup instances.\n     */\n    Collection<OptionGroup> getOptionGroups()\n    {\n        return new HashSet<>(optionGroups.values());\n    }\n\n    /**\n     * Add an option that only contains a short name.\n     *\n     * <p>\n     * The option does not take an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.3\n     */\n    public Options addOption(final String opt, final String description)\n    {\n        addOption(opt, null, false, description);\n        return this;\n    }\n\n    /**\n     * Add an option that only contains a short-name.\n     *\n     * <p>\n     * It may be specified as requiring an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(final String opt, final boolean hasArg, final String description)\n    {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }\n\n    /**\n     * Add an option that contains a short-name and a long-name.\n     *\n     * <p>\n     * It may be specified as requiring an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(final String opt, final String longOpt, final boolean hasArg, final String description)\n    {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }\n\n    /**\n     * Add an option that contains a short-name and a long-name.\n     *\n     * <p>\n     * The added option is set as required. It may be specified as requiring an argument. This method is a shortcut for:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * Options option = new Option(opt, longOpt, hasArg, description);\n     * option.setRequired(true);\n     * options.add(option);\n     * </code>\n     * </pre>\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.4\n     */\n    public Options addRequiredOption(final String opt, final String longOpt, final boolean hasArg, final String description)\n    {\n        final Option option = new Option(opt, longOpt, hasArg, description);\n        option.setRequired(true);\n        addOption(option);\n        return this;\n    }\n\n    /**\n     * Adds an option instance\n     *\n     * @param opt the option that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOption(final Option opt)\n    {\n        final String key = opt.getKey();\n\n        // add it to the long option list\n        if (opt.hasLongOpt())\n        {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n\n        // if the option is required add it to the required list\n        if (opt.isRequired())\n        {\n            if (requiredOpts.contains(key))\n            {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n\n        shortOpts.put(key, opt);\n\n        return this;\n    }\n\n    /**\n     * Retrieve a read-only list of options in this set\n     *\n     * @return read-only Collection of {@link Option} objects in this descriptor\n     */\n    public Collection<Option> getOptions()\n    {\n        return Collections.unmodifiableCollection(helpOptions());\n    }\n\n    /**\n     * Returns the Options for use by the HelpFormatter.\n     *\n     * @return the List of Options\n     */\n    List<Option> helpOptions()\n    {\n        return new ArrayList<>(shortOpts.values());\n    }\n\n    /**\n     * Returns the required options.\n     *\n     * @return read-only List of required options\n     */\n    public List getRequiredOptions()\n    {\n        return Collections.unmodifiableList(requiredOpts);\n    }\n\n    /**\n     * Retrieve the {@link Option} matching the long or short name specified.\n     *\n     * <p>\n     * The leading hyphens in the name are ignored (up to 2).\n     * </p>\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return the option represented by opt\n     */\n    public Option getOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        if (shortOpts.containsKey(opt))\n        {\n            return shortOpts.get(opt);\n        }\n\n        return longOpts.get(opt);\n    }\n\n    /**\n     * Returns the options with a long name starting with the name specified.\n     *\n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        final List<String> matchingOpts = new ArrayList<>();\n\n        // for a perfect match return the single option only\n        if (longOpts.containsKey(opt))\n        {\n            return Collections.singletonList(opt);\n        }\n\n        for (final String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n\n        return matchingOpts;\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     */\n    public boolean hasOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasLongOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasShortOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns the OptionGroup the <code>opt</code> belongs to.\n     *\n     * @param opt the option whose OptionGroup is being queried.\n     * @return the OptionGroup if <code>opt</code> is part of an OptionGroup, otherwise return null\n     */\n    public OptionGroup getOptionGroup(final Option opt)\n    {\n        return optionGroups.get(opt.getKey());\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString()\n    {\n        final StringBuilder buf = new StringBuilder();\n\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/Options.java b/src/main/java/org/apache/commons/cli/Options.java\nindex 1661f46d6..65f5343c0 100644\n--- a/src/main/java/org/apache/commons/cli/Options.java\n+++ b/src/main/java/org/apache/commons/cli/Options.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/ParseException.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ParseExceptionTest {\n\n    @Test\n    public void testParseExceptionMessage() {\n        String message = \"Test message\";\n        ParseException exception = new ParseException(message);\n        assertEquals(message, exception.getMessage());\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Base for Exceptions thrown during parsing of a command-line.\n */\npublic class ParseException extends Exception\n{\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 9112808380089253192L;\n\n    /**\n     * Construct a new <code>ParseException</code>\n     * with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public ParseException(final String message)\n    {\n        super(message);\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/ParseException.java b/src/main/java/org/apache/commons/cli/ParseException.java\nindex bb28210f3..498801fa1 100644\n--- a/src/main/java/org/apache/commons/cli/ParseException.java\n+++ b/src/main/java/org/apache/commons/cli/ParseException.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/Parser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class ParserTest {\n\n    @Test\n    public void testParseWithNullArguments() throws ParseException {\n        Parser parser = new ConcreteParser();\n        Options options = new Options();\n        CommandLine cmd = parser.parse(options, null);\n        assertNotNull(cmd);\n        assertEquals(0, cmd.getArgs().length);\n    }\n\n    @Test\n    public void testParseWithEmptyArguments() throws ParseException {\n        Parser parser = new ConcreteParser();\n        Options options = new Options();\n        CommandLine cmd = parser.parse(options, new String[0]);\n        assertNotNull(cmd);\n        assertEquals(0, cmd.getArgs().length);\n    }\n\n    @Test\n    public void testParseWithStopAtNonOption() throws ParseException {\n        Parser parser = new ConcreteParser();\n        Options options = new Options();\n        options.addOption(\"a\", false, \"Option a\");\n        String[] args = {\"-a\", \"non-option\"};\n        CommandLine cmd = parser.parse(options, args, true);\n        assertNotNull(cmd);\n        assertTrue(cmd.hasOption(\"a\"));\n        assertEquals(1, cmd.getArgs().length);\n        assertEquals(\"non-option\", cmd.getArgs()[0]);\n    }\n\n    @Test\n    public void testProcessPropertiesWithNullProperties() throws ParseException {\n        Parser parser = new ConcreteParser();\n        Options options = new Options();\n        parser.setOptions(options);\n        parser.processProperties(null);\n        // No exception should be thrown\n    }\n\n    @Test(expected = UnrecognizedOptionException.class)\n    public void testProcessPropertiesWithUnrecognizedOption() throws ParseException {\n        Parser parser = new ConcreteParser();\n        Options options = new Options();\n        parser.setOptions(options);\n        Properties properties = new Properties();\n        properties.setProperty(\"unrecognized\", \"value\");\n        parser.processProperties(properties);\n    }\n\n    @Test\n    public void testProcessPropertiesWithRecognizedOption() throws ParseException {\n        Parser parser = new ConcreteParser();\n        Options options = new Options();\n        Option option = new Option(\"a\", true, \"Option a\");\n        options.addOption(option);\n        parser.setOptions(options);\n        Properties properties = new Properties();\n        properties.setProperty(\"a\", \"value\");\n        parser.processProperties(properties);\n        assertTrue(parser.cmd.hasOption(\"a\"));\n        assertEquals(\"value\", parser.cmd.getOptionValue(\"a\"));\n    }\n\n    @Test(expected = MissingOptionException.class)\n    public void testCheckRequiredOptions() throws ParseException {\n        Parser parser = new ConcreteParser();\n        Options options = new Options();\n        Option option = new Option(\"a\", true, \"Option a\");\n        option.setRequired(true);\n        options.addOption(option);\n        parser.setOptions(options);\n        parser.checkRequiredOptions();\n    }\n\n    // Concrete implementation of the abstract Parser class for testing purposes\n    private static class ConcreteParser extends Parser {\n        @Override\n        protected String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException {\n            return arguments;\n        }\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <code>Parser</code> creates {@link CommandLine}s.\n *\n * @deprecated since 1.3, the two-pass parsing with the flatten method is not enough flexible to handle complex cases\n */\n@Deprecated\npublic abstract class Parser implements CommandLineParser\n{\n    /** commandline instance */\n    protected CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    protected void setOptions(final Options options)\n    {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }\n\n    protected Options getOptions()\n    {\n        return options;\n    }\n\n    protected List getRequiredOptions()\n    {\n        return requiredOptions;\n    }\n\n    /**\n     * Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop\n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line tokens.\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption)\n            throws ParseException;\n\n    /**\n     * Parses the specified <code>arguments</code> based\n     * on the specified {@link Options}.\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line tokens.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parses the specified <code>arguments</code>\n     * based on the specified {@link Options}.\n     *\n     * @param options         the <code>Options</code>\n     * @param arguments       the <code>arguments</code>\n     * @param stopAtNonOption if <code>true</code> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the\n     *     {@link CommandLine}s args list. If <code>false</code> an unrecognized\n     *     argument triggers a ParseException.\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if <code>true</code> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the\n     *     {@link CommandLine}s args list. If <code>false</code> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, String[] arguments, final Properties properties, final boolean stopAtNonOption)\n            throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (final Option opt : options.helpOptions())\n        {\n            opt.clearValues();\n        }\n\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups())\n        {\n            group.setSelected(null);\n        }\n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        final List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\n        final ListIterator<String> iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            final String t = iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    final String str = iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     * @throws ParseException if there are any problems encountered\n     *                        while processing the properties.\n     */\n    protected void processProperties(final Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            final String option = e.nextElement().toString();\n\n            final Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties instance\n                final String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (final RuntimeException exp) //NOPMD\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(final Option opt, final ListIterator<String> iter) throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            final String str = iter.next();\n\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n            }\n            catch (final RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if (opt.getValues() == null && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    /**\n     * Process the Option specified by <code>arg</code> using the values\n     * retrieved from the specified iterator <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not represent an Option\n     */\n    protected void processOption(final String arg, final ListIterator<String> iter) throws ParseException\n    {\n        final boolean hasOption = getOptions().hasOption(arg);\n\n        // if there is no option throw an UnrecognizedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n\n        // get the option represented by arg\n        final Option opt = (Option) getOptions().getOption(arg).clone();\n\n        // update the required options and groups\n        updateRequiredOptions(opt);\n\n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param opt\n     */\n    private void updateRequiredOptions(final Option opt) throws ParseException\n    {\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            final OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/Parser.java b/src/main/java/org/apache/commons/cli/Parser.java\nindex 4bc9e05f9..f6278b470 100644\n--- a/src/main/java/org/apache/commons/cli/Parser.java\n+++ b/src/main/java/org/apache/commons/cli/Parser.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/PatternOptionBuilder.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.net.URL;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Vector;\nimport org.junit.Test;\n\n@SuppressWarnings(\"deprecation\")\npublic class PatternOptionBuilderTest2 {\n\n    @Test\n    public void testLicenseHeaderChange() throws Exception {\n        // This test is a placeholder to ensure that the license header change does not affect functionality.\n        final Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/m*z#\");\n        final String[] args = new String[] {\"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\", \"https://example.com\"};\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, args);\n\n        assertEquals(\"flag a\", \"foo\", line.getOptionValue(\"a\"));\n        assertEquals(\"string flag a\", \"foo\", line.getOptionObject(\"a\"));\n        assertEquals(\"object flag b\", new Vector<>(), line.getOptionObject(\"b\"));\n        assertTrue(\"boolean true flag c\", line.hasOption(\"c\"));\n        assertFalse(\"boolean false flag d\", line.hasOption(\"d\"));\n        assertEquals(\"file flag e\", new File(\"build.xml\"), line.getOptionObject(\"e\"));\n        assertEquals(\"class flag f\", Calendar.class, line.getOptionObject(\"f\"));\n        assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject(\"n\"));\n        assertEquals(\"url flag t\", new URL(\"https://example.com\"), line.getOptionObject(\"t\"));\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.net.URL;\nimport java.util.Date;\n\n/**\n * <p>Allows Options to be created from a single String.\n * The pattern contains various single character flags and via\n * an optional punctuation character, their expected type.\n * </p>\n *\n * <table border=\"1\">\n *   <caption>Overview of PatternOptionBuilder patterns</caption>\n *   <tr><td>a</td><td>-a flag</td></tr>\n *   <tr><td>b@</td><td>-b [classname]</td></tr>\n *   <tr><td>c&gt;</td><td>-c [filename]</td></tr>\n *   <tr><td>d+</td><td>-d [classname] (creates object via empty constructor)</td></tr>\n *   <tr><td>e%</td><td>-e [number] (creates Double/Long instance depending on existing of a '.')</td></tr>\n *   <tr><td>f/</td><td>-f [url]</td></tr>\n *   <tr><td>g:</td><td>-g [string]</td></tr>\n * </table>\n *\n * <p>\n * For example, the following allows command line flags of '-v -p string-value -f /dir/file'.\n * The exclamation mark precede a mandatory option.\n * </p>\n *\n * <pre>\n *     Options options = PatternOptionBuilder.parsePattern(\"vp:!f/\");\n * </pre>\n *\n * <p>\n * TODO: These need to break out to OptionType and also to be pluggable.\n * </p>\n */\npublic class PatternOptionBuilder\n{\n    /** String class */\n    public static final Class<String> STRING_VALUE = String.class;\n\n    /** Object class */\n    public static final Class<Object> OBJECT_VALUE = Object.class;\n\n    /** Number class */\n    public static final Class<Number> NUMBER_VALUE = Number.class;\n\n    /** Date class */\n    public static final Class<Date> DATE_VALUE = Date.class;\n\n    /** Class class */\n    public static final Class<?> CLASS_VALUE = Class.class;\n\n    /// can we do this one??\n    // is meant to check that the file exists, else it errors.\n    // ie) it's for reading not writing.\n\n    /** FileInputStream class */\n    public static final Class<FileInputStream> EXISTING_FILE_VALUE = FileInputStream.class;\n\n    /** File class */\n    public static final Class<File> FILE_VALUE = File.class;\n\n    /** File array class */\n    public static final Class<File[]> FILES_VALUE = File[].class;\n\n    /** URL class */\n    public static final Class<URL> URL_VALUE = URL.class;\n\n    /**\n     * Retrieve the class that <code>ch</code> represents.\n     *\n     * @param ch the specified character\n     * @return The class that <code>ch</code> represents\n     */\n    public static Object getValueClass(final char ch)\n    {\n        switch (ch)\n        {\n            case '@':\n                return PatternOptionBuilder.OBJECT_VALUE;\n            case ':':\n                return PatternOptionBuilder.STRING_VALUE;\n            case '%':\n                return PatternOptionBuilder.NUMBER_VALUE;\n            case '+':\n                return PatternOptionBuilder.CLASS_VALUE;\n            case '#':\n                return PatternOptionBuilder.DATE_VALUE;\n            case '<':\n                return PatternOptionBuilder.EXISTING_FILE_VALUE;\n            case '>':\n                return PatternOptionBuilder.FILE_VALUE;\n            case '*':\n                return PatternOptionBuilder.FILES_VALUE;\n            case '/':\n                return PatternOptionBuilder.URL_VALUE;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns whether <code>ch</code> is a value code, i.e.\n     * whether it represents a class in a pattern.\n     *\n     * @param ch the specified character\n     * @return true if <code>ch</code> is a value code, otherwise false.\n     */\n    public static boolean isValueCode(final char ch)\n    {\n        return ch == '@'\n                || ch == ':'\n                || ch == '%'\n                || ch == '+'\n                || ch == '#'\n                || ch == '<'\n                || ch == '>'\n                || ch == '*'\n                || ch == '/'\n                || ch == '!';\n    }\n\n    /**\n     * Returns the {@link Options} instance represented by <code>pattern</code>.\n     *\n     * @param pattern the pattern string\n     * @return The {@link Options} instance\n     */\n    public static Options parsePattern(final String pattern)\n    {\n        char opt = ' ';\n        boolean required = false;\n        Class<?> type = null;\n\n        final Options options = new Options();\n\n        for (int i = 0; i < pattern.length(); i++)\n        {\n            final char ch = pattern.charAt(i);\n\n            // a value code comes after an option and specifies\n            // details about it\n            if (!isValueCode(ch))\n            {\n                if (opt != ' ')\n                {\n                    final Option option = Option.builder(String.valueOf(opt))\n                        .hasArg(type != null)\n                        .required(required)\n                        .type(type)\n                        .build();\n\n                    // we have a previous one to deal with\n                    options.addOption(option);\n                    required = false;\n                    type = null;\n                    opt = ' ';\n                }\n\n                opt = ch;\n            }\n            else if (ch == '!')\n            {\n                required = true;\n            }\n            else\n            {\n                type = (Class<?>) getValueClass(ch);\n            }\n        }\n\n        if (opt != ' ')\n        {\n            final Option option = Option.builder(String.valueOf(opt))\n                .hasArg(type != null)\n                .required(required)\n                .type(type)\n                .build();\n\n            // we have a final one to deal with\n            options.addOption(option);\n        }\n\n        return options;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/PatternOptionBuilder.java b/src/main/java/org/apache/commons/cli/PatternOptionBuilder.java\nindex bd824ef5a..37421bab2 100644\n--- a/src/main/java/org/apache/commons/cli/PatternOptionBuilder.java\n+++ b/src/main/java/org/apache/commons/cli/PatternOptionBuilder.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/PosixParser.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class PosixParserTest2 extends ParserTestCase {\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    @Before\n    public void setUp() {\n        super.setUp();\n        parser = new PosixParser();\n    }\n\n    @Test\n    public void testLicenseHeaderChange() {\n        // This test ensures that the license header change does not affect functionality.\n        // Since the license header change is a non-functional change, we can run a basic functionality test.\n        try {\n            String[] args = {\"-a\", \"value\"};\n            Options options = new Options();\n            options.addOption(\"a\", true, \"option a\");\n            CommandLine cmd = parser.parse(options, args);\n            assertTrue(cmd.hasOption(\"a\"));\n            assertEquals(\"value\", cmd.getOptionValue(\"a\"));\n        } catch (ParseException e) {\n            fail(\"Parsing failed: \" + e.getMessage());\n        }\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the\n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @deprecated since 1.3, use the {@link DefaultParser} instead\n */\n@Deprecated\npublic class PosixParser extends Parser\n{\n    /** holder for flattened tokens */\n    private final List<String> tokens = new ArrayList<>();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries and set <code>eatTheRest</code>\n     * to false.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.</p>\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of\n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see\n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled\n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        final Iterator<String> iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            final String token = iter.next();\n\n            // single or double hyphen\n            if (\"-\".equals(token) || \"--\".equals(token))\n            {\n                tokens.add(token);\n            }\n\n            // handle long option --foo or --foo=bar\n            else if (token.startsWith(\"--\"))\n            {\n                final int pos = token.indexOf('=');\n                final String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                final List<String> matchingOpts = options.getMatchingOptions(opt);\n\n                if (matchingOpts.isEmpty())\n                {\n                    processNonOptionToken(token, stopAtNonOption);\n                }\n                else if (matchingOpts.size() > 1)\n                {\n                    throw new AmbiguousOptionException(opt, matchingOpts);\n                }\n                else\n                {\n                    currentOption = options.getOption(matchingOpts.get(0));\n\n                    tokens.add(\"--\" + currentOption.getLongOpt());\n                    if (pos != -1)\n                    {\n                        tokens.add(token.substring(pos + 1));\n                    }\n                }\n            }\n\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2 || options.hasOption(token))\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (!options.getMatchingOptions(token).isEmpty())\n                {\n                    final List<String> matchingOpts = options.getMatchingOptions(token);\n                    if (matchingOpts.size() > 1)\n                    {\n                        throw new AmbiguousOptionException(token, matchingOpts);\n                    }\n                    final Option opt = options.getOption(matchingOpts.get(0));\n                    processOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else\n            {\n                processNonOptionToken(token, stopAtNonOption);\n            }\n\n            gobble(iter);\n        }\n\n        return tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(final Iterator<String> iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * Add the special token \"<b>--</b>\" and the current <code>value</code>\n     * to the processed tokens list. Then add all the remaining\n     * <code>argument</code> values to the processed tokens list.\n     *\n     * @param value The current token\n     */\n    private void processNonOptionToken(final String value, final boolean stopAtNonOption)\n    {\n        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg()))\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n        }\n\n        tokens.add(value);\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * add the token to the processed list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then add the remaining tokens to the processed tokens list\n     * directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(final String token, final boolean stopAtNonOption)\n    {\n        if (stopAtNonOption && !options.hasOption(token))\n        {\n            eatTheRest = true;\n        }\n\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n        }\n\n        tokens.add(token);\n    }\n\n    /**\n     * Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     *\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>for each remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there\n     *  are remaining characters in the token then add the remaining\n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also\n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(final String token, final boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            final String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && token.length() != i + 1)\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                processNonOptionToken(token.substring(i), true);\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/PosixParser.java b/src/main/java/org/apache/commons/cli/PosixParser.java\nindex 59e0b8e0e..98b93bf57 100644\n--- a/src/main/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/main/java/org/apache/commons/cli/PosixParser.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/TypeHandler.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Test;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.net.URL;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\npublic class TypeHandlerTest2 {\n\n    @Test\n    public void testCreateValueString() throws Exception {\n        assertEquals(\"String\", TypeHandler.createValue(\"String\", PatternOptionBuilder.STRING_VALUE));\n    }\n\n    @Test(expected = ParseException.class)\n    public void testCreateValueObject_unknownClass() throws Exception {\n        TypeHandler.createValue(\"unknown\", PatternOptionBuilder.OBJECT_VALUE);\n    }\n\n    @Test(expected = ParseException.class)\n    public void testCreateValueObject_notInstantiableClass() throws Exception {\n        TypeHandler.createValue(NotInstantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE);\n    }\n\n    @Test\n    public void testCreateValueObject_InstantiableClass() throws Exception {\n        final Object result = TypeHandler.createValue(Instantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE);\n        assertTrue(result instanceof Instantiable);\n    }\n\n    @Test(expected = ParseException.class)\n    public void testCreateValueNumber_noNumber() throws Exception {\n        TypeHandler.createValue(\"not a number\", PatternOptionBuilder.NUMBER_VALUE);\n    }\n\n    @Test\n    public void testCreateValueNumber_Double() throws Exception {\n        assertEquals(1.5d, TypeHandler.createValue(\"1.5\", PatternOptionBuilder.NUMBER_VALUE));\n    }\n\n    @Test\n    public void testCreateValueNumber_Long() throws Exception {\n        assertEquals(Long.valueOf(15), TypeHandler.createValue(\"15\", PatternOptionBuilder.NUMBER_VALUE));\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void testCreateValueDate() throws Exception {\n        TypeHandler.createValue(\"what ever\", PatternOptionBuilder.DATE_VALUE);\n    }\n\n    @Test(expected = ParseException.class)\n    public void testCreateValueClass_notFound() throws Exception {\n        TypeHandler.createValue(\"what ever\", PatternOptionBuilder.CLASS_VALUE);\n    }\n\n    @Test\n    public void testCreateValueClass() throws Exception {\n        final Object clazz = TypeHandler.createValue(Instantiable.class.getName(), PatternOptionBuilder.CLASS_VALUE);\n        assertEquals(Instantiable.class, clazz);\n    }\n\n    @Test\n    public void testCreateValueFile() throws Exception {\n        final File result = TypeHandler.createValue(\"some-file.txt\", PatternOptionBuilder.FILE_VALUE);\n        assertEquals(\"some-file.txt\", result.getName());\n    }\n\n    @Test\n    public void testCreateValueExistingFile() throws Exception {\n        final FileInputStream result = TypeHandler.createValue(\"src/test/resources/org/apache/commons/cli/existing-readable.file\", PatternOptionBuilder.EXISTING_FILE_VALUE);\n        assertNotNull(result);\n    }\n\n    @Test(expected = ParseException.class)\n    public void testCreateValueExistingFile_nonExistingFile() throws Exception {\n        TypeHandler.createValue(\"non-existing.file\", PatternOptionBuilder.EXISTING_FILE_VALUE);\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void testCreateValueFiles() throws Exception {\n        TypeHandler.createValue(\"some.files\", PatternOptionBuilder.FILES_VALUE);\n    }\n\n    @Test\n    public void testCreateValueURL() throws Exception {\n        final String urlString = \"https://example.com\";\n        final URL result = TypeHandler.createValue(urlString, PatternOptionBuilder.URL_VALUE);\n        assertEquals(urlString, result.toString());\n    }\n\n    @Test(expected = ParseException.class)\n    public void testCreateValueURL_malformed() throws Exception {\n        TypeHandler.createValue(\"malformed-url\", PatternOptionBuilder.URL_VALUE);\n    }\n\n    @Test(expected = ParseException.class)\n    public void testCreateValueInteger_failure() throws Exception {\n        TypeHandler.createValue(\"just-a-string\", Integer.class);\n    }\n\n    public static class Instantiable {\n    }\n\n    public static class NotInstantiable {\n        private NotInstantiable() {}\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport java.util.Date;\n\n/**\n * This is a temporary implementation. TypeHandler will handle the\n * pluggableness of OptionTypes and it will direct all of these types\n * of conversion functionalities to ConvertUtils component in Commons\n * already. BeanUtils I think.\n */\npublic class TypeHandler\n{\n    /**\n     * Returns the <code>Object</code> of type <code>obj</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param obj the type of argument\n     * @return The instance of <code>obj</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given object type failed\n     */\n    public static Object createValue(final String str, final Object obj) throws ParseException\n    {\n        return createValue(str, (Class<?>) obj);\n    }\n\n    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the class representing the type of argument\n     * @param <T> type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return (T) str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n            throw new ParseException(\"Unable to handle the class: \" + clazz);\n        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n\n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n    /**\n     * Create a number from a String. If a . is present, it creates a\n     * Double, otherwise a Long.\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>\n     * @throws ParseException if <code>str</code> is not a number\n     */\n    public static Number createNumber(final String str) throws ParseException\n    {\n        try\n        {\n            if (str.indexOf('.') != -1)\n            {\n                return Double.valueOf(str);\n            }\n            return Long.valueOf(str);\n        }\n        catch (final NumberFormatException e)\n        {\n            throw new ParseException(e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the class whose name is <code>classname</code>.\n     *\n     * @param classname the class name\n     * @return The class if it is found\n     * @throws ParseException if the class could not be found\n     */\n    public static Class<?> createClass(final String classname) throws ParseException\n    {\n        try\n        {\n            return Class.forName(classname);\n        }\n        catch (final ClassNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n    }\n\n    /**\n     * Returns the date represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the date string\n     * @return The date if <code>str</code> is a valid date string,\n     * otherwise return null.\n     * @throws UnsupportedOperationException always\n     */\n    public static Date createDate(final String str)\n    {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    /**\n     * Returns the URL represented by <code>str</code>.\n     *\n     * @param str the URL string\n     * @return The URL in <code>str</code> is well-formed\n     * @throws ParseException if the URL in <code>str</code> is not well-formed\n     */\n    public static URL createURL(final String str) throws ParseException\n    {\n        try\n        {\n            return new URL(str);\n        }\n        catch (final MalformedURLException e)\n        {\n            throw new ParseException(\"Unable to parse the URL: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File represented by <code>str</code>.\n     *\n     * @param str the File location\n     * @return The file represented by <code>str</code>.\n     */\n    public static File createFile(final String str)\n    {\n        return new File(str);\n    }\n\n    /**\n     * Returns the opened FileInputStream represented by <code>str</code>.\n     *\n     * @param str the file location\n     * @return The file input stream represented by <code>str</code>.\n     * @throws ParseException if the file is not exist or not readable\n     */\n    public static FileInputStream openFile(final String str) throws ParseException\n    {\n        try\n        {\n            return new FileInputStream(str);\n        }\n        catch (final FileNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find file: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File[] represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the paths to the files\n     * @return The File[] represented by <code>str</code>.\n     * @throws UnsupportedOperationException always\n     */\n    public static File[] createFiles(final String str)\n    {\n        // to implement/port:\n        //        return FileW.findFiles(str);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/TypeHandler.java b/src/main/java/org/apache/commons/cli/TypeHandler.java\nindex dc77552ea..2c2c713e4 100644\n--- a/src/main/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/main/java/org/apache/commons/cli/TypeHandler.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n@@ -114,7 +114,7 @@ else if (PatternOptionBuilder.URL_VALUE == clazz)\n       */\n     public static Object createObject(final String classname) throws ParseException\n     {\n-        Class<?> cl;\n+        final Class<?> cl;\n \n         try\n         {\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class UnrecognizedOptionExceptionTest {\n\n    @Test\n    public void testConstructorWithMessage() {\n        String message = \"Unrecognized option\";\n        UnrecognizedOptionException exception = new UnrecognizedOptionException(message);\n        assertEquals(message, exception.getMessage());\n        assertNull(exception.getOption());\n    }\n\n    @Test\n    public void testConstructorWithMessageAndOption() {\n        String message = \"Unrecognized option\";\n        String option = \"--unknown\";\n        UnrecognizedOptionException exception = new UnrecognizedOptionException(message, option);\n        assertEquals(message, exception.getMessage());\n        assertEquals(option, exception.getOption());\n    }\n\n    @Test\n    public void testGetOption() {\n        String option = \"--unknown\";\n        UnrecognizedOptionException exception = new UnrecognizedOptionException(\"Unrecognized option\", option);\n        assertEquals(option, exception.getOption());\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Exception thrown during parsing signalling an unrecognized\n * option was seen.\n */\npublic class UnrecognizedOptionException extends ParseException\n{\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = -252504690284625623L;\n\n    /** The  unrecognized option */\n    private String option;\n\n    /**\n     * Construct a new <code>UnrecognizedArgumentException</code>\n     * with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public UnrecognizedOptionException(final String message)\n    {\n        super(message);\n    }\n\n    /**\n     * Construct a new <code>UnrecognizedArgumentException</code>\n     * with the specified option and detail message.\n     *\n     * @param message the detail message\n     * @param option  the unrecognized option\n     * @since 1.2\n     */\n    public UnrecognizedOptionException(final String message, final String option)\n    {\n        this(message);\n        this.option = option;\n    }\n\n    /**\n     * Returns the unrecognized option.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public String getOption()\n    {\n        return option;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java b/src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java\nindex 9a2b18deb..33515e44c 100644\n--- a/src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java\n+++ b/src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/main/java/org/apache/commons/cli/Util.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport org.junit.Test;\n\npublic class UtilTest2 {\n    // No new functionality or modifications were made to the methods in the diff file.\n    // The diff file only contains changes to the comments (license header).\n    // Therefore, no new tests are required for the existing methods.\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Contains useful helper methods for classes within this package.\n */\nfinal class Util\n{\n    /**\n     * Remove the hyphens from the beginning of <code>str</code> and\n     * return the new String.\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(final String str)\n    {\n        if (str == null)\n        {\n            return null;\n        }\n        if (str.startsWith(\"--\"))\n        {\n            return str.substring(2, str.length());\n        }\n        else if (str.startsWith(\"-\"))\n        {\n            return str.substring(1, str.length());\n        }\n\n        return str;\n    }\n\n    /**\n     * Remove the leading and trailing quotes from <code>str</code>.\n     * E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes\n     * should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(String str)\n    {\n        final int length = str.length();\n        if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\n        {\n            str = str.substring(1, length - 1);\n        }\n\n        return str;\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/Util.java b/src/main/java/org/apache/commons/cli/Util.java\nindex 48ab718be..18cae9d56 100644\n--- a/src/main/java/org/apache/commons/cli/Util.java\n+++ b/src/main/java/org/apache/commons/cli/Util.java\n@@ -1,18 +1,18 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+/*\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n  */\n \n package org.apache.commons.cli;\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/ApplicationTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/ArgumentIsOptionTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/BasicParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/CommandLineTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/DefaultParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/DisablePartialMatchingTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/GnuParserTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/HelpFormatterTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  },
  {
    "pr_number": 55,
    "title": "Option Javadocs grammar nits",
    "state": "closed",
    "created_at": "2020-11-30T13:32:03Z",
    "merge_commit_sha": "ef1309b0975a102abcb1d7e351b1ec2438173d2c",
    "base_sha": "e5fb78e2fa5e8d839fb85c337af9ec28b9427b59",
    "head_sha": "d35b8d9d8c56c0320a532048e2285500f94edfd9",
    "user_login": "elharo",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/cli/Option.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertTrue;\nimport org.junit.Test;\n\npublic class OptionTest2 {\n\n    @Test\n    public void testRequiredFlagCannotBeChanged() {\n        // Create an Option instance\n        Option option = Option.builder(\"a\").required(true).build();\n        assertTrue(option.isRequired());\n\n        // Attempt to change the required flag\n        option.setRequired(false);\n        assertTrue(option.isRequired()); // The required flag should remain true\n\n        // Create another Option instance with required flag set to false\n        Option option2 = Option.builder(\"b\").required(false).build();\n        assertFalse(option2.isRequired());\n\n        // Attempt to change the required flag\n        option2.setRequired(true);\n        assertFalse(option2.isRequired()); // The required flag should remain false\n    }\n}",
        "file_content": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Describes a single command-line option.  It maintains\n * information regarding the short-name of the option, the long-name,\n * if any exists, a flag indicating if an argument is required for\n * this option, and a self-documenting description of the option.\n * <p>\n * An Option is not created independently, but is created through\n * an instance of {@link Options}. An Option is required to have\n * at least a short or a long-name.\n * <p>\n * <b>Note:</b> once an {@link Option} has been added to an instance\n * of {@link Options}, it's required flag may not be changed anymore.\n *\n * @see org.apache.commons.cli.Options\n * @see org.apache.commons.cli.CommandLine\n */\npublic class Option implements Cloneable, Serializable\n{\n    /** constant that specifies the number of argument values has not been specified */\n    public static final int UNINITIALIZED = -1;\n\n    /** constant that specifies the number of argument values is infinite */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** the name of the option */\n    private final String opt;\n\n    /** the long representation of the option */\n    private String longOpt;\n\n    /** the name of the argument for this option */\n    private String argName;\n\n    /** description of the option */\n    private String description;\n\n    /** specifies whether this option is required to be present */\n    private boolean required;\n\n    /** specifies whether the argument value of this Option is optional */\n    private boolean optionalArg;\n\n    /** the number of argument values this option can have */\n    private int numberOfArgs = UNINITIALIZED;\n\n    /** the type of this Option */\n    private Class<?> type = String.class;\n\n    /** the list of argument values **/\n    private List<String> values = new ArrayList<>();\n\n    /** the character that is the value separator */\n    private char valuesep;\n\n    /**\n     * Private constructor used by the nested Builder class.\n     *\n     * @param builder builder used to create this option\n     */\n    private Option(final Builder builder)\n    {\n        this.argName = builder.argName;\n        this.description = builder.description;\n        this.longOpt = builder.longOpt;\n        this.numberOfArgs = builder.numberOfArgs;\n        this.opt = builder.opt;\n        this.optionalArg = builder.optionalArg;\n        this.required = builder.required;\n        this.type = builder.type;\n        this.valuesep = builder.valuesep;\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     * The option does not take an argument.\n     *\n     * @param opt short representation of the option\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(final String opt, final String description) throws IllegalArgumentException\n    {\n        this(opt, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException\n    {\n        this(opt, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param longOpt the long representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(final String opt, final String longOpt, final boolean hasArg, final String description)\n           throws IllegalArgumentException\n    {\n        // ensure that the option is valid\n        OptionValidator.validateOption(opt);\n\n        this.opt = opt;\n        this.longOpt = longOpt;\n\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg)\n        {\n            this.numberOfArgs = 1;\n        }\n\n        this.description = description;\n    }\n\n    /**\n     * Returns the id of this Option.  This is only set when the\n     * Option shortOpt is a single character.  This is used for switch\n     * statements.\n     *\n     * @return the id of this Option\n     */\n    public int getId()\n    {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Returns the 'unique' Option identifier.\n     *\n     * @return the 'unique' Option identifier\n     */\n    String getKey()\n    {\n        // if 'opt' is null, then it is a 'long' option\n        return (opt == null) ? longOpt : opt;\n    }\n\n    /**\n     * Retrieve the name of this Option.\n     *\n     * It is this String which can be used with\n     * {@link CommandLine#hasOption(String opt)} and\n     * {@link CommandLine#getOptionValue(String opt)} to check\n     * for existence and argument.\n     *\n     * @return The name of this option\n     */\n    public String getOpt()\n    {\n        return opt;\n    }\n\n    /**\n     * Retrieve the type of this Option.\n     *\n     * @return The type of this option\n     */\n    public Object getType()\n    {\n        return type;\n    }\n\n    /**\n     * Sets the type of this Option.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the\n     * input type is supposed to be a {@link Class} object.\n     *\n     * @param type the type of this Option\n     * @deprecated since 1.3, use {@link #setType(Class)} instead\n     */\n    @Deprecated\n    public void setType(final Object type)\n    {\n        setType((Class<?>) type);\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option\n     * @since 1.3\n     */\n    public void setType(final Class<?> type)\n    {\n        this.type = type;\n    }\n\n    /**\n     * Retrieve the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name\n     */\n    public String getLongOpt()\n    {\n        return longOpt;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option\n     */\n    public void setLongOpt(final String longOpt)\n    {\n        this.longOpt = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have\n     * an optional argument.\n     */\n    public void setOptionalArg(final boolean optionalArg)\n    {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * @return whether this Option can have an optional argument\n     */\n    public boolean hasOptionalArg()\n    {\n        return optionalArg;\n    }\n\n    /**\n     * Query to see if this Option has a long name\n     *\n     * @return boolean flag indicating existence of a long name\n     */\n    public boolean hasLongOpt()\n    {\n        return longOpt != null;\n    }\n\n    /**\n     * Query to see if this Option requires an argument\n     *\n     * @return boolean flag indicating if an argument is required\n     */\n    public boolean hasArg()\n    {\n        return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /**\n     * Retrieve the self-documenting description of this Option\n     *\n     * @return The string description of this option\n     */\n    public String getDescription()\n    {\n        return description;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option\n     *\n     * @param description The description of this option\n     * @since 1.1\n     */\n    public void setDescription(final String description)\n    {\n        this.description = description;\n    }\n\n    /**\n     * Query to see if this Option is mandatory\n     *\n     * @return boolean flag indicating whether this Option is mandatory\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory\n     */\n    public void setRequired(final boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(final String argName)\n    {\n        this.argName = argName;\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName()\n    {\n        return argName;\n    }\n\n    /**\n     * Returns whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName()\n    {\n        return argName != null && argName.length() > 0;\n    }\n\n    /**\n     * Query to see if this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed\n     */\n    public boolean hasArgs()\n    {\n        return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /**\n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values\n     */\n    public void setArgs(final int num)\n    {\n        this.numberOfArgs = num;\n    }\n\n    /**\n     * Sets the value separator.  For example if the argument value\n     * was a Java property, the value separator would be '='.\n     *\n     * @param sep The value separator.\n     */\n    public void setValueSeparator(final char sep)\n    {\n        this.valuesep = sep;\n    }\n\n    /**\n     * Returns the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator()\n    {\n        return valuesep;\n    }\n\n    /**\n     * Return whether this Option has specified a value separator.\n     *\n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator()\n    {\n        return valuesep > 0;\n    }\n\n    /**\n     * Returns the number of argument values this Option can take.\n     *\n     * <p>\n     * A value equal to the constant {@link #UNINITIALIZED} (= -1) indicates\n     * the number of arguments has not been specified.\n     * A value equal to the constant {@link #UNLIMITED_VALUES} (= -2) indicates\n     * that this options takes an unlimited amount of values.\n     * </p>\n     *\n     * @return num the number of argument values\n     * @see #UNINITIALIZED\n     * @see #UNLIMITED_VALUES\n     */\n    public int getArgs()\n    {\n        return numberOfArgs;\n    }\n\n    /**\n     * Adds the specified value to this Option.\n     *\n     * @param value is a/the value of this Option\n     */\n    void addValueForProcessing(final String value)\n    {\n        if (numberOfArgs == UNINITIALIZED)\n        {\n            throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n        }\n        processValue(value);\n    }\n\n    /**\n     * Processes the value.  If this Option has a value separator\n     * the value will have to be parsed into individual tokens.  When\n     * n-1 tokens have been processed and there are more value separators\n     * in the value, parsing is ceased and the remaining characters are\n     * added as a single token.\n     *\n     * @param value The String to be processed.\n     *\n     * @since 1.0.1\n     */\n    private void processValue(String value)\n    {\n        // this Option has a separator character\n        if (hasValueSeparator())\n        {\n            // get the separator character\n            final char sep = getValueSeparator();\n\n            // store the index for the value separator\n            int index = value.indexOf(sep);\n\n            // while there are more value separators\n            while (index != -1)\n            {\n                // next value to be added\n                if (values.size() == numberOfArgs - 1)\n                {\n                    break;\n                }\n\n                // store\n                add(value.substring(0, index));\n\n                // parse\n                value = value.substring(index + 1);\n\n                // get new index\n                index = value.indexOf(sep);\n            }\n        }\n\n        // store the actual value or the last value that has been parsed\n        add(value);\n    }\n\n    /**\n     * Add the value to this Option.  If the number of arguments\n     * is greater than zero and there is enough space in the list then\n     * add the value.  Otherwise, throw a runtime exception.\n     *\n     * @param value The value to be added to this Option\n     *\n     * @since 1.0.1\n     */\n    private void add(final String value)\n    {\n        if (!acceptsArg())\n        {\n            throw new RuntimeException(\"Cannot add value, list full.\");\n        }\n\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * Returns the specified value of this Option or\n     * <code>null</code> if there is no value.\n     *\n     * @return the value/first value of this Option or\n     * <code>null</code> if there is no value.\n     */\n    public String getValue()\n    {\n        return hasNoValues() ? null : values.get(0);\n    }\n\n    /**\n     * Returns the specified value of this Option or\n     * <code>null</code> if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or\n     * <code>null</code> if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1\n     * or greater than the number of the values for this Option.\n     */\n    public String getValue(final int index) throws IndexOutOfBoundsException\n    {\n        return hasNoValues() ? null : values.get(index);\n    }\n\n    /**\n     * Returns the value/first value of this Option or the\n     * <code>defaultValue</code> if there is no value.\n     *\n     * @param defaultValue The value to be returned if there\n     * is no value.\n     *\n     * @return the value/first value of this Option or the\n     * <code>defaultValue</code> if there are no values.\n     */\n    public String getValue(final String defaultValue)\n    {\n        final String value = getValue();\n\n        return (value != null) ? value : defaultValue;\n    }\n\n    /**\n     * Return the values of this Option as a String array\n     * or null if there are no values\n     *\n     * @return the values of this Option as a String array\n     * or null if there are no values\n     */\n    public String[] getValues()\n    {\n        return hasNoValues() ? null : values.toArray(new String[values.size()]);\n    }\n\n    /**\n     * @return the values of this Option as a List\n     * or null if there are no values\n     */\n    public List<String> getValuesList()\n    {\n        return values;\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString()\n    {\n        final StringBuilder buf = new StringBuilder().append(\"[ option: \");\n\n        buf.append(opt);\n\n        if (longOpt != null)\n        {\n            buf.append(\" \").append(longOpt);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs())\n        {\n            buf.append(\"[ARG...]\");\n        }\n        else if (hasArg())\n        {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null)\n        {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n\n    /**\n     * Returns whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues()\n    {\n        return values.isEmpty();\n    }\n\n    @Override\n    public boolean equals(final Object o)\n    {\n        if (this == o)\n        {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass())\n        {\n            return false;\n        }\n\n        final Option option = (Option) o;\n\n        if (opt != null ? !opt.equals(option.opt) : option.opt != null)\n        {\n            return false;\n        }\n        if (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        int result;\n        result = opt != null ? opt.hashCode() : 0;\n        result = 31 * result + (longOpt != null ? longOpt.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public\n     * and in 1.1 rather than throwing a CloneNotSupportedException it throws\n     * a RuntimeException so as to maintain backwards compat at the API level.\n     *\n     * After calling this method, it is very likely you will want to call\n     * clearValues().\n     *\n     * @return a clone of this Option instance\n     * @throws RuntimeException if a {@link CloneNotSupportedException} has been thrown\n     * by {@code super.clone()}\n     */\n    @Override\n    public Object clone()\n    {\n        try\n        {\n            final Option option = (Option) super.clone();\n            option.values = new ArrayList<>(values);\n            return option;\n        }\n        catch (final CloneNotSupportedException cnse)\n        {\n            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n\n    /**\n     * Clear the Option values. After a parse is complete, these are left with\n     * data in them and they need clearing if another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues()\n    {\n        values.clear();\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal\n     * API that was made public in 1.0. It currently throws an UnsupportedOperationException.\n     *\n     * @param value the value to add\n     * @return always throws an {@link UnsupportedOperationException}\n     * @throws UnsupportedOperationException always\n     * @deprecated\n     */\n    @Deprecated\n    public boolean addValue(final String value)\n    {\n        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. \"\n                + \"Subclasses should use the addValueForProcessing method instead. \");\n    }\n\n    /**\n     * Tells if the option can accept more arguments.\n     *\n     * @return false if the maximum number of arguments is reached\n     * @since 1.3\n     */\n    boolean acceptsArg()\n    {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n    }\n\n    /**\n     * Tells if the option requires more arguments to be valid.\n     *\n     * @return false if the option doesn't require more arguments\n     * @since 1.3\n     */\n    boolean requiresArg()\n    {\n        if (optionalArg)\n        {\n            return false;\n        }\n        if (numberOfArgs == UNLIMITED_VALUES)\n        {\n            return values.isEmpty();\n        }\n        return acceptsArg();\n    }\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive\n     * methods.\n     *\n     * @return a new {@link Builder} instance\n     * @since 1.3\n     */\n    public static Builder builder()\n    {\n        return builder(null);\n    }\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive\n     * methods.\n     *\n     * @param opt short representation of the option\n     * @return a new {@link Builder} instance\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n     * @since 1.3\n     */\n    public static Builder builder(final String opt)\n    {\n        return new Builder(opt);\n    }\n\n    /**\n     * A nested builder class to create <code>Option</code> instances\n     * using descriptive methods.\n     * <p>\n     * Example usage:\n     * <pre>\n     * Option option = Option.builder(\"a\")\n     *     .required(true)\n     *     .longOpt(\"arg-name\")\n     *     .build();\n     * </pre>\n     *\n     * @since 1.3\n     */\n    public static final class Builder\n    {\n        /** the name of the option */\n        private final String opt;\n\n        /** description of the option */\n        private String description;\n\n        /** the long representation of the option */\n        private String longOpt;\n\n        /** the name of the argument for this option */\n        private String argName;\n\n        /** specifies whether this option is required to be present */\n        private boolean required;\n\n        /** specifies whether the argument value of this Option is optional */\n        private boolean optionalArg;\n\n        /** the number of argument values this option can have */\n        private int numberOfArgs = UNINITIALIZED;\n\n        /** the type of this Option */\n        private Class<?> type = String.class;\n\n        /** the character that is the value separator */\n        private char valuesep;\n\n        /**\n         * Constructs a new <code>Builder</code> with the minimum\n         * required parameters for an <code>Option</code> instance.\n         *\n         * @param opt short representation of the option\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n         */\n        private Builder(final String opt) throws IllegalArgumentException\n        {\n            OptionValidator.validateOption(opt);\n            this.opt = opt;\n        }\n\n        /**\n         * Sets the display name for the argument value.\n         *\n         * @param argName the display name for the argument value.\n         * @return this builder, to allow method chaining\n         */\n        public Builder argName(final String argName)\n        {\n            this.argName = argName;\n            return this;\n        }\n\n        /**\n         * Sets the description for this option.\n         *\n         * @param description the description of the option.\n         * @return this builder, to allow method chaining\n         */\n        public Builder desc(final String description)\n        {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Sets the long name of the Option.\n         *\n         * @param longOpt the long name of the Option\n         * @return this builder, to allow method chaining\n         */\n        public Builder longOpt(final String longOpt)\n        {\n            this.longOpt = longOpt;\n            return this;\n        }\n\n        /**\n         * Sets the number of argument values the Option can take.\n         *\n         * @param numberOfArgs the number of argument values\n         * @return this builder, to allow method chaining\n         */\n        public Builder numberOfArgs(final int numberOfArgs)\n        {\n            this.numberOfArgs = numberOfArgs;\n            return this;\n        }\n\n        /**\n         * Sets whether the Option can have an optional argument.\n         *\n         * @param isOptional specifies whether the Option can have\n         * an optional argument.\n         * @return this builder, to allow method chaining\n         */\n        public Builder optionalArg(final boolean isOptional)\n        {\n            this.optionalArg = isOptional;\n            return this;\n        }\n\n        /**\n         * Marks this Option as required.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder required()\n        {\n            return required(true);\n        }\n\n        /**\n         * Sets whether the Option is mandatory.\n         *\n         * @param required specifies whether the Option is mandatory\n         * @return this builder, to allow method chaining\n         */\n        public Builder required(final boolean required)\n        {\n            this.required = required;\n            return this;\n        }\n\n        /**\n         * Sets the type of the Option.\n         *\n         * @param type the type of the Option\n         * @return this builder, to allow method chaining\n         */\n        public Builder type(final Class<?> type)\n        {\n            this.type = type;\n            return this;\n        }\n\n        /**\n         * The Option will use '=' as a means to separate argument value.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder valueSeparator()\n        {\n            return valueSeparator('=');\n        }\n\n        /**\n         * The Option will use <code>sep</code> as a means to\n         * separate argument values.\n         * <p>\n         * <b>Example:</b>\n         * <pre>\n         * Option opt = Option.builder(\"D\").hasArgs()\n         *                                 .valueSeparator('=')\n         *                                 .build();\n         * Options options = new Options();\n         * options.addOption(opt);\n         * String[] args = {\"-Dkey=value\"};\n         * CommandLineParser parser = new DefaultParser();\n         * CommandLine line = parser.parse(options, args);\n         * String propertyName = line.getOptionValues(\"D\")[0];  // will be \"key\"\n         * String propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n         * </pre>\n         *\n         * @param sep The value separator.\n         * @return this builder, to allow method chaining\n         */\n        public Builder valueSeparator(final char sep)\n        {\n            valuesep = sep;\n            return this;\n        }\n\n        /**\n         * Indicates that the Option will require an argument.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArg()\n        {\n            return hasArg(true);\n        }\n\n        /**\n         * Indicates if the Option has an argument or not.\n         *\n         * @param hasArg specifies whether the Option takes an argument or not\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArg(final boolean hasArg)\n        {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n            return this;\n        }\n\n        /**\n         * Indicates that the Option can have unlimited argument values.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArgs()\n        {\n            numberOfArgs = Option.UNLIMITED_VALUES;\n            return this;\n        }\n\n        /**\n         * Constructs an Option with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link Option}\n         * @throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set\n         */\n        public Option build()\n        {\n            if (opt == null && longOpt == null)\n            {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/Option.java b/src/main/java/org/apache/commons/cli/Option.java\nindex b564f9868..4a9b7741f 100644\n--- a/src/main/java/org/apache/commons/cli/Option.java\n+++ b/src/main/java/org/apache/commons/cli/Option.java\n@@ -32,7 +32,7 @@\n  * at least a short or a long-name.\n  * <p>\n  * <b>Note:</b> once an {@link Option} has been added to an instance\n- * of {@link Options}, it's required flag may not be changed anymore.\n+ * of {@link Options}, its required flag cannot be changed.\n  *\n  * @see org.apache.commons.cli.Options\n  * @see org.apache.commons.cli.CommandLine\n"
      }
    ]
  },
  {
    "pr_number": 33,
    "title": "Added setter for Builder.option",
    "state": "closed",
    "created_at": "2020-02-24T15:57:36Z",
    "merge_commit_sha": "c886434a34107af01ae3cf70645e8e7d8aaa9ede",
    "base_sha": "0b980a180d66545bfcc669d6185107e6b665be01",
    "head_sha": "c3a00f3bad00bd91fd7eafb523b39a6d5c99b850",
    "user_login": "waso",
    "changed_files": [
      {
        "filename": "src/main/java/org/apache/commons/cli/Option.java",
        "status": "modified",
        "do_experiment": true,
        "generated_test_file_content": "package org.apache.commons.cli;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\nimport org.junit.Test;\n\npublic class OptionTest2 {\n\n    /**\n     * Test the new opt() method in the Builder class.\n     */\n    @Test\n    public void testBuilderOptMethod() {\n        Option.Builder builder = Option.builder(\"a\").desc(\"desc\");\n        builder.opt(\"b\");\n        Option option = builder.build();\n        assertEquals(\"b\", option.getOpt());\n    }\n\n    /**\n     * Test the opt() method with invalid characters.\n     */\n    @Test\n    public void testBuilderOptMethodInvalidCharacters() {\n        Option.Builder builder = Option.builder(\"a\").desc(\"desc\");\n        assertThrows(IllegalArgumentException.class, () -> builder.opt(\"invalid opt\"));\n    }\n}",
        "file_content": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * Describes a single command-line option. It maintains information regarding the short-name of the option, the\n * long-name, if any exists, a flag indicating if an argument is required for this option, and a self-documenting\n * description of the option.\n * <p>\n * An Option is not created independently, but is created through an instance of {@link Options}. An Option is required\n * to have at least a short or a long-name.\n * <p>\n * <b>Note:</b> once an {@link Option} has been added to an instance of {@link Options}, its required flag cannot be\n * changed.\n *\n * @see org.apache.commons.cli.Options\n * @see org.apache.commons.cli.CommandLine\n */\npublic class Option implements Cloneable, Serializable {\n    /**\n     * A nested builder class to create {@code Option} instances using descriptive methods.\n     * <p>\n     * Example usage:\n     *\n     * <pre>\n     * Option option = Option.builder(\"a\").required(true).longOpt(\"arg-name\").build();\n     * </pre>\n     *\n     * @since 1.3\n     */\n    public static final class Builder {\n\n        /** The name of the option */\n        private final String option;\n\n        /** description of the option */\n        private String description;\n\n        /** The long representation of the option */\n        private String longOption;\n\n        /** The name of the argument for this option */\n        private String argName;\n\n        /** specifies whether this option is required to be present */\n        private boolean required;\n\n        /** specifies whether the argument value of this Option is optional */\n        private boolean optionalArg;\n\n        /** The number of argument values this option can have */\n        private int argCount = UNINITIALIZED;\n\n        /** The type of this Option */\n        private Class<?> type = String.class;\n\n        /** The character that is the value separator */\n        private char valueSeparator;\n\n        /**\n         * Constructs a new {@code Builder} with the minimum required parameters for an {@code Option} instance.\n         *\n         * @param option short representation of the option\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n         */\n        private Builder(final String option) throws IllegalArgumentException {\n            this.option = OptionValidator.validate(option);\n        }\n\n        /**\n         * Sets the display name for the argument value.\n         *\n         * @param argName the display name for the argument value.\n         * @return this builder, to allow method chaining\n         */\n        public Builder argName(final String argName) {\n            this.argName = argName;\n            return this;\n        }\n\n        /**\n         * Constructs an Option with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link Option}\n         * @throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set\n         */\n        public Option build() {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }\n\n        /**\n         * Sets the description for this option.\n         *\n         * @param description the description of the option.\n         * @return this builder, to allow method chaining\n         */\n        public Builder desc(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Indicates that the Option will require an argument.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArg() {\n            return hasArg(true);\n        }\n\n        /**\n         * Indicates if the Option has an argument or not.\n         *\n         * @param hasArg specifies whether the Option takes an argument or not\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArg(final boolean hasArg) {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : Option.UNINITIALIZED;\n            return this;\n        }\n\n        /**\n         * Indicates that the Option can have unlimited argument values.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder hasArgs() {\n            argCount = Option.UNLIMITED_VALUES;\n            return this;\n        }\n\n        /**\n         * Sets the long name of the Option.\n         *\n         * @param longOpt the long name of the Option\n         * @return this builder, to allow method chaining\n         */\n        public Builder longOpt(final String longOpt) {\n            this.longOption = longOpt;\n            return this;\n        }\n\n        /**\n         * Sets the number of argument values the Option can take.\n         *\n         * @param numberOfArgs the number of argument values\n         * @return this builder, to allow method chaining\n         */\n        public Builder numberOfArgs(final int numberOfArgs) {\n            this.argCount = numberOfArgs;\n            return this;\n        }\n\n        /**\n         * Sets whether the Option can have an optional argument.\n         *\n         * @param isOptional specifies whether the Option can have an optional argument.\n         * @return this builder, to allow method chaining\n         */\n        public Builder optionalArg(final boolean isOptional) {\n            this.optionalArg = isOptional;\n            return this;\n        }\n\n        /**\n         * Marks this Option as required.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder required() {\n            return required(true);\n        }\n\n        /**\n         * Sets whether the Option is mandatory.\n         *\n         * @param required specifies whether the Option is mandatory\n         * @return this builder, to allow method chaining\n         */\n        public Builder required(final boolean required) {\n            this.required = required;\n            return this;\n        }\n\n        /**\n         * Sets the type of the Option.\n         *\n         * @param type the type of the Option\n         * @return this builder, to allow method chaining\n         */\n        public Builder type(final Class<?> type) {\n            this.type = type;\n            return this;\n        }\n\n        /**\n         * The Option will use '=' as a means to separate argument value.\n         *\n         * @return this builder, to allow method chaining\n         */\n        public Builder valueSeparator() {\n            return valueSeparator('=');\n        }\n\n        /**\n         * The Option will use {@code sep} as a means to separate argument values.\n         * <p>\n         * <b>Example:</b>\n         *\n         * <pre>\n         * Option opt = Option.builder(\"D\").hasArgs().valueSeparator('=').build();\n         * Options options = new Options();\n         * options.addOption(opt);\n         * String[] args = {\"-Dkey=value\"};\n         * CommandLineParser parser = new DefaultParser();\n         * CommandLine line = parser.parse(options, args);\n         * String propertyName = line.getOptionValues(\"D\")[0]; // will be \"key\"\n         * String propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n         * </pre>\n         *\n         * @param sep The value separator.\n         * @return this builder, to allow method chaining\n         */\n        public Builder valueSeparator(final char sep) {\n            valueSeparator = sep;\n            return this;\n        }\n    }\n\n    /** Specifies the number of argument values has not been specified */\n    public static final int UNINITIALIZED = -1;\n\n    /** Specifies the number of argument values is infinite */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @return a new {@link Builder} instance\n     * @since 1.3\n     */\n    public static Builder builder() {\n        return builder(null);\n    }\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @param opt short representation of the option\n     * @return a new {@link Builder} instance\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n     * @since 1.3\n     */\n    public static Builder builder(final String opt) {\n        return new Builder(opt);\n    }\n\n    /** The name of the option. */\n    private final String option;\n\n    /** The long representation of the option. */\n    private String longOption;\n\n    /** The name of the argument for this option. */\n    private String argName;\n\n    /** Description of the option. */\n    private String description;\n\n    /** Specifies whether this option is required to be present. */\n    private boolean required;\n\n    /** Specifies whether the argument value of this Option is optional. */\n    private boolean optionalArg;\n\n    /** The number of argument values this option can have. */\n    private int argCount = UNINITIALIZED;\n\n    /** The type of this Option. */\n    private Class<?> type = String.class;\n\n    /** The list of argument values. **/\n    private List<String> values = new ArrayList<>();\n\n    /** The character that is the value separator. */\n    private char valuesep;\n\n    /**\n     * Private constructor used by the nested Builder class.\n     *\n     * @param builder builder used to create this option\n     */\n    private Option(final Builder builder) {\n        this.argName = builder.argName;\n        this.description = builder.description;\n        this.longOption = builder.longOption;\n        this.argCount = builder.argCount;\n        this.option = builder.option;\n        this.optionalArg = builder.optionalArg;\n        this.required = builder.required;\n        this.type = builder.type;\n        this.valuesep = builder.valueSeparator;\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option short representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final boolean hasArg, final String description) throws IllegalArgumentException {\n        this(option, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters. The option does not take an argument.\n     *\n     * @param option short representation of the option\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String description) throws IllegalArgumentException {\n        this(option, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option short representation of the option\n     * @param longOption the long representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String longOption, final boolean hasArg, final String description) throws IllegalArgumentException {\n        // ensure that the option is valid\n        this.option = OptionValidator.validate(option);\n        this.longOption = longOption;\n\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg) {\n            this.argCount = 1;\n        }\n\n        this.description = description;\n    }\n\n    /**\n     * Tells if the option can accept more arguments.\n     *\n     * @return false if the maximum number of arguments is reached\n     * @since 1.3\n     */\n    boolean acceptsArg() {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (argCount <= 0 || values.size() < argCount);\n    }\n\n    /**\n     * Add the value to this Option. If the number of arguments is greater than zero and there is enough space in the list\n     * then add the value. Otherwise, throw a runtime exception.\n     *\n     * @param value The value to be added to this Option\n     *\n     * @since 1.0.1\n     */\n    private void add(final String value) {\n        if (!acceptsArg()) {\n            throw new RuntimeException(\"Cannot add value, list full.\");\n        }\n\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal API that was made public in 1.0. It currently\n     * throws an UnsupportedOperationException.\n     *\n     * @param value the value to add\n     * @return always throws an {@link UnsupportedOperationException}\n     * @throws UnsupportedOperationException always\n     * @deprecated Unused.\n     */\n    @Deprecated\n    public boolean addValue(final String value) {\n        throw new UnsupportedOperationException(\n            \"The addValue method is not intended for client use. \" + \"Subclasses should use the addValueForProcessing method instead. \");\n    }\n\n    /**\n     * Adds the specified value to this Option.\n     *\n     * @param value is a/the value of this Option\n     */\n    void addValueForProcessing(final String value) {\n        if (argCount == UNINITIALIZED) {\n            throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n        }\n        processValue(value);\n    }\n\n    /**\n     * Clear the Option values. After a parse is complete, these are left with data in them and they need clearing if\n     * another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues() {\n        values.clear();\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public and in 1.1 rather than throwing a\n     * CloneNotSupportedException it throws a RuntimeException so as to maintain backwards compat at the API level.\n     *\n     * After calling this method, it is very likely you will want to call clearValues().\n     *\n     * @return a clone of this Option instance\n     * @throws RuntimeException if a {@link CloneNotSupportedException} has been thrown by {@code super.clone()}\n     */\n    @Override\n    public Object clone() {\n        try {\n            final Option option = (Option) super.clone();\n            option.values = new ArrayList<>(values);\n            return option;\n        } catch (final CloneNotSupportedException cnse) {\n            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Option)) {\n            return false;\n        }\n        final Option other = (Option) obj;\n        return Objects.equals(longOption, other.longOption) && Objects.equals(option, other.option);\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName() {\n        return argName;\n    }\n\n    /**\n     * Gets the number of argument values this Option can take.\n     *\n     * <p>\n     * A value equal to the constant {@link #UNINITIALIZED} (= -1) indicates the number of arguments has not been specified.\n     * A value equal to the constant {@link #UNLIMITED_VALUES} (= -2) indicates that this options takes an unlimited amount\n     * of values.\n     * </p>\n     *\n     * @return num the number of argument values\n     * @see #UNINITIALIZED\n     * @see #UNLIMITED_VALUES\n     */\n    public int getArgs() {\n        return argCount;\n    }\n\n    /**\n     * Gets the self-documenting description of this Option\n     *\n     * @return The string description of this option\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Gets the id of this Option. This is only set when the Option shortOpt is a single character. This is used for\n     * switch statements.\n     *\n     * @return the id of this Option\n     */\n    public int getId() {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Gets the 'unique' Option identifier.\n     *\n     * @return the 'unique' Option identifier\n     */\n    String getKey() {\n        // if 'opt' is null, then it is a 'long' option\n        return option == null ? longOption : option;\n    }\n\n    /**\n     * Gets the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name\n     */\n    public String getLongOpt() {\n        return longOption;\n    }\n\n    /**\n     * Gets the name of this Option.\n     *\n     * It is this String which can be used with {@link CommandLine#hasOption(String opt)} and\n     * {@link CommandLine#getOptionValue(String opt)} to check for existence and argument.\n     *\n     * @return The name of this option\n     */\n    public String getOpt() {\n        return option;\n    }\n\n    /**\n     * Gets the type of this Option.\n     *\n     * @return The type of this option\n     */\n    public Object getType() {\n        return type;\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @return the value/first value of this Option or {@code null} if there is no value.\n     */\n    public String getValue() {\n        return hasNoValues() ? null : values.get(0);\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or {@code null} if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1 or greater than the number of the values for this Option.\n     */\n    public String getValue(final int index) throws IndexOutOfBoundsException {\n        return hasNoValues() ? null : values.get(index);\n    }\n\n    /**\n     * Gets the value/first value of this Option or the {@code defaultValue} if there is no value.\n     *\n     * @param defaultValue The value to be returned if there is no value.\n     *\n     * @return the value/first value of this Option or the {@code defaultValue} if there are no values.\n     */\n    public String getValue(final String defaultValue) {\n        final String value = getValue();\n\n        return value != null ? value : defaultValue;\n    }\n\n    /**\n     * Gets the values of this Option as a String array or null if there are no values\n     *\n     * @return the values of this Option as a String array or null if there are no values\n     */\n    public String[] getValues() {\n        return hasNoValues() ? null : values.toArray(new String[values.size()]);\n    }\n\n    /**\n     * Gets the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator() {\n        return valuesep;\n    }\n\n    /**\n     * Gets the values of this Option as a List or null if there are no values.\n     *\n     * @return the values of this Option as a List or null if there are no values\n     */\n    public List<String> getValuesList() {\n        return values;\n    }\n\n    /**\n     * Query to see if this Option requires an argument\n     *\n     * @return boolean flag indicating if an argument is required\n     */\n    public boolean hasArg() {\n        return argCount > 0 || argCount == UNLIMITED_VALUES;\n    }\n\n    /**\n     * Returns whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName() {\n        return argName != null && !argName.isEmpty();\n    }\n\n    /**\n     * Query to see if this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed\n     */\n    public boolean hasArgs() {\n        return argCount > 1 || argCount == UNLIMITED_VALUES;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(longOption, option);\n    }\n\n    /**\n     * Query to see if this Option has a long name\n     *\n     * @return boolean flag indicating existence of a long name\n     */\n    public boolean hasLongOpt() {\n        return longOption != null;\n    }\n\n    /**\n     * Returns whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues() {\n        return values.isEmpty();\n    }\n\n    /**\n     * @return whether this Option can have an optional argument\n     */\n    public boolean hasOptionalArg() {\n        return optionalArg;\n    }\n\n    /**\n     * Return whether this Option has specified a value separator.\n     *\n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator() {\n        return valuesep > 0;\n    }\n\n    /**\n     * Query to see if this Option is mandatory\n     *\n     * @return boolean flag indicating whether this Option is mandatory\n     */\n    public boolean isRequired() {\n        return required;\n    }\n\n    /**\n     * Processes the value. If this Option has a value separator the value will have to be parsed into individual tokens.\n     * When n-1 tokens have been processed and there are more value separators in the value, parsing is ceased and the\n     * remaining characters are added as a single token.\n     *\n     * @param value The String to be processed.\n     *\n     * @since 1.0.1\n     */\n    private void processValue(String value) {\n        // this Option has a separator character\n        if (hasValueSeparator()) {\n            // get the separator character\n            final char sep = getValueSeparator();\n\n            // store the index for the value separator\n            int index = value.indexOf(sep);\n\n            // while there are more value separators\n            while (index != -1) {\n                // next value to be added\n                if (values.size() == argCount - 1) {\n                    break;\n                }\n\n                // store\n                add(value.substring(0, index));\n\n                // parse\n                value = value.substring(index + 1);\n\n                // get new index\n                index = value.indexOf(sep);\n            }\n        }\n\n        // store the actual value or the last value that has been parsed\n        add(value);\n    }\n\n    /**\n     * Tells if the option requires more arguments to be valid.\n     *\n     * @return false if the option doesn't require more arguments\n     * @since 1.3\n     */\n    boolean requiresArg() {\n        if (optionalArg) {\n            return false;\n        }\n        if (argCount == UNLIMITED_VALUES) {\n            return values.isEmpty();\n        }\n        return acceptsArg();\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(final String argName) {\n        this.argName = argName;\n    }\n\n    /**\n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values\n     */\n    public void setArgs(final int num) {\n        this.argCount = num;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option\n     *\n     * @param description The description of this option\n     * @since 1.1\n     */\n    public void setDescription(final String description) {\n        this.description = description;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option\n     */\n    public void setLongOpt(final String longOpt) {\n        this.longOption = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have an optional argument.\n     */\n    public void setOptionalArg(final boolean optionalArg) {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory\n     */\n    public void setRequired(final boolean required) {\n        this.required = required;\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option\n     * @since 1.3\n     */\n    public void setType(final Class<?> type) {\n        this.type = type;\n    }\n\n    /**\n     * Sets the type of this Option.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class}\n     * object.\n     *\n     * @param type the type of this Option\n     * @deprecated since 1.3, use {@link #setType(Class)} instead\n     */\n    @Deprecated\n    public void setType(final Object type) {\n        setType((Class<?>) type);\n    }\n\n    /**\n     * Sets the value separator. For example if the argument value was a Java property, the value separator would be '='.\n     *\n     * @param sep The value separator.\n     */\n    public void setValueSeparator(final char sep) {\n        this.valuesep = sep;\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder().append(\"[ option: \");\n\n        buf.append(option);\n\n        if (longOption != null) {\n            buf.append(\" \").append(longOption);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs()) {\n            buf.append(\"[ARG...]\");\n        } else if (hasArg()) {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null) {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n}",
        "diff": " a/src/main/java/org/apache/commons/cli/Option.java b/src/main/java/org/apache/commons/cli/Option.java\nindex 4a8590782..dfaff0ebc 100644\n--- a/src/main/java/org/apache/commons/cli/Option.java\n+++ b/src/main/java/org/apache/commons/cli/Option.java\n@@ -51,7 +51,7 @@ public class Option implements Cloneable, Serializable {\n     public static final class Builder {\n \n         /** The name of the option */\n-        private final String option;\n+        private String option;\n \n         /** description of the option */\n         private String description;\n@@ -87,6 +87,18 @@ private Builder(final String option) throws IllegalArgumentException {\n             this.option = OptionValidator.validate(option);\n         }\n \n+        /**\n+         * Sets the name of the Option.\n+         *\n+         * @param opt the name of the Option\n+         * @return this builder, to allow method chaining\n+         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}\n+         */\n+        public Builder opt(String opt) throws IllegalArgumentException {\n+            this.option = OptionValidator.validate(opt);\n+            return this;\n+        }\n+\n         /**\n          * Sets the display name for the argument value.\n          *\n"
      },
      {
        "filename": "src/test/java/org/apache/commons/cli/OptionTest.java",
        "status": "modified",
        "do_experiment": null,
        "generated_test_file_content": null,
        "file_content": null,
        "diff": null
      }
    ]
  }
]